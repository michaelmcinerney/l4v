--- Tcb_C.thy
+++ Tcb_C.thy
@@ -574,441 +652,304 @@ lemma invokeTCB_ThreadControl_ccorres:
   (is "ccorres ?rvr ?xf (?P and (\<lambda>_. ?P')) ?Q [] ?af ?cf")
   supply option.case_cong_weak[cong]
   apply (rule ccorres_gen_asm)
-  apply (cinit lift: target_' slot_' faultep_' mcp_' priority_' cRoot_newCap_' cRoot_srcSlot_'
-                     vRoot_newCap_' vRoot_srcSlot_' bufferAddr_' bufferSrcSlot_' bufferCap_'
-                     updateFlags_')
+  apply (cinit lift: target_' slot_' mcp_' priority_' cRoot_newCap_' cRoot_srcSlot_'
+                     vRoot_newCap_' vRoot_srcSlot_' fh_newCap_' fh_srcSlot_'
+                     bufferAddr_' bufferSrcSlot_' bufferCap_' updateFlags_')
    apply csymbr
    apply (simp add: liftE_bindE case_option_If2 thread_control_flag_defs
                     word_ao_dist if_and_helper if_n_0_0
                     tcb_cnode_index_defs[THEN ptr_add_assertion_positive[OF ptr_add_assertion_positive_helper]]
                del: Collect_const cong: call_ignore_cong if_cong)
-   apply (rule_tac P="ptr_val (tcb_ptr_to_ctcb_ptr target) && ~~ mask 4
-                          = ptr_val (tcb_ptr_to_ctcb_ptr target)
-                        \<and> ptr_val (tcb_ptr_to_ctcb_ptr target) && 0xFFFFFE00 = target"
+   apply (rule_tac P="ptr_val (tcb_ptr_to_ctcb_ptr target) && ~~ mask 4 = ptr_val (tcb_ptr_to_ctcb_ptr target)
+                    \<and> ptr_val (tcb_ptr_to_ctcb_ptr target) && 0xFFFFFE00 = target"
                 in ccorres_gen_asm)
    apply (rule_tac r'=dc and xf'=xfdc in ccorres_split_nothrow_novcg)
        apply (rule ccorres_cond_both'[where Q=\<top> and Q'=\<top>])
          apply (simp add: Collect_const_mem)
-        apply (rule ccorres_move_c_guard_tcb)
-        apply (rule threadSet_ccorres_lemma2[where P=\<top>])
-         apply vcg
-        apply clarsimp
-        apply (subst StateSpace.state.fold_congs[OF refl refl])
-         apply (rule globals.fold_congs[OF refl refl])
-         apply (rule heap_update_field_hrs)
-           apply (simp add: typ_heap_simps)
-          apply (fastforce intro: typ_heap_simps)
-         apply simp
-        apply (erule(1) rf_sr_tcb_update_no_queue2,
-               (simp add: typ_heap_simps)+)
-         apply (rule ball_tcb_cte_casesI, simp+)
-        apply (clarsimp simp: ctcb_relation_def option_to_0_def)
+        apply (rule_tac A="\<lambda>s. invs' s \<and> tcb_at' target s \<and> fst (the mcp) \<le> maxPriority" in ccorres_guard_imp2)
+         apply (ctac add: setMCPriority_ccorres)
+        apply (clarsimp cong: conj_cong imp_cong)
        apply (rule ccorres_return_Skip)
       apply (rule ceqv_refl)
-     apply (rule_tac r'=dc and xf'=xfdc in ccorres_split_nothrow_novcg)
-         apply (rule ccorres_cond_both'[where Q=\<top> and Q'=\<top>])
-           apply (simp add: Collect_const_mem)
-          apply (ctac add: setMCPriority_ccorres)
-         apply (rule ccorres_return_Skip)
-        apply (rule ceqv_refl)
-       apply (rule ccorres_subgoal_tailE)
-        apply (rule ccorres_subgoal_tailE)
-         apply (rule_tac A="invs' and sch_act_simple and tcb_at' target
-                            and (\<lambda>(s::kernel_state). (case priority of None \<Rightarrow> True | Some x \<Rightarrow> ((\<lambda>y. fst y \<le> maxPriority)) x))
-                            and case_option \<top> (case_option \<top> (valid_cap' \<circ> fst) \<circ> snd) buf
-                            and case_option \<top> (case_option \<top> (cte_at' \<circ> snd) \<circ> snd) buf
-                            and K (case_option True (swp is_aligned msg_align_bits \<circ> fst) buf)
-                            and K (case_option True (case_option True (isArchObjectCap \<circ> fst) \<circ> snd) buf)"
-                  (* bits of tcb_inv_wf' *)
-                  in ccorres_guard_imp2[where A'=UNIV])
-          apply (rule ccorres_Cond_rhs_Seq)
-           apply (simp only: if_True Collect_True split_def bindE_assoc)
-           apply (rule ccorres_rhs_assoc)+
-           apply csymbr
-           apply (rule ccorres_move_array_assertion_tcb_ctes ccorres_Guard_Seq)+
-           apply csymbr
-           apply (simp add: liftE_bindE[symmetric] bindE_assoc getThreadBufferSlot_def
-                            locateSlot_conv o_def
-                       del: Collect_const)
-           apply (simp add: liftE_bindE del: Collect_const)
-           apply (ctac(no_vcg) add: cteDelete_ccorres)
-             apply (simp del: Collect_const add: Collect_False)
-             apply (rule ccorres_move_c_guard_tcb)
-             apply (rule ccorres_split_nothrow_novcg)
-                 apply (rule threadSet_ccorres_lemma2[where P=\<top>])
-                  apply vcg
-                 apply clarsimp
-                 apply (erule(1) rf_sr_tcb_update_no_queue2,
-                        (simp add: typ_heap_simps')+, simp_all?)[1]
-                  apply (rule ball_tcb_cte_casesI, simp+)
-                 apply (clarsimp simp: ctcb_relation_def option_to_0_def)
-                apply (rule ceqv_refl)
-               apply csymbr
-               apply (simp add: ccorres_cond_iffs Collect_False split_def
-                           del: Collect_const)
-               apply (rule ccorres_Cond_rhs_Seq)
-                (* P *)
-                apply (rule ccorres_rhs_assoc)+
-                apply (simp add: case_option_If2 if_n_0_0 split_def
-                            del: Collect_const)
-                apply (rule checkCapAt_ccorres)
-                   apply ceqv
-                  apply csymbr
-                  apply (simp add: true_def Collect_True
-                              del: Collect_const)
-                  apply (rule ccorres_rhs_assoc)+
-                  apply (rule checkCapAt_ccorres)
-                     apply ceqv
-                    apply csymbr
-                    apply (simp add: true_def Collect_True
-                                del: Collect_const)
-                    apply (simp add: assertDerived_def bind_assoc del: Collect_const)
-                    apply (rule ccorres_symb_exec_l)
-                       apply (ctac(no_vcg) add: cteInsert_ccorres)
-                        apply (rule ccorres_pre_getCurThread)
-                        apply (rule ccorres_split_nothrow_novcg_dc)
-                           apply (simp add: when_def)
-                           apply (rename_tac curThread)
-                           apply (rule_tac C'="{s. target = curThread}"
-                                           and Q="\<lambda>s. ksCurThread s = curThread"
-                                           and Q'=UNIV in ccorres_rewrite_cond_sr)
-                            apply (clarsimp simp: Collect_const_mem rf_sr_ksCurThread)
-                           apply (rule ccorres_Cond_rhs; clarsimp)
-                            apply (ctac (no_vcg) add: rescheduleRequired_ccorres[unfolded dc_def])
-                           apply (rule ccorres_return_Skip')
-                          apply (rule ccorres_split_nothrow_novcg_dc)
-                             apply (rule ccorres_cond2[where R=\<top>], simp add: Collect_const_mem)
-                              apply (ctac add: setPriority_ccorres)
-                             apply (rule ccorres_return_Skip)
-                            apply (rule ccorres_return_CE, simp+)[1]
-                           apply (wp (once))
-                          apply (clarsimp simp: guard_is_UNIV_def)
-                         apply (wpsimp wp: when_def static_imp_wp)
-                          apply (strengthen sch_act_wf_weak, wp)
-                         apply clarsimp
-                         apply wp
-                        apply (clarsimp simp: guard_is_UNIV_def Collect_const_mem)
-                       apply (rule hoare_strengthen_post[
-                                    where Q= "\<lambda>rv s.
-                                              Invariants_H.valid_queues s \<and>
-                                              valid_objs' s \<and>
-                                              weak_sch_act_wf (ksSchedulerAction s) s \<and>
-                                              ((\<exists>a b. priority = Some (a, b)) \<longrightarrow>
-                                                   tcb_at' target s \<and> ksCurDomain s \<le> maxDomain \<and>
-                                                   valid_queues' s \<and>  fst (the priority) \<le> maxPriority)"])
-                        apply (strengthen sch_act_wf_weak)
-                        apply (wp static_imp_wp)
-                       apply (clarsimp split: if_splits)
-                      apply (wp empty_fail_stateAssert hoare_case_option_wp | simp del: Collect_const)+
-                   apply csymbr
-                   apply (simp add: false_def Collect_False ccorres_cond_iffs
-                               del: Collect_const)
-                   apply (rule ccorres_pre_getCurThread)
-                   apply (rename_tac curThread)
-                   apply (rule ccorres_split_nothrow_novcg_dc)
-                      apply (simp add: when_def to_bool_def)
-                      apply (rule_tac C'="{s. target = curThread}"
-                                      and Q="\<lambda>s. ksCurThread s = curThread"
-                                      and Q'=UNIV in ccorres_rewrite_cond_sr)
-                       apply (clarsimp simp: Collect_const_mem rf_sr_ksCurThread)
-                      apply (rule ccorres_Cond_rhs; clarsimp)
-                       apply (ctac (no_vcg) add: rescheduleRequired_ccorres[unfolded dc_def])
-                      apply (rule ccorres_return_Skip')
-                     apply (rule ccorres_split_nothrow_novcg_dc)
-                        apply (rule ccorres_cond2[where R=\<top>], simp add: Collect_const_mem)
-                         apply (ctac add: setPriority_ccorres)
-                        apply (rule ccorres_return_Skip)
-                       apply (rule ccorres_return_CE, simp+)
-                      apply wp
-                     apply (clarsimp simp: guard_is_UNIV_def)
-                    apply (simp add: when_def)
-                    apply (wp hoare_vcg_if_lift2(1) static_imp_wp, strengthen sch_act_wf_weak; wp)
-                   apply (clarsimp simp: guard_is_UNIV_def Collect_const_mem)
-                  apply (clarsimp simp: guard_is_UNIV_def Collect_const_mem
-                                        tcbBuffer_def size_of_def cte_level_bits_def
-                                        tcbIPCBufferSlot_def)
-                 apply csymbr
-                 apply (simp add: Collect_False false_def
-                             del: Collect_const)
-                 apply (rule ccorres_cond_false_seq, simp)
-                 apply (rule ccorres_pre_getCurThread)
-                 apply (rename_tac curThread)
-                 apply (simp add: when_def to_bool_def)
-                 apply (rule ccorres_split_nothrow_novcg_dc)
-                    apply (rule_tac C'="{s. target = curThread}"
-                                    and Q="\<lambda>s. ksCurThread s = curThread"
-                                    and Q'=UNIV in ccorres_rewrite_cond_sr)
-                     apply (clarsimp simp: Collect_const_mem rf_sr_ksCurThread)
-                    apply (rule ccorres_Cond_rhs; clarsimp)
-                     apply (ctac(no_vcg) add: rescheduleRequired_ccorres[unfolded dc_def])
-                    apply (rule ccorres_return_Skip')
-                   apply (rule ccorres_split_nothrow_novcg_dc)
-                      apply(rule ccorres_cond2[where R=\<top>], simp add: Collect_const_mem)
-                       apply(ctac add: setPriority_ccorres)
-                      apply(rule ccorres_return_Skip)
-                     apply (rule ccorres_return_CE, simp+)
-                    apply wp
-                   apply (clarsimp simp: guard_is_UNIV_def)
-                  apply (wp hoare_vcg_if_lift2(1) static_imp_wp, strengthen sch_act_wf_weak; wp)
-                 apply (clarsimp simp: guard_is_UNIV_def Collect_const_mem)
-                apply (simp add: guard_is_UNIV_def false_def Collect_const_mem)
-                apply (clarsimp simp: ccap_relation_def cap_thread_cap_lift cap_to_H_def)
-               apply simp
-               apply (rule ccorres_cond_false_seq, simp)
-               apply (rule ccorres_cond_false_seq, simp)
-               apply (simp split: option.split_asm)
-               apply (rule ccorres_pre_getCurThread)
-               apply (rename_tac curThread)
-               apply (simp add: when_def to_bool_def)
-               apply (rule ccorres_split_nothrow_novcg_dc)
-                  apply (rule_tac C'="{s. target = curThread}"
-                                  and Q="\<lambda>s. ksCurThread s = curThread"
-                                  and Q'=UNIV in ccorres_rewrite_cond_sr)
-                   apply (clarsimp simp: Collect_const_mem rf_sr_ksCurThread)
-                  apply (rule ccorres_Cond_rhs; clarsimp)
-                   apply (ctac(no_vcg) add: rescheduleRequired_ccorres[unfolded dc_def])
-                  apply (rule ccorres_return_Skip')
-                 apply (rule ccorres_split_nothrow_novcg_dc)
-                    apply (rule ccorres_cond2[where R=\<top>], simp add: Collect_const_mem)
-                     apply (ctac add: setPriority_ccorres)
-                    apply (rule ccorres_return_Skip)
-                   apply (rule ccorres_return_CE, simp+)
-                  apply wp
-                 apply (clarsimp simp: guard_is_UNIV_def)
-                apply wpsimp
-                 apply (wp static_imp_wp, strengthen sch_act_wf_weak, wp )
-                apply wp
-               apply (clarsimp simp: guard_is_UNIV_def Collect_const_mem)
-              apply (simp cong: conj_cong)
-              apply (rule hoare_strengthen_post[
-                            where Q="\<lambda>a b. (Invariants_H.valid_queues b \<and>
-                                       valid_objs' b \<and>
-                                       sch_act_wf (ksSchedulerAction b) b \<and>
-                                       ((\<exists>a b. priority = Some (a, b)) \<longrightarrow>
-                                          tcb_at'  target b \<and>
-                                          ksCurDomain b \<le> maxDomain \<and> valid_queues' b \<and>
-                                          fst (the priority) \<le> maxPriority)) \<and>
-                                       ((case snd (the buf)
-                                           of None \<Rightarrow> 0
-                                            | Some x \<Rightarrow> snd x) \<noteq> 0 \<longrightarrow>
-                                                invs' b \<and>
-                                                valid_cap' (capability.ThreadCap target) b \<and>
-                                                valid_cap' (fst (the (snd (the buf)))) b \<and>
-                                                (cte_wp_at' (\<lambda>a. is_derived' (map_to_ctes (ksPSpace b))
-                                                                 (snd (the (snd (the buf))))
-                                                                 (fst (the (snd (the buf))))
-                                                                 (cteCap a))
-                                                            (snd (the (snd (the buf)))) b \<longrightarrow>
-                                                  cte_wp_at' (\<lambda>scte. capMasterCap (cteCap scte)
-                                                                   = capMasterCap (fst (the (snd (the buf))))
-                                                                   \<or> is_simple_cap' (fst (the (snd (the buf)))))
-                                                             (snd (the (snd (the buf)))) b \<and>
-                                                  valid_mdb' b \<and>
-                                                  pspace_aligned' b \<and>
-                                                  cte_wp_at' (\<lambda>c. True) (snd (the (snd (the buf)))) b))"])
-               prefer 2
-               apply fastforce
-              apply (strengthen cte_is_derived_capMasterCap_strg
-                                invs_queues invs_weak_sch_act_wf invs_sch_act_wf'
-                                invs_valid_objs' invs_mdb' invs_pspace_aligned',
-                            simp add: o_def)
-              apply (rule_tac P="is_aligned (fst (the buf)) msg_align_bits"
-                       in hoare_gen_asm)
-              apply (wp threadSet_ipcbuffer_trivial static_imp_wp
-                     | simp
-                     | strengthen invs_sch_act_wf' invs_valid_objs' invs_weak_sch_act_wf  invs_queues
-                                  invs_valid_queues' | wp hoare_drop_imps)+
-             (* \<not> P *)
-             apply (clarsimp simp: guard_is_UNIV_def Collect_const_mem
-                                   option_to_0_def
-                            split: option.split_asm)
-            apply (clarsimp simp: ccap_relation_def cap_thread_cap_lift cap_to_H_def)
-            apply (rule ccorres_split_throws)
-             apply (rule ccorres_return_C_errorE, simp+)[1]
-            apply vcg
-           apply (simp add: conj_comms cong: conj_cong)
-           apply (strengthen invs_ksCurDomain_maxDomain')
-           apply (wp hoare_vcg_const_imp_lift_R cteDelete_invs')
-          apply simp
-          apply (rule ccorres_split_nothrow_novcg_dc)
-             apply (rule ccorres_cond2[where R=\<top>], simp add: Collect_const_mem)
-              apply (ctac add: setPriority_ccorres)
-             apply (rule ccorres_return_Skip)
-            apply (rule ccorres_return_CE, simp+)
-           apply wp
-          apply (clarsimp simp: guard_is_UNIV_def)
-         apply (clarsimp simp: inQ_def Collect_const_mem cintr_def
-                               exception_defs tcb_cnode_index_defs)
-         apply (simp add: tcbBuffer_def tcbIPCBufferSlot_def word_sle_def
-                          cte_level_bits_def from_bool_def true_def size_of_def case_option_If2 )
-         apply (rule conjI)
-          apply (clarsimp simp: case_option_If2 if_n_0_0 objBits_simps' valid_cap'_def
-                                capAligned_def word_bits_conv obj_at'_def projectKOs)
-         apply (clarsimp simp: invs_valid_objs' invs_valid_queues'
-                               Invariants_H.invs_queues invs_ksCurDomain_maxDomain')
-        apply (rule ccorres_Cond_rhs_Seq)
-         apply (rule ccorres_rhs_assoc)+
-         apply csymbr
-         apply (rule ccorres_move_array_assertion_tcb_ctes ccorres_Guard_Seq)+
-         apply (simp add: split_def getThreadVSpaceRoot_def locateSlot_conv
-                          bindE_assoc liftE_bindE
-                     del: Collect_const)
-         apply csymbr
-         apply (ctac(no_vcg) add: cteDelete_ccorres)
-           apply (simp add: liftE_bindE Collect_False ccorres_cond_iffs
-                            dc_def
-                       del: Collect_const)
-           apply ((rule ccorres_split_nothrow_novcg_dc[rotated], assumption) | rule ccorres_rhs_assoc2)+
-             apply (simp add: conj_comms pred_conj_def)
-             apply (simp add: o_def cong: conj_cong option.case_cong)
-             apply (wp checked_insert_tcb_invs' hoare_case_option_wp
-                       checkCap_inv [where P="tcb_at' p0" for p0]
-                       checkCap_inv [where P="cte_at' p0" for p0]
-                       checkCap_inv [where P="valid_cap' c" for c]
-                       checkCap_inv [where P="sch_act_simple"]
-                    | simp)+
-            apply (simp add: guard_is_UNIV_def)
-           apply (thin_tac "ccorres a1 a2 a3 a4 a5 a6 a7" for a1 a2 a3 a4 a5 a6 a7)
-           apply (rule ccorres_rhs_assoc)+
-           apply (rule checkCapAt_ccorres2)
-              apply ceqv
-             apply csymbr
-             apply (simp add: true_def Collect_True
-                         del: Collect_const)
-             apply (rule ccorres_rhs_assoc)+
-             apply (rule checkCapAt_ccorres2)
-                apply ceqv
-               apply csymbr
-               apply (simp add: true_def Collect_True
-                                assertDerived_def bind_assoc
-                                ccorres_cond_iffs dc_def[symmetric]
-                           del: Collect_const)
-               apply (rule ccorres_symb_exec_l)
-                  apply (ctac add: cteInsert_ccorres)
-                 apply (wp empty_fail_stateAssert hoare_case_option_wp | simp del: Collect_const)+
-              apply csymbr
-              apply (simp add: false_def Collect_False ccorres_cond_iffs
-                          del: Collect_const)
-              apply (rule ccorres_return_Skip[unfolded dc_def])
-             apply (fastforce simp: guard_is_UNIV_def Kernel_C.tcbVTable_def tcbVTableSlot_def
-                                    cte_level_bits_def size_of_def)
-            apply csymbr
-            apply (simp add: false_def Collect_False
-                        del: Collect_const)
-            apply (rule ccorres_cond_false)
-            apply (rule ccorres_return_Skip[unfolded dc_def])
-           apply (clarsimp simp: guard_is_UNIV_def false_def
-                                 ccap_relation_def cap_thread_cap_lift
-                                 cap_to_H_def)
-          apply simp
-          apply (rule ccorres_split_throws, rule ccorres_return_C_errorE, simp+)
-          apply vcg
-         apply (simp add: conj_comms, simp cong: conj_cong add: invs_mdb' invs_pspace_aligned')
-         apply (simp add: cte_is_derived_capMasterCap_strg o_def)
-         apply (wp cteDelete_invs' hoare_case_option_wp cteDelete_deletes
-                   cteDelete_sch_act_simple
-                | strengthen invs_valid_objs')+
-         apply (rule hoare_post_imp_R[where Q' = "\<lambda>r. invs'"])
-          apply (wp cteDelete_invs')
-         apply (clarsimp simp:cte_wp_at_ctes_of)
-        apply simp
+     apply (rule subst[where P="%t. ccorres _ _ _ _ _ (_ t) _", OF bindE_assoc])
+     apply (rule subst[where P="%t. ccorres _ _ _ _ _ (_ t) _", OF bindE_assoc])
+     apply (rule ccorres_subgoal_tailE)
+      apply (rule_tac A="invs' and sch_act_simple and tcb_at' target
+                                and (\<lambda>(s::kernel_state). (case priority of None \<Rightarrow> True
+                                                                         | Some x \<Rightarrow> ((\<lambda>y. fst y \<le> maxPriority)) x))
+                                and case_option \<top> (case_option \<top> (valid_cap' \<circ> fst) \<circ> snd) buf
+                                and case_option \<top> (case_option \<top> (cte_at' \<circ> snd) \<circ> snd) buf
+                                and K (case_option True (swp is_aligned msg_align_bits \<circ> fst) buf)
+                                and K (case_option True (case_option True (isArchObjectCap \<circ> fst) \<circ> snd) buf)"
+                      (* bits of tcb_inv_wf' *)
+                      in ccorres_guard_imp2[where A'=UNIV])
+       apply (rule ssubst[where P="%t. ccorres _ _ _ _ _ t _"])
+        apply (unfold installTCBFrameCap_def fun_app_def)[1]
+        apply (clarsimp simp: case_option_If2 liftE_bindE)
+        apply (rule refl)
        apply (rule ccorres_Cond_rhs_Seq)
+        apply (simp only: if_True Collect_True split_def bindE_assoc)
         apply (rule ccorres_rhs_assoc)+
         apply csymbr
         apply (rule ccorres_move_array_assertion_tcb_ctes ccorres_Guard_Seq)+
-        apply (simp add: split_def getThreadCSpaceRoot_def locateSlot_conv
-                         bindE_assoc liftE_bindE
-                    del: Collect_const)
         apply csymbr
+        apply (simp add: liftE_bindE[symmetric] bindE_assoc getThreadBufferSlot_def
+                         locateSlot_conv o_def
+                    del: Collect_const)
+        apply (simp add: liftE_bindE del: Collect_const)
         apply (ctac(no_vcg) add: cteDelete_ccorres)
-          apply (simp add: liftE_bindE Collect_False ccorres_cond_iffs
-                           dc_def
-                      del: Collect_const)
-          apply ((rule ccorres_split_nothrow_novcg_dc[rotated], assumption)
-                  | rule ccorres_rhs_assoc2)+
-            apply (simp add: conj_comms pred_conj_def)
-            apply (simp add: o_def cong: conj_cong option.case_cong)
-            apply (wp checked_insert_tcb_invs' hoare_case_option_wp
-                      checkCap_inv [where P="tcb_at' p0" for p0]
-                      checkCap_inv [where P="cte_at' p0" for p0]
-                      checkCap_inv [where P="valid_cap' c" for c]
-                      checkCap_inv [where P="sch_act_simple"]
-                   | simp)+
-           apply (fastforce simp: guard_is_UNIV_def
-                                  Kernel_C.tcbVTable_def tcbVTableSlot_def
-                                  cte_level_bits_def size_of_def
-                                  tcb_cnode_index_defs)
-          apply (thin_tac "ccorres a1 a2 a3 a4 a5 a6 a7" for a1 a2 a3 a4 a5 a6 a7)
-          apply (rule ccorres_rhs_assoc)+
-          apply (rule checkCapAt_ccorres2)
-             apply ceqv
+          apply (simp del: Collect_const add: Collect_False)
+          apply (rule ccorres_move_c_guard_tcb)
+          apply (rule ccorres_split_nothrow_novcg)
+              apply (rule threadSet_ccorres_lemma2[where P=\<top>])
+               apply vcg
+              apply clarsimp
+              apply (erule(1) rf_sr_tcb_update_no_queue2,
+                     (simp add: typ_heap_simps')+, simp_all?)[1]
+               apply (rule ball_tcb_cte_casesI, simp+)
+              apply (clarsimp simp: ctcb_relation_def option_to_0_def)
+             apply (rule ceqv_refl)
             apply csymbr
-            apply (simp add: true_def Collect_True
+            apply (simp add: ccorres_cond_iffs Collect_False split_def
                         del: Collect_const)
-            apply (rule ccorres_rhs_assoc)+
-            apply (rule checkCapAt_ccorres2)
-               apply ceqv
+            apply (rule ccorres_Cond_rhs_Seq)
+             (* P *)
+             apply (rule ccorres_rhs_assoc)+
+             apply (simp add: case_option_If2 if_n_0_0 split_def
+                         del: Collect_const)
+             apply (rule checkCapAt_ccorres)
+                apply ceqv
+               apply csymbr
+               apply (simp add: true_def Collect_True
+                           del: Collect_const)
+               apply (rule ccorres_rhs_assoc)+
+               apply (rule checkCapAt_ccorres)
+                  apply ceqv
+                 apply csymbr
+                 apply (simp add: true_def Collect_True
+                             del: Collect_const)
+                 apply (simp add: assertDerived_def bind_assoc del: Collect_const)
+                 apply (rule ccorres_symb_exec_l)
+                    apply (ctac(no_vcg) add: cteInsert_ccorres)
+                     apply (rule ccorres_pre_getCurThread)
+                     apply (rule ccorres_split_nothrow_novcg_dc)
+                        apply (simp add: when_def)
+                        apply (rename_tac curThread)
+                        apply (rule_tac C'="{s. target = curThread}"
+                                        and Q="\<lambda>s. ksCurThread s = curThread"
+                                        and Q'=UNIV in ccorres_rewrite_cond_sr)
+                         apply (clarsimp simp: Collect_const_mem rf_sr_ksCurThread)
+                        apply (rule ccorres_Cond_rhs; clarsimp)
+                         apply (ctac (no_vcg) add: rescheduleRequired_ccorres[unfolded dc_def])
+                        apply (rule ccorres_return_Skip')
+                       apply (rule ccorres_split_nothrow_novcg_dc)
+                          apply (rule ccorres_cond2[where R=\<top>], simp add: Collect_const_mem)
+                           apply (ctac add: setPriority_ccorres)
+                          apply (rule ccorres_return_Skip)
+                         apply (rule ccorres_return_CE, simp+)[1]
+                        apply (wp (once))
+                       apply (clarsimp simp: guard_is_UNIV_def)
+                      apply (wpsimp wp: when_def static_imp_wp)
+                       apply (strengthen sch_act_wf_weak, wp)
+                      apply clarsimp
+                      apply wp
+                     apply (clarsimp simp : guard_is_UNIV_def Collect_const_mem)
+                    apply (rule hoare_strengthen_post[
+                                 where Q= "\<lambda>rv s.
+                                           Invariants_H.valid_queues s \<and>
+                                           valid_objs' s \<and>
+                                           weak_sch_act_wf (ksSchedulerAction s) s \<and>
+                                           ((\<exists>a b. priority = Some (a, b)) \<longrightarrow>
+                                                tcb_at' target s \<and> ksCurDomain s \<le> maxDomain \<and>
+                                                valid_queues' s \<and>  fst (the priority) \<le> maxPriority)"])
+                     apply (strengthen sch_act_wf_weak)
+                     apply (wp static_imp_wp)
+                    apply (clarsimp split: if_splits)
+                   apply (wp empty_fail_stateAssert hoare_case_option_wp | simp del: Collect_const)+
+                apply csymbr
+                apply (simp add: false_def Collect_False ccorres_cond_iffs
+                            del: Collect_const)
+                apply (rule ccorres_pre_getCurThread)
+                apply (rename_tac curThread)
+                apply (rule ccorres_split_nothrow_novcg_dc)
+                   (* \<not>P *)
+                   apply (simp add: when_def to_bool_def)
+                   apply (rule_tac C'="{s. target = curThread}"
+                                   and Q="\<lambda>s. ksCurThread s = curThread"
+                                   and Q'=UNIV in ccorres_rewrite_cond_sr)
+                    apply (clarsimp simp: Collect_const_mem rf_sr_ksCurThread)
+                   apply (rule ccorres_Cond_rhs; clarsimp)
+                    apply (ctac (no_vcg) add: rescheduleRequired_ccorres[unfolded dc_def])
+                   apply (rule ccorres_return_Skip')
+                  apply (rule ccorres_split_nothrow_novcg_dc)
+                     apply (rule ccorres_cond2[where R=\<top>], simp add: Collect_const_mem)
+                      apply (ctac add: setPriority_ccorres)
+                     apply (rule ccorres_return_Skip)
+                    apply (rule ccorres_return_CE, simp+)
+                   apply wp
+                  apply (clarsimp simp: guard_is_UNIV_def)
+                 apply (simp add: when_def)
+                 apply (wp hoare_vcg_if_lift2(1) static_imp_wp, strengthen sch_act_wf_weak; wp)
+                apply (clarsimp simp : guard_is_UNIV_def Collect_const_mem)
+               apply (clarsimp simp: guard_is_UNIV_def Collect_const_mem
+                                     tcbBuffer_def size_of_def cte_level_bits_def
+                                     tcbIPCBufferSlot_def)
               apply csymbr
-              apply (simp add: true_def Collect_True
-                               assertDerived_def bind_assoc
-                               ccorres_cond_iffs dc_def[symmetric]
+              apply (simp add: Collect_False false_def
                           del: Collect_const)
-              apply (rule ccorres_symb_exec_l)
-                 apply (ctac add: cteInsert_ccorres)
-                apply (wp empty_fail_stateAssert  hoare_case_option_wp | simp del: Collect_const)+
-             apply csymbr
-             apply (simp add: false_def Collect_False ccorres_cond_iffs
-                         del: Collect_const)
-             apply (rule ccorres_return_Skip[unfolded dc_def])
-            apply (clarsimp simp: guard_is_UNIV_def Collect_const_mem
-                                  Kernel_C.tcbCTable_def tcbCTableSlot_def
-                                  cte_level_bits_def size_of_def option_to_0_def)
-           apply csymbr
-           apply (simp add: false_def Collect_False
-                       del: Collect_const)
-           apply (rule ccorres_cond_false)
-           apply (rule ccorres_return_Skip[unfolded dc_def])
-          apply (clarsimp simp: guard_is_UNIV_def false_def
-                                ccap_relation_def cap_thread_cap_lift
-                                cap_to_H_def)
-         apply simp
-         apply (rule ccorres_split_throws, rule ccorres_return_C_errorE, simp+)
+              apply (rule ccorres_cond_false_seq, simp)
+              apply (rule ccorres_pre_getCurThread)
+              apply (rename_tac curThread)
+              apply (simp add: when_def to_bool_def)
+              apply (rule ccorres_split_nothrow_novcg_dc)
+                 apply (rule_tac C'="{s. target = curThread}"
+                                 and Q="\<lambda>s. ksCurThread s = curThread"
+                                 and Q'=UNIV in ccorres_rewrite_cond_sr)
+                  apply (clarsimp simp: Collect_const_mem rf_sr_ksCurThread)
+                 apply (rule ccorres_Cond_rhs; clarsimp)
+                  apply (ctac(no_vcg) add: rescheduleRequired_ccorres[unfolded dc_def])
+                 apply (rule ccorres_return_Skip')
+                apply (rule ccorres_split_nothrow_novcg_dc)
+                   apply (rule ccorres_cond2[where R=\<top>], simp add: Collect_const_mem)
+                    apply (ctac add: setPriority_ccorres)
+                   apply (rule ccorres_return_Skip)
+                  apply (rule ccorres_return_CE, simp+)
+                 apply wp
+                apply (clarsimp simp: guard_is_UNIV_def)
+               apply (wp hoare_vcg_if_lift2(1) static_imp_wp, strengthen sch_act_wf_weak; wp)
+              apply (clarsimp simp : guard_is_UNIV_def Collect_const_mem)
+             apply (simp add: guard_is_UNIV_def false_def Collect_const_mem)
+             apply (clarsimp simp: ccap_relation_def cap_thread_cap_lift cap_to_H_def)
+            apply simp
+            apply (rule ccorres_cond_false_seq, simp)
+            apply (rule ccorres_cond_false_seq, simp)
+            apply (simp split: option.split_asm)
+            apply (rule ccorres_pre_getCurThread)
+            apply (rename_tac curThread)
+            apply (simp add: when_def to_bool_def)
+            apply (rule ccorres_split_nothrow_novcg_dc)
+               apply (rule_tac C'="{s. target = curThread}"
+                               and Q="\<lambda>s. ksCurThread s = curThread"
+                               and Q'=UNIV in ccorres_rewrite_cond_sr)
+                apply (clarsimp simp: Collect_const_mem rf_sr_ksCurThread)
+               apply (rule ccorres_Cond_rhs; clarsimp)
+                apply (ctac(no_vcg) add: rescheduleRequired_ccorres[unfolded dc_def])
+               apply (rule ccorres_return_Skip')
+              apply (rule ccorres_split_nothrow_novcg_dc)
+                 apply (rule ccorres_cond2[where R=\<top>], simp add: Collect_const_mem)
+                  apply (ctac add: setPriority_ccorres)
+                 apply (rule ccorres_return_Skip)
+                apply (rule ccorres_return_CE, simp+)
+               apply wp
+              apply (clarsimp simp: guard_is_UNIV_def)
+             apply wpsimp
+              apply (wp static_imp_wp, strengthen sch_act_wf_weak, wp )
+             apply wp
+            apply (clarsimp simp : guard_is_UNIV_def Collect_const_mem)
+           apply (simp cong: conj_cong)
+           apply (rule hoare_strengthen_post[
+                         where Q="\<lambda>a b. (Invariants_H.valid_queues b \<and>
+                                    valid_objs' b \<and>
+                                    sch_act_wf (ksSchedulerAction b) b \<and>
+                                    ((\<exists>a b. priority = Some (a, b)) \<longrightarrow>
+                                       tcb_at'  target b \<and>
+                                       ksCurDomain b \<le> maxDomain \<and> valid_queues' b \<and>
+                                       fst (the priority) \<le> maxPriority)) \<and>
+                                    ((case snd (the buf)
+                                        of None \<Rightarrow> 0
+                                         | Some x \<Rightarrow> snd x) \<noteq> 0 \<longrightarrow>
+                                             invs' b \<and>
+                                             valid_cap' (capability.ThreadCap target) b \<and>
+                                             valid_cap' (fst (the (snd (the buf)))) b \<and>
+                                             (cte_wp_at' (\<lambda>a. is_derived' (map_to_ctes (ksPSpace b))
+                                                              (snd (the (snd (the buf))))
+                                                              (fst (the (snd (the buf))))
+                                                              (cteCap a))
+                                                         (snd (the (snd (the buf)))) b \<longrightarrow>
+                                                cte_wp_at' (\<lambda>scte. capMasterCap (cteCap scte)
+                                                                 = capMasterCap (fst (the (snd (the buf))))
+                                                                 \<or> is_simple_cap' (fst (the (snd (the buf)))))
+                                                           (snd (the (snd (the buf)))) b \<and>
+                                                valid_mdb' b \<and>
+                                                pspace_aligned' b \<and>
+                                                cte_wp_at' (\<lambda>c. True) (snd (the (snd (the buf)))) b))"])
+            prefer 2
+            apply fastforce
+           apply (strengthen cte_is_derived_capMasterCap_strg
+                             invs_queues invs_weak_sch_act_wf invs_sch_act_wf'
+                             invs_valid_objs' invs_mdb' invs_pspace_aligned',
+                   simp add: o_def)
+           apply (rule_tac P="is_aligned (fst (the buf)) msg_align_bits"
+                    in hoare_gen_asm)
+           apply (wp threadSet_ipcbuffer_trivial static_imp_wp
+                  | simp
+                  | strengthen invs_sch_act_wf' invs_valid_objs' invs_weak_sch_act_wf invs_queues
+                               invs_valid_queues' | wp hoare_drop_imps)+
+          apply (clarsimp simp: guard_is_UNIV_def Collect_const_mem
+                                option_to_0_def
+                         split: option.split_asm)
+         apply (clarsimp simp: ccap_relation_def cap_thread_cap_lift cap_to_H_def)
+         apply (rule ccorres_split_throws)
+          apply (rule ccorres_return_C_errorE, simp+)[1]
          apply vcg
-        apply (simp add: conj_comms, simp cong: conj_cong add: invs_mdb' invs_pspace_aligned')
-        apply (simp add: cte_is_derived_capMasterCap_strg o_def)
-        apply (wp cteDelete_invs' hoare_case_option_wp cteDelete_deletes cteDelete_sch_act_simple
-               | strengthen invs_valid_objs')+
-        apply (rule hoare_post_imp_R[where Q' = "\<lambda>r. invs'"])
-         apply (wp cteDelete_invs')
-        apply (clarsimp simp:cte_wp_at_ctes_of)
+        apply (simp add: conj_comms cong: conj_cong)
+        apply (strengthen invs_ksCurDomain_maxDomain')
+        apply (wp hoare_vcg_const_imp_lift_R cteDelete_invs')
        apply simp
-      apply (simp add: conj_comms)
-      apply (wp hoare_case_option_wp threadSet_invs_trivial setMCPriority_invs'
-                typ_at_lifts[OF setMCPriority_typ_at']
-                threadSet_cap_to' static_imp_wp | simp)+
-     apply (clarsimp simp: guard_is_UNIV_def tcbCTableSlot_def Kernel_C.tcbCTable_def
-                           cte_level_bits_def size_of_def word_sle_def option_to_0_def
-                           true_def from_bool_def cintr_def Collect_const_mem)
-    apply (simp add: conj_comms)
-    apply (wp hoare_case_option_wp threadSet_invs_trivial
-              threadSet_cap_to' static_imp_wp | simp)+
-   apply (clarsimp simp: guard_is_UNIV_def Collect_const_mem)
-  apply (clarsimp simp: inQ_def)
+       apply (rule ccorres_split_nothrow_novcg_dc)
+          apply (rule ccorres_cond2[where R=\<top>], simp add: Collect_const_mem)
+           apply (ctac add: setPriority_ccorres)
+          apply (rule ccorres_return_Skip)
+         apply (rule ccorres_return_CE, simp+)
+        apply wp
+       apply (clarsimp simp: guard_is_UNIV_def)
+      apply (clarsimp simp: inQ_def Collect_const_mem cintr_def
+                            exception_defs tcb_cnode_index_defs)
+      apply (simp add: tcbBuffer_def tcbIPCBufferSlot_def word_sle_def
+                       cte_level_bits_def from_bool_def true_def size_of_def case_option_If2 )
+      apply (rule conjI)
+       apply (clarsimp simp: case_option_If2 if_n_0_0 objBits_simps' valid_cap'_def
+                             capAligned_def  word_bits_conv obj_at'_def projectKOs)
+      apply (clarsimp simp: invs_valid_objs' invs_valid_queues'
+                            Invariants_H.invs_queues invs_ksCurDomain_maxDomain')
+     apply (rule ccorres_Cond_rhs_Seq)
+      apply (rule ccorres_rhs_assoc)+
+      apply (rule subst[where P="%t. ccorres _ _ _ _ _ (_ t) _", OF bindE_assoc[symmetric]])
+      apply (rule subst[where P="%t. ccorres _ _ _ _ _ (_ t) _", OF bindE_assoc[symmetric]])
+      apply (ctac (no_vcg) add: installTCBCap_ccorres[where newCap="fst(the faultep)" and srcSlot = "snd(the faultep)"])
+        apply (simp add: true_def)
+        apply (ctac (no_vcg) add: installTCBCap_ccorres[where newCap="fst(the cRoot)" and srcSlot = "snd(the cRoot)"])
+          apply (simp add: true_def)
+          apply (ctac (no_vcg) add: installTCBCap_ccorres[where newCap="fst(the vRoot)" and srcSlot = "snd(the vRoot)"])
+            apply (clarsimp, assumption)
+           apply (simp add: false_def)
+           apply (rule ccorres_split_throws[OF ccorres_return_C_errorE]; clarsimp)
+           apply vcg
+          apply (wpsimp wp: installTCBCap_invs' installTCBCap_sch_act_simple installTCBCap_valid_cap'
+                            hoare_case_option_wpR hoare_vcg_all_lift_R hoare_vcg_const_imp_lift_R)
+         apply (simp add: false_def)
+         apply (rule ccorres_split_throws[OF ccorres_return_C_errorE]; clarsimp)
+         apply vcg
+        apply (wpsimp wp: installTCBCap_invs' installTCBCap_sch_act_simple installTCBCap_valid_cap'
+                          hoare_case_option_wpR hoare_vcg_all_lift_R hoare_vcg_const_imp_lift_R)
+       apply (simp add: false_def)
+       apply (rule ccorres_split_throws[OF ccorres_return_C_errorE]; clarsimp)
+       apply vcg
+      apply (wpsimp wp: installTCBCap_invs' installTCBCap_sch_act_simple installTCBCap_valid_cap'
+                        hoare_case_option_wpR hoare_vcg_all_lift_R hoare_vcg_const_imp_lift_R)
+     apply (clarsimp simp: installTCBCap_def, assumption)
+    apply (wpsimp wp: setMCPriority_invs' setMCPriority_sch_act_simple setMCPriority_valid_cap
+                      hoare_case_option_wp hoare_vcg_all_lift hoare_vcg_const_imp_lift)
+   apply (fastforce simp: Kernel_C.tcbCTable_def Kernel_C.tcbVTable_def Kernel_C.tcbFaultHandler_def
+                          guard_is_UNIV_def option_to_0_def ccap_relation_def cap_thread_cap_lift cap_to_H_def)
   apply (subst is_aligned_neg_mask_eq)
    apply (simp add: tcb_ptr_to_ctcb_ptr_def)
    apply (rule aligned_add_aligned)
      apply (fastforce simp add: obj_at'_def projectKOs objBits_simps')
     apply (simp add: ctcb_offset_defs is_aligned_def)
    apply (simp add: word_bits_conv)
-  apply simp
-  apply (subgoal_tac "s \<turnstile>' capability.ThreadCap target")
-   apply (clarsimp simp: cte_level_bits_def Kernel_C.tcbCTable_def Kernel_C.tcbVTable_def
-                         tcbCTableSlot_def tcbVTableSlot_def size_of_def
-                         tcb_cte_cases_def isCap_simps
-                  split: option.split_asm
-                  dest!: isValidVTableRootD)
-  apply (clarsimp simp: valid_cap'_def capAligned_def word_bits_conv
-                        obj_at'_def objBits_simps' projectKOs)
+  apply (clarsimp cong: conj_cong imp_cong)
+  apply (auto simp: isValidFaultHandler_def isValidVTableRoot_def isCap_simps split: option.split_asm)
   done
 
 lemma setupReplyMaster_ccorres:
@@ -4493,18 +4500,17 @@ lemma decodeSetSpace_ccorres:
                         word_sless_def)
   apply (frule interpret_excaps_eq[rule_format, where n=0], simp)
   apply (frule interpret_excaps_eq[rule_format, where n=1], simp)
+  apply (frule interpret_excaps_eq[rule_format, where n=2], simp)
   apply (clarsimp simp: mask_def[where n=4] ccap_rights_relation_def
                         rightsFromWord_wordFromRights
                         capTCBPtr_eq tcb_cnode_index_defs size_of_def
                         option_to_0_def rf_sr_ksCurThread
-                        "StrictC'_thread_state_defs" mask_eq_iff_w2p word_size)
+                        "StrictC'_thread_state_defs" mask_eq_iff_w2p word_size numerals)
   apply (simp add: word_sle_def cap_get_tag_isCap)
-  apply (subgoal_tac "args \<noteq> []")
-   apply (clarsimp simp: hd_conv_nth)
-   apply (drule sym, simp, simp add: true_def from_bool_0)
-   apply (clarsimp simp: objBits_defs)
-   apply fastforce
-  apply clarsimp
+  apply (clarsimp simp: hd_conv_nth)
+  apply (drule sym, simp, simp add: true_def from_bool_0)
+  apply (clarsimp simp: objBits_defs)
+  apply fastforce
   done
 
 lemma invokeTCB_SetTLSBase_ccorres:

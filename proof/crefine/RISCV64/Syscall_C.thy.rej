--- Syscall_C.thy
+++ Syscall_C.thy
@@ -495,26 +493,6 @@ lemma cap_case_EndpointCap_CanSend_CanGrant:
   by (simp add: isCap_simps
            split: capability.split bool.split)
 
-lemma threadGet_tcbFaultHandler_ccorres [corres]:
-  "ccorres (=) handlerCPtr_' (tcb_at' tptr) UNIV hs
-           (threadGet tcbFaultHandler tptr)
-           (Guard C_Guard \<lbrace>hrs_htd \<acute>t_hrs \<Turnstile>\<^sub>t (tcb_ptr_to_ctcb_ptr tptr)\<rbrace>
-               (\<acute>handlerCPtr :==
-                  h_val (hrs_mem \<acute>t_hrs)
-                   (Ptr &(tcb_ptr_to_ctcb_ptr tptr\<rightarrow>[''tcbFaultHandler_C''])::word32 ptr)))"
-  apply (rule ccorres_guard_imp2)
-   apply (rule ccorres_add_return2)
-   apply (rule ccorres_pre_threadGet)
-   apply (rule_tac P = "obj_at' (\<lambda>tcb. tcbFaultHandler tcb = x) tptr" and
-                   P'="{s'. \<exists> ctcb.
-          cslift s' (tcb_ptr_to_ctcb_ptr tptr) = Some ctcb \<and>
-                 tcbFaultHandler_C ctcb = x }" in ccorres_from_vcg)
-   apply (rule allI, rule conseqPre, vcg)
-   apply clarsimp
-   apply (clarsimp simp: return_def typ_heap_simps')
-  apply (clarsimp simp: obj_at'_def ctcb_relation_def)
-done
-
 lemma rf_sr_tcb_update_twice:
   "h_t_valid (hrs_htd (hrs2 (globals s') (t_hrs_' (gs2 (globals s'))))) c_guard
       (ptr (t_hrs_' (gs2 (globals s'))) (globals s'))
@@ -538,142 +516,82 @@ lemma hrs_mem_update_use_hrs_mem:
   by (simp add: hrs_mem_update_def hrs_mem_def fun_eq_iff)
 
 lemma sendFaultIPC_ccorres:
-  "ccorres  (cfault_rel2 \<currency> dc) (liftxf errstate id (K ()) ret__unsigned_long_')
-      (invs' and st_tcb_at' simple' tptr and sch_act_not tptr and
-       (\<lambda>s. \<forall>p. tptr \<notin> set (ksReadyQueues s p)))
+  "ccorres  (cfault_rel2 \<currency> (\<lambda>rv rv'. rv' = from_bool rv))
+            (liftxf errstate (K 0) id ret__unsigned_long_')
+      (invs' and st_tcb_at' simple' tptr and sch_act_not tptr
+             and (\<lambda>s. \<forall>p. tptr \<notin> set (ksReadyQueues s p))
+             and (\<lambda>s. isEndpointCap handlerCap \<longrightarrow> ep_at' (capEPPtr handlerCap) s))
       (UNIV \<inter> {s. (cfault_rel (Some fault) (seL4_Fault_lift(current_fault_' (globals s)))
-                       (lookup_fault_lift(current_lookup_fault_' (globals s))))}
+                                           (lookup_fault_lift(current_lookup_fault_' (globals s))))}
+            \<inter> {s. ccap_relation handlerCap (handlerCap_' s)}
             \<inter> {s. tptr_' s = tcb_ptr_to_ctcb_ptr tptr})
-      [] (sendFaultIPC tptr fault)
+      [] (sendFaultIPC tptr handlerCap fault)
          (Call sendFaultIPC_'proc)"
   supply if_cong[cong] option.case_cong[cong]
   supply Collect_const[simp del]
-  apply (cinit lift: tptr_' cong: call_ignore_cong)
-   apply (simp add: liftE_bindE del:Collect_const cong:call_ignore_cong)
-   apply (rule ccorres_symb_exec_r)
-     apply (rule ccorres_split_nothrow)
-         apply (rule threadGet_tcbFaultHandler_ccorres)
-        apply ceqv
-       apply (rule_tac  xf'=lu_ret___struct_lookupCap_ret_C_'
-                in ccorres_split_nothrow_callE)
-                apply (rule capFaultOnFailure_ccorres)
-                apply (rule lookupCap_ccorres)
-               apply simp+
-           apply ceqv
-          apply (rename_tac epcap epcap')
-          apply clarsimp
-          apply ccorres_rewrite
-          apply csymbr
-          apply (simp add: cap_case_EndpointCap)
-          apply (rule ccorres_rhs_assoc2)
-          apply (rule ccorres_rhs_assoc2)
-          apply (rule ccorres_rhs_assoc2)
-          apply (rule_tac val="from_bool (isEndpointCap epcap \<and> capEPCanSend epcap
-                                          \<and> (capEPCanGrant epcap \<or> capEPCanGrantReply epcap))"
-                   and xf'=ret__int_' and R=\<top> and R'=UNIV in ccorres_symb_exec_r_known_rv)
-             apply (rule conseqPre, vcg)
-             apply (fastforce simp: from_bool_eq_if' cap_get_tag_isCap isCap_simps
-                                    ccap_relation_ep_helpers)
-            apply ceqv
-           apply clarsimp
-           apply (rule ccorres_Cond_rhs)
-            (* case: we send the IPC *)
-            apply clarsimp
-            apply (simp add: liftE_def bind_assoc)
-            apply (rule ccorres_rhs_assoc)+
-            apply (rule ccorres_rhs_assoc2)
-            apply (rule ccorres_rhs_assoc2)
-            apply (rule_tac ccorres_split_nothrow_novcg)
-                apply (rule_tac P=\<top> and P'=invs'
-                          and R="{s.
-                        (cfault_rel (Some fault)
-                        (seL4_Fault_lift(current_fault_' (globals s)))
-                         (lookup_fault_lift(original_lookup_fault_'  s)))}"
-                          in threadSet_ccorres_lemma4)
-                 apply vcg
-                apply (clarsimp simp: typ_heap_simps' rf_sr_tcb_update_twice)
-
-                apply (intro conjI allI impI)
-                 apply (simp add: typ_heap_simps' rf_sr_def)
-                 apply (rule rf_sr_tcb_update_no_queue2[unfolded rf_sr_def, simplified],
-                         assumption+, (simp add: typ_heap_simps')+)
-                  apply (rule ball_tcb_cte_casesI, simp+)
-                 apply (simp add: ctcb_relation_def cthread_state_relation_def)
-                 apply (case_tac "tcbState tcb", simp+)
-                apply (simp add: rf_sr_def)
-                apply (rule rf_sr_tcb_update_no_queue2[unfolded rf_sr_def, simplified],
-                       assumption+, (simp add: typ_heap_simps' | simp only: hrs_mem_update_use_hrs_mem)+)
-                 apply (rule ball_tcb_cte_casesI, simp+)
-                apply (clarsimp simp: typ_heap_simps')
-                apply (simp add: ctcb_relation_def cthread_state_relation_def)
-                apply (rule conjI)
-                 apply (case_tac "tcbState tcb", simp+)
-                apply (simp add: cfault_rel_def)
-                apply (clarsimp)
-                apply (clarsimp simp: seL4_Fault_lift_def Let_def is_cap_fault_def
-                                split: if_split_asm)
-               apply ceqv
-              apply csymbr
-              apply csymbr
-              apply csymbr
-              apply (ctac (no_vcg) add: sendIPC_ccorres)
-               apply (ctac (no_vcg) add: ccorres_return_CE [unfolded returnOk_def comp_def])
-              apply wp
-             apply (wp threadSet_pred_tcb_no_state threadSet_invs_trivial threadSet_typ_at_lifts
-                    | simp)+
-
-            apply (clarsimp simp: guard_is_UNIV_def)
-            apply (subgoal_tac "capEPBadge epcap && mask 28 = capEPBadge epcap")
-             apply (clarsimp simp: cap_get_tag_isCap isEndpointCap_def isCap_simps
-                                    ccap_relation_ep_helpers)
-            apply (frule cap_get_tag_isCap(4)[symmetric])
-            apply (clarsimp simp: cap_get_tag_EndpointCap to_bool_def)
-            apply (drule cap_get_tag_isCap(4) [symmetric])
-            apply (clarsimp simp: isCap_simps cap_endpoint_cap_lift cap_lift_capEPBadge_mask_eq)
-           apply (clarsimp simp: case_bool_If)
-           apply (rule_tac P=\<top> and P'=UNIV in ccorres_from_vcg_throws)
-           apply clarsimp
-           apply (clarsimp simp add: throwError_def throw_def return_def)
-           apply (rule conseqPre, vcg)
-           apply (clarsimp simp: EXCEPTION_FAULT_def EXCEPTION_NONE_def)
-           apply (simp add: cfault_rel2_def cfault_rel_def EXCEPTION_FAULT_def)
-           apply (simp add: seL4_Fault_CapFault_lift)
-           apply (simp add: lookup_fault_missing_capability_lift is_cap_fault_def)
-          apply clarsimp
-          apply vcg
-         apply clarsimp
-         apply (rule ccorres_split_throws)
-          apply (rule_tac P=\<top> and P'="{x. errstate x= err'}" in ccorres_from_vcg_throws)
-          apply clarsimp
-          apply (clarsimp simp add: throwError_def throw_def return_def)
-          apply (rule conseqPre, vcg)
-          apply (clarsimp simp: EXCEPTION_FAULT_def EXCEPTION_NONE_def)
-          apply (simp add: cfault_rel2_def cfault_rel_def EXCEPTION_FAULT_def)
-          apply (simp add: seL4_Fault_CapFault_lift is_cap_fault_def)
-          apply (erule lookup_failure_rel_fault_lift [rotated, unfolded EXCEPTION_NONE_def, simplified]
-                 , assumption)
-         apply vcg
-        apply (clarsimp simp: inQ_def)
-        apply (rule_tac Q="\<lambda>a b. invs' b \<and> st_tcb_at' simple' tptr b
-                                 \<and> sch_act_not tptr b \<and> valid_cap' a b
-                                 \<and> (\<forall>p. tptr \<notin> set (ksReadyQueues b p))"
-                 and E="\<lambda> _. \<top>"
-                 in hoare_post_impErr)
-          apply (wp)
-         apply (clarsimp simp: isCap_simps)
-         apply (clarsimp simp: valid_cap'_def pred_tcb_at')
-        apply simp
-       apply (clarsimp simp: if_1_0_0)
-       apply (vcg exspec=lookupCap_modifies)
-      apply clarsimp
-      apply wp
-     apply (clarsimp simp: if_1_0_0)
-     apply (vcg)
-    apply (clarsimp, vcg)
-   apply (rule conseqPre, vcg)
+  apply (cinit lift: handlerCap_' tptr_' cong: call_ignore_cong)
+   apply csymbr
    apply clarsimp
-  apply (clarsimp simp: if_1_0_0)
-  apply fastforce
+   apply (rule ccorres_Cond_rhs)
+    (* case: we send the IPC *)
+    apply (rule ccorres_rhs_assoc)+
+    apply (rule_tac b="(withoutFailure $ do threadSet (tcbFault_update (\<lambda>_. Just fault)) tptr;
+                                           sendIPC True True (capEPBadge handlerCap)
+                                                             (capEPCanGrant handlerCap)
+                                                             (capEPCanGrantReply handlerCap)
+                                                             tptr (capEPPtr handlerCap);
+                                           return True
+                                        od)" in forw_subst[where P="%t. ccorres _ _ _ _ _ t _"])
+     apply (frule cap_get_tag_isCap(4), clarsimp split: capability.split simp: isCap_simps)
+    apply (simp add: liftE_def bind_assoc)
+    apply (rule ccorres_rhs_assoc2)
+    apply (rule ccorres_rhs_assoc2)
+    apply (rule_tac ccorres_split_nothrow_novcg)
+        apply (rule_tac P=\<top> and P'=invs' and R="{s. cfault_rel (Some fault)
+                                                    (seL4_Fault_lift(current_fault_' (globals s)))
+                                                    (lookup_fault_lift(current_lookup_fault_' (globals s)))}"
+                             in threadSet_ccorres_lemma4)
+         apply vcg
+        apply (clarsimp simp: typ_heap_simps' rf_sr_tcb_update_twice)
+        apply (intro conjI allI impI)
+         apply (simp add: typ_heap_simps' rf_sr_def)
+         apply (rule rf_sr_tcb_update_no_queue2[unfolded rf_sr_def, simplified],
+                 assumption+, (simp add: typ_heap_simps')+)
+          apply (rule ball_tcb_cte_casesI, simp+)
+         apply (simp add: ctcb_relation_def cthread_state_relation_def)
+         apply (case_tac "tcbState tcb", simp+)
+        apply (simp add: rf_sr_def)
+        apply (rule rf_sr_tcb_update_no_queue2[unfolded rf_sr_def, simplified],
+               assumption+, (simp add: typ_heap_simps' | simp only: hrs_mem_update_use_hrs_mem)+)
+         apply (rule ball_tcb_cte_casesI, simp+)
+        apply (clarsimp simp: typ_heap_simps' ctcb_relation_def cthread_state_relation_def)
+        apply (rule conjI)
+         apply (case_tac "tcbState tcb"; simp)
+        apply (clarsimp simp: cfault_rel_def seL4_Fault_lift_def Let_def is_cap_fault_def
+                       split: if_split_asm)
+       apply ceqv
+      apply csymbr
+      apply csymbr
+      apply csymbr
+      apply csymbr
+      apply (ctac (no_vcg) add: sendIPC_ccorres)
+       apply (ctac (no_vcg) add: ccorres_return_CE [unfolded returnOk_def comp_def])
+      apply (wp threadSet_invs_trivial threadSet_pred_tcb_no_state | simp)+
+    apply (clarsimp simp: guard_is_UNIV_def)
+    apply (subgoal_tac "capEPBadge handlerCap && mask 28 = capEPBadge handlerCap")
+     apply (clarsimp simp: cap_get_tag_isCap isEndpointCap_def isCap_simps
+                            ccap_relation_ep_helpers EXCEPTION_NONE_def)
+    apply (frule cap_get_tag_isCap(4)[symmetric])
+    apply (clarsimp simp: cap_get_tag_EndpointCap to_bool_def)
+    apply (clarsimp simp: isCap_simps)
+    apply (drule cap_get_tag_isCap(4) [symmetric])
+    apply (clarsimp simp: isCap_simps cap_endpoint_cap_lift cap_lift_capEPBadge_mask_eq)
+   apply (case_tac "handlerCap = NullCap")
+    apply (clarsimp simp: liftE_def)
+    apply (ctac (no_vcg) add: ccorres_return_CE[unfolded returnOk_def comp_def])
+   apply (case_tac handlerCap; clarsimp simp: isCap_simps ccorres_fail' cap_get_tag_isCap)
+  apply (clarsimp simp: inQ_def ccap_relation_def map_option_Some_eq2 c_valid_cap_def cl_valid_cap_def
+                        cap_to_H_def cap_lift_def Let_def cap_tag_defs isCap_simps EXCEPTION_NONE_def)
   done
 
 lemma handleFault_ccorres:
@@ -757,7 +691,7 @@ lemma getMRs_length:
   done
 
 lemma getMessageInfo_msgLength':
-  "\<lbrace>\<top>\<rbrace> getMessageInfo t \<lbrace>\<lambda>rv s. msgLength rv \<le> 0x78\<rbrace>"
+  "\<lbrace>\<top>\<rbrace> getMessageInfo t \<lbrace>\<lambda>rv s. msgLength rv \<le> 0x74\<rbrace>"
   including no_pre
   apply (simp add: getMessageInfo_def)
   apply wp
@@ -963,7 +897,7 @@ lemma handleInvocation_ccorres:
        apply clarsimp
        apply (vcg exspec= lookupCapAndSlot_modifies)
       apply simp
-      apply (wp getMessageInfo_le3 getMessageInfo_msgLength')+
+      apply (wp getMessageInfo_le7 getMessageInfo_msgLength')+
      apply (simp add: msgMaxLength_def, wp getMessageInfo_msgLength')[1]
     apply simp
     apply wp

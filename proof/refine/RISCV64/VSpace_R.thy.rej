--- VSpace_R.thy
+++ VSpace_R.thy
@@ -11,8 +11,10 @@
 theory VSpace_R
 imports TcbAcc_R
 begin
+
 context Arch begin global_naming ARM (*FIXME: arch_split*)
 
+(*FIXME: move to ainvs*)
 lemmas store_pte_typ_ats[wp] = store_pte_typ_ats abs_atyp_at_lifts[OF store_pte_typ_at]
 lemmas store_pde_typ_ats[wp] = store_pde_typ_ats abs_atyp_at_lifts[OF store_pde_typ_at]
 
@@ -77,7 +79,7 @@ lemma pspace_relation_pd:
   apply (drule_tac x="ucast y" in spec, clarsimp)
   apply (simp add: ucast_ucast_mask iffD2 [OF mask_eq_iff_w2p] word_size)
   apply (clarsimp simp add: pde_relation_def)
-  apply (drule(2) aligned_distinct_pde_atI')
+  apply (drule(2) aligned_distinct_pde_atI', simp)
   apply (erule obj_at'_weakenE)
   apply simp
   done
@@ -114,7 +116,7 @@ lemma find_pd_for_asid_eq_helper:
   apply (drule ucast_up_inj, simp)
   apply (simp add: find_pd_for_asid_def bind_assoc
                    word_neq_0_conv[symmetric] liftE_bindE)
-  apply (simp add: exec_gets liftE_bindE bind_assoc
+  apply (simp add: exec_gets liftE_bindE bind_assoc gets_the_def
                    get_asid_pool_def get_object_def)
   apply (simp add: mask_asid_low_bits_ucast_ucast)
   apply (drule ucast_up_inj, simp)
@@ -137,9 +139,8 @@ lemma find_pd_for_asid_assert_eq:
                   cong: bind_apply_cong)
   apply (clarsimp split: Structures_A.kernel_object.splits
                          arch_kernel_obj.splits if_split_asm)
-  apply (simp add: get_pde_def get_pd_def get_object_def
-                   bind_assoc is_aligned_neg_mask_eq
-                   pd_bits_def pdBits_def pdeBits_def pageBits_def)
+  apply (simp add: get_pde_def get_pd_def get_object_def gets_the_def
+                   bind_assoc pd_bits_def pdBits_def pdeBits_def pageBits_def)
   apply (simp add: exec_gets)
   done
 
@@ -161,8 +162,7 @@ lemma find_pd_for_asid_valids:
   apply (simp_all add: validE_def validE_R_def validE_E_def
                        valid_def split: sum.split)
   apply (auto simp: returnOk_def return_def pdeBits_def
-                    pde_at_def pd_bits_def pdBits_def
-                    pageBits_def is_aligned_neg_mask_eq
+                    pde_at_def pd_bits_def pdBits_def pageBits_def
              dest!: find_pd_for_asid_eq_helper
              elim!: is_aligned_weaken)
   done
@@ -221,7 +221,7 @@ lemma findPDForASIDAssert_corres:
            apply (clarsimp split: Structures_A.kernel_object.splits
                                   arch_kernel_obj.splits if_split_asm)
            apply (simp add: get_pde_def exs_valid_def bind_def return_def
-                            get_pd_def get_object_def simpler_gets_def)
+                            get_pd_def get_object_def simpler_gets_def gets_the_def)
           apply wp
           apply simp
          apply (simp add: get_pde_def get_pd_def)
@@ -233,8 +233,7 @@ lemma findPDForASIDAssert_corres:
         apply simp
        apply (clarsimp simp: state_relation_def)
        apply (erule(3) pspace_relation_pd)
-       apply (simp add: pde_at_def pd_bits_def pdBits_def
-                        is_aligned_neg_mask_eq pdeBits_def pageBits_def)
+       apply (simp add: pde_at_def pd_bits_def pdBits_def pdeBits_def pageBits_def)
       apply (rule corres_split_catch [OF _ find_pd_for_asid_corres'[where pd=pd]])
         apply (rule_tac P="\<bottom>" and P'="\<top>" in corres_inst)
         apply (simp add: corres_fail)
@@ -458,7 +457,7 @@ lemma getHWASID_corres:
   apply (simp add: get_hw_asid_def getHWASID_def)
   apply (rule corres_guard_imp)
     apply (rule corres_split_eqr [OF _ loadHWASID_corres[where pd=pd]])
-      apply (case_tac maybe_hw_asid, simp_all)[1]
+      apply (case_tac maybe_hw_asid; simp)
       apply (rule corres_split_eqr [OF _ findFreeHWASID_corres])
          apply (rule corres_split_deprecated [OF _ storeHWASID_corres[where pd=pd]])
            apply (rule corres_trivial, simp )
@@ -610,7 +609,6 @@ lemma invalidate_tlb_by_asid_corres_ex:
    apply simp+
   done
 
-crunch valid_global_objs[wp]: do_machine_op "valid_global_objs"
 lemma state_relation_asid_map:
   "(s, s') \<in> state_relation \<Longrightarrow> armKSASIDMap (ksArchState s') = arm_asid_map (arch_state s)"
   by (simp add: state_relation_def arch_state_relation_def)
@@ -811,16 +809,10 @@ lemma invalidateASIDEntry_corres:
   apply simp
   done
 
-crunch aligned'[wp]: invalidateASID "pspace_aligned'"
-crunch distinct'[wp]: invalidateASID "pspace_distinct'"
-
-lemma invalidateASID_cur' [wp]:
-  "\<lbrace>cur_tcb'\<rbrace> invalidateASID x \<lbrace>\<lambda>_. cur_tcb'\<rbrace>"
-  by (simp add: invalidateASID_def|wp)+
-
-crunch aligned' [wp]: invalidateASIDEntry pspace_aligned'
-crunch distinct' [wp]: invalidateASIDEntry pspace_distinct'
-crunch cur' [wp]: invalidateASIDEntry cur_tcb'
+crunches invalidateASIDEntry
+  for aligned' [wp]: pspace_aligned'
+  and distinct' [wp]:  pspace_distinct'
+  and cur' [wp]:  cur_tcb'
 
 lemma invalidateASID_valid_arch_state [wp]:
   "\<lbrace>valid_arch_state'\<rbrace> invalidateASIDEntry x \<lbrace>\<lambda>_. valid_arch_state'\<rbrace>"
@@ -838,7 +830,7 @@ crunch no_0_obj'[wp]: deleteASID "no_0_obj'"
 
 lemma deleteASID_corres:
   "corres dc
-          (invs and valid_etcbs and K (asid \<le> mask asid_bits \<and> asid \<noteq> 0))
+          (invs and K (asid \<le> mask asid_bits \<and> asid \<noteq> 0))
           (pspace_aligned' and pspace_distinct' and no_0_obj'
               and valid_arch_state' and cur_tcb')
           (delete_asid asid pd) (deleteASID asid pd)"
@@ -850,7 +842,7 @@ lemma deleteASID_corres:
       apply (rule_tac P="\<lambda>s. asid_high_bits_of asid \<in> dom (asidTable o ucast) \<longrightarrow>
                              asid_pool_at (the ((asidTable o ucast) (asid_high_bits_of asid))) s" and
                       P'="pspace_aligned' and pspace_distinct'" and
-                      Q="invs and valid_etcbs and K (asid \<le> mask asid_bits \<and> asid \<noteq> 0) and
+                      Q="invs and K (asid \<le> mask asid_bits \<and> asid \<noteq> 0) and
                          (\<lambda>s. arm_asid_table (arch_state s) = asidTable \<circ> ucast)" in
                       corres_split_deprecated)
          prefer 2
@@ -859,8 +851,7 @@ lemma deleteASID_corres:
         apply (rule corres_when, simp add: mask_asid_low_bits_ucast_ucast)
         apply (rule corres_split_deprecated [OF _ flushSpace_corres[where pd=pd]])
           apply (rule corres_split_deprecated [OF _ invalidateASIDEntry_corres[where pd=pd]])
-            apply (rule_tac P="asid_pool_at (the (asidTable (ucast (asid_high_bits_of asid))))
-                               and valid_etcbs"
+            apply (rule_tac P="asid_pool_at (the (asidTable (ucast (asid_high_bits_of asid))))"
                         and P'="pspace_aligned' and pspace_distinct'"
                          in corres_split_deprecated)
                prefer 2
@@ -921,9 +912,7 @@ lemma valid_arch_state_unmap_strg':
   apply (auto simp: ran_def split: if_split_asm)
   done
 
-crunch armKSASIDTable_inv[wp]: invalidateASIDEntry
-    "\<lambda>s. P (armKSASIDTable (ksArchState s))"
-crunch armKSASIDTable_inv[wp]: flushSpace
+crunch armKSASIDTable_inv[wp]: invalidateASIDEntry, flushSpace
     "\<lambda>s. P (armKSASIDTable (ksArchState s))"
 
 lemma deleteASIDPool_corres:
@@ -1006,7 +995,7 @@ lemma deleteASIDPool_corres:
                                   mask_eq_iff_w2p asid_low_bits_def word_size)
                 apply (rule_tac f="\<lambda>a. a && mask n" for n in arg_cong)
                 apply (rule shiftr_eq_mask_eq)
-                apply (simp add: is_aligned_add_helper is_aligned_neg_mask_eq)
+                apply (simp add: is_aligned_add_helper)
                apply clarsimp
                apply (subgoal_tac "base \<le> base + xa")
                 apply (simp add: valid_vs_lookup_def asid_high_bits_of_def)
@@ -1129,20 +1118,23 @@ proof -
   done
 qed
 
-crunch typ_at' [wp]: armv_contextSwitch "\<lambda>s. P (typ_at' T p s)"
-  (simp: crunch_simps)
+crunches armv_contextSwitch, setVMRoot, setVMRootForFlush
+  for typ_at' [wp]: "\<lambda>s. P (typ_at' T p s)"
+  and sc_at'_n[wp]: "\<lambda>s. P (sc_at'_n n p s)"
+  (wp: hoare_drop_imps)
 
-crunch typ_at' [wp]: setVMRoot "\<lambda>s. P (typ_at' T p s)"
-  (simp: crunch_simps)
+end
 
-lemmas setVMRoot_typ_ats [wp] = typ_at_lifts [OF setVMRoot_typ_at']
+sublocale Arch < setVMRoot: typ_at_all_props' "setVMRoot tcb"
+  by typ_at_props'
 
-lemmas loadHWASID_typ_ats [wp] = typ_at_lifts [OF loadHWASID_inv]
+sublocale Arch < loadHWASID: typ_at_all_props' "loadHWASID asid"
+  by typ_at_props'
 
-crunch typ_at' [wp]: setVMRootForFlush "\<lambda>s. P (typ_at' T p s)"
-  (wp: hoare_drop_imps)
+sublocale Arch < setVMRootForFlush: typ_at_all_props' "setVMRootForFlush pd asid"
+  by typ_at_props'
 
-lemmas setVMRootForFlush_typ_ats' [wp] = typ_at_lifts [OF setVMRootForFlush_typ_at']
+context begin interpretation Arch . (*FIXME: arch_split*)
 
 crunch aligned' [wp]: setVMRootForFlush pspace_aligned'
   (wp: hoare_drop_imps)
@@ -1352,17 +1344,27 @@ lemma flushPage_corres:
               | clarsimp simp: cur_tcb_def [symmetric] cur_tcb'_def [symmetric])+
   done
 
-crunch typ_at' [wp]: flushTable "\<lambda>s. P (typ_at' T p s)"
+crunches flushTable, flushPage
+  for typ_at' [wp]: "\<lambda>s. P (typ_at' T p s)"
+  and sc_at'_n[wp]: "\<lambda>s. P (sc_at'_n n p s)"
   (wp: crunch_wps)
 
-lemmas flushTable_typ_ats' [wp] = typ_at_lifts [OF flushTable_typ_at']
+end
 
-lemmas findPDForASID_typ_ats' [wp] = typ_at_lifts [OF findPDForASID_inv]
+sublocale Arch < flushTable: typ_at_all_props' "flushTable pd asid vptr"
+  by typ_at_props'
 
-crunch aligned'[wp]: unmapPageTable "pspace_aligned'"
-  (simp: crunch_simps
-   wp: crunch_wps getObject_inv loadObject_default_inv)
-crunch distinct'[wp]: unmapPageTable "pspace_distinct'"
+sublocale Arch < flushPage: typ_at_all_props' "flushPage arg1 pd asid vptr"
+  by typ_at_props'
+
+sublocale Arch < findPDForASID: typ_at_all_props' "findPDForASID asid"
+  by typ_at_props'
+
+context begin interpretation Arch . (*FIXME: arch_split*)
+
+crunches unmapPageTable
+  for aligned'[wp]: "pspace_aligned'"
+  and distinct'[wp]: "pspace_distinct'"
   (simp: crunch_simps
    wp: crunch_wps getObject_inv loadObject_default_inv)
 
@@ -1391,14 +1393,9 @@ lemma pageTableMapped_corres:
 crunch inv[wp]: pageTableMapped "P"
   (wp: loadObject_default_inv)
 
-crunches storePDE, storePTE
-  for no_0_obj'[wp]: no_0_obj'
-  and valid_arch'[wp]: valid_arch_state'
-  and cur_tcb'[wp]: cur_tcb'
-
 lemma unmapPageTable_corres:
   "corres dc
-          (invs and valid_etcbs and page_table_at pt and
+          (invs and page_table_at pt and
            K (0 < asid \<and> is_aligned vptr 20 \<and> asid \<le> mask asid_bits))
           (valid_arch_state' and pspace_aligned' and pspace_distinct'
             and no_0_obj' and cur_tcb' and valid_objs')
@@ -1430,21 +1427,15 @@ lemma unmapPageTable_corres:
                      vs_refs_pages_def graph_of_def split: if_splits)
   done
 
-crunch typ_at' [wp]: flushPage "\<lambda>s. P (typ_at' T p s)"
-  (wp: crunch_wps hoare_drop_imps)
-
-lemmas flushPage_typ_ats' [wp] = typ_at_lifts [OF flushPage_typ_at']
-
 crunch valid_objs' [wp]: flushPage "valid_objs'"
   (wp: crunch_wps hoare_drop_imps simp: crunch_simps)
 
 crunch inv: lookupPTSlot "P"
   (wp: loadObject_default_inv)
 
-crunch aligned' [wp]: unmapPage pspace_aligned'
-  (wp: crunch_wps simp: crunch_simps)
-
-crunch distinct' [wp]: unmapPage pspace_distinct'
+crunches unmapPage
+  for aligned' [wp]: pspace_aligned'
+  and distinct' [wp]: pspace_distinct'
   (wp: crunch_wps simp: crunch_simps)
 
 lemma corres_split_strengthen_ftE:
@@ -1507,7 +1498,7 @@ lemma store_pte_pd_at_asid[wp]:
   done
 
 lemma unmapPage_corres:
-  "corres dc (invs and valid_etcbs and
+  "corres dc (invs and
               K (valid_unmap sz (asid,vptr) \<and> vptr < kernel_base \<and> asid \<le> mask asid_bits))
              (valid_objs' and valid_arch_state' and pspace_aligned' and
               pspace_distinct' and no_0_obj' and cur_tcb')
@@ -1526,7 +1517,7 @@ lemma unmapPage_corres:
                              and (\<exists>\<rhd> (lookup_pd_slot pd vptr && ~~ mask pd_bits))
                              and valid_arch_state and valid_vspace_objs
                              and equal_kernel_mappings
-                             and pspace_aligned and valid_global_objs and valid_etcbs and
+                             and pspace_aligned and valid_global_objs and
                              K (valid_unmap sz (asid,vptr) )" and
                           P'="pspace_aligned' and pspace_distinct'" in corres_inst)
           apply clarsimp
@@ -1567,7 +1558,7 @@ lemma unmapPage_corres:
                          apply simp
                         apply simp
                        apply clarsimp
-                       apply (rule_tac P="(\<lambda>s. \<forall>x\<in>set [0, 4 .e. 0x3C]. pte_at (x + pa) s) and pspace_aligned and valid_etcbs"
+                       apply (rule_tac P="(\<lambda>s. \<forall>x\<in>set [0, 4 .e. 0x3C]. pte_at (x + pa) s) and pspace_aligned"
                                    and P'="pspace_aligned' and pspace_distinct'"
                                     in corres_guard_imp)
                          apply (rule storePTE_corres',  simp add:pte_relation_aligned_def)
@@ -1609,7 +1600,7 @@ lemma unmapPage_corres:
                                        superSectionPDEOffsets_def pdeBits_def)
                  apply (rule corres_Id, rule refl, simp)
                  apply (rule no_fail_cleanCacheRange_PoU)
-                apply (rule_tac P="page_directory_at pd and pspace_aligned and valid_etcbs
+                apply (rule_tac P="page_directory_at pd and pspace_aligned
                                       and K (valid_unmap sz (asid, vptr))"
                             in corres_mapM [where r=dc], simp, simp)
                     prefer 5
@@ -1888,7 +1879,7 @@ crunch ctes [wp]: unmapPage "\<lambda>s. P (ctes_of s)"
 
 lemma corres_store_pde_with_invalid_tail:
   "\<forall>slot \<in>set ys. \<not> is_aligned (slot >> 2) (pde_align' ab)
-  \<Longrightarrow>corres dc ((\<lambda>s. \<forall>y\<in> set ys. pde_at y s) and pspace_aligned and valid_etcbs)
+  \<Longrightarrow>corres dc ((\<lambda>s. \<forall>y\<in> set ys. pde_at y s) and pspace_aligned)
            (pspace_aligned' and pspace_distinct')
            (mapM (swp store_pde ARM_A.pde.InvalidPDE) ys)
            (mapM (swp storePDE ab) ys)"
@@ -1911,7 +1902,7 @@ lemma corres_store_pde_with_invalid_tail:
 
 lemma corres_store_pte_with_invalid_tail:
   "\<forall>slot\<in> set ys. \<not> is_aligned (slot >> 2) (pte_align' aa)
-  \<Longrightarrow> corres dc ((\<lambda>s. \<forall>y\<in>set ys. pte_at y s) and pspace_aligned and valid_etcbs)
+  \<Longrightarrow> corres dc ((\<lambda>s. \<forall>y\<in>set ys. pte_at y s) and pspace_aligned)
                 (pspace_aligned' and pspace_distinct')
              (mapM (swp store_pte ARM_A.pte.InvalidPTE) ys)
              (mapM (swp storePTE aa) ys)"
@@ -1970,8 +1961,7 @@ lemma pdeCheckIfMapped_corres:
   done
 
 crunches do_machine_op, store_pte
-  for unique_table_refs[wp]: "\<lambda>s. (unique_table_refs (caps_of_state s))"
-  and valid_asid_map[wp]: "valid_asid_map"
+  for valid_asid_map[wp]: "valid_asid_map"
 
 lemma set_cap_pd_at_asid [wp]:
   "\<lbrace>vspace_at_asid asid pd\<rbrace> set_cap t st \<lbrace>\<lambda>rv. vspace_at_asid asid pd\<rbrace>"
@@ -2115,7 +2110,7 @@ lemma same_refs_vs_cap_ref_eq:
 
 lemma performPageInvocation_corres:
   assumes "page_invocation_map pgi pgi'"
-  shows "corres dc (invs and valid_etcbs and valid_page_inv pgi)
+  shows "corres dc (invs and valid_page_inv pgi)
             (invs' and valid_page_inv' pgi' and (\<lambda>s. vs_valid_duplicates' (ksPSpace s)))
             (perform_page_invocation pgi) (performPageInvocation pgi')"
 proof -
@@ -2124,6 +2119,7 @@ proof -
        (\<forall>c. caps_of_state s p = Some c \<longrightarrow> P s \<and> Q s c)"
    by blast
   show ?thesis
+  apply add_cur_tcb'
   using assms
   apply (cases pgi)
      apply (rename_tac word cap prod sum)
@@ -2132,7 +2128,7 @@ proof -
                            page_invocation_map_def)
      apply (rule corres_guard_imp)
        apply (rule_tac R="\<lambda>_. invs and (valid_page_map_inv word cap (a,b) sum)
-                              and valid_etcbs and (\<lambda>s. caps_of_state s (a,b) = Some cap)"
+                              and (\<lambda>s. caps_of_state s (a,b) = Some cap)"
          and R'="\<lambda>_. invs' and valid_slots' m' and pspace_aligned' and valid_slots_duplicated' m'
          and pspace_distinct' and (\<lambda>s. vs_valid_duplicates' (ksPSpace s))" in corres_split_deprecated)
           prefer 2
@@ -2327,6 +2323,8 @@ proof -
     apply (auto simp: valid_page_inv_def invs_vspace_objs[simplified])[2]
   \<comment> \<open>PageGetAddr\<close>
   apply (clarsimp simp: perform_page_invocation_def performPageInvocation_def page_invocation_map_def fromPAddr_def)
+  apply (rule corres_stateAssert_add_assertion[rotated])
+    apply (clarsimp simp: cur_tcb'_asrt_def)
   apply (rule corres_guard_imp)
     apply (rule corres_split_deprecated[OF _ getCurThread_corres])
       apply simp
@@ -2335,7 +2333,7 @@ proof -
         apply clarsimp
        apply (wp)+
    apply (clarsimp simp: tcb_at_invs)
-  apply (clarsimp simp: tcb_at_invs')
+  apply (clarsimp simp: cur_tcb'_def)
   done
 qed
 
@@ -2362,7 +2360,7 @@ definition
                                  and K (isPageTableCap cap)"
 
 lemma clear_page_table_corres:
-  "corres dc (pspace_aligned and page_table_at p and valid_etcbs)
+  "corres dc (pspace_aligned and page_table_at p)
              (pspace_aligned' and pspace_distinct')
     (mapM_x (swp store_pte ARM_A.InvalidPTE)
        [p , p + 4 .e. p + 2 ^ ptBits - 1])
@@ -2380,7 +2378,7 @@ lemma clear_page_table_corres:
                    mapM_x_mapM liftM_def[symmetric])
   apply (rule corres_guard_imp,
          rule_tac r'=dc and S="(=)"
-               and Q="\<lambda>xs s. \<forall>x \<in> set xs. pte_at x s \<and> pspace_aligned s \<and> valid_etcbs s"
+               and Q="\<lambda>xs s. \<forall>x \<in> set xs. pte_at x s \<and> pspace_aligned s"
                and Q'="\<lambda>xs. pspace_aligned' and pspace_distinct'"
                 in corres_mapM_list_all2, simp_all)
       apply (rule corres_guard_imp, rule storePTE_corres')
@@ -2394,17 +2392,26 @@ lemma clear_page_table_corres:
   apply simp
   done
 
-crunch typ_at'[wp]: unmapPageTable "\<lambda>s. P (typ_at' T p s)"
-lemmas unmapPageTable_typ_ats[wp] = typ_at_lifts[OF unmapPageTable_typ_at']
+crunches unmapPageTable
+  for typ_at' [wp]: "\<lambda>s. P (typ_at' T p s)"
+  and sc_at'_n[wp]: "\<lambda>s. P (sc_at'_n n p s)"
+
+end
+
+sublocale Arch < unmapPageTable: typ_at_all_props' "unmapPageTable asid vaddr pt"
+  by typ_at_props'
+
+context begin interpretation Arch . (*FIXME: arch_split*)
 
 lemma performPageTableInvocation_corres:
   "page_table_invocation_map pti pti' \<Longrightarrow>
    corres dc
-          (invs and valid_etcbs and valid_pti pti)
+          (invs and valid_pti pti)
           (invs' and valid_pti' pti')
           (perform_page_table_invocation pti)
           (performPageTableInvocation pti')"
   (is "?mp \<Longrightarrow> corres dc ?P ?P' ?f ?g")
+  apply add_cur_tcb'
   apply (simp add: perform_page_table_invocation_def performPageTableInvocation_def)
   apply (cases pti)
    apply (clarsimp simp: page_table_invocation_map_def)
@@ -2480,7 +2487,7 @@ definition
 lemma performASIDPoolInvocation_corres:
   "ap' = asid_pool_invocation_map ap \<Longrightarrow>
   corres dc
-          (valid_objs and pspace_aligned and pspace_distinct and valid_apinv ap and valid_etcbs)
+          (valid_objs and pspace_aligned and pspace_distinct and valid_apinv ap)
           (pspace_aligned' and pspace_distinct' and valid_apinv' ap')
           (perform_asid_pool_invocation ap)
           (performASIDPoolInvocation ap')"
@@ -2491,7 +2498,7 @@ lemma performASIDPoolInvocation_corres:
     apply (rule corres_split_deprecated [OF _ getSlotCap_corres])
       apply (rule_tac F="\<exists>p asid. rv = Structures_A.ArchObjectCap (ARM_A.PageDirectoryCap p asid)" in corres_gen_asm)
       apply clarsimp
-      apply (rule_tac Q="valid_objs and pspace_aligned and pspace_distinct and asid_pool_at word2 and valid_etcbs and
+      apply (rule_tac Q="valid_objs and pspace_aligned and pspace_distinct and asid_pool_at word2 and
                          cte_wp_at (\<lambda>c. cap_master_cap c =
                                         cap_master_cap (cap.ArchObjectCap (arch_cap.PageDirectoryCap p asid))) (a,b)"
                       in corres_split_deprecated)
@@ -2542,23 +2549,7 @@ lemma storeHWASID_invs:
    apply fastforce
   apply (simp add: storeHWASID_def)
   apply (wp findPDForASIDAssert_pd_at_wp)
-  apply (clarsimp simp: invs'_def valid_state'_def valid_arch_state'_def
-             valid_global_refs'_def global_refs'_def valid_machine_state'_def
-             ct_not_inQ_def ct_idle_or_in_cur_domain'_def tcb_in_cur_domain'_def)
-  done
-
-lemma storeHWASID_invs_no_cicd':
-  "\<lbrace>invs_no_cicd' and
-   (\<lambda>s. armKSASIDMap (ksArchState s) asid = None \<and>
-        armKSHWASIDTable (ksArchState s) hw_asid = None)\<rbrace>
-  storeHWASID asid hw_asid
-  \<lbrace>\<lambda>x. invs_no_cicd'\<rbrace>"
-  apply (rule hoare_add_post)
-    apply (rule storeHWASID_valid_arch')
-   apply (fastforce simp: all_invs_but_ct_idle_or_in_cur_domain'_def)
-  apply (simp add: storeHWASID_def)
-  apply (wp findPDForASIDAssert_pd_at_wp)
-  apply (clarsimp simp: all_invs_but_ct_idle_or_in_cur_domain'_def valid_state'_def valid_arch_state'_def
+  apply (clarsimp simp: invs'_def valid_arch_state'_def valid_dom_schedule'_def
              valid_global_refs'_def global_refs'_def valid_machine_state'_def
              ct_not_inQ_def ct_idle_or_in_cur_domain'_def tcb_in_cur_domain'_def)
   done
@@ -2572,9 +2563,9 @@ lemma findFreeHWASID_invs:
                    doMachineOp_def split_def
               cong: option.case_cong)
   apply (wp findPDForASIDAssert_pd_at_wp | wpc)+
-  apply (clarsimp simp: invs'_def valid_state'_def valid_arch_state'_def
+  apply (clarsimp simp: invs'_def valid_arch_state'_def
              valid_global_refs'_def global_refs'_def valid_machine_state'_def
-             ct_not_inQ_def
+             ct_not_inQ_def valid_dom_schedule'_def
            split del: if_split)
   apply (intro conjI)
    apply (fastforce dest: no_irq_use [OF no_irq_invalidateLocalTLB_ASID])
@@ -2586,29 +2577,6 @@ lemma findFreeHWASID_invs:
   apply clarsimp
   done
 
-lemma findFreeHWASID_invs_no_cicd':
-  "\<lbrace>invs_no_cicd'\<rbrace> findFreeHWASID \<lbrace>\<lambda>asid. invs_no_cicd'\<rbrace>"
-  apply (rule hoare_add_post)
-    apply (rule findFreeHWASID_valid_arch)
-   apply (fastforce simp: all_invs_but_ct_idle_or_in_cur_domain'_def)
-  apply (simp add: findFreeHWASID_def invalidateHWASIDEntry_def invalidateASID_def
-                   doMachineOp_def split_def
-              cong: option.case_cong)
-  apply (wp findPDForASIDAssert_pd_at_wp | wpc)+
-  apply (clarsimp simp: all_invs_but_ct_idle_or_in_cur_domain'_def valid_state'_def valid_arch_state'_def
-             valid_global_refs'_def global_refs'_def valid_machine_state'_def
-             ct_not_inQ_def
-           split del: if_split)
-  apply (intro conjI)
-    apply (fastforce dest: no_irq_use [OF no_irq_invalidateLocalTLB_ASID])
-   apply clarsimp
-   apply (drule_tac x=p in spec)
-   apply (drule use_valid)
-    apply (rule_tac p=p in invalidateLocalTLB_ASID_underlying_memory)
-    apply blast
-   apply clarsimp
-  done
-
 lemma getHWASID_invs [wp]:
   "\<lbrace>invs'\<rbrace> getHWASID asid \<lbrace>\<lambda>hw_asid. invs'\<rbrace>"
   apply (simp add: getHWASID_def)
@@ -2616,13 +2584,6 @@ lemma getHWASID_invs [wp]:
   apply simp
   done
 
-lemma getHWASID_invs_no_cicd':
-  "\<lbrace>invs_no_cicd'\<rbrace> getHWASID asid \<lbrace>\<lambda>hw_asid. invs_no_cicd'\<rbrace>"
-  apply (simp add: getHWASID_def)
-  apply (wp storeHWASID_invs_no_cicd' findFreeHWASID_invs_no_cicd'|wpc)+
-  apply simp
-  done
-
 lemmas armv_ctxt_sw_defs = armv_contextSwitch_HWASID_def setHardwareASID_def setCurrentPD_def
                            writeTTBR0_def writeTTBR0Ptr_def set_current_pd_def isb_def dsb_def
 
@@ -2642,21 +2603,9 @@ lemma armv_contextSwitch_invs [wp]:
   apply (drule_tac Q="\<lambda>_ m'. underlying_memory m' p = underlying_memory m p"
          in use_valid)
     apply (simp add: machine_op_lift_def machine_rest_lift_def split_def armv_ctxt_sw_defs
-                     writeTTBR0Ptr_def
               | wp)+
   done
 
-lemma armv_contextSwitch_invs_no_cicd':
-  "\<lbrace>invs_no_cicd'\<rbrace> armv_contextSwitch pd asid \<lbrace>\<lambda>rv. invs_no_cicd'\<rbrace>"
-  apply (simp add: armv_contextSwitch_def armv_contextSwitch_HWASID_def setCurrentPD_to_abs)
-  apply (wp dmo_invs_no_cicd' no_irq_setHardwareASID no_irq_set_current_pd no_irq)
-  apply (rule hoare_post_imp[rotated], rule getHWASID_invs_no_cicd')
-  apply clarsimp
-  apply (drule_tac Q="\<lambda>_ m'. underlying_memory m' p = underlying_memory m p"
-         in use_valid)
-    apply (clarsimp simp: machine_op_lift_def machine_rest_lift_def split_def armv_ctxt_sw_defs | wp)+
-  done
-
 lemma dmo_setCurrentPD_invs'[wp]:
   "\<lbrace>invs'\<rbrace> doMachineOp (setCurrentPD addr) \<lbrace>\<lambda>rv. invs'\<rbrace>"
   apply (wpsimp wp: dmo_invs' no_irq_set_current_pd no_irq simp: setCurrentPD_to_abs)
@@ -2666,40 +2615,19 @@ lemma dmo_setCurrentPD_invs'[wp]:
                           machine_rest_lift_def split_def | wp)+
   done
 
-lemma dmo_setCurrentPD_invs_no_cicd':
-  "\<lbrace>invs_no_cicd'\<rbrace> doMachineOp (setCurrentPD addr) \<lbrace>\<lambda>rv. invs_no_cicd'\<rbrace>"
-  apply (wpsimp wp: dmo_invs_no_cicd' no_irq_set_current_pd no_irq  simp: setCurrentPD_to_abs)
-  apply (drule_tac Q="\<lambda>_ m'. underlying_memory m' p = underlying_memory m p"
-         in use_valid)
-  apply (clarsimp simp: set_current_pd_def machine_op_lift_def writeTTBR0_def dsb_def isb_def
-                        machine_rest_lift_def split_def | wp)+
-  done
-
 crunch invs[wp]: setVMRoot "invs'"
   (wp: crunch_wps simp: crunch_simps ignore: doMachineOp)
 
-crunch invs_no_cicd': setVMRoot "invs_no_cicd'"
-  (wp: crunch_wps dmo_setCurrentPD_invs_no_cicd' simp: crunch_simps ignore: doMachineOp)
-
 crunch nosch [wp]: setVMRoot "\<lambda>s. P (ksSchedulerAction s)"
   (wp: crunch_wps getObject_inv simp: crunch_simps
        loadObject_default_def)
 
-crunch it' [wp]: findPDForASID "\<lambda>s. P (ksIdleThread s)"
-  (simp: crunch_simps loadObject_default_def wp: getObject_inv)
-
 crunch it' [wp]: deleteASIDPool "\<lambda>s. P (ksIdleThread s)"
   (simp: crunch_simps loadObject_default_def wp: getObject_inv mapM_wp')
 
 crunch it' [wp]: lookupPTSlot "\<lambda>s. P (ksIdleThread s)"
   (simp: crunch_simps loadObject_default_def wp: getObject_inv)
 
-crunch it' [wp]: storePTE "\<lambda>s. P (ksIdleThread s)"
-  (simp: crunch_simps updateObject_default_def wp: setObject_idle')
-
-crunch it' [wp]: storePDE "\<lambda>s. P (ksIdleThread s)"
-  (simp: crunch_simps updateObject_default_def wp: setObject_idle')
-
 crunch it' [wp]: flushTable "\<lambda>s. P (ksIdleThread s)"
   (simp: crunch_simps loadObject_default_def
    wp: setObject_idle' hoare_drop_imps mapM_wp')
@@ -2716,50 +2644,30 @@ lemma valid_slots_lift':
    apply (rule hoare_pre, wp hoare_vcg_const_Ball_lift t valid_pde_lift' valid_pte_lift', simp)+
   done
 
-crunch typ_at' [wp]: performPageTableInvocation "\<lambda>s. P (typ_at' T p s)"
-  (wp: crunch_wps)
-
-crunch typ_at' [wp]: performPageDirectoryInvocation "\<lambda>s. P (typ_at' T p s)"
-  (wp: crunch_wps)
-
-crunch typ_at' [wp]: performPageInvocation "\<lambda>s. P (typ_at' T p s)"
-  (wp: crunch_wps)
+crunches performPageTableInvocation, performPageDirectoryInvocation,
+         performPageInvocation, performASIDPoolInvocation
+  for typ_at' [wp]: "\<lambda>s. P (typ_at' T p s)"
+  and sc_at'_n[wp]: "\<lambda>s. P (sc_at'_n n p s)"
+  (wp: crunch_wps getASID_wp)
 
-crunch typ_at' [wp]: performASIDPoolInvocation "\<lambda>s. P (typ_at' T p s)"
-  (wp: getObject_cte_inv getASID_wp)
+end
 
-lemmas performPageTableInvocation_typ_ats' [wp] =
-  typ_at_lifts [OF performPageTableInvocation_typ_at']
+sublocale Arch < performPageTableInvocation: typ_at_all_props' "performPageTableInvocation i"
+  by typ_at_props'
 
-lemmas performPageDirectoryInvocation_typ_ats' [wp] =
-  typ_at_lifts [OF performPageDirectoryInvocation_typ_at']
+sublocale Arch < performPageDirectoryInvocation: typ_at_all_props' "performPageDirectoryInvocation i"
+  by typ_at_props'
 
-lemmas performPageInvocation_typ_ats' [wp] =
-  typ_at_lifts [OF performPageInvocation_typ_at']
+sublocale Arch < performPageInvocation: typ_at_all_props' "performPageInvocation i"
+  by typ_at_props'
 
-lemmas performASIDPoolInvocation_typ_ats' [wp] =
-  typ_at_lifts [OF performASIDPoolInvocation_typ_at']
+sublocale Arch < performASIDPoolInvocation: typ_at_all_props' "performASIDPoolInvocation i"
+  by typ_at_props'
 
-lemma storePDE_pred_tcb_at' [wp]:
-  "\<lbrace>pred_tcb_at' proj P t\<rbrace> storePDE p pde \<lbrace>\<lambda>_. pred_tcb_at' proj P t\<rbrace>"
-  apply (simp add: storePDE_def pred_tcb_at'_def)
-  apply (rule obj_at_setObject2)
-  apply (clarsimp simp add: updateObject_default_def in_monad)
-  done
+sublocale Arch < unmapPage: typ_at_all_props' "unmapPage magnitude asid vptr ptr"
+  by typ_at_props'
 
-lemma storePTE_pred_tcb_at' [wp]:
-  "\<lbrace>pred_tcb_at' proj P t\<rbrace> storePTE p pte \<lbrace>\<lambda>_. pred_tcb_at' proj P t\<rbrace>"
-  apply (simp add: storePTE_def pred_tcb_at'_def)
-  apply (rule obj_at_setObject2)
-  apply (clarsimp simp add: updateObject_default_def in_monad)
-  done
-
-lemma setASID_pred_tcb_at' [wp]:
-  "\<lbrace>pred_tcb_at' proj P t\<rbrace> setObject p (ap::asidpool) \<lbrace>\<lambda>_. pred_tcb_at' proj P t\<rbrace>"
-  apply (simp add: pred_tcb_at'_def)
-  apply (rule obj_at_setObject2)
-  apply (clarsimp simp add: updateObject_default_def in_monad)
-  done
+context begin interpretation Arch . (*FIXME: arch_split*)
 
 lemma dmo_ct[wp]:
   "\<lbrace>\<lambda>s. P (ksCurThread s)\<rbrace> doMachineOp m \<lbrace>\<lambda>rv s. P (ksCurThread s)\<rbrace>"
@@ -2768,37 +2676,6 @@ lemma dmo_ct[wp]:
   apply clarsimp
   done
 
-lemma storePDE_valid_mdb [wp]:
-  "\<lbrace>valid_mdb'\<rbrace> storePDE p pde \<lbrace>\<lambda>rv. valid_mdb'\<rbrace>"
-  by (simp add: valid_mdb'_def) wp
-
-crunch nosch [wp]: storePDE "\<lambda>s. P (ksSchedulerAction s)"
-  (simp: updateObject_default_def ignore_del: setObject)
-
-crunch ksQ [wp]: storePDE "\<lambda>s. P (ksReadyQueues s)"
-  (simp: updateObject_default_def)
-
-lemma storePDE_inQ[wp]:
-  "\<lbrace>\<lambda>s. P (obj_at' (inQ d p) t s)\<rbrace> storePDE ptr pde \<lbrace>\<lambda>rv s. P (obj_at' (inQ d p) t s)\<rbrace>"
-  apply (simp add: obj_at'_real_def storePDE_def)
-  apply (wp setObject_ko_wp_at | simp add: objBits_simps archObjSize_def pdeBits_def)+
-  apply (clarsimp simp: projectKOs obj_at'_def ko_wp_at'_def)
-  done
-
-crunch norqL1[wp]: storePDE "\<lambda>s. P (ksReadyQueuesL1Bitmap s)"
-  (simp: updateObject_default_def)
-
-crunch norqL2[wp]: storePDE "\<lambda>s. P (ksReadyQueuesL2Bitmap s)"
-  (simp: updateObject_default_def)
-
-lemma storePDE_valid_queues [wp]:
-  "\<lbrace>Invariants_H.valid_queues\<rbrace> storePDE p pde \<lbrace>\<lambda>_. Invariants_H.valid_queues\<rbrace>"
-  by (wp valid_queues_lift | simp add: pred_tcb_at'_def)+
-
-lemma storePDE_valid_queues' [wp]:
-  "\<lbrace>valid_queues'\<rbrace> storePDE p pde \<lbrace>\<lambda>_. valid_queues'\<rbrace>"
-  by (wp valid_queues_lift')
-
 lemma storePDE_state_refs' [wp]:
   "\<lbrace>\<lambda>s. P (state_refs_of' s)\<rbrace> storePDE p pde \<lbrace>\<lambda>rv s. P (state_refs_of' s)\<rbrace>"
   apply (clarsimp simp: storePDE_def)
@@ -2819,44 +2696,6 @@ lemma storePDE_iflive [wp]:
      apply (auto simp: updateObject_default_def in_monad projectKOs pdeBits_def)
   done
 
-lemma setObject_pde_ksInt [wp]:
-  "\<lbrace>\<lambda>s. P (ksInterruptState s)\<rbrace> setObject p (pde::pde) \<lbrace>\<lambda>_. \<lambda>s. P (ksInterruptState s)\<rbrace>"
-  by (wp setObject_ksInterrupt updateObject_default_inv|simp)+
-
-crunch ksInterruptState [wp]: storePDE "\<lambda>s. P (ksInterruptState s)"
-
-lemma storePDE_ifunsafe [wp]:
-  "\<lbrace>if_unsafe_then_cap'\<rbrace> storePDE p pde \<lbrace>\<lambda>rv. if_unsafe_then_cap'\<rbrace>"
-  apply (simp add: storePDE_def)
-  apply (rule hoare_pre)
-   apply (rule setObject_ifunsafe' [where P=\<top>], simp)
-     apply (auto simp: updateObject_default_def in_monad projectKOs)[2]
-   apply wp
-  apply simp
-  done
-
-method valid_idle'_setObject uses simp =
-  simp add: valid_idle'_def, rule hoare_lift_Pf [where f="ksIdleThread"]; wpsimp?;
-  (wpsimp wp: obj_at_setObject2[where P="idle_tcb'", simplified] hoare_drop_imp
-        simp: simp
-   | clarsimp dest!: updateObject_default_result)+
-
-lemma storePDE_idle [wp]:
-  "\<lbrace>valid_idle'\<rbrace> storePDE p pde \<lbrace>\<lambda>rv. valid_idle'\<rbrace>" by (valid_idle'_setObject simp: storePDE_def)
-
-crunches storePDE
-  for arch'[wp]: "\<lambda>s. P (ksArchState s)"
-  and cur'[wp]: "\<lambda>s. P (ksCurThread s)"
-
-lemma storePDE_irq_states' [wp]:
-  "\<lbrace>valid_irq_states'\<rbrace> storePDE pde p \<lbrace>\<lambda>_. valid_irq_states'\<rbrace>"
-  apply (simp add: storePDE_def)
-  apply (wpsimp wp: valid_irq_states_lift' dmo_lift' no_irq_storeWord setObject_ksMachine
-                    updateObject_default_inv)
-  done
-
-crunch no_0_obj' [wp]: storePDE no_0_obj'
-
 lemma storePDE_pde_mappings'[wp]:
   "\<lbrace>valid_pde_mappings' and K (valid_pde_mapping' (p && mask pdBits) pde)\<rbrace>
       storePDE p pde
@@ -2869,86 +2708,16 @@ lemma storePDE_pde_mappings'[wp]:
    apply (wp setObject_ko_wp_at)
       apply simp
      apply (simp add: objBits_simps archObjSize_def)
-    apply (simp add: pdeBits_def)
    apply (clarsimp simp: obj_at'_def ko_wp_at'_def projectKOs)
   apply assumption
   done
 
-lemma storePDE_vms'[wp]:
-  "\<lbrace>valid_machine_state'\<rbrace> storePDE p pde \<lbrace>\<lambda>_. valid_machine_state'\<rbrace>"
-  apply (simp add: storePDE_def valid_machine_state'_def pointerInUserData_def
-                   pointerInDeviceData_def)
-  apply (wp setObject_typ_at_inv setObject_ksMachine updateObject_default_inv
-            hoare_vcg_all_lift hoare_vcg_disj_lift | simp)+
-  done
-
-crunch pspace_domain_valid[wp]: storePDE "pspace_domain_valid"
-
-lemma storePDE_ct_not_inQ[wp]:
-  "\<lbrace>ct_not_inQ\<rbrace> storePDE p pde \<lbrace>\<lambda>_. ct_not_inQ\<rbrace>"
-  apply (rule ct_not_inQ_lift [OF storePDE_nosch])
-  apply (simp add: storePDE_def)
-  apply (rule hoare_weaken_pre)
-   apply (wps setObject_PDE_ct)
-  apply (rule obj_at_setObject2)
-  apply (clarsimp simp: updateObject_default_def in_monad)+
-  done
-
-lemma setObject_pde_cur_domain[wp]:
-  "\<lbrace>\<lambda>s. P (ksCurDomain s)\<rbrace> setObject t (v::pde) \<lbrace>\<lambda>rv s. P (ksCurDomain s)\<rbrace>"
-  apply (simp add: setObject_def split_def)
-  apply (wp updateObject_default_inv | simp)+
-  done
-
-lemma setObject_pde_ksDomSchedule[wp]:
-  "\<lbrace>\<lambda>s. P (ksDomSchedule s)\<rbrace> setObject t (v::pde) \<lbrace>\<lambda>rv s. P (ksDomSchedule s)\<rbrace>"
-  apply (simp add: setObject_def split_def)
-  apply (wp updateObject_default_inv | simp)+
-  done
-
-lemma storePDE_cur_domain[wp]:
-  "\<lbrace>\<lambda>s. P (ksCurDomain s)\<rbrace> storePDE p pde \<lbrace>\<lambda>rv s. P (ksCurDomain s)\<rbrace>"
-by (simp add: storePDE_def) wp
-
-lemma storePDE_ksDomSchedule[wp]:
-  "\<lbrace>\<lambda>s. P (ksDomSchedule s)\<rbrace> storePDE p pde \<lbrace>\<lambda>rv s. P (ksDomSchedule s)\<rbrace>"
-by (simp add: storePDE_def) wp
-
-lemma storePDE_tcb_obj_at'[wp]:
-  "\<lbrace>obj_at' (P::tcb \<Rightarrow> bool) t\<rbrace> storePDE p pde \<lbrace>\<lambda>_. obj_at' P t\<rbrace>"
-  apply (simp add: storePDE_def)
-  apply (rule obj_at_setObject2)
-  apply (clarsimp simp add: updateObject_default_def in_monad)
-  done
-
-lemma storePDE_tcb_in_cur_domain'[wp]:
-  "\<lbrace>tcb_in_cur_domain' t\<rbrace> storePDE p pde \<lbrace>\<lambda>_. tcb_in_cur_domain' t\<rbrace>"
-  by (wp tcb_in_cur_domain'_lift)
-
-lemma storePDE_ct_idle_or_in_cur_domain'[wp]:
-  "\<lbrace>ct_idle_or_in_cur_domain'\<rbrace> storePDE p pde \<lbrace>\<lambda>_. ct_idle_or_in_cur_domain'\<rbrace>"
-  by (wp ct_idle_or_in_cur_domain'_lift hoare_vcg_disj_lift)
-
-lemma setObject_pte_ksDomScheduleIdx [wp]:
-  "\<lbrace>\<lambda>s. P (ksDomScheduleIdx s)\<rbrace> setObject p (pte::pte) \<lbrace>\<lambda>_. \<lambda>s. P (ksDomScheduleIdx s)\<rbrace>"
-  by (wp updateObject_default_inv|simp add:setObject_def | wpc)+
-
-lemma setObject_pde_ksDomScheduleIdx [wp]:
-  "\<lbrace>\<lambda>s. P (ksDomScheduleIdx s)\<rbrace> setObject p (pde::pde) \<lbrace>\<lambda>_. \<lambda>s. P (ksDomScheduleIdx s)\<rbrace>"
-  by (wp updateObject_default_inv|simp add:setObject_def | wpc)+
-
-crunches storePTE, storePDE
-  for ksDomScheduleIdx[wp]: "\<lambda>s. P (ksDomScheduleIdx s)"
-  and gsMaxObjectSize[wp]: "\<lambda>s. P (gsMaxObjectSize s)"
-  and gsUntypedZeroRanges[wp]: "\<lambda>s. P (gsUntypedZeroRanges s)"
-  (wp: setObject_ksPSpace_only updateObject_default_inv)
-
 lemma storePDE_invs[wp]:
   "\<lbrace>invs' and valid_pde' pde
           and (\<lambda>s. valid_pde_mapping' (p && mask pdBits) pde)\<rbrace>
       storePDE p pde
    \<lbrace>\<lambda>_. invs'\<rbrace>"
-  apply (simp add: invs'_def valid_state'_def valid_pspace'_def)
+  apply (simp add: invs'_def valid_pspace'_def valid_dom_schedule'_def)
   apply (rule hoare_pre)
    apply (wp sch_act_wf_lift valid_global_refs_lift'
              irqs_masked_lift
@@ -2959,37 +2728,6 @@ lemma storePDE_invs[wp]:
   apply clarsimp
   done
 
-lemma storePTE_valid_mdb [wp]:
-  "\<lbrace>valid_mdb'\<rbrace> storePTE p pte \<lbrace>\<lambda>rv. valid_mdb'\<rbrace>"
-  by (simp add: valid_mdb'_def) wp
-
-crunch nosch [wp]: storePTE "\<lambda>s. P (ksSchedulerAction s)"
-  (simp: updateObject_default_def ignore_del: setObject)
-
-crunch ksQ [wp]: storePTE "\<lambda>s. P (ksReadyQueues s)"
-  (simp: updateObject_default_def)
-
-lemma storePTE_inQ[wp]:
-  "\<lbrace>\<lambda>s. P (obj_at' (inQ d p) t s)\<rbrace> storePTE ptr pde \<lbrace>\<lambda>rv s. P (obj_at' (inQ d p) t s)\<rbrace>"
-  apply (simp add: obj_at'_real_def storePTE_def)
-  apply (wp setObject_ko_wp_at | simp add: objBits_simps archObjSize_def pteBits_def)+
-  apply (clarsimp simp: projectKOs obj_at'_def ko_wp_at'_def)
-  done
-
-crunch norqL1[wp]: storePTE "\<lambda>s. P (ksReadyQueuesL1Bitmap s)"
-  (simp: updateObject_default_def)
-
-crunch norqL2[wp]: storePTE "\<lambda>s. P (ksReadyQueuesL2Bitmap s)"
-  (simp: updateObject_default_def)
-
-lemma storePTE_valid_queues [wp]:
-  "\<lbrace>Invariants_H.valid_queues\<rbrace> storePTE p pde \<lbrace>\<lambda>_. Invariants_H.valid_queues\<rbrace>"
-  by (wp valid_queues_lift | simp add: pred_tcb_at'_def)+
-
-lemma storePTE_valid_queues' [wp]:
-  "\<lbrace>valid_queues'\<rbrace> storePTE p pde \<lbrace>\<lambda>_. valid_queues'\<rbrace>"
-  by (wp valid_queues_lift')
-
 lemma storePTE_state_refs' [wp]:
   "\<lbrace>\<lambda>s. P (state_refs_of' s)\<rbrace> storePTE p pte \<lbrace>\<lambda>rv s. P (state_refs_of' s)\<rbrace>"
   apply (clarsimp simp: storePTE_def)
@@ -3010,50 +2748,6 @@ lemma storePTE_iflive [wp]:
      apply (auto simp: updateObject_default_def in_monad projectKOs pteBits_def)
   done
 
-lemma setObject_pte_ksInt [wp]:
-  "\<lbrace>\<lambda>s. P (ksInterruptState s)\<rbrace> setObject p (pte::pte) \<lbrace>\<lambda>_. \<lambda>s. P (ksInterruptState s)\<rbrace>"
-  by (wp setObject_ksInterrupt updateObject_default_inv|simp)+
-
-crunch ksInt' [wp]: storePTE "\<lambda>s. P (ksInterruptState s)"
-
-lemma storePTE_ifunsafe [wp]:
-  "\<lbrace>if_unsafe_then_cap'\<rbrace> storePTE p pte \<lbrace>\<lambda>rv. if_unsafe_then_cap'\<rbrace>"
-  apply (simp add: storePTE_def)
-  apply (rule hoare_pre)
-   apply (rule setObject_ifunsafe' [where P=\<top>], simp)
-     apply (auto simp: updateObject_default_def in_monad projectKOs)[2]
-   apply wp
-  apply simp
-  done
-
-lemma storePTE_idle [wp]:
-  "\<lbrace>valid_idle'\<rbrace> storePTE p pte \<lbrace>\<lambda>rv. valid_idle'\<rbrace>" by (valid_idle'_setObject simp: storePTE_def)
-
-crunches storePTE
-  for arch'[wp]: "\<lambda>s. P (ksArchState s)"
-  and cur'[wp]: "\<lambda>s. P (ksCurThread s)"
-
-lemma storePTE_irq_states' [wp]:
-  "\<lbrace>valid_irq_states'\<rbrace> storePTE pte p \<lbrace>\<lambda>_. valid_irq_states'\<rbrace>"
-  apply (simp add: storePTE_def)
-  apply (wpsimp wp: valid_irq_states_lift' dmo_lift' no_irq_storeWord setObject_ksMachine
-                    updateObject_default_inv)
-  done
-
-lemma storePTE_valid_objs [wp]:
-  "\<lbrace>valid_objs' and valid_pte' pte\<rbrace> storePTE p pte \<lbrace>\<lambda>_. valid_objs'\<rbrace>"
-  apply (simp add: storePTE_def doMachineOp_def split_def)
-  apply (rule hoare_pre)
-   apply (wp hoare_drop_imps|wpc|simp)+
-   apply (rule setObject_valid_objs')
-   prefer 2
-   apply assumption
-  apply (clarsimp simp: updateObject_default_def in_monad)
-  apply (clarsimp simp: valid_obj'_def)
-  done
-
-crunch no_0_obj' [wp]: storePTE no_0_obj'
-
 lemma storePTE_pde_mappings'[wp]:
   "\<lbrace>valid_pde_mappings'\<rbrace> storePTE p pte \<lbrace>\<lambda>rv. valid_pde_mappings'\<rbrace>"
   apply (wp valid_pde_mappings_lift')
@@ -3063,65 +2757,9 @@ lemma storePTE_pde_mappings'[wp]:
   apply assumption
   done
 
-lemma storePTE_vms'[wp]:
-  "\<lbrace>valid_machine_state'\<rbrace> storePTE p pde \<lbrace>\<lambda>_. valid_machine_state'\<rbrace>"
-  apply (simp add: storePTE_def valid_machine_state'_def pointerInUserData_def
-                   pointerInDeviceData_def)
-  apply (wp setObject_typ_at_inv setObject_ksMachine updateObject_default_inv
-            hoare_vcg_all_lift hoare_vcg_disj_lift | simp)+
-  done
-
-crunch pspace_domain_valid[wp]: storePTE "pspace_domain_valid"
-
-lemma storePTE_ct_not_inQ[wp]:
-  "\<lbrace>ct_not_inQ\<rbrace> storePTE p pte \<lbrace>\<lambda>_. ct_not_inQ\<rbrace>"
-  apply (rule ct_not_inQ_lift [OF storePTE_nosch])
-  apply (simp add: storePTE_def)
-  apply (rule hoare_weaken_pre)
-   apply (wps setObject_pte_ct)
-  apply (rule obj_at_setObject2)
-   apply (clarsimp simp: updateObject_default_def in_monad)+
-  done
-
-lemma setObject_pte_cur_domain[wp]:
-  "\<lbrace>\<lambda>s. P (ksCurDomain s)\<rbrace> setObject t (v::pte) \<lbrace>\<lambda>rv s. P (ksCurDomain s)\<rbrace>"
-  apply (simp add: setObject_def split_def)
-  apply (wp updateObject_default_inv | simp)+
-  done
-
-lemma setObject_pte_ksDomSchedule[wp]:
-  "\<lbrace>\<lambda>s. P (ksDomSchedule s)\<rbrace> setObject t (v::pte) \<lbrace>\<lambda>rv s. P (ksDomSchedule s)\<rbrace>"
-  apply (simp add: setObject_def split_def)
-  apply (wp updateObject_default_inv | simp)+
-  done
-
-lemma storePTE_cur_domain[wp]:
-  "\<lbrace>\<lambda>s. P (ksCurDomain s)\<rbrace> storePTE p pde \<lbrace>\<lambda>rv s. P (ksCurDomain s)\<rbrace>"
-  by (simp add: storePTE_def) wp
-
-lemma storePTE_ksDomSchedule[wp]:
-  "\<lbrace>\<lambda>s. P (ksDomSchedule s)\<rbrace> storePTE p pde \<lbrace>\<lambda>rv s. P (ksDomSchedule s)\<rbrace>"
-  by (simp add: storePTE_def) wp
-
-
-lemma storePTE_tcb_obj_at'[wp]:
-  "\<lbrace>obj_at' (P::tcb \<Rightarrow> bool) t\<rbrace> storePTE p pte \<lbrace>\<lambda>_. obj_at' P t\<rbrace>"
-  apply (simp add: storePTE_def)
-  apply (rule obj_at_setObject2)
-  apply (clarsimp simp add: updateObject_default_def in_monad)
-  done
-
-lemma storePTE_tcb_in_cur_domain'[wp]:
-  "\<lbrace>tcb_in_cur_domain' t\<rbrace> storePTE p pte \<lbrace>\<lambda>_. tcb_in_cur_domain' t\<rbrace>"
-  by (wp tcb_in_cur_domain'_lift)
-
-lemma storePTE_ct_idle_or_in_cur_domain'[wp]:
-  "\<lbrace>ct_idle_or_in_cur_domain'\<rbrace> storePTE p pte \<lbrace>\<lambda>_. ct_idle_or_in_cur_domain'\<rbrace>"
-  by (wp ct_idle_or_in_cur_domain'_lift hoare_vcg_disj_lift)
-
 lemma storePTE_invs [wp]:
   "\<lbrace>invs' and valid_pte' pte\<rbrace> storePTE p pte \<lbrace>\<lambda>_. invs'\<rbrace>"
-  apply (simp add: invs'_def valid_state'_def valid_pspace'_def)
+  apply (simp add: invs'_def valid_pspace'_def valid_dom_schedule'_def)
   apply (rule hoare_pre)
    apply (wp sch_act_wf_lift valid_global_refs_lift' irqs_masked_lift
              valid_arch_state_lift' valid_irq_node_lift
@@ -3141,45 +2779,6 @@ lemma setASIDPool_valid_objs [wp]:
   apply (clarsimp simp: valid_obj'_def)
   done
 
-lemma setASIDPool_valid_mdb [wp]:
-  "\<lbrace>valid_mdb'\<rbrace> setObject p (ap::asidpool) \<lbrace>\<lambda>rv. valid_mdb'\<rbrace>"
-  by (simp add: valid_mdb'_def) wp
-
-lemma setASIDPool_nosch [wp]:
-  "\<lbrace>\<lambda>s. P (ksSchedulerAction s)\<rbrace> setObject p (ap::asidpool) \<lbrace>\<lambda>rv s. P (ksSchedulerAction s)\<rbrace>"
-  by (wp setObject_nosch updateObject_default_inv|simp)+
-
-lemma setASIDPool_ksQ [wp]:
-  "\<lbrace>\<lambda>s. P (ksReadyQueues s)\<rbrace> setObject p (ap::asidpool) \<lbrace>\<lambda>rv s. P (ksReadyQueues s)\<rbrace>"
-  by (wp setObject_qs updateObject_default_inv|simp)+
-
-lemma setASIDPool_inQ[wp]:
-  "\<lbrace>\<lambda>s. P (obj_at' (inQ d p) t s)\<rbrace>
-     setObject ptr (ap::asidpool)
-   \<lbrace>\<lambda>rv s. P (obj_at' (inQ d p) t s)\<rbrace>"
-  apply (simp add: obj_at'_real_def)
-  apply (wp setObject_ko_wp_at
-            | simp add: objBits_simps archObjSize_def)+
-   apply (simp add: pageBits_def)
-  apply (clarsimp simp: obj_at'_def ko_wp_at'_def projectKOs)
-  done
-
-lemma setASIDPool_qsL1 [wp]:
-  "\<lbrace>\<lambda>s. P (ksReadyQueuesL1Bitmap s)\<rbrace> setObject p (ap::asidpool) \<lbrace>\<lambda>rv s. P (ksReadyQueuesL1Bitmap s)\<rbrace>"
-  by (wp setObject_qs updateObject_default_inv|simp)+
-
-lemma setASIDPool_qsL2 [wp]:
-  "\<lbrace>\<lambda>s. P (ksReadyQueuesL2Bitmap s)\<rbrace> setObject p (ap::asidpool) \<lbrace>\<lambda>rv s. P (ksReadyQueuesL2Bitmap s)\<rbrace>"
-  by (wp setObject_qs updateObject_default_inv|simp)+
-
-lemma setASIDPool_valid_queues [wp]:
-  "\<lbrace>Invariants_H.valid_queues\<rbrace> setObject p (ap::asidpool) \<lbrace>\<lambda>_. Invariants_H.valid_queues\<rbrace>"
-  by (wp valid_queues_lift | simp add: pred_tcb_at'_def)+
-
-lemma setASIDPool_valid_queues' [wp]:
-  "\<lbrace>valid_queues'\<rbrace> setObject p (ap::asidpool) \<lbrace>\<lambda>_. valid_queues'\<rbrace>"
-  by (wp valid_queues_lift')
-
 lemma setASIDPool_state_refs' [wp]:
   "\<lbrace>\<lambda>s. P (state_refs_of' s)\<rbrace> setObject p (ap::asidpool) \<lbrace>\<lambda>rv s. P (state_refs_of' s)\<rbrace>"
   apply (clarsimp simp: setObject_def valid_def in_monad split_def
@@ -3198,103 +2797,14 @@ lemma setASIDPool_iflive [wp]:
      apply (auto simp: updateObject_default_def in_monad projectKOs pageBits_def)
   done
 
-lemma setASIDPool_ksInt [wp]:
-  "\<lbrace>\<lambda>s. P (ksInterruptState s)\<rbrace> setObject p (ap::asidpool) \<lbrace>\<lambda>_. \<lambda>s. P (ksInterruptState s)\<rbrace>"
-  by (wp setObject_ksInterrupt updateObject_default_inv|simp)+
-
-lemma setASIDPool_ifunsafe [wp]:
-  "\<lbrace>if_unsafe_then_cap'\<rbrace> setObject p (ap::asidpool) \<lbrace>\<lambda>rv. if_unsafe_then_cap'\<rbrace>"
-  apply (rule hoare_pre)
-   apply (rule setObject_ifunsafe' [where P=\<top>], simp)
-     apply (auto simp: updateObject_default_def in_monad projectKOs)[2]
-   apply wp
-  apply simp
-  done
-
-lemma setASIDPool_it' [wp]:
-  "\<lbrace>\<lambda>s. P (ksIdleThread s)\<rbrace> setObject p (ap::asidpool) \<lbrace>\<lambda>_. \<lambda>s. P (ksIdleThread s)\<rbrace>"
-  by (wp setObject_it updateObject_default_inv|simp)+
-
-lemma setASIDPool_idle [wp]:
-  "\<lbrace>valid_idle'\<rbrace> setObject p (ap::asidpool) \<lbrace>\<lambda>rv. valid_idle'\<rbrace>" by valid_idle'_setObject
-
-lemma setASIDPool_irq_states' [wp]:
-  "\<lbrace>valid_irq_states'\<rbrace> setObject p (ap::asidpool) \<lbrace>\<lambda>_. valid_irq_states'\<rbrace>"
-  apply (rule hoare_pre)
-   apply (rule hoare_use_eq [where f=ksInterruptState, OF setObject_ksInterrupt])
-    apply (simp, rule updateObject_default_inv)
-   apply (rule hoare_use_eq [where f=ksMachineState, OF setObject_ksMachine])
-    apply (simp, rule updateObject_default_inv)
-   apply wp
-  apply assumption
-  done
-
 lemma setObject_asidpool_mappings'[wp]:
   "\<lbrace>valid_pde_mappings'\<rbrace> setObject p (ap::asidpool) \<lbrace>\<lambda>rv. valid_pde_mappings'\<rbrace>"
   apply (wp valid_pde_mappings_lift')
-   apply (rule obj_at_setObject2)
-   apply (clarsimp dest!: updateObject_default_result)
-  apply assumption
-  done
-
-lemma setASIDPool_vms'[wp]:
-  "\<lbrace>valid_machine_state'\<rbrace> setObject p (ap::asidpool) \<lbrace>\<lambda>_. valid_machine_state'\<rbrace>"
-  apply (simp add: valid_machine_state'_def pointerInUserData_def pointerInDeviceData_def)
-  apply (wp setObject_typ_at_inv setObject_ksMachine updateObject_default_inv
-            hoare_vcg_all_lift hoare_vcg_disj_lift | simp)+
-  done
-
-lemma setASIDPool_ct_not_inQ[wp]:
-  "\<lbrace>ct_not_inQ\<rbrace> setObject p (ap::asidpool) \<lbrace>\<lambda>_. ct_not_inQ\<rbrace>"
-  apply (rule ct_not_inQ_lift [OF setObject_nosch])
-   apply (simp add: updateObject_default_def | wp)+
-  apply (rule hoare_weaken_pre)
-   apply (wps setObject_ASID_ct)
-  apply (rule obj_at_setObject2)
-   apply (clarsimp simp: updateObject_default_def in_monad)+
-  done
-
-lemma setObject_asidpool_cur'[wp]:
-  "\<lbrace>\<lambda>s. P (ksCurThread s)\<rbrace> setObject p (ap::asidpool) \<lbrace>\<lambda>rv s. P (ksCurThread s)\<rbrace>"
-  apply (simp add: setObject_def)
-  apply (wp | wpc | simp add: updateObject_default_def)+
-  done
-
-lemma setObject_asidpool_cur_domain[wp]:
-  "\<lbrace>\<lambda>s. P (ksCurDomain s)\<rbrace> setObject p (ap::asidpool) \<lbrace>\<lambda>rv s. P (ksCurDomain s)\<rbrace>"
-  apply (simp add: setObject_def split_def)
-  apply (wp updateObject_default_inv | simp)+
-  done
-
-lemma setObject_asidpool_ksDomSchedule[wp]:
-  "\<lbrace>\<lambda>s. P (ksDomSchedule s)\<rbrace> setObject p (ap::asidpool) \<lbrace>\<lambda>rv s. P (ksDomSchedule s)\<rbrace>"
-  apply (simp add: setObject_def split_def)
-  apply (wp updateObject_default_inv | simp)+
-  done
-
-lemma setObject_tcb_obj_at'[wp]:
-  "\<lbrace>obj_at' (P::tcb \<Rightarrow> bool) t\<rbrace> setObject p (ap::asidpool) \<lbrace>\<lambda>_. obj_at' P t\<rbrace>"
-  apply (rule obj_at_setObject2)
-  apply (clarsimp simp add: updateObject_default_def in_monad)
   done
 
-lemma setObject_asidpool_tcb_in_cur_domain'[wp]:
-  "\<lbrace>tcb_in_cur_domain' t\<rbrace> setObject p (ap::asidpool) \<lbrace>\<lambda>_. tcb_in_cur_domain' t\<rbrace>"
-  by (wp tcb_in_cur_domain'_lift)
-
-lemma setObject_asidpool_ct_idle_or_in_cur_domain'[wp]:
-  "\<lbrace>ct_idle_or_in_cur_domain'\<rbrace> setObject p (ap::asidpool) \<lbrace>\<lambda>_. ct_idle_or_in_cur_domain'\<rbrace>"
-  apply (rule ct_idle_or_in_cur_domain'_lift)
-      apply (wp hoare_vcg_disj_lift)+
-  done
-
-lemma setObject_ap_ksDomScheduleIdx [wp]:
-  "\<lbrace>\<lambda>s. P (ksDomScheduleIdx s)\<rbrace> setObject p (ap::asidpool) \<lbrace>\<lambda>_. \<lambda>s. P (ksDomScheduleIdx s)\<rbrace>"
-  by (wp updateObject_default_inv|simp add:setObject_def | wpc)+
-
 lemma setASIDPool_invs [wp]:
   "\<lbrace>invs' and valid_asid_pool' ap\<rbrace> setObject p (ap::asidpool) \<lbrace>\<lambda>_. invs'\<rbrace>"
-  apply (simp add: invs'_def valid_state'_def valid_pspace'_def)
+  apply (simp add: invs'_def valid_pspace'_def valid_dom_schedule'_def)
   apply (rule hoare_pre)
    apply (wp sch_act_wf_lift valid_global_refs_lift' irqs_masked_lift
              valid_arch_state_lift' valid_irq_node_lift
@@ -3399,8 +2913,6 @@ lemma perform_pti_invs [wp]:
   apply (clarsimp simp: cte_wp_at_ctes_of valid_pti'_def)
   done
 
-crunch invs'[wp]: setVMRootForFlush "invs'"
-
 lemma mapM_storePTE_invs:
   "\<lbrace>invs' and valid_pte' pte\<rbrace> mapM (swp storePTE pte) ps \<lbrace>\<lambda>xa. invs'\<rbrace>"
   apply (rule hoare_post_imp)
@@ -3426,11 +2938,6 @@ lemma mapM_storePDE_invs:
 crunch cte_wp_at': unmapPage "\<lambda>s. P (cte_wp_at' P' p s)"
   (wp: crunch_wps simp: crunch_simps)
 
-lemmas unmapPage_typ_ats [wp] = typ_at_lifts [OF unmapPage_typ_at']
-
-crunch inv: lookupPTSlot P
-  (wp: crunch_wps simp: crunch_simps)
-
 lemma flushPage_invs' [wp]:
   "\<lbrace>invs'\<rbrace> flushPage sz pd asid vptr \<lbrace>\<lambda>_. invs'\<rbrace>"
   apply (simp add: flushPage_def)
@@ -3463,8 +2970,9 @@ lemma perform_pt_invs [wp]:
   "\<lbrace>invs' and valid_page_inv' pt\<rbrace> performPageInvocation pt \<lbrace>\<lambda>_. invs'\<rbrace>"
   apply (simp add: performPageInvocation_def)
   apply (cases pt)
-     apply clarsimp
-     apply ((wp dmo_invs' hoare_vcg_all_lift setVMRootForFlush_invs' | simp add: tcb_at_invs')+)[2]
+     apply (clarsimp simp: cur_tcb'_asrt_def)
+     apply (rule hoare_seq_ext[OF _ stateAssert_sp])
+     apply ((wp dmo_invs' hoare_vcg_all_lift setVMRootForFlush_invs' | simp add: cur_tcb'_def)+)[2]
        apply (rule hoare_pre_imp[of _ \<top>], assumption)
        apply (clarsimp simp: valid_def
                              disj_commute[of "pointerInUserData p s" for p s])
@@ -3541,10 +3049,46 @@ lemma isPDCap_PD :
   "isPDCap (ArchObjectCap (PageDirectoryCap r m))"
   by (simp add: isPDCap_def)
 
+lemma lookupIPCBuffer_valid_ipc_buffer [wp]:
+  "\<lbrace>valid_objs'\<rbrace> lookupIPCBuffer b t \<lbrace>case_option \<top> valid_ipc_buffer_ptr'\<rbrace>"
+  unfolding lookupIPCBuffer_def ARM_H.lookupIPCBuffer_def
+  apply (simp add: Let_def getSlotCap_def getThreadBufferSlot_def
+                   locateSlot_conv threadGet_getObject)
+  apply (wp getCTE_wp getObject_tcb_wp | wpc)+
+  apply (clarsimp simp del: imp_disjL)
+  apply (drule obj_at_ko_at')
+  apply (clarsimp simp del: imp_disjL)
+  apply (rule_tac x = ko in exI)
+  apply (frule ko_at_cte_ipcbuffer)
+  apply (clarsimp simp: cte_wp_at_ctes_of simp del: imp_disjL)
+  apply (rename_tac d ref rghts sz mapdata)
+  apply (clarsimp simp: valid_ipc_buffer_ptr'_def)
+  apply (frule (1) ko_at_valid_objs')
+   apply (clarsimp simp: projectKO_opts_defs split: kernel_object.split_asm)
+  apply (clarsimp simp: valid_obj'_def valid_tcb'_def
+                        isCap_simps cte_level_bits_def field_simps)
+  apply (drule bspec [OF _ ranI [where a = "0x20"]])
+   apply simp
+  apply (clarsimp simp: valid_cap'_def)
+  apply (rule conjI)
+   apply (rule aligned_add_aligned)
+     apply (clarsimp simp: capAligned_def)
+     apply assumption
+    apply (erule is_aligned_andI1)
+   apply (case_tac sz; simp add: msg_align_bits)
+  apply (clarsimp simp: capAligned_def)
+  apply (drule_tac x = "(tcbIPCBuffer ko && mask (pageBitsForSize sz)) >> pageBits" in spec)
+  apply (subst(asm) mult.commute mult.left_commute, subst(asm) shiftl_t2n[symmetric])
+  apply (simp add: shiftr_shiftl1)
+  apply (subst (asm) mask_out_add_aligned)
+   apply (erule is_aligned_weaken [OF _ pbfs_atleast_pageBits])
+  apply (erule mp)
+  apply (rule shiftr_less_t2n)
+  apply (clarsimp simp: pbfs_atleast_pageBits)
+  apply (rule and_mask_less')
+  apply (simp add: word_bits_conv)
+  done
 
 end
 
-lemma cteCaps_of_ctes_of_lift:
-  "(\<And>P. \<lbrace>\<lambda>s. P (ctes_of s)\<rbrace> f \<lbrace>\<lambda>_ s. P (ctes_of s)\<rbrace>) \<Longrightarrow> \<lbrace>\<lambda>s. P (cteCaps_of s) \<rbrace> f \<lbrace>\<lambda>_ s. P (cteCaps_of s)\<rbrace>"
-  unfolding cteCaps_of_def .
 end

--- Invariants_H.thy
+++ Invariants_H.thy
@@ -7,11 +7,15 @@
 theory Invariants_H
 imports
   LevityCatch
-  "AInvs.Deterministic_AI"
   "AInvs.AInvs"
   "Lib.AddUpdSimps"
+  ArchMove_R
 begin
 
+(* FIXME: this should go somewhere in spec *)
+translations
+  (type) "'a kernel" <=(type) "kernel_state \<Rightarrow> ('a \<times> kernel_state) set \<times> bool"
+
 context Arch begin
 lemmas [crunch_def] =
   deriveCap_def finaliseCap_def
@@ -61,9 +65,18 @@ definition
 definition
   "ko_wp_at' P p s \<equiv>
    \<exists>ko. ksPSpace s p = Some ko \<and> is_aligned p (objBitsKO ko) \<and> P ko \<and>
-        ps_clear p (objBitsKO ko) s"
-
-
+        ps_clear p (objBitsKO ko) s \<and> objBitsKO ko < word_bits"
+
+lemma valid_sz_simps:
+  "objBitsKO ko < word_bits =
+    (case ko of
+      (KOSchedContext sc) \<Rightarrow> scBitsFromRefillLength sc < word_bits
+      | _ \<Rightarrow>    True)"
+  by (cases ko;
+      clarsimp simp: objBits_def objBitsKO_def word_size_def archObjSize_def pageBits_def word_bits_def
+                     tcbBlockSizeBits_def epSizeBits_def ntfnSizeBits_def cteSizeBits_def word_size
+                     pdeBits_def pteBits_def wordSizeCase_def wordBits_def replySizeBits_def
+              split: arch_kernel_object.splits)
 
 definition
   obj_at' :: "('a::pspace_storable \<Rightarrow> bool) \<Rightarrow> word32 \<Rightarrow> kernel_state \<Rightarrow> bool"
@@ -77,13 +90,17 @@ where
   "typ_at' T \<equiv> ko_wp_at' (\<lambda>ko. koTypeOf ko = T)"
 
 abbreviation
-  "ep_at' \<equiv> obj_at' ((\<lambda>x. True) :: endpoint \<Rightarrow> bool)"
+  "ep_at' \<equiv> obj_at' (\<lambda>_ :: endpoint. True)"
+abbreviation
+  "ntfn_at' \<equiv> obj_at' (\<lambda>_:: notification. True)"
 abbreviation
-  "ntfn_at' \<equiv> obj_at' ((\<lambda>x. True) :: Structures_H.notification \<Rightarrow> bool)"
+  "tcb_at' \<equiv> obj_at' (\<lambda>_:: tcb. True)"
 abbreviation
-  "tcb_at' \<equiv> obj_at' ((\<lambda>x. True) :: tcb \<Rightarrow> bool)"
+  "real_cte_at' \<equiv> obj_at' (\<lambda>_ :: cte. True)"
 abbreviation
-  "real_cte_at' \<equiv> obj_at' ((\<lambda>x. True) :: cte \<Rightarrow> bool)"
+  "sc_at' \<equiv> obj_at' (\<lambda>_ :: sched_context. True)"
+abbreviation
+  "reply_at' \<equiv> obj_at' (\<lambda>_ :: reply. True)"
 
 abbreviation
   "ko_at' v \<equiv> obj_at' (\<lambda>k. k = v)"
@@ -94,49 +111,60 @@ abbreviation
   "pte_at' \<equiv> typ_at' (ArchT PTET)"
 end
 
+
 record itcb' =
-  itcbState          :: thread_state
-  itcbFaultHandler   :: cptr
-  itcbIPCBuffer      :: vptr
-  itcbBoundNotification       :: "word32 option"
-  itcbPriority       :: priority
-  itcbFault          :: "fault option"
-  itcbTimeSlice      :: nat
-  itcbMCP            :: priority
-
-definition "tcb_to_itcb' tcb \<equiv> \<lparr> itcbState        = tcbState tcb,
-                                 itcbFaultHandler = tcbFaultHandler tcb,
-                                 itcbIPCBuffer    = tcbIPCBuffer tcb,
-                                 itcbBoundNotification     = tcbBoundNotification tcb,
-                                 itcbPriority     = tcbPriority tcb,
-                                 itcbFault        = tcbFault tcb,
-                                 itcbTimeSlice    = tcbTimeSlice tcb,
-                                 itcbMCP          = tcbMCP tcb\<rparr>"
-
-lemma [simp]: "itcbState (tcb_to_itcb' tcb) = tcbState tcb"
+  itcbState             :: thread_state
+  itcbIPCBuffer         :: vptr
+  itcbBoundNotification :: "word32 option"
+  itcbPriority          :: priority
+  itcbFault             :: "fault option"
+  itcbMCP               :: priority
+  itcbSchedContext      :: "obj_ref option"
+  itcbYieldTo           :: "obj_ref option"
+
+definition tcb_to_itcb' :: "tcb \<Rightarrow> itcb'" where
+  "tcb_to_itcb' tcb \<equiv> \<lparr> itcbState             = tcbState tcb,
+                        itcbIPCBuffer         = tcbIPCBuffer tcb,
+                        itcbBoundNotification = tcbBoundNotification tcb,
+                        itcbPriority          = tcbPriority tcb,
+                        itcbFault             = tcbFault tcb,
+                        itcbMCP               = tcbMCP tcb,
+                        itcbSchedContext      = tcbSchedContext tcb,
+                        itcbYieldTo           = tcbYieldTo tcb\<rparr>"
+
+lemma itcbState[simp]:
+  "itcbState (tcb_to_itcb' tcb) = tcbState tcb"
   by (auto simp: tcb_to_itcb'_def)
 
-lemma [simp]: "itcbFaultHandler (tcb_to_itcb' tcb) = tcbFaultHandler tcb"
+lemma itcbIPCBuffer[simp]:
+  "itcbIPCBuffer (tcb_to_itcb' tcb) = tcbIPCBuffer tcb"
   by (auto simp: tcb_to_itcb'_def)
 
-lemma [simp]: "itcbIPCBuffer (tcb_to_itcb' tcb) = tcbIPCBuffer tcb"
+lemma itcbBoundNotification[simp]:
+  "itcbBoundNotification (tcb_to_itcb' tcb) = tcbBoundNotification tcb"
   by (auto simp: tcb_to_itcb'_def)
 
-lemma [simp]: "itcbBoundNotification (tcb_to_itcb' tcb) = tcbBoundNotification tcb"
+lemma itcbPriority[simp]:
+  "itcbPriority (tcb_to_itcb' tcb) = tcbPriority tcb"
   by (auto simp: tcb_to_itcb'_def)
 
-lemma [simp]: "itcbPriority (tcb_to_itcb' tcb) = tcbPriority tcb"
+lemma itcbFault[simp]:
+  "itcbFault (tcb_to_itcb' tcb) = tcbFault tcb"
   by (auto simp: tcb_to_itcb'_def)
 
-lemma [simp]: "itcbFault (tcb_to_itcb' tcb) = tcbFault tcb"
+lemma itcbMCP[simp]:
+  "itcbMCP (tcb_to_itcb' tcb) = tcbMCP tcb"
   by (auto simp: tcb_to_itcb'_def)
 
-lemma [simp]: "itcbTimeSlice (tcb_to_itcb' tcb) = tcbTimeSlice tcb"
+lemma itcbSchedContext[simp]:
+  "itcbSchedContext (tcb_to_itcb' tcb) = tcbSchedContext tcb"
   by (auto simp: tcb_to_itcb'_def)
 
-lemma [simp]: "itcbMCP (tcb_to_itcb' tcb) = tcbMCP tcb"
+lemma itcbYieldTo[simp]:
+  "itcbYieldTo (tcb_to_itcb' tcb) = tcbYieldTo tcb"
   by (auto simp: tcb_to_itcb'_def)
 
+
 definition
   pred_tcb_at' :: "(itcb' \<Rightarrow> 'a) \<Rightarrow> ('a \<Rightarrow> bool) \<Rightarrow> word32 \<Rightarrow> kernel_state \<Rightarrow> bool"
 where
@@ -144,12 +172,18 @@ where
 
 abbreviation "st_tcb_at' \<equiv> pred_tcb_at' itcbState"
 abbreviation "bound_tcb_at' \<equiv> pred_tcb_at' itcbBoundNotification"
+abbreviation "bound_sc_tcb_at' \<equiv> pred_tcb_at' itcbSchedContext"
+abbreviation "bound_yt_tcb_at' \<equiv> pred_tcb_at' itcbYieldTo"
 abbreviation "mcpriority_tcb_at' \<equiv> pred_tcb_at' itcbMCP"
 
 lemma st_tcb_at'_def:
   "st_tcb_at' test \<equiv> obj_at' (test \<circ> tcbState)"
   by (simp add: pred_tcb_at'_def o_def)
 
+definition
+  active_sc_at' :: "word32 \<Rightarrow> kernel_state \<Rightarrow> bool"
+where
+  "active_sc_at' \<equiv> obj_at' (\<lambda>ko :: sched_context. 0 < scRefillMax ko)"
 
 text \<open>cte with property at\<close>
 definition
@@ -158,146 +192,274 @@ definition
 abbreviation
   "cte_at' \<equiv> cte_wp_at' \<top>"
 
+text \<open>replyNext aliases\<close>
+
+abbreviation
+  "replySC \<equiv> \<lambda>r. getHeadScPtr (replyNext r)"
+
+abbreviation
+  "replyNext_of \<equiv> \<lambda>r. getReplyNextPtr (replyNext r)"
+
+lemma getReplyNextPtr_None[simp]:
+  "getReplyNextPtr None = None" by (simp add: getReplyNextPtr_def)
+
+lemma getHeadScPtr_None[simp]:
+  "getHeadScPtr None = None" by (simp add: getHeadScPtr_def)
+
+lemma getReplyNextPtr_Some_Next[simp]:
+  "getReplyNextPtr (Some (Next rn)) = Some rn" by (simp add: getReplyNextPtr_def)
+
+lemma getHeadScPtr_Some_Head[simp]:
+  "getHeadScPtr (Some (Head sc)) = Some sc" by (simp add: getHeadScPtr_def)
+
+lemma theReplyNextPtr_Some_Next[simp]:
+  "theReplyNextPtr (Some (Next rn)) = rn" by (simp add: theReplyNextPtr_def)
+
+lemma theHeadScPtr_Some_Head[simp]:
+  "theHeadScPtr (Some (Head sc)) = sc" by (simp add: theHeadScPtr_def)
+
+lemma getReplyNextPtr_Some_iff[iff]:
+  "(getReplyNextPtr x) = (Some rn) \<longleftrightarrow> x = Some (Next rn)"
+  by (cases x; clarsimp simp: getReplyNextPtr_def split: reply_next.split)
+
+lemma getHeadScPtr_Some_iff[iff]:
+  "(getHeadScPtr x) = (Some rn) \<longleftrightarrow> x = Some (Head rn)"
+  by (cases x; clarsimp simp: getHeadScPtr_def split: reply_next.split)
+
+lemma getReplyNextPtr_None_iff:
+  "(getReplyNextPtr x) = None \<longleftrightarrow> (\<forall>rn. x \<noteq> Some (Next rn))"
+  by (cases x; clarsimp simp: getReplyNextPtr_def split: reply_next.split)
+
+lemma getHeadScPtr_None_iff:
+  "(getHeadScPtr x) = None \<longleftrightarrow> (\<forall>rn. x \<noteq> Some (Head rn))"
+  by (cases x; clarsimp simp: getHeadScPtr_def split: reply_next.split)
+
+lemma replyNext_None_iff:
+  "replyNext r = None \<longleftrightarrow> replyNext_of r = None \<and> replySC r = None"
+  apply (cases "replyNext r"; clarsimp)
+  apply (case_tac a; clarsimp)
+  done
+
+lemma getReplyNextPtr_Head_None[simp]:
+  "getReplyNextPtr (Some (Head rn)) = None" by (simp add: getReplyNextPtr_def)
+
+lemma getHeadScPtr_Next_None[simp]:
+  "getHeadScPtr (Some (Next sc)) = None" by (simp add: getHeadScPtr_def)
+
+text \<open>Heap projections:\<close>
+abbreviation reply_of' :: "kernel_object \<Rightarrow> reply option" where
+  "reply_of' \<equiv> projectKO_opt"
+
+abbreviation replies_of' :: "kernel_state \<Rightarrow> obj_ref \<Rightarrow> reply option" where
+  "replies_of' s \<equiv> ksPSpace s |> reply_of'"
+
+abbreviation replyNexts_of :: "kernel_state \<Rightarrow> obj_ref \<Rightarrow> obj_ref option" where
+  "replyNexts_of s \<equiv> replies_of' s |> replyNext_of"
+
+abbreviation replyPrevs_of :: "kernel_state \<Rightarrow> obj_ref \<Rightarrow> obj_ref option" where
+  "replyPrevs_of s \<equiv> replies_of' s |> replyPrev"
+
+abbreviation replyTCBs_of :: "kernel_state \<Rightarrow> obj_ref \<Rightarrow> obj_ref option" where
+  "replyTCBs_of s \<equiv> replies_of' s |> replyTCB"
+
+abbreviation replySCs_of :: "kernel_state \<Rightarrow> obj_ref \<Rightarrow> obj_ref option" where
+  "replySCs_of s \<equiv> replies_of' s |> replySC"
+
+abbreviation sc_of' :: "kernel_object \<Rightarrow> sched_context option" where
+  "sc_of' \<equiv> projectKO_opt"
+
+abbreviation scs_of' :: "kernel_state \<Rightarrow> obj_ref \<Rightarrow> sched_context option" where
+  "scs_of' s \<equiv> ksPSpace s |> sc_of'"
+
+abbreviation scReplies_of :: "kernel_state \<Rightarrow> obj_ref \<Rightarrow> obj_ref option" where
+  "scReplies_of s \<equiv> scs_of' s |> scReply"
+
+abbreviation tcb_of' :: "kernel_object \<Rightarrow> tcb option" where
+  "tcb_of' \<equiv> projectKO_opt"
+
+abbreviation tcbs_of' :: "kernel_state \<Rightarrow> obj_ref \<Rightarrow> tcb option" where
+  "tcbs_of' s \<equiv> ksPSpace s |> tcb_of'"
+
+abbreviation tcbSCs_of :: "kernel_state \<Rightarrow> obj_ref \<Rightarrow> obj_ref option" where
+  "tcbSCs_of s \<equiv> tcbs_of' s |> tcbSchedContext"
+
+abbreviation scTCBs_of :: "kernel_state \<Rightarrow> obj_ref \<Rightarrow> obj_ref option" where
+  "scTCBs_of s \<equiv> scs_of' s |> scTCB"
+
+abbreviation sym_heap_tcbSCs where
+  "sym_heap_tcbSCs s \<equiv> sym_heap (tcbSCs_of s) (scTCBs_of s)"
+
+abbreviation sym_heap_scReplies where
+  "sym_heap_scReplies s \<equiv> sym_heap (scReplies_of s) (replySCs_of s)"
+
 definition
-  tcb_cte_cases :: "word32 \<rightharpoonup> ((tcb \<Rightarrow> cte) \<times> ((cte \<Rightarrow> cte) \<Rightarrow> tcb \<Rightarrow> tcb))"
-where
- "tcb_cte_cases \<equiv> [ 0 \<mapsto> (tcbCTable, tcbCTable_update),
-                   16 \<mapsto> (tcbVTable, tcbVTable_update),
-                   32 \<mapsto> (tcbReply, tcbReply_update),
-                   48 \<mapsto> (tcbCaller, tcbCaller_update),
-                   64 \<mapsto> (tcbIPCBufferFrame, tcbIPCBufferFrame_update) ]"
+  tcb_cte_cases :: "word32 \<rightharpoonup> ((tcb \<Rightarrow> cte) \<times> ((cte \<Rightarrow> cte) \<Rightarrow> tcb \<Rightarrow> tcb))" where
+ "tcb_cte_cases \<equiv> [    0 \<mapsto> (tcbCTable, tcbCTable_update),
+                    0x10 \<mapsto> (tcbVTable, tcbVTable_update),
+                    0x20 \<mapsto> (tcbIPCBufferFrame, tcbIPCBufferFrame_update),
+                    0x30 \<mapsto> (tcbFaultHandler, tcbFaultHandler_update),
+                    0x40 \<mapsto> (tcbTimeoutHandler, tcbTimeoutHandler_update)
+                   ]"
 
 definition
-  max_ipc_words :: word32
-where
+  max_ipc_words :: word32 where
   "max_ipc_words \<equiv> capTransferDataSize + msgMaxLength + msgMaxExtraCaps + 2"
 
-definition
-  tcb_st_refs_of' :: "Structures_H.thread_state \<Rightarrow> (word32 \<times> reftype) set"
-where
-  "tcb_st_refs_of' z \<equiv> case z of (Running)                  => {}
-  | (Inactive)                 => {}
-  | (Restart)                  => {}
-  | (BlockedOnReceive x a)     => {(x, TCBBlockedRecv)}
-  | (BlockedOnSend x a b c d)  => {(x, TCBBlockedSend)}
-  | (BlockedOnNotification x)  => {(x, TCBSignal)}
-  | (BlockedOnReply)           => {}
-  | (IdleThreadState)          => {}"
+type_synonym ref_set = "(obj_ref \<times> reftype) set"
+
+definition tcb_st_refs_of' :: "thread_state \<Rightarrow> ref_set" where
+  "tcb_st_refs_of' z \<equiv> case z of
+    Running                    => {}
+  | Inactive                   => {}
+  | Restart                    => {}
+  | (BlockedOnReply r)         => if bound r then {(the r, TCBReply)} else {}
+  | IdleThreadState            => {}
+  | (BlockedOnReceive x _ r)   => if bound r then {(x, TCBBlockedRecv), (the r, TCBReply)}
+                                  else {(x, TCBBlockedRecv)}
+  | (BlockedOnSend x _ _ _ _)  => {(x, TCBBlockedSend)}
+  | (BlockedOnNotification x)  => {(x, TCBSignal)}"
 
 definition
-  ep_q_refs_of'   :: "Structures_H.endpoint       \<Rightarrow> (word32 \<times> reftype) set"
-where
+  tcb_bound_refs' ::
+  "word32 option \<Rightarrow> word32 option \<Rightarrow> word32 option \<Rightarrow> ref_set" where
+  "tcb_bound_refs' ntfn sc yt \<equiv> get_refs TCBBound ntfn
+                                  \<union> get_refs TCBSchedContext sc
+                                  \<union> get_refs TCBYieldTo yt"
+
+definition refs_of_tcb' :: "tcb \<Rightarrow> ref_set" where
+  "refs_of_tcb' tcb \<equiv>
+     tcb_st_refs_of' (tcbState tcb)
+       \<union> tcb_bound_refs' (tcbBoundNotification tcb) (tcbSchedContext tcb) (tcbYieldTo tcb)"
+
+definition ep_q_refs_of' :: "endpoint \<Rightarrow> ref_set" where
   "ep_q_refs_of' x \<equiv> case x of
-  IdleEP    => {}
-  | (RecvEP q) => set q \<times> {EPRecv}
-  | (SendEP q) => set q \<times> {EPSend}"
+     IdleEP    => {}
+   | (RecvEP q) => set q \<times> {EPRecv}
+   | (SendEP q) => set q \<times> {EPSend}"
 
-definition
-  ntfn_q_refs_of'  :: "Structures_H.ntfn \<Rightarrow> (word32 \<times> reftype) set"
-where
-  "ntfn_q_refs_of' x \<equiv> case x of  IdleNtfn         => {}
-  | (WaitingNtfn q)      => set q \<times> {NTFNSignal}
-  | (ActiveNtfn b)  => {}"
+definition ntfn_q_refs_of' :: "ntfn \<Rightarrow> ref_set" where
+  "ntfn_q_refs_of' x \<equiv> case x of
+     IdleNtfn        => {}
+   | (WaitingNtfn q) => set q \<times> {NTFNSignal}
+   | (ActiveNtfn b)  => {}"
 
-definition
-  ntfn_bound_refs' :: "word32 option \<Rightarrow> (word32 \<times> reftype) set"
-where
+definition ntfn_bound_refs' :: "word32 option \<Rightarrow> ref_set" where
   "ntfn_bound_refs' t \<equiv> set_option t \<times> {NTFNBound}"
 
-definition
-  tcb_bound_refs' :: "word32 option \<Rightarrow> (word32 \<times> reftype) set"
-where
-  "tcb_bound_refs' a \<equiv> set_option a \<times> {TCBBound}"
+definition refs_of_ntfn' :: "notification \<Rightarrow> ref_set" where
+  "refs_of_ntfn' ntfn \<equiv> ntfn_q_refs_of' (ntfnObj ntfn)
+                          \<union> get_refs NTFNBound (ntfnBoundTCB ntfn)
+                          \<union> get_refs NTFNSchedContext (ntfnSc ntfn)"
 
-definition
-  refs_of'        :: "Structures_H.kernel_object  \<Rightarrow> (word32 \<times> reftype) set"
-where
-  "refs_of' x \<equiv> case x of
-    (KOTCB tcb) => tcb_st_refs_of' (tcbState tcb) \<union> tcb_bound_refs' (tcbBoundNotification tcb)
-  | (KOCTE cte)           => {}
-  | (KOEndpoint ep)       => ep_q_refs_of' ep
-  | (KONotification ntfn)     => ntfn_q_refs_of' (ntfnObj ntfn) \<union> ntfn_bound_refs' (ntfnBoundTCB ntfn)
-  | (KOUserData)          => {}
-  | (KOUserDataDevice)    => {}
-  | (KOKernelData)        => {}
-  | (KOArch ako)          => {}"
+definition refs_of_sc' :: "sched_context \<Rightarrow> ref_set" where
+  "refs_of_sc' sc \<equiv> get_refs SCNtfn (scNtfn sc)
+                          \<union> get_refs SCTcb (scTCB sc)
+                          \<union> get_refs SCYieldFrom (scYieldFrom sc)
+                          \<union> get_refs SCReply (scReply sc)"
 
-definition
-  state_refs_of' :: "kernel_state \<Rightarrow> word32 \<Rightarrow> (word32 \<times> reftype) set"
-where
- "state_refs_of' s \<equiv> (\<lambda>x. case (ksPSpace s x)
-                           of None \<Rightarrow> {}
-                            | Some ko \<Rightarrow>
-                              (if is_aligned x (objBitsKO ko) \<and> ps_clear x (objBitsKO ko) s
-                               then refs_of' ko
-                               else {}))"
+definition refs_of_reply' :: "reply \<Rightarrow> ref_set" where
+  "refs_of_reply' r \<equiv> get_refs ReplySchedContext (replySC r)
+                          \<union> get_refs ReplyTCB (replyTCB r)"
 
+definition list_refs_of_reply' :: "reply \<Rightarrow> ref_set" where
+  "list_refs_of_reply' r = get_refs ReplyNext (replyNext_of r) \<union> get_refs ReplyPrev (replyPrev r)"
 
-primrec
-  live' :: "Structures_H.kernel_object \<Rightarrow> bool"
-where
+abbreviation list_refs_of_replies_opt' :: "kernel_state \<Rightarrow> obj_ref \<Rightarrow> ref_set option" where
+  "list_refs_of_replies_opt' s \<equiv> replies_of' s ||> list_refs_of_reply'"
+
+(* FIXME RT: move to Option_Monad? *)
+definition map_set :: "('a \<Rightarrow> 'b set option) \<Rightarrow> 'a \<Rightarrow> 'b set" where
+  "map_set f \<equiv> case_option {} id \<circ> f"
+
+abbreviation list_refs_of_replies' :: "kernel_state \<Rightarrow> obj_ref \<Rightarrow> ref_set" where
+  "list_refs_of_replies' s \<equiv> map_set (list_refs_of_replies_opt' s)"
+
+lemmas list_refs_of_replies'_def = map_set_def
+
+lemmas refs_of'_defs[simp] = refs_of_tcb'_def refs_of_ntfn'_def refs_of_sc'_def refs_of_reply'_def
+
+definition refs_of' :: "kernel_object \<Rightarrow> ref_set" where
+  "refs_of' x \<equiv> case x of
+    (KOTCB tcb)           => refs_of_tcb' tcb
+  | (KOCTE cte)           => {}
+  | (KOEndpoint ep)       => ep_q_refs_of' ep
+  | (KONotification ntfn) => refs_of_ntfn' ntfn
+  | (KOSchedContext sc)   => refs_of_sc' sc
+  | (KOReply r)           => refs_of_reply' r
+  | _                     => {}"
+
+definition state_refs_of' :: "kernel_state \<Rightarrow> word32 \<Rightarrow> ref_set" where
+ "state_refs_of' s \<equiv> \<lambda>x. case ksPSpace s x of
+                            None \<Rightarrow> {}
+                          | Some ko \<Rightarrow>
+                              if is_aligned x (objBitsKO ko) \<and> ps_clear x (objBitsKO ko) s
+                                 \<and> objBitsKO ko < word_bits
+                              then refs_of' ko
+                              else {}"
+
+defs sym_refs_asrt_def:
+  "sym_refs_asrt \<equiv> \<lambda>s. sym_refs (state_refs_of' s)"
+
+definition live_sc' :: "sched_context \<Rightarrow> bool" where
+  "live_sc' sc \<equiv> bound (scTCB sc) \<and> scTCB sc \<noteq> Some idle_thread_ptr
+                  \<or> bound (scYieldFrom sc) \<or> bound (scNtfn sc) \<or> scReply sc \<noteq> None"
+
+definition live_ntfn' :: "notification \<Rightarrow> bool" where
+  "live_ntfn' ntfn \<equiv> bound (ntfnBoundTCB ntfn) \<or> bound (ntfnSc ntfn)
+                      \<or> (\<exists>ts. ntfnObj ntfn = WaitingNtfn ts)"
+
+definition live_reply' :: "reply \<Rightarrow> bool" where
+  "live_reply' reply \<equiv> bound (replyTCB reply) \<or> bound (replyNext reply) \<or> bound (replyPrev reply)"
+
+primrec live' :: "Structures_H.kernel_object \<Rightarrow> bool" where
   "live' (KOTCB tcb) =
      (bound (tcbBoundNotification tcb) \<or>
-     (tcbState tcb \<noteq> Inactive \<and> tcbState tcb \<noteq> IdleThreadState) \<or>  tcbQueued tcb)"
+      bound (tcbSchedContext tcb) \<and> tcbSchedContext tcb \<noteq> Some idle_sc_ptr \<or>
+      bound (tcbYieldTo tcb) \<or>
+      tcbState tcb \<noteq> Inactive \<and> tcbState tcb \<noteq> IdleThreadState \<or>
+      tcbQueued tcb)"
 | "live' (KOCTE cte)           = False"
 | "live' (KOEndpoint ep)       = (ep \<noteq> IdleEP)"
-| "live' (KONotification ntfn)     = (bound (ntfnBoundTCB ntfn) \<or> (\<exists>ts. ntfnObj ntfn = WaitingNtfn ts))"
+| "live' (KONotification ntfn) = live_ntfn' ntfn"
+| "live' (KOSchedContext sc)   = live_sc' sc"
+| "live' (KOReply r)           = live_reply' r"
 | "live' (KOUserData)          = False"
 | "live' (KOUserDataDevice)    = False"
 | "live' (KOKernelData)        = False"
 | "live' (KOArch ako)          = False"
 
-primrec
-  zobj_refs' :: "capability \<Rightarrow> word32 set"
-where
-  "zobj_refs' NullCap                        = {}"
-| "zobj_refs' DomainCap                      = {}"
-| "zobj_refs' (UntypedCap d r n f)           = {}"
-| "zobj_refs' (EndpointCap r badge x y z t)  = {r}"
-| "zobj_refs' (NotificationCap r badge x y)  = {r}"
-| "zobj_refs' (CNodeCap r b g gsz)           = {}"
-| "zobj_refs' (ThreadCap r)                  = {r}"
-| "zobj_refs' (Zombie r b n)                 = {}"
-| "zobj_refs' (ArchObjectCap ac)             = {}"
-| "zobj_refs' (IRQControlCap)                = {}"
-| "zobj_refs' (IRQHandlerCap irq)            = {}"
-| "zobj_refs' (ReplyCap tcb m x)             = {}"
-
-definition
-  ex_nonz_cap_to' :: "word32 \<Rightarrow> kernel_state \<Rightarrow> bool"
-where
-  "ex_nonz_cap_to' ref \<equiv>
-   (\<lambda>s. \<exists>cref. cte_wp_at' (\<lambda>c. ref \<in> zobj_refs' (cteCap c)) cref s)"
-
-definition
-  if_live_then_nonz_cap' :: "kernel_state \<Rightarrow> bool"
-where
- "if_live_then_nonz_cap' s \<equiv>
-    \<forall>ptr. ko_wp_at' live' ptr s \<longrightarrow> ex_nonz_cap_to' ptr s"
-
-
-primrec
-  cte_refs' :: "capability \<Rightarrow> word32 \<Rightarrow> word32 set"
-where
-  "cte_refs' (UntypedCap d p n f) x               = {}"
-| "cte_refs' (NullCap) x                          = {}"
-| "cte_refs' (DomainCap) x                        = {}"
-| "cte_refs' (EndpointCap ref badge s r g gr) x   = {}"
-| "cte_refs' (NotificationCap ref badge s r) x    = {}"
-| "cte_refs' (CNodeCap ref bits g gs) x           =
-     (\<lambda>x. ref + (x * 2 ^ cteSizeBits)) ` {0 .. 2 ^ bits - 1}"
-| "cte_refs' (ThreadCap ref) x                    =
-     (\<lambda>x. ref + x) ` (dom tcb_cte_cases)"
-| "cte_refs' (Zombie r b n) x                     =
-     (\<lambda>x. r + (x * 2 ^ cteSizeBits)) ` {0 ..< of_nat n}"
-| "cte_refs' (ArchObjectCap cap) x                = {}"
-| "cte_refs' (IRQControlCap) x                    = {}"
-| "cte_refs' (IRQHandlerCap irq) x                = {x + (ucast irq) * 16}"
-| "cte_refs' (ReplyCap tcb m g) x                 = {}"
-
+fun zobj_refs' :: "capability \<Rightarrow> word32 set" where
+  "zobj_refs' (EndpointCap r _ _ _ _ _)  = {r}"
+| "zobj_refs' (NotificationCap r _ _ _)  = {r}"
+| "zobj_refs' (ThreadCap r)              = {r}"
+| "zobj_refs' (SchedContextCap r _)      = {r}"
+| "zobj_refs' (ReplyCap r _)             = {r}"
+| "zobj_refs'                 _          = {}"
+
+definition ex_nonz_cap_to' :: "word32 \<Rightarrow> kernel_state \<Rightarrow> bool" where
+  "ex_nonz_cap_to' ref \<equiv> \<lambda>s. \<exists>cref. cte_wp_at' (\<lambda>c. ref \<in> zobj_refs' (cteCap c)) cref s"
+
+definition if_live_then_nonz_cap' :: "kernel_state \<Rightarrow> bool" where
+  "if_live_then_nonz_cap' s \<equiv> \<forall>ptr. ko_wp_at' live' ptr s \<longrightarrow> ex_nonz_cap_to' ptr s"
+
+primrec cte_refs' :: "capability \<Rightarrow> word32 \<Rightarrow> word32 set" where
+  "cte_refs' (UntypedCap _ _ _ _) _      = {}"
+| "cte_refs' NullCap _                   = {}"
+| "cte_refs' DomainCap _                 = {}"
+| "cte_refs' (EndpointCap _ _ _ _ _ _) _ = {}"
+| "cte_refs' (NotificationCap _ _ _ _) _ = {}"
+| "cte_refs' (CNodeCap ref bits _ _) x   = (\<lambda>x. ref + (x * 2^cteSizeBits)) ` {0 .. 2 ^ bits - 1}"
+| "cte_refs' (ThreadCap ref) x           = (\<lambda>x. ref + x) ` (dom tcb_cte_cases)"
+| "cte_refs' (Zombie r _ n) x            = (\<lambda>x. r + (x * 2 ^ cteSizeBits)) ` {0 ..< of_nat n}"
+| "cte_refs' (ArchObjectCap _) _         = {}"
+| "cte_refs' (IRQControlCap) _           = {}"
+| "cte_refs' (IRQHandlerCap irq) x       = {x + (ucast irq) * 16}"
+| "cte_refs' (ReplyCap _ _) _            = {}"
+| "cte_refs' (SchedContextCap _ _) _     = {}"
+| "cte_refs' SchedControlCap _           = {}"
 
 abbreviation
- "irq_node' s \<equiv> intStateIRQNode (ksInterruptState s)"
+  "irq_node' s \<equiv> intStateIRQNode (ksInterruptState s)"
 
 definition
   ex_cte_cap_wp_to' :: "(capability \<Rightarrow> bool) \<Rightarrow> word32 \<Rightarrow> kernel_state \<Rightarrow> bool"
@@ -335,28 +497,27 @@ where
   "zBits (ZombieCNode n) = objBits (undefined::cte) + n"
 | "zBits (ZombieTCB) = tcbBlockSizeBits"
 
-primrec
- capBits :: "capability \<Rightarrow> nat"
-where
+primrec capBits :: "capability \<Rightarrow> nat" where
   "capBits NullCap = 0"
 | "capBits DomainCap = 0"
 | "capBits (UntypedCap d r b f) = b"
 | "capBits (EndpointCap r b x y z t) = objBits (undefined::endpoint)"
-| "capBits (NotificationCap r b x y) = objBits (undefined::Structures_H.notification)"
+| "capBits (NotificationCap r b x y) = objBits (undefined::notification)"
 | "capBits (CNodeCap r b g gs) = objBits (undefined::cte) + b"
 | "capBits (ThreadCap r) = objBits (undefined::tcb)"
 | "capBits (Zombie r z n) = zBits z"
 | "capBits (IRQControlCap) = 0"
 | "capBits (IRQHandlerCap irq) = 0"
-| "capBits (ReplyCap tcb m x) = objBits (undefined :: tcb)"
+| "capBits (ReplyCap tcb m) = objBits (undefined :: reply)"
+| "capBits (SchedContextCap sc n) = n"
+| "capBits SchedControlCap = 0"
 | "capBits (ArchObjectCap x) = acapBits x"
 
 lemmas objBits_defs =
-  tcbBlockSizeBits_def epSizeBits_def ntfnSizeBits_def cteSizeBits_def
+  tcbBlockSizeBits_def epSizeBits_def ntfnSizeBits_def cteSizeBits_def replySizeBits_def
 
-definition
-  "capAligned c \<equiv>
-   is_aligned (capUntypedPtr c) (capBits c) \<and> capBits c < word_bits"
+definition capAligned :: "capability \<Rightarrow> bool" where
+  "capAligned c \<equiv> is_aligned (capUntypedPtr c) (capBits c) \<and> capBits c < word_bits"
 
 definition
  "obj_range' (p::word32) ko \<equiv> {p .. p + 2 ^ objBitsKO ko - 1}"
@@ -391,16 +552,15 @@ where
 abbreviation
   "asid_pool_at' \<equiv> typ_at' (ArchT ASIDPoolT)"
 
-(* FIXME: duplicated with vmsz_aligned *)
-definition
-  "vmsz_aligned' ref sz \<equiv> is_aligned ref (pageBitsForSize sz)"
-
 primrec
   zombieCTEs :: "zombie_type \<Rightarrow> nat"
 where
   "zombieCTEs ZombieTCB = 5"
 | "zombieCTEs (ZombieCNode n) = (2 ^ n)"
 
+abbreviation
+  "sc_at'_n n \<equiv> ko_wp_at' (\<lambda>ko. koTypeOf ko = SchedContextT \<and> objBitsKO ko = n)"
+
 definition
   valid_cap' :: "capability \<Rightarrow> kernel_state \<Rightarrow> bool"
 where valid_cap'_def:
@@ -418,9 +578,12 @@ where valid_cap'_def:
     guard && mask guard_sz = guard \<and>
     (\<forall>addr. real_cte_at' (r + 2^cteSizeBits * (addr && mask bits)) s)
   | Structures_H.ThreadCap r \<Rightarrow> tcb_at' r s
-  | Structures_H.ReplyCap r m x \<Rightarrow> tcb_at' r s
+  | Structures_H.ReplyCap r m \<Rightarrow> reply_at' r s
   | Structures_H.IRQControlCap \<Rightarrow> True
   | Structures_H.IRQHandlerCap irq \<Rightarrow> irq \<le> maxIRQ
+  | Structures_H.SchedControlCap \<Rightarrow> True
+  | Structures_H.SchedContextCap sc n \<Rightarrow> sc_at'_n n sc s
+             \<and> minSchedContextBits \<le> n \<and> n \<le> maxUntypedSizeBits
   | Structures_H.Zombie r b n \<Rightarrow> n \<le> zombieCTEs b \<and> zBits b < word_bits
             \<and> (case b of ZombieTCB \<Rightarrow> tcb_at' r s | ZombieCNode n \<Rightarrow> n \<noteq> 0
                     \<and> (\<forall>addr. real_cte_at' (r + 2^cteSizeBits * (addr && mask n)) s))
@@ -432,7 +595,7 @@ where valid_cap'_def:
     (\<forall>p < 2 ^ (pageBitsForSize sz - pageBits). typ_at' (if d then UserDataDeviceT else UserDataT)
     (ref + p * 2 ^ pageBits) s) \<and>
     (case mapdata of None \<Rightarrow> True | Some (asid, ref) \<Rightarrow>
-            0 < asid \<and> asid \<le> 2 ^ asid_bits - 1 \<and> vmsz_aligned' ref sz \<and> ref < pptrBase)
+            0 < asid \<and> asid \<le> 2 ^ asid_bits - 1 \<and> vmsz_aligned ref sz \<and> ref < pptrBase)
   | PageTableCap ref mapdata \<Rightarrow>
     page_table_at' ref s \<and>
     (case mapdata of None \<Rightarrow> True | Some (asid, ref) \<Rightarrow>
@@ -451,27 +614,36 @@ definition
 where
   "valid_cte' cte s \<equiv> s \<turnstile>' (cteCap cte)"
 
-definition
-  valid_tcb_state' :: "Structures_H.thread_state \<Rightarrow> kernel_state \<Rightarrow> bool"
-where
+definition valid_bound_obj' ::
+  "(machine_word \<Rightarrow> kernel_state \<Rightarrow> bool) \<Rightarrow> machine_word option \<Rightarrow> kernel_state \<Rightarrow> bool" where
+  "valid_bound_obj' f p_opt s \<equiv> case p_opt of None \<Rightarrow> True | Some p \<Rightarrow> f p s"
+
+abbreviation
+  "valid_bound_ntfn' \<equiv> valid_bound_obj' ntfn_at'"
+
+abbreviation
+  "valid_bound_tcb' \<equiv> valid_bound_obj' tcb_at'"
+
+abbreviation
+  "valid_bound_sc' \<equiv> valid_bound_obj' sc_at'"
+
+abbreviation
+  "valid_bound_reply' \<equiv> valid_bound_obj' reply_at'"
+
+definition valid_tcb_state' :: "thread_state \<Rightarrow> kernel_state \<Rightarrow> bool" where
   "valid_tcb_state' ts s \<equiv> case ts of
-    Structures_H.BlockedOnReceive ref a \<Rightarrow> ep_at' ref s
-  | Structures_H.BlockedOnSend ref a b d c \<Rightarrow> ep_at' ref s
-  | Structures_H.BlockedOnNotification ref \<Rightarrow> ntfn_at' ref s
+    BlockedOnReceive ref _ rep \<Rightarrow> ep_at' ref s \<and> valid_bound_reply' rep s
+  | BlockedOnSend ref _ _ _ _  \<Rightarrow> ep_at' ref s
+  | BlockedOnNotification ref  \<Rightarrow> ntfn_at' ref s
+  | BlockedOnReply r \<Rightarrow>  valid_bound_reply' r s
   | _ \<Rightarrow> True"
 
+
 definition
   valid_ipc_buffer_ptr' :: "word32 \<Rightarrow> kernel_state \<Rightarrow> bool"
 where
   "valid_ipc_buffer_ptr' a s \<equiv> is_aligned a msg_align_bits \<and> typ_at' UserDataT (a && ~~ mask pageBits) s"
 
-definition
-  valid_bound_ntfn' :: "word32 option \<Rightarrow> kernel_state \<Rightarrow> bool"
-where
-  "valid_bound_ntfn' ntfn_opt s \<equiv> case ntfn_opt of
-                                 None \<Rightarrow> True
-                               | Some a \<Rightarrow> ntfn_at' a s"
-
 definition
   is_device_page_cap' :: "capability \<Rightarrow> bool"
 where
@@ -479,17 +651,19 @@ where
     capability.ArchObjectCap (arch_capability.PageCap dev _ _ _ _) \<Rightarrow> dev
    | _ \<Rightarrow> False"
 
-definition
-  valid_tcb' :: "Structures_H.tcb \<Rightarrow> kernel_state \<Rightarrow> bool"
-where
+
+definition valid_tcb' :: "tcb \<Rightarrow> kernel_state \<Rightarrow> bool" where
   "valid_tcb' t s \<equiv> (\<forall>(getF, setF) \<in> ran tcb_cte_cases. s \<turnstile>' cteCap (getF t))
                   \<and> valid_tcb_state' (tcbState t) s
                   \<and> is_aligned (tcbIPCBuffer t) msg_align_bits
                   \<and> valid_bound_ntfn' (tcbBoundNotification t) s
+                  \<and> valid_bound_sc' (tcbSchedContext t) s
+                  \<and> valid_bound_sc' (tcbYieldTo t) s
                   \<and> tcbDomain t \<le> maxDomain
                   \<and> tcbPriority t \<le> maxPriority
                   \<and> tcbMCP t \<le> maxPriority"
 
+
 definition
   valid_ep' :: "Structures_H.endpoint \<Rightarrow> kernel_state \<Rightarrow> bool"
 where
@@ -499,23 +673,37 @@ where
   | Structures_H.RecvEP ts \<Rightarrow> (ts \<noteq> [] \<and> (\<forall>t \<in> set ts. tcb_at' t s) \<and> distinct ts)"
 
 
-definition
-  valid_bound_tcb' :: "word32 option \<Rightarrow> kernel_state \<Rightarrow> bool"
-where
-  "valid_bound_tcb' tcb_opt s \<equiv> case tcb_opt of
-                                 None \<Rightarrow> True
-                               | Some t \<Rightarrow> tcb_at' t s"
-
 definition
   valid_ntfn' :: "Structures_H.notification \<Rightarrow> kernel_state \<Rightarrow> bool"
 where
   "valid_ntfn' ntfn s \<equiv> (case ntfnObj ntfn of
     Structures_H.IdleNtfn \<Rightarrow> True
   | Structures_H.WaitingNtfn ts \<Rightarrow>
-      (ts \<noteq> [] \<and> (\<forall>t \<in> set ts. tcb_at' t s) \<and> distinct ts
-     \<and> (case ntfnBoundTCB ntfn of Some tcb \<Rightarrow> ts = [tcb] | _ \<Rightarrow> True))
+      ts \<noteq> [] \<and> (\<forall>t \<in> set ts. tcb_at' t s) \<and> distinct ts
+      \<and> (case ntfnBoundTCB ntfn of Some tcb \<Rightarrow> ts = [tcb] | _ \<Rightarrow> True)
   | Structures_H.ActiveNtfn b \<Rightarrow> True)
-  \<and> valid_bound_tcb' (ntfnBoundTCB ntfn) s"
+      \<and> valid_bound_tcb' (ntfnBoundTCB ntfn) s
+      \<and> valid_bound_sc' (ntfnSc ntfn) s"
+
+definition valid_sched_context' :: "sched_context \<Rightarrow> kernel_state \<Rightarrow> bool" where
+  "valid_sched_context' sc s \<equiv>
+     valid_bound_ntfn' (scNtfn sc) s
+     \<and> valid_bound_tcb' (scTCB sc) s
+     \<and> valid_bound_tcb' (scYieldFrom sc) s
+     \<and> valid_bound_reply' (scReply sc) s
+     \<and> MIN_REFILLS \<le> length (scRefills sc)
+     \<and> scRefillMax sc \<le> length (scRefills sc)
+     \<and> (0 < scRefillMax sc \<longrightarrow> scRefillHead sc < scRefillMax sc
+                               \<and> scRefillCount sc \<le> scRefillMax sc
+                               \<and> 0 < scRefillCount sc)
+     \<and> length (scRefills sc) = refillAbsoluteMax' (scBitsFromRefillLength' (length (scRefills sc)))"
+
+definition valid_reply' :: "reply \<Rightarrow> kernel_state \<Rightarrow> bool" where
+  "valid_reply' reply s \<equiv>
+     valid_bound_tcb' (replyTCB reply) s
+     \<and> valid_bound_sc' (replySC reply) s
+     \<and> valid_bound_reply' (replyPrev reply) s
+     \<and> valid_bound_reply' (replyNext_of reply) s"
 
 definition
   valid_mapping' :: "word32 \<Rightarrow> vmpage_size \<Rightarrow> kernel_state \<Rightarrow> bool"
@@ -585,11 +781,30 @@ where
   "pspace_distinct' s \<equiv>
    \<forall>x \<in> dom (ksPSpace s). ps_clear x (objBitsKO (the (ksPSpace s x))) s"
 
+definition pspace_bounded' :: "kernel_state \<Rightarrow> bool" where
+ "pspace_bounded' s \<equiv>
+  \<forall>x \<in> dom (ksPSpace s). objBitsKO (the (ksPSpace s x)) < word_bits"
+
 definition
   valid_objs' :: "kernel_state \<Rightarrow> bool"
 where
   "valid_objs' s \<equiv> \<forall>obj \<in> ran (ksPSpace s). valid_obj' obj s"
 
+definition valid_obj_size' :: "kernel_object \<Rightarrow> kernel_state \<Rightarrow> bool" where
+  "valid_obj_size' ko s \<equiv> case ko of
+    KOSchedContext sc \<Rightarrow> valid_sched_context_size' sc
+  | _ \<Rightarrow> True"
+
+definition
+  valid_objs_size' :: "kernel_state \<Rightarrow> bool"
+where
+  "valid_objs_size' s \<equiv> \<forall>obj \<in> ran (ksPSpace s). valid_obj_size' obj s"
+
+lemma valid_objs'_valid_objs_size':
+  "valid_objs' s \<Longrightarrow> valid_objs_size' s"
+  by (clarsimp simp: valid_objs'_def valid_objs_size'_def valid_obj'_def valid_obj_size'_def)
+     (fastforce split: kernel_object.splits)
+
 type_synonym cte_heap = "word32 \<Rightarrow> cte option"
 
 definition
@@ -848,12 +1058,31 @@ definition "vs_valid_duplicates' \<equiv> \<lambda>h.
               x && ~~ mask (vs_ptr_align ko) = y && ~~ mask (vs_ptr_align ko) \<longrightarrow>
               h x = h y"
 
+abbreviation
+  "is_reply_linked rptr s \<equiv> replyNexts_of s rptr \<noteq> None \<or> replyPrevs_of s rptr \<noteq> None"
+
+definition valid_replies'_except :: "obj_ref set \<Rightarrow> kernel_state \<Rightarrow> bool" where
+  "valid_replies'_except RS s \<equiv>
+     (\<forall>rptr. rptr \<notin> RS \<and> is_reply_linked rptr s
+             \<longrightarrow> (\<exists>tptr. replyTCBs_of s rptr = Some tptr
+                         \<and> st_tcb_at' ((=) (BlockedOnReply (Some rptr))) tptr s))"
+
+definition [simplified empty_iff simp_thms valid_replies'_except_def]:
+  "valid_replies' s \<equiv> valid_replies'_except {} s"
+
+defs valid_replies'_sc_asrt_def:
+  "valid_replies'_sc_asrt \<equiv> \<lambda>rptr s.
+     replySCs_of s rptr \<noteq> None
+       \<longrightarrow> (\<exists>tptr. replyTCBs_of s rptr = Some tptr
+                   \<and> st_tcb_at' ((=) (BlockedOnReply (Some rptr))) tptr s)"
 definition
   valid_pspace' :: "kernel_state \<Rightarrow> bool"
 where
   "valid_pspace' \<equiv> valid_objs' and
+                   valid_replies' and
                    pspace_aligned' and
                    pspace_distinct' and
+                   pspace_bounded' and
                    no_0_obj' and
                    valid_mdb'"
 
@@ -940,11 +1174,37 @@ where
 lemmas bitmapQ_defs = valid_bitmapQ_def valid_bitmapQ_except_def bitmapQ_def
                        bitmapQ_no_L2_orphans_def bitmapQ_no_L1_orphans_def
 
+(* valid_queues is too strong sometimes *)
+definition valid_inQ_queues :: "KernelStateData_H.kernel_state \<Rightarrow> bool" where
+  "valid_inQ_queues \<equiv> \<lambda>s. \<forall>d p. (\<forall>t\<in>set (ksReadyQueues s (d, p)). obj_at' (inQ d p) t s)"
+
+definition
+  (* when in the middle of updates, a particular queue might not be entirely valid *)
+  valid_inQ_queues_except :: "word32 \<Rightarrow> kernel_state \<Rightarrow> bool"
+where
+ "valid_inQ_queues_except t'
+   \<equiv> \<lambda>s. (\<forall>d p. (\<forall>t \<in> set (ksReadyQueues s (d, p)). t \<noteq> t' \<longrightarrow> obj_at' (inQ d p) t s))"
+
 definition
   valid_queues' :: "kernel_state \<Rightarrow> bool"
 where
  "valid_queues' \<equiv> \<lambda>s. \<forall>d p t. obj_at' (inQ d p) t s \<longrightarrow> t \<in> set (ksReadyQueues s (d, p))"
 
+definition
+  valid_release_queue :: "kernel_state \<Rightarrow> bool"
+where
+ "valid_release_queue \<equiv> \<lambda>s. \<forall>t. t \<in> set (ksReleaseQueue s) \<longrightarrow> obj_at' (tcbInReleaseQueue) t s"
+
+definition
+  valid_release_queue' :: "kernel_state \<Rightarrow> bool"
+where
+ "valid_release_queue' \<equiv> \<lambda>s. \<forall>t. obj_at' (tcbInReleaseQueue) t s \<longrightarrow> t \<in> set (ksReleaseQueue s)"
+
+abbreviation
+  valid_release_queue_iff :: "kernel_state \<Rightarrow> bool"
+where
+  "valid_release_queue_iff \<equiv> valid_release_queue and valid_release_queue'"
+
 definition tcb_in_cur_domain' :: "32 word \<Rightarrow> kernel_state \<Rightarrow> bool" where
   "tcb_in_cur_domain' t \<equiv> \<lambda>s. obj_at' (\<lambda>tcb. ksCurDomain s = tcbDomain tcb) t s"
 
@@ -998,19 +1268,45 @@ where
 abbreviation
   "sch_act_not t \<equiv> \<lambda>s. ksSchedulerAction s \<noteq> SwitchToThread t"
 
-definition idle_tcb'_2 :: "Structures_H.thread_state \<times> machine_word option \<Rightarrow> bool" where
-  "idle_tcb'_2 \<equiv> \<lambda>(st, ntfn_opt). (idle' st \<and> ntfn_opt = None)"
+definition
+  idle_tcb'_2 :: "Structures_H.thread_state \<times> 32 word option \<times> 32 word option \<times> 32 word option
+                  \<Rightarrow> bool"
+where
+  "idle_tcb'_2 \<equiv> \<lambda>(st, ntfn_opt, sc_opt, yt_opt).
+                    (idle' st \<and> ntfn_opt = None \<and> sc_opt = Some idle_sc_ptr \<and> yt_opt = None)"
 
 abbreviation
-  "idle_tcb' tcb \<equiv> idle_tcb'_2 (tcbState tcb, tcbBoundNotification tcb)"
+  "idle_tcb' tcb \<equiv>
+      idle_tcb'_2 (tcbState tcb, tcbBoundNotification tcb, tcbSchedContext tcb, tcbYieldTo tcb)"
 
 lemmas idle_tcb'_def = idle_tcb'_2_def
 
-definition valid_idle' :: "kernel_state \<Rightarrow> bool" where
-  "valid_idle' \<equiv> \<lambda>s. obj_at' idle_tcb' (ksIdleThread s) s \<and> idle_thread_ptr = ksIdleThread s"
+abbreviation idle_sc' :: "sched_context \<Rightarrow> bool" where
+  "idle_sc' sc \<equiv>
+      scPeriod sc = 0
+      \<and> scTCB sc = Some idle_thread_ptr
+      \<and> scNtfn sc = None
+      \<and> scRefillMax sc = MIN_REFILLS
+      \<and> scBadge sc = 0
+      \<and> scYieldFrom sc = None
+      \<and> scReply sc = None"
+
+abbreviation
+  "idle_sc_at' \<equiv> obj_at' idle_sc'"
+
+definition
+  valid_idle' :: "kernel_state \<Rightarrow> bool"
+where
+  "valid_idle' \<equiv>
+     \<lambda>s. obj_at' idle_tcb' (ksIdleThread s) s
+         \<and> idle_sc_at' idle_sc_ptr s
+         \<and> idle_thread_ptr = ksIdleThread s"
+
+defs valid_idle'_asrt_def:
+  "valid_idle'_asrt \<equiv> \<lambda>s. valid_idle' s"
 
 lemma valid_idle'_tcb_at':
-  "valid_idle' s \<Longrightarrow> obj_at' idle_tcb' (ksIdleThread s) s"
+  "valid_idle' s \<Longrightarrow> obj_at' idle_tcb' (ksIdleThread s) s \<and> idle_sc_at' idle_sc_ptr s"
   by (clarsimp simp: valid_idle'_def)
 
 definition valid_irq_node' :: "word32 \<Rightarrow> kernel_state \<Rightarrow> bool" where
@@ -1036,7 +1332,7 @@ definition
   global_refs' :: "kernel_state \<Rightarrow> obj_ref set"
 where
   "global_refs' \<equiv> \<lambda>s.
-  {ksIdleThread s} \<union>
+  {ksIdleThread s, idle_sc_ptr} \<union>
    page_directory_refs' (armKSGlobalPD (ksArchState s)) \<union>
    (\<Union>pt \<in> set (armKSGlobalPTs (ksArchState s)). page_table_refs' pt) \<union>
    range (\<lambda>irq :: irq. irq_node' s + (ucast irq << cteSizeBits))"
@@ -1158,47 +1454,51 @@ abbreviation
   "untyped_ranges_zero' s \<equiv> untyped_ranges_zero_inv (cteCaps_of s)
       (gsUntypedZeroRanges s)"
 
-(* FIXME: this really should be a definition like the above. *)
 (* The schedule is invariant. *)
-abbreviation
+definition
   "valid_dom_schedule' \<equiv>
    \<lambda>s. ksDomSchedule s \<noteq> [] \<and> (\<forall>x\<in>set (ksDomSchedule s). dschDomain x \<le> maxDomain \<and> 0 < dschLength x)
        \<and> ksDomSchedule s = ksDomSchedule (newKernelState undefined)
        \<and> ksDomScheduleIdx s < length (ksDomSchedule (newKernelState undefined))"
 
 definition
-  valid_state' :: "kernel_state \<Rightarrow> bool"
-where
-  "valid_state' \<equiv> \<lambda>s. valid_pspace' s \<and> sch_act_wf (ksSchedulerAction s) s
-                      \<and> valid_queues s \<and> sym_refs (state_refs_of' s)
-                      \<and> if_live_then_nonz_cap' s \<and> if_unsafe_then_cap' s
-                      \<and> valid_idle' s
-                      \<and> valid_global_refs' s \<and> valid_arch_state' s
-                      \<and> valid_irq_node' (irq_node' s) s
-                      \<and> valid_irq_handlers' s
-                      \<and> valid_irq_states' s
-                      \<and> valid_machine_state' s
-                      \<and> irqs_masked' s
-                      \<and> valid_queues' s
-                      \<and> ct_not_inQ s
-                      \<and> ct_idle_or_in_cur_domain' s
-                      \<and> valid_pde_mappings' s
-                      \<and> pspace_domain_valid s
-                      \<and> ksCurDomain s \<le> maxDomain
-                      \<and> valid_dom_schedule' s
-                      \<and> untyped_ranges_zero' s"
+  invs' :: "kernel_state \<Rightarrow> bool"
+where
+  "invs' \<equiv> \<lambda>s. valid_pspace' s
+                \<and> valid_queues s
+                \<and> sym_refs (list_refs_of_replies' s)
+                \<and> if_live_then_nonz_cap' s \<and> if_unsafe_then_cap' s
+                \<and> valid_global_refs' s \<and> valid_arch_state' s
+                \<and> valid_irq_node' (irq_node' s) s
+                \<and> valid_irq_handlers' s
+                \<and> valid_irq_states' s
+                \<and> valid_machine_state' s
+                \<and> irqs_masked' s
+                \<and> valid_queues' s
+                \<and> valid_release_queue s
+                \<and> valid_release_queue' s
+                \<and> valid_pde_mappings' s
+                \<and> pspace_domain_valid s
+                \<and> ksCurDomain s \<le> maxDomain
+                \<and> valid_dom_schedule' s
+                \<and> untyped_ranges_zero' s"
 
 definition
   "cur_tcb' s \<equiv> tcb_at' (ksCurThread s) s"
 
-definition
-  invs' :: "kernel_state \<Rightarrow> bool" where
-  "invs' \<equiv> valid_state' and cur_tcb'"
+defs cur_tcb'_asrt_def:
+  "cur_tcb'_asrt \<equiv> \<lambda>s. cur_tcb' s"
+
+defs sch_act_sane_asrt_def:
+  "sch_act_sane_asrt \<equiv> \<lambda>s. sch_act_sane s"
+
+defs ct_not_ksQ_asrt_def:
+  "ct_not_ksQ_asrt \<equiv> \<lambda>s. \<forall>pd. ksCurThread s \<notin> set (ksReadyQueues s pd)"
 
 subsection "Derived concepts"
 
 abbreviation
-  "awaiting_reply' ts \<equiv> ts = Structures_H.BlockedOnReply"
+  "awaiting_reply' ts \<equiv> isBlockedOnReply ts"
 
   (* x-symbol doesn't have a reverse leadsto.. *)
 definition
@@ -1250,65 +1557,9 @@ abbreviation
 abbreviation
   "ct_running' \<equiv> ct_in_state' (\<lambda>st. st = Structures_H.Running)"
 
-abbreviation(input)
- "all_invs_but_sym_refs_ct_not_inQ'
-    \<equiv> \<lambda>s. valid_pspace' s \<and> sch_act_wf (ksSchedulerAction s) s
-           \<and> valid_queues s \<and> if_live_then_nonz_cap' s \<and> if_unsafe_then_cap' s
-           \<and> valid_idle' s \<and> valid_global_refs' s \<and> valid_arch_state' s
-           \<and> valid_irq_node' (irq_node' s) s \<and> valid_irq_handlers' s
-           \<and> valid_irq_states' s \<and> irqs_masked' s \<and> valid_machine_state' s
-           \<and> cur_tcb' s \<and> valid_queues' s \<and> ct_idle_or_in_cur_domain' s \<and> valid_pde_mappings' s
-           \<and> pspace_domain_valid s
-           \<and> ksCurDomain s \<le> maxDomain
-           \<and> valid_dom_schedule' s \<and> untyped_ranges_zero' s"
-
-abbreviation(input)
- "all_invs_but_ct_not_inQ'
-    \<equiv> \<lambda>s. valid_pspace' s \<and> sch_act_wf (ksSchedulerAction s) s
-           \<and> valid_queues s \<and> sym_refs (state_refs_of' s)
-           \<and> if_live_then_nonz_cap' s \<and> if_unsafe_then_cap' s
-           \<and> valid_idle' s \<and> valid_global_refs' s \<and> valid_arch_state' s
-           \<and> valid_irq_node' (irq_node' s) s \<and> valid_irq_handlers' s
-           \<and> valid_irq_states' s \<and> irqs_masked' s \<and> valid_machine_state' s
-           \<and> cur_tcb' s \<and> valid_queues' s \<and> ct_idle_or_in_cur_domain' s \<and> valid_pde_mappings' s
-           \<and> pspace_domain_valid s
-           \<and> ksCurDomain s \<le> maxDomain
-           \<and> valid_dom_schedule' s \<and> untyped_ranges_zero' s"
-
-lemma all_invs_but_sym_refs_not_ct_inQ_check':
-  "(all_invs_but_sym_refs_ct_not_inQ' and sym_refs \<circ> state_refs_of' and ct_not_inQ) = invs'"
-  by (simp add: pred_conj_def conj_commute conj_left_commute invs'_def valid_state'_def)
-
-lemma all_invs_but_not_ct_inQ_check':
-  "(all_invs_but_ct_not_inQ' and ct_not_inQ) = invs'"
-  by (simp add: pred_conj_def conj_commute conj_left_commute invs'_def valid_state'_def)
-
-definition
-  "all_invs_but_ct_idle_or_in_cur_domain'
-    \<equiv> \<lambda>s. valid_pspace' s \<and> sch_act_wf (ksSchedulerAction s) s
-           \<and> valid_queues s \<and> sym_refs (state_refs_of' s)
-           \<and> if_live_then_nonz_cap' s \<and> if_unsafe_then_cap' s
-           \<and> valid_idle' s \<and> valid_global_refs' s \<and> valid_arch_state' s
-           \<and> valid_irq_node' (irq_node' s) s \<and> valid_irq_handlers' s
-           \<and> valid_irq_states' s \<and> irqs_masked' s \<and> valid_machine_state' s
-           \<and> cur_tcb' s \<and> valid_queues' s \<and> ct_not_inQ s \<and> valid_pde_mappings' s
-           \<and> pspace_domain_valid s
-           \<and> ksCurDomain s \<le> maxDomain
-           \<and> valid_dom_schedule' s \<and> untyped_ranges_zero' s"
-
-lemmas invs_no_cicd'_def = all_invs_but_ct_idle_or_in_cur_domain'_def
-
-lemma all_invs_but_ct_idle_or_in_cur_domain_check':
-  "(all_invs_but_ct_idle_or_in_cur_domain' and ct_idle_or_in_cur_domain') = invs'"
-  by (simp add: all_invs_but_ct_idle_or_in_cur_domain'_def pred_conj_def
-                conj_left_commute conj_commute invs'_def valid_state'_def)
+defs ct_active'_asrt_def:
+  "ct_active'_asrt \<equiv> ct_active'"
 
-abbreviation (input)
-  "invs_no_cicd' \<equiv> all_invs_but_ct_idle_or_in_cur_domain'"
-
-lemma invs'_to_invs_no_cicd'_def:
-  "invs' = (all_invs_but_ct_idle_or_in_cur_domain' and ct_idle_or_in_cur_domain')"
-  by (fastforce simp: invs'_def all_invs_but_ct_idle_or_in_cur_domain'_def valid_state'_def )
 end
 
 locale mdb_next =
@@ -1398,26 +1646,25 @@ lemma ps_clear_def2:
   done
 
 lemma projectKO_stateI:
-  "fst (projectKO e s) = {(obj, s)} \<Longrightarrow> fst (projectKO e s') = {(obj, s')}"
+  "projectKO e s = Some obj \<Longrightarrow> projectKO e s' = Some obj"
   unfolding projectKO_def
-  by (auto simp: fail_def return_def valid_def split: option.splits)
+  by (auto simp: omonad_defs split: option.splits)
 
 lemma singleton_in_magnitude_check:
   "(x, s) \<in> fst (magnitudeCheck a b c s') \<Longrightarrow> \<forall>s'. fst (magnitudeCheck a b c s') = {(x, s')}"
-  by (simp add: magnitudeCheck_def when_def in_monad return_def
-         split: if_split_asm option.split_asm)
+  by (fastforce simp: read_magnitudeCheck_def magnitudeCheck_def in_monad
+               split: option.split_asm)
 
 lemma wordSizeCase_simp [simp]: "wordSizeCase a b = a"
   by (simp add: wordSizeCase_def wordBits_def word_size)
 
-lemma projectKO_eq:
-  "(fst (projectKO ko c) = {(obj, c)}) = (projectKO_opt ko = Some obj)"
-  by (simp add: projectKO_def fail_def return_def split: option.splits)
+(* FIXME RT: cleanup: with the reader monad, projectKO_eq is identical to projectKO_eq2. *)
+lemmas projectKO_eq = projectKO_eq2
 
 lemma obj_at'_def':
   "obj_at' P p s = (\<exists>ko obj. ksPSpace s p = Some ko \<and> is_aligned p (objBitsKO ko)
-                   \<and> fst (projectKO ko s) = {(obj,s)} \<and> P obj
-                   \<and> ps_clear p (objBitsKO ko) s)"
+                   \<and> projectKO ko s = Some obj \<and> P obj
+                   \<and> ps_clear p (objBitsKO ko) s \<and> objBitsKO ko < word_bits)"
   apply (simp add: obj_at'_real_def ko_wp_at'_def projectKO_eq
                    True_notin_set_replicate_conv objBits_def)
   apply fastforce
@@ -1453,45 +1700,16 @@ lemma cte_at'_def:
 
 lemma tcb_cte_cases_simps[simp]:
   "tcb_cte_cases 0  = Some (tcbCTable, tcbCTable_update)"
-  "tcb_cte_cases 16 = Some (tcbVTable, tcbVTable_update)"
-  "tcb_cte_cases 32 = Some (tcbReply, tcbReply_update)"
-  "tcb_cte_cases 48 = Some (tcbCaller, tcbCaller_update)"
-  "tcb_cte_cases 64 = Some (tcbIPCBufferFrame, tcbIPCBufferFrame_update)"
+  "tcb_cte_cases 0x10 = Some (tcbVTable, tcbVTable_update)"
+  "tcb_cte_cases 0x20 = Some (tcbIPCBufferFrame, tcbIPCBufferFrame_update)"
+  "tcb_cte_cases 0x30 = Some (tcbFaultHandler, tcbFaultHandler_update)"
+  "tcb_cte_cases 0x40 = Some (tcbTimeoutHandler, tcbTimeoutHandler_update)"
   by (simp add: tcb_cte_cases_def)+
 
-lemma refs_of'_simps[simp]:
- "refs_of' (KOTCB tcb)           = tcb_st_refs_of' (tcbState tcb) \<union> tcb_bound_refs' (tcbBoundNotification tcb)"
- "refs_of' (KOCTE cte)           = {}"
- "refs_of' (KOEndpoint ep)       = ep_q_refs_of' ep"
- "refs_of' (KONotification ntfn)     = ntfn_q_refs_of' (ntfnObj ntfn) \<union> ntfn_bound_refs' (ntfnBoundTCB ntfn)"
- "refs_of' (KOUserData)          = {}"
- "refs_of' (KOUserDataDevice)          = {}"
- "refs_of' (KOKernelData)        = {}"
- "refs_of' (KOArch ako)          = {}"
-  by (auto simp: refs_of'_def)
-
-lemma tcb_st_refs_of'_simps[simp]:
- "tcb_st_refs_of' (Running)                  = {}"
- "tcb_st_refs_of' (Inactive)                 = {}"
- "tcb_st_refs_of' (Restart)                  = {}"
- "tcb_st_refs_of' (BlockedOnReceive x'' a')  = {(x'', TCBBlockedRecv)}"
- "tcb_st_refs_of' (BlockedOnSend x a b c d)  = {(x, TCBBlockedSend)}"
- "tcb_st_refs_of' (BlockedOnNotification x') = {(x', TCBSignal)}"
- "tcb_st_refs_of' (BlockedOnReply)           = {}"
- "tcb_st_refs_of' (IdleThreadState)          = {}"
-  by (auto simp: tcb_st_refs_of'_def)
-
-lemma ep_q_refs_of'_simps[simp]:
- "ep_q_refs_of'  IdleEP    = {}"
- "ep_q_refs_of' (RecvEP q) = set q \<times> {EPRecv}"
- "ep_q_refs_of' (SendEP q) = set q \<times> {EPSend}"
-  by (auto simp: ep_q_refs_of'_def)
-
-lemma ntfn_q_refs_of'_simps[simp]:
- "ntfn_q_refs_of'  IdleNtfn         = {}"
- "ntfn_q_refs_of' (WaitingNtfn q)      = set q \<times> {NTFNSignal}"
- "ntfn_q_refs_of' (ActiveNtfn b)  = {}"
-  by (auto simp: ntfn_q_refs_of'_def)
+lemmas refs_of'_simps[simp] = refs_of'_def[split_simps kernel_object.split]
+lemmas tcb_st_refs_of'_simps[simp] = tcb_st_refs_of'_def[split_simps thread_state.split]
+lemmas ep_q_refs_of'_simps[simp] = ep_q_refs_of'_def[split_simps endpoint.split]
+lemmas ntfn_q_refs_of'_simps[simp] = ntfn_q_refs_of'_def[split_simps ntfn.split]
 
 lemma ntfn_bound_refs'_simps[simp]:
   "ntfn_bound_refs' (Some t) = {(t, NTFNBound)}"
@@ -1593,20 +1836,32 @@ lemma ko_at_state_refs_ofD':
   "ko_at' ko p s \<Longrightarrow> state_refs_of' s p = refs_of' (injectKO ko)"
   by (clarsimp dest!: obj_at_state_refs_ofD')
 
+abbreviation distinct_release_queue :: "kernel_state \<Rightarrow> bool" where
+  "distinct_release_queue \<equiv> \<lambda>s. distinct (ksReleaseQueue s)"
+
 definition
   tcb_ntfn_is_bound' :: "word32 option \<Rightarrow> tcb \<Rightarrow> bool"
 where
   "tcb_ntfn_is_bound' ntfn tcb \<equiv> tcbBoundNotification tcb = ntfn"
 
 lemma st_tcb_at_state_refs_ofD':
-  "st_tcb_at' P t s \<Longrightarrow> \<exists>ts ntfnptr. P ts \<and> obj_at' (tcb_ntfn_is_bound' ntfnptr) t s
-          \<and> state_refs_of' s t = (tcb_st_refs_of' ts \<union> tcb_bound_refs' ntfnptr)"
+  "st_tcb_at' P t s \<Longrightarrow>
+    \<exists>ts ntfnptr sc_ptr yieldto_ptr. P ts
+                 \<and> obj_at' ((=) ntfnptr o tcbBoundNotification) t s
+                 \<and> obj_at' ((=) sc_ptr o tcbSchedContext) t s
+                 \<and> obj_at' ((=) yieldto_ptr o tcbYieldTo) t s
+                 \<and> state_refs_of' s t = (tcb_st_refs_of' ts
+                                         \<union> tcb_bound_refs' ntfnptr sc_ptr yieldto_ptr)"
   by (auto simp: pred_tcb_at'_def tcb_ntfn_is_bound'_def obj_at'_def projectKO_eq
                  project_inject state_refs_of'_def)
 
 lemma bound_tcb_at_state_refs_ofD':
-  "bound_tcb_at' P t s \<Longrightarrow> \<exists>ts ntfnptr. P ntfnptr \<and> obj_at' (tcb_ntfn_is_bound' ntfnptr) t s
-          \<and> state_refs_of' s t = (tcb_st_refs_of' ts \<union> tcb_bound_refs' ntfnptr)"
+  "bound_tcb_at' P t s \<Longrightarrow>
+    \<exists>ts ntfnptr sc_ptr yieldto_ptr. P ntfnptr
+                 \<and> obj_at' ((=) ntfnptr o tcbBoundNotification) t s
+                 \<and> obj_at' ((=) sc_ptr o tcbSchedContext) t s
+                 \<and> obj_at' ((=) yieldto_ptr o tcbYieldTo) t s
+          \<and> state_refs_of' s t = (tcb_st_refs_of' ts \<union> tcb_bound_refs' ntfnptr sc_ptr yieldto_ptr)"
   by (auto simp: pred_tcb_at'_def obj_at'_def tcb_ntfn_is_bound'_def projectKO_eq
                  project_inject state_refs_of'_def)
 
@@ -1785,32 +2078,32 @@ lemma valid_pde_mapping'_simps[simp]:
 lemmas valid_irq_states'_def = valid_irq_masks'_def
 
 lemma valid_pspaceI' [intro]:
-  "\<lbrakk>valid_objs' s; pspace_aligned' s; pspace_distinct' s; valid_mdb' s; no_0_obj' s\<rbrakk>
+  "\<lbrakk>valid_objs' s; pspace_aligned' s; pspace_distinct' s; pspace_bounded' s; valid_mdb' s; no_0_obj' s;
+    valid_replies' s\<rbrakk>
   \<Longrightarrow> valid_pspace' s"  unfolding valid_pspace'_def by simp
 
 lemma valid_pspaceE' [elim]:
   "\<lbrakk>valid_pspace' s;
-    \<lbrakk> valid_objs' s; pspace_aligned' s; pspace_distinct' s; no_0_obj' s;
-      valid_mdb' s\<rbrakk> \<Longrightarrow> R \<rbrakk> \<Longrightarrow> R"
+    \<lbrakk> valid_objs' s; valid_replies' s; pspace_aligned' s; pspace_distinct' s; pspace_bounded' s;
+      no_0_obj' s; valid_mdb' s\<rbrakk> \<Longrightarrow> R \<rbrakk> \<Longrightarrow> R"
   unfolding valid_pspace'_def by simp
 
-lemma idle'_no_refs:
-  "valid_idle' s \<Longrightarrow> state_refs_of' s (ksIdleThread s) = {}"
+lemma idle'_only_sc_refs:
+  "valid_idle' s \<Longrightarrow> state_refs_of' s (ksIdleThread s) = {(idle_sc_ptr, TCBSchedContext)}"
   by (clarsimp simp: valid_idle'_def pred_tcb_at'_def obj_at'_def tcb_ntfn_is_bound'_def
                      projectKO_eq project_inject state_refs_of'_def idle_tcb'_def)
 
 lemma idle'_not_queued':
   "\<lbrakk>valid_idle' s; sym_refs (state_refs_of' s);
-    state_refs_of' s ptr = insert t queue \<times> {rt}\<rbrakk>\<Longrightarrow>
-   ksIdleThread s \<notin> queue"
-  by (frule idle'_no_refs, fastforce simp: valid_idle'_def sym_refs_def)
+    state_refs_of' s ptr = insert t queue \<times> {rt}; ksIdleThread s \<in> queue\<rbrakk>
+     \<Longrightarrow> ptr = idle_sc_ptr"
+  by (frule idle'_only_sc_refs, fastforce simp: valid_idle'_def sym_refs_def)
 
 lemma idle'_not_queued:
   "\<lbrakk>valid_idle' s; sym_refs (state_refs_of' s);
-    state_refs_of' s ptr = queue \<times> {rt}\<rbrakk> \<Longrightarrow>
-   ksIdleThread s \<notin> queue"
-  by (frule idle'_no_refs, fastforce simp: valid_idle'_def sym_refs_def)
-
+    state_refs_of' s ptr = queue \<times> {rt}; ksIdleThread s \<in> queue\<rbrakk>
+      \<Longrightarrow> ptr = idle_sc_ptr"
+  by (frule idle'_only_sc_refs, fastforce simp: valid_idle'_def sym_refs_def)
 
 lemma obj_at_conj':
   "\<lbrakk> obj_at' P p s; obj_at' Q p s \<rbrakk> \<Longrightarrow> obj_at' (\<lambda>k. P k \<and> Q k) p s"
@@ -1838,24 +2135,29 @@ lemma obj_at'_pspaceI:
   "obj_at' t ref s \<Longrightarrow> ksPSpace s = ksPSpace s' \<Longrightarrow>  obj_at' t ref s'"
   by (auto intro!: projectKO_stateI simp: obj_at'_def ps_clear_def)
 
+lemma sc_at'_n_pspaceI:
+  "sc_at'_n n ref s \<Longrightarrow> ksPSpace s = ksPSpace s' \<Longrightarrow>  sc_at'_n n ref s'"
+  by (auto intro!: projectKO_stateI simp: ko_wp_at'_def ps_clear_def)
+
 lemma cte_wp_at'_pspaceI:
   "\<lbrakk>cte_wp_at' P p s; ksPSpace s = ksPSpace s'\<rbrakk> \<Longrightarrow> cte_wp_at' P p s'"
   supply if_cong[cong]
-  apply (clarsimp simp add: cte_wp_at'_def getObject_def)
+  apply (clarsimp simp: cte_wp_at'_def getObject_def readObject_def gets_the_def)
   apply (drule equalityD2)
-  apply (clarsimp simp: in_monad loadObject_cte gets_def
-                        get_def bind_def return_def split_def)
-  apply (case_tac b)
-        apply (simp_all add: in_monad typeError_def)
+  apply (clarsimp simp: in_monad loadObject_cte gets_def asks_def
+                        get_def bind_def split_def oassert_opt_def
+                 split: option.split_asm)
+  apply (rename_tac b; case_tac b)
+           apply (simp_all add: in_monad read_typeError_def)
    prefer 2
-   apply (simp add: in_monad return_def alignError_def assert_opt_def
-                    alignCheck_def magnitudeCheck_def when_def bind_def
+   apply (simp add: in_monad omonad_defs read_alignError_def obind_def
+                    read_alignCheck_def read_magnitudeCheck_def return_def
              split: if_split_asm option.splits)
-  apply (clarsimp simp: in_monad return_def alignError_def fail_def assert_opt_def
-                        alignCheck_def bind_def when_def
+  apply (clarsimp simp: in_monad omonad_defs read_alignError_def obind_def
+                        read_alignCheck_def read_magnitudeCheck_def return_def
                         objBits_cte_conv tcbCTableSlot_def tcbVTableSlot_def
-                        tcbReplySlot_def cteSizeBits_def
-                 split: if_split_asm
+                        cteSizeBits_def tcbIPCBufferSlot_def tcbFaultHandlerSlot_def
+                 split: if_split_asm option.split_asm
                  dest!: singleton_in_magnitude_check)
   done
 
@@ -1874,7 +2176,7 @@ lemma valid_cap'_pspaceI:
   by (cases cap)
      (force intro: obj_at'_pspaceI[rotated]
                   cte_wp_at'_pspaceI valid_untyped'_pspaceI
-                  typ_at'_pspaceI[rotated]
+                  typ_at'_pspaceI[rotated] sc_at'_n_pspaceI[rotated]
             simp: page_table_at'_def page_directory_at'_def
            split: arch_capability.split zombie_type.split option.splits)+
 
@@ -1897,12 +2199,17 @@ lemma valid_obj'_pspaceI:
   unfolding valid_obj'_def
   by (cases obj)
      (auto simp: valid_ep'_def valid_ntfn'_def valid_tcb'_def valid_cte'_def
-                 valid_tcb_state'_def valid_arch_obj'_pspaceI valid_bound_tcb'_def
-                 valid_bound_ntfn'_def
+                 valid_tcb_state'_def valid_arch_obj'_pspaceI valid_bound_obj'_def
+                 valid_sched_context'_def valid_reply'_def
            split: Structures_H.endpoint.splits Structures_H.notification.splits
                   Structures_H.thread_state.splits ntfn.splits option.splits
            intro: obj_at'_pspaceI valid_cap'_pspaceI)
 
+lemma valid_obj_size'_pspaceI:
+  "valid_obj_size' obj s \<Longrightarrow> ksPSpace s = ksPSpace s' \<Longrightarrow> valid_obj_size' obj s'"
+  unfolding valid_obj_size'_def
+  by (cases obj; simp)
+
 lemma pred_tcb_at'_pspaceI:
   "pred_tcb_at' proj P t s \<Longrightarrow> ksPSpace s = ksPSpace s' \<Longrightarrow> pred_tcb_at' proj P t s'"
   unfolding pred_tcb_at'_def by (fast intro: obj_at'_pspaceI)
@@ -1911,23 +2218,33 @@ lemma valid_mdb'_pspaceI:
   "valid_mdb' s \<Longrightarrow> ksPSpace s = ksPSpace s' \<Longrightarrow> valid_mdb' s'"
   unfolding valid_mdb'_def by simp
 
+lemma valid_replies'_pspaceI:
+  "valid_replies' s \<Longrightarrow> ksPSpace s = ksPSpace s' \<Longrightarrow> valid_replies' s'"
+  unfolding valid_replies'_def
+  apply clarsimp
+  apply (drule_tac x=rptr in spec)
+  apply (auto simp: opt_map_def intro: pred_tcb_at'_pspaceI)
+  done
+
 lemma state_refs_of'_pspaceI:
   "P (state_refs_of' s) \<Longrightarrow> ksPSpace s = ksPSpace s' \<Longrightarrow> P (state_refs_of' s')"
-  unfolding state_refs_of'_def ps_clear_def by (simp cong: option.case_cong)
+  unfolding state_refs_of'_def ps_clear_def
+  by (erule rsubst[where P=P], rule ext) (simp split: option.splits)
 
 lemma valid_pspace':
   "valid_pspace' s \<Longrightarrow> ksPSpace s = ksPSpace s' \<Longrightarrow> valid_pspace' s'"
-  by  (auto simp add: valid_pspace'_def valid_objs'_def pspace_aligned'_def
+  by (auto simp add: valid_pspace'_def valid_objs'_def pspace_aligned'_def
                      pspace_distinct'_def ps_clear_def no_0_obj'_def ko_wp_at'_def
-                     typ_at'_def
-           intro: valid_obj'_pspaceI valid_mdb'_pspaceI)
+                     typ_at'_def pspace_bounded'_def
+              intro: valid_obj'_pspaceI valid_mdb'_pspaceI valid_replies'_pspaceI)
 
 lemma valid_idle'_pspace_itI[elim]:
   "\<lbrakk> valid_idle' s; ksPSpace s = ksPSpace s'; ksIdleThread s = ksIdleThread s' \<rbrakk>
       \<Longrightarrow> valid_idle' s'"
   apply (clarsimp simp: valid_idle'_def ex_nonz_cap_to'_def)
-  apply (erule obj_at'_pspaceI, assumption)
-  done
+  apply (rule conjI)
+   apply (erule obj_at'_pspaceI, assumption)
+  using obj_at'_pspaceI by blast
 
 lemma obj_at'_weaken:
   assumes x: "obj_at' P t s"
@@ -2086,43 +2403,83 @@ lemma ps_clear_lookupAround2:
   apply (drule word_le_minus_one_leq, fastforce)
   done
 
-lemma in_magnitude_check:
-  "\<lbrakk> is_aligned x n; (1 :: word32) < 2 ^ n; ksPSpace s x = Some y \<rbrakk> \<Longrightarrow>
-   ((v, s') \<in> fst (magnitudeCheck x (snd (lookupAround2 x (ksPSpace s))) n s))
-     = (s' = s \<and> ps_clear x n s)"
-  apply (rule iffI)
-   apply (clarsimp simp: magnitudeCheck_def in_monad lookupAround2_None2
-                         lookupAround2_char2
-                  split: option.split_asm)
-    apply (erule(1) ps_clearI)
-    apply simp
-   apply (erule(1) ps_clearI)
-   apply (simp add: linorder_not_less)
-   apply (drule word_leq_le_minus_one[where x="2 ^ n"])
-    apply (clarsimp simp: power_overflow)
-   apply (drule word_l_diffs)
-    apply simp
-   apply (simp add: field_simps)
+lemma magnitudeCheck_wp:
+  "\<lbrace>\<lambda>s. (case next of
+                  Some next' \<Rightarrow> next' - ptr \<ge> 1 << bits
+                | None \<Rightarrow> True)
+        \<longrightarrow> P s\<rbrace>
+   magnitudeCheck ptr next bits
+   \<lbrace>\<lambda>_. P\<rbrace>"
+  unfolding magnitudeCheck_def read_magnitudeCheck_def
+  apply (simp add: gets_the_def exec_gets assert_opt_def valid_def
+                   return_def split_def fail_def
+            split: option.split)
+  done
+
+
+lemma alignCheck_wp:
+  "\<lbrace>\<lambda>s. is_aligned ptr bits \<longrightarrow> P s\<rbrace>
+   alignCheck ptr bits
+   \<lbrace>\<lambda>_. P\<rbrace>"
+  unfolding alignCheck_def read_alignCheck_def
+  apply (wpsimp simp: read_alignError_def is_aligned_mask omonad_defs)
+  done
+
+lemma lookupAround2_no_after_ps_clear:
+  "snd (lookupAround2 p (ksPSpace s)) = None \<Longrightarrow> ps_clear p bits s"
+  apply (fastforce simp: ps_clear_def lookupAround2_None2 dom_def set_eq_iff word_le_less_eq)
+  done
+
+lemma lookupAround2_after_ps_clear:
+  "\<lbrakk>snd (lookupAround2 p (ksPSpace s)) = Some after;
+    2 ^ bits \<le> after - p;
+    1 < (2 :: machine_word) ^ bits;
+    is_aligned p bits\<rbrakk> \<Longrightarrow>
+   ps_clear p bits s"
+  apply (rule ps_clearI; clarsimp simp: lookupAround2_char2)
+  apply (rename_tac x obj_after)
+  apply (drule_tac x=x in spec)
+  apply (frule word_l_diffs, simp)
+  apply (prop_tac "x < after")
+   apply (frule word_leq_minus_one_le[rotated])
+    apply (metis add.commute arith_simps(49) plus_minus_not_NULL_ab word_le_less_eq
+                 word_not_simps(1))
+   apply (frule_tac a=x in order.strict_trans2; fastforce simp: add.commute)
   apply clarsimp
-  apply (erule is_aligned_get_word_bits)
-   apply (erule(1) ps_clear_lookupAround2)
-     apply simp
-    apply (simp add: is_aligned_no_overflow)
-   apply (clarsimp simp add: magnitudeCheck_def in_monad
-                      split: option.split_asm)
-   apply simp
-  apply (simp add: power_overflow)
   done
 
-lemma in_magnitude_check3:
+lemma read_magnitude_check_simp[simp]:
+  assumes "is_aligned ptr bits"
+          "(1 :: machine_word) < 2 ^ bits"
+          "ksPSpace s ptr = Some y"
+  shows "read_magnitudeCheck ptr (snd (lookupAround2 ptr (ksPSpace s))) bits s = Some ()
+          = ps_clear ptr bits s"
+  using assms
+  apply (clarsimp simp: read_magnitudeCheck_def)
+  apply (rule iffI)
+   apply (clarsimp simp: lookupAround2_no_after_ps_clear lookupAround2_after_ps_clear omonad_defs
+                  split: option.splits if_split_asm)
+  apply (fastforce elim!: ps_clear_lookupAround2 is_aligned_no_overflow split: option.splits)
+  done
+
+lemma in_magnitude_check:
+  assumes "is_aligned ptr bits"
+          "(1 :: machine_word) < 2 ^ bits"
+          "ksPSpace s ptr = Some y"
+  shows "((v, s') \<in> fst (magnitudeCheck ptr (snd (lookupAround2 ptr (ksPSpace s))) bits s))
+          = (s' = s \<and> ps_clear ptr bits s)"
+  using assms
+  by (clarsimp simp: magnitudeCheck_def in_monad)
+
+lemma read_magnitude_check3[simp]:
   "\<lbrakk> \<forall>z. x < z \<and> z \<le> y \<longrightarrow> ksPSpace s z = None; is_aligned x n;
      (1 :: word32) < 2 ^ n; ksPSpace s x = Some v; x \<le> y; y - x < 2 ^ n \<rbrakk> \<Longrightarrow>
-   fst (magnitudeCheck x (snd (lookupAround2 y (ksPSpace s))) n s)
-     = (if ps_clear x n s then {((), s)} else {})"
-  apply (rule set_eqI, rule iffI)
-   apply (clarsimp simp: magnitudeCheck_def lookupAround2_char2
-                         lookupAround2_None2 in_monad
-                  split: option.split_asm)
+   read_magnitudeCheck x (snd (lookupAround2 y (ksPSpace s))) n s
+     = (if ps_clear x n s then Some () else None)"
+  apply (clarsimp simp: read_magnitudeCheck_def lookupAround2_char2
+                        lookupAround2_None2 in_monad
+                 split: option.splits)
+  apply safe
     apply (drule(1) range_convergence1)
     apply (erule(1) ps_clearI)
     apply simp
@@ -2206,73 +2574,70 @@ lemma cte_wp_at_cases':
              \<and> tcb_cte_cases n = Some (getF, setF) \<and> P (getF tcb) \<and> ps_clear (p - n) tcbBlockSizeBits s))"
   (is "?LHS = ?RHS")
   apply (rule iffI)
-   apply (clarsimp simp: cte_wp_at'_def split_def
-                         getObject_def bind_def simpler_gets_def
+   apply (clarsimp simp: cte_wp_at'_def gets_the_def readObject_def
+                         getObject_def bind_def simpler_gets_def omonad_defs
                          assert_opt_def return_def fail_def
-                  split: option.splits
+                  split: option.splits dest!: prod_injects
                     del: disjCI)
-   apply (clarsimp simp: loadObject_cte typeError_def alignError_def
+   apply (clarsimp simp: loadObject_cte read_typeError_def split_def
                          fail_def return_def objBits_simps'
-                         is_aligned_mask[symmetric] alignCheck_def
+                         is_aligned_mask[symmetric]
                          tcbVTableSlot_def field_simps tcbCTableSlot_def
-                         tcbReplySlot_def tcbCallerSlot_def
                          tcbIPCBufferSlot_def
-                         lookupAround2_char1
+                         tcbFaultHandlerSlot_def tcbTimeoutHandlerSlot_def
+                         lookupAround2_char1 omonad_defs
                          cte_level_bits_def Ball_def
                          unless_def when_def bind_def
                   split: kernel_object.splits if_split_asm option.splits
                     del: disjCI)
-        apply (subst(asm) in_magnitude_check3, simp+,
-               simp split: if_split_asm, (rule disjI2)?, intro exI, rule conjI,
-               erule rsubst[where P="\<lambda>x. ksPSpace s x = v" for s v],
-               fastforce simp add: field_simps, simp)+
-   apply (subst(asm) in_magnitude_check3, simp+)
-   apply (simp split: if_split_asm)
-  apply (simp add: cte_wp_at'_def getObject_def split_def
-                   bind_def simpler_gets_def return_def
-                   assert_opt_def fail_def objBits_simps'
+       apply ((rule disjI2)?, fastforce simp: field_simps elim: rsubst[where P="\<lambda>x. ksPSpace s x = v" for s v])+
+  apply (simp add: cte_wp_at'_def getObject_def split_def gets_the_def
+                   bind_def simpler_gets_def return_def readObject_def
+                   assert_opt_def fail_def objBits_simps' omonad_defs obind_def
             split: option.splits)
   apply (elim disjE conjE exE)
    apply (erule(1) ps_clear_lookupAround2)
      apply simp
     apply (simp add: field_simps)
     apply (erule is_aligned_no_wrap')
-     apply (simp add: cte_level_bits_def word_bits_conv)
-    apply (simp add: cte_level_bits_def)
+    apply (simp add: cte_level_bits_def word_bits_conv)
+   apply (simp add: cte_level_bits_def)
    apply (simp add: loadObject_cte unless_def alignCheck_def
                     is_aligned_mask[symmetric] objBits_simps'
-                    cte_level_bits_def magnitudeCheck_def
-                    return_def fail_def)
+                    cte_level_bits_def magnitudeCheck_def obind_def
+                    read_magnitudeCheck_def read_alignCheck_def
+                    omonad_defs return_def fail_def)
    apply (clarsimp simp: bind_def return_def when_def fail_def
                   split: option.splits)
    apply simp
   apply (erule(1) ps_clear_lookupAround2)
-    prefer 3
-    apply (simp add: loadObject_cte unless_def alignCheck_def
-                    is_aligned_mask[symmetric] objBits_simps'
-                    cte_level_bits_def magnitudeCheck_def
-                    return_def fail_def tcbCTableSlot_def tcbVTableSlot_def
-                    tcbIPCBufferSlot_def tcbReplySlot_def tcbCallerSlot_def
-                split: option.split_asm)
-     apply (clarsimp simp: bind_def tcb_cte_cases_def split: if_split_asm)
-    apply (clarsimp simp: bind_def tcb_cte_cases_def iffD2[OF linorder_not_less]
-                          return_def
-                   split: if_split_asm)
-   apply (subgoal_tac "p - n \<le> (p - n) + n", simp)
-   apply (erule is_aligned_no_wrap')
+    apply (subgoal_tac "p - n \<le> (p - n) + n", simp)
+    apply (erule is_aligned_no_wrap')
     apply (simp add: word_bits_conv)
-   apply (simp add: tcb_cte_cases_def split: if_split_asm)
-  apply (subgoal_tac "(p - n) + n \<le> (p - n) + 511")
-   apply (simp add: field_simps)
-  apply (rule word_plus_mono_right)
-   apply (simp add: tcb_cte_cases_def split: if_split_asm)
-  apply (erule is_aligned_no_wrap')
-  apply simp
+    apply (simp add: tcb_cte_cases_def split: if_split_asm)
+   apply (subgoal_tac "(p - n) + n \<le> (p - n) + 511")
+    apply (simp add: field_simps)
+   apply (rule word_plus_mono_right)
+    apply (simp add: tcb_cte_cases_def split: if_split_asm)
+   apply (erule is_aligned_no_wrap')
+   apply simp
+  apply (simp add: loadObject_cte unless_def alignCheck_def
+                   is_aligned_mask[symmetric] objBits_simps'
+                   cte_level_bits_def magnitudeCheck_def
+                   return_def fail_def tcbCTableSlot_def tcbVTableSlot_def
+                   tcbFaultHandlerSlot_def tcbTimeoutHandlerSlot_def
+                   tcbIPCBufferSlot_def omonad_defs obind_def
+                   read_magnitudeCheck_def read_alignCheck_def
+            split: option.split_asm)
+   apply (clarsimp simp: bind_def tcb_cte_cases_def split: if_split_asm)
+  apply (clarsimp simp: bind_def tcb_cte_cases_def iffD2[OF linorder_not_less]
+                        return_def
+                 split: if_split_asm)
   done
 
 lemma tcb_at_cte_at':
   "tcb_at' t s \<Longrightarrow> cte_at' t s"
-  apply (clarsimp simp add: cte_wp_at_cases' obj_at'_def projectKO_def
+  apply (clarsimp simp add: cte_wp_at_cases' obj_at'_def projectKO_def oassert_opt_def
                        del: disjCI)
   apply (case_tac ko)
    apply (simp_all add: projectKO_opt_tcb fail_def)
@@ -2354,76 +2735,65 @@ lemma locateSlot_conv:
     x \<leftarrow> stateAssert (\<lambda>s. case (gsCNodes s A) of None \<Rightarrow> False | Some n \<Rightarrow> n = bits \<and> B < 2 ^ n) [];
     locateSlotBasic A B od)"
   "locateSlotCap c B = (do
-    x \<leftarrow> stateAssert (\<lambda>s. ((isCNodeCap c \<or> (isZombie c \<and> capZombieType c \<noteq> ZombieTCB))
-            \<and> (case gsCNodes s (capUntypedPtr c) of None \<Rightarrow> False
+    x \<leftarrow> stateAssert (\<lambda>s.
+            (
+             (isCNodeCap c
+              \<or> (isZombie c \<and> capZombieType c \<noteq> ZombieTCB))
+             \<and> (case gsCNodes s (capUntypedPtr c) of
+                  None \<Rightarrow> False
                 | Some n \<Rightarrow> (isCNodeCap c \<and> n = capCNodeBits c
-                    \<or> isZombie c \<and> n = zombieCTEBits (capZombieType c)) \<and> B < 2 ^ n))
-        \<or> isThreadCap c \<or> (isZombie c \<and> capZombieType c = ZombieTCB)) [];
+                             \<or> isZombie c \<and> n = zombieCTEBits (capZombieType c)) \<and> B < 2 ^ n)
+            )
+            \<or> isThreadCap c
+            \<or> (isZombie c \<and> capZombieType c = ZombieTCB)) [];
     locateSlotBasic (capUntypedPtr c) B od)"
   apply (simp_all add: locateSlotCap_def locateSlotTCB_def fun_eq_iff)
     apply (simp add: locateSlotBasic_def objBits_simps cte_level_bits_def objBits_defs)
    apply (simp add: locateSlotCNode_def stateAssert_def)
-  apply (cases c, simp_all add: locateSlotCNode_def isZombie_def isThreadCap_def
-                                isCNodeCap_def capUntypedPtr_def stateAssert_def
-                                bind_assoc exec_get locateSlotTCB_def
-                                objBits_simps'
-                           split: zombie_type.split
-                           cong: option.case_cong)
-  done
+  apply (cases c; simp)
+  by (auto simp: locateSlotCNode_def isZombie_def isThreadCap_def
+                 isCNodeCap_def capUntypedPtr_def stateAssert_def
+                 bind_assoc exec_get locateSlotTCB_def assert_def
+                 objBits_simps'
+          split: zombie_type.split option.split)
+
+context
+begin
+
+private method typ_at_proof =
+  unfold obj_at'_real_def typ_at'_def ko_wp_at'_def,
+  (rule ext)+,
+  (rule iffI; clarsimp, case_tac ko; clarsimp simp: projectKO_opts_defs)
 
 lemma typ_at_tcb':
   "typ_at' TCBT = tcb_at'"
-  apply (rule ext)+
-  apply (simp add: obj_at'_real_def typ_at'_def)
-  apply (simp add: ko_wp_at'_def)
-  apply (rule iffI)
-   apply clarsimp
-   apply (case_tac ko)
-   apply (auto simp: projectKO_opt_tcb)[9]
-  apply (case_tac ko)
-  apply (auto simp: projectKO_opt_tcb)
-  done
+  by typ_at_proof
 
-lemma typ_at_ep:
+lemma typ_at_ep:  (* FIXME: rename to ' *)
   "typ_at' EndpointT = ep_at'"
-  apply (rule ext)+
-  apply (simp add: obj_at'_real_def typ_at'_def)
-  apply (simp add: ko_wp_at'_def)
-  apply (rule iffI)
-   apply clarsimp
-   apply (case_tac ko)
-   apply (auto simp: projectKO_opt_ep)[9]
-  apply (case_tac ko)
-  apply (auto simp: projectKO_opt_ep)
-  done
+  by typ_at_proof
 
-lemma typ_at_ntfn:
+lemma typ_at_ntfn: (* FIXME: rename to ' *)
   "typ_at' NotificationT = ntfn_at'"
-  apply (rule ext)+
-  apply (simp add: obj_at'_real_def typ_at'_def)
-  apply (simp add: ko_wp_at'_def)
-  apply (rule iffI)
-   apply clarsimp
-   apply (case_tac ko)
-   apply (auto simp: projectKO_opt_ntfn)[8]
-  apply clarsimp
-  apply (case_tac ko)
-  apply (auto simp: projectKO_opt_ntfn)
-  done
+  by typ_at_proof
 
-lemma typ_at_cte:
+lemma typ_at_cte: (* FIXME: rename to ' *)
   "typ_at' CTET = real_cte_at'"
-  apply (rule ext)+
-  apply (simp add: obj_at'_real_def typ_at'_def)
-  apply (simp add: ko_wp_at'_def)
-  apply (rule iffI)
-   apply clarsimp
-   apply (case_tac ko)
-   apply (auto simp: projectKO_opt_cte)[8]
-  apply clarsimp
-  apply (case_tac ko)
-  apply (auto simp: projectKO_opt_cte)
-  done
+  by typ_at_proof
+
+lemma typ_at_reply':
+  "typ_at' ReplyT = reply_at'"
+  by typ_at_proof
+
+lemma typ_at_sc':
+  "typ_at' SchedContextT = sc_at'"
+  by typ_at_proof
+
+lemmas typ_ats' = typ_at_sc' typ_at_reply' typ_at_cte typ_at_ntfn typ_at_ep typ_at_tcb'
+
+end
+
+
 
 lemma cte_at_typ':
   "cte_at' c = (\<lambda>s. typ_at' CTET c s \<or> (\<exists>n. typ_at' TCBT (c - n) s \<and> n \<in> dom tcb_cte_cases))"
@@ -2434,58 +2804,213 @@ proof -
   have Q: "\<And>P f. (\<exists>x. (\<exists>y. x = f y) \<and> P x) = (\<exists>y. P (f y))"
     by fastforce
   show ?thesis
-    by (fastforce simp: cte_wp_at_cases' obj_at'_real_def typ_at'_def
+    by (fastforce simp: cte_wp_at_cases' obj_at'_real_def typ_at'_def word_bits_def
                         ko_wp_at'_def objBits_simps' P Q conj_comms cte_level_bits_def)
 qed
 
-lemma typ_at_lift_tcb':
-  "\<lbrace>typ_at' TCBT p\<rbrace> f \<lbrace>\<lambda>_. typ_at' TCBT p\<rbrace> \<Longrightarrow> \<lbrace>tcb_at' p\<rbrace> f \<lbrace>\<lambda>_. tcb_at' p\<rbrace>"
+lemma typ_at_lift_tcb'_strong:
+  "f \<lbrace>\<lambda>s. P (typ_at' TCBT p s)\<rbrace> \<Longrightarrow> f \<lbrace>\<lambda>s. P (tcb_at' p s)\<rbrace>"
   by (simp add: typ_at_tcb')
 
-lemma typ_at_lift_ep':
-  "\<lbrace>typ_at' EndpointT p\<rbrace> f \<lbrace>\<lambda>_. typ_at' EndpointT p\<rbrace> \<Longrightarrow> \<lbrace>ep_at' p\<rbrace> f \<lbrace>\<lambda>_. ep_at' p\<rbrace>"
+lemma typ_at_lift_ep'_strong:
+  "f \<lbrace>\<lambda>s. P (typ_at' EndpointT p s)\<rbrace> \<Longrightarrow> f \<lbrace>\<lambda>s. P (ep_at' p s)\<rbrace>"
   by (simp add: typ_at_ep)
 
-lemma typ_at_lift_ntfn':
-  "\<lbrace>typ_at' NotificationT p\<rbrace> f \<lbrace>\<lambda>_. typ_at' NotificationT p\<rbrace> \<Longrightarrow> \<lbrace>ntfn_at' p\<rbrace> f \<lbrace>\<lambda>_. ntfn_at' p\<rbrace>"
+lemma typ_at_lift_ntfn'_strong:
+  "f \<lbrace>\<lambda>s. P (typ_at' NotificationT p s)\<rbrace> \<Longrightarrow> f \<lbrace>\<lambda>s. P (ntfn_at' p s)\<rbrace>"
   by (simp add: typ_at_ntfn)
 
-lemma typ_at_lift_cte':
-  "\<lbrace>typ_at' CTET p\<rbrace> f \<lbrace>\<lambda>_. typ_at' CTET p\<rbrace> \<Longrightarrow> \<lbrace>real_cte_at' p\<rbrace> f \<lbrace>\<lambda>_. real_cte_at' p\<rbrace>"
+lemma typ_at_lift_cte'_strong:
+  "f \<lbrace>\<lambda>s. P (typ_at' CTET p s)\<rbrace> \<Longrightarrow> f \<lbrace>\<lambda>s. P (real_cte_at' p s)\<rbrace>"
   by (simp add: typ_at_cte)
 
+lemma typ_at_lift_sc'_strong:
+  "f \<lbrace>\<lambda>s. P (typ_at' SchedContextT p s)\<rbrace> \<Longrightarrow> f \<lbrace>\<lambda>s. P (sc_at' p s)\<rbrace>"
+  by (simp add: typ_ats')
+
+lemma typ_at_lift_reply'_strong:
+  "f \<lbrace>\<lambda>s. P (typ_at' ReplyT p s)\<rbrace> \<Longrightarrow> f \<lbrace>\<lambda>s. P (reply_at' p s)\<rbrace>"
+  by (simp add: typ_ats')
+
 lemma typ_at_lift_cte_at':
-  assumes x: "\<And>T p. \<lbrace>typ_at' T p\<rbrace> f \<lbrace>\<lambda>rv. typ_at' T p\<rbrace>"
-  shows      "\<lbrace>cte_at' c\<rbrace> f \<lbrace>\<lambda>rv. cte_at' c\<rbrace>"
+  assumes x: "\<And>P T p. f \<lbrace>\<lambda>s. P (typ_at' T p s)\<rbrace>"
+  shows      "f \<lbrace>\<lambda>s. P (cte_at' c s)\<rbrace>"
   apply (simp only: cte_at_typ')
-  apply (wp hoare_vcg_disj_lift hoare_vcg_ex_lift x)
+  apply (rule P_bool_lift[where P=P])
+   apply (wpsimp wp: hoare_vcg_disj_lift hoare_vcg_ex_lift hoare_vcg_all_lift x)+
   done
 
-lemma typ_at_lift_page_directory_at':
-  assumes x: "\<And>T p. \<lbrace>typ_at' T p\<rbrace> f \<lbrace>\<lambda>rv. typ_at' T p\<rbrace>"
-  shows      "\<lbrace>page_directory_at' p\<rbrace> f \<lbrace>\<lambda>rv. page_directory_at' p\<rbrace>"
+lemma typ_at_lift_page_directory_at'_strong:
+  assumes x: "\<And>p. f \<lbrace>\<lambda>s. P (typ_at' (ArchT PDET) p s)\<rbrace>"
+  shows      "f \<lbrace>\<lambda>s. P (page_directory_at' p s)\<rbrace>"
   unfolding page_directory_at'_def All_less_Ball
-  by (wp hoare_vcg_const_Ball_lift x)
+  using x
+  apply -
+  apply (rule P_bool_lift[where P=P])
+  apply (wpsimp wp: hoare_vcg_const_Ball_lift hoare_vcg_bex_lift hoare_vcg_imp_lift
+         | fastforce)+
+  done
 
-lemma typ_at_lift_page_table_at':
-  assumes x: "\<And>T p. \<lbrace>typ_at' T p\<rbrace> f \<lbrace>\<lambda>rv. typ_at' T p\<rbrace>"
-  shows      "\<lbrace>page_table_at' p\<rbrace> f \<lbrace>\<lambda>rv. page_table_at' p\<rbrace>"
+lemma typ_at_lift_page_table_at'_strong:
+  assumes x: "\<And>p. f \<lbrace>\<lambda>s. P (typ_at' (ArchT PTET) p s)\<rbrace>"
+  shows      "f \<lbrace>\<lambda>s. P (page_table_at' p s)\<rbrace>"
   unfolding page_table_at'_def All_less_Ball
-  by (wp hoare_vcg_const_Ball_lift x)
+  using x
+  apply -
+  apply (rule P_bool_lift[where P=P])
+  apply (wpsimp wp: hoare_vcg_const_Ball_lift hoare_vcg_bex_lift hoare_vcg_imp_lift
+         | fastforce)+
+  done
+
+lemma typ_at_lift_valid_tcb_state'_strong:
+  assumes ep: "\<And>p. f \<lbrace>\<lambda>s. P (typ_at' EndpointT p s)\<rbrace>"
+      and reply: "\<And>p. f \<lbrace>\<lambda>s. P (typ_at' ReplyT p s)\<rbrace>"
+      and ntfn: "\<And>p. f \<lbrace>\<lambda>s. P (typ_at' NotificationT p s)\<rbrace>"
+  shows "f \<lbrace>\<lambda>s. P (valid_tcb_state' st s)\<rbrace>"
+  unfolding valid_tcb_state'_def valid_bound_reply'_def
+  apply (case_tac st
+         ; clarsimp split: option.splits
+         , wpsimp wp: hoare_vcg_imp_lift' hoare_vcg_all_lift hoare_vcg_conj_lift_N[where N=P]
+                           typ_at_lift_ep'_strong[OF ep] typ_at_lift_reply'_strong[OF reply]
+                           typ_at_lift_ntfn'_strong[OF ntfn])
+  done
+
+lemmas typ_at_lifts_strong =
+  typ_at_lift_tcb'_strong typ_at_lift_ep'_strong
+  typ_at_lift_ntfn'_strong typ_at_lift_cte'_strong
+  typ_at_lift_reply'_strong typ_at_lift_sc'_strong
+  typ_at_lift_page_directory_at'_strong
+  typ_at_lift_valid_tcb_state'_strong
+  typ_at_lift_page_table_at'_strong
 
 lemma ko_wp_typ_at':
   "ko_wp_at' P p s \<Longrightarrow> \<exists>T. typ_at' T p s"
   by (clarsimp simp: typ_at'_def ko_wp_at'_def)
 
 lemma koType_obj_range':
-  "koTypeOf k = koTypeOf k' \<Longrightarrow> obj_range' p k = obj_range' p k'"
+  "koTypeOf k = koTypeOf k' \<Longrightarrow> koTypeOf k = SchedContextT \<longrightarrow> objBitsKO k = objBitsKO k' \<Longrightarrow> obj_range' p k = obj_range' p k'"
   apply (rule ccontr)
   apply (simp add: obj_range'_def objBitsKO_def archObjSize_def
             split: kernel_object.splits arch_kernel_object.splits)
   done
 
+lemma typ_at_lift_valid_irq_node':
+  assumes P: "\<And>P T p. \<lbrace>\<lambda>s. P (typ_at' T p s)\<rbrace> f \<lbrace>\<lambda>rv s. P (typ_at' T p s)\<rbrace>"
+  shows      "\<lbrace>valid_irq_node' p\<rbrace> f \<lbrace>\<lambda>_. valid_irq_node' p\<rbrace>"
+  apply (simp add: valid_irq_node'_def)
+  apply (wp hoare_vcg_all_lift P typ_at_lifts_strong)
+  done
+
+lemma valid_pde_lift':
+  assumes x: "\<And>T p. \<lbrace>typ_at' T p\<rbrace> f \<lbrace>\<lambda>rv. typ_at' T p\<rbrace>"
+  shows "\<lbrace>\<lambda>s. valid_pde' pde s\<rbrace> f \<lbrace>\<lambda>rv s. valid_pde' pde s\<rbrace>"
+  by (cases pde) (simp add: valid_mapping'_def|wp x typ_at_lifts_strong[where P=id])+
+
+lemma valid_pte_lift':
+  assumes x: "\<And>T p. \<lbrace>typ_at' T p\<rbrace> f \<lbrace>\<lambda>rv. typ_at' T p\<rbrace>"
+  shows "\<lbrace>\<lambda>s. valid_pte' pte s\<rbrace> f \<lbrace>\<lambda>rv s. valid_pte' pte s\<rbrace>"
+  by (cases pte) (simp add: valid_mapping'_def|wp x typ_at_lifts_strong[where P=id])+
+
+lemma valid_asid_pool_lift':
+  assumes x: "\<And>T p. \<lbrace>typ_at' T p\<rbrace> f \<lbrace>\<lambda>rv. typ_at' T p\<rbrace>"
+  shows "\<lbrace>\<lambda>s. valid_asid_pool' ap s\<rbrace> f \<lbrace>\<lambda>rv s. valid_asid_pool' ap s\<rbrace>"
+  by (cases ap) (simp|wp x typ_at_lifts_strong[where P=id] hoare_vcg_const_Ball_lift)+
+
+lemma valid_dom_schedule'_lift:
+  assumes dsi: "\<And>Q. \<lbrace>\<lambda>s. Q (ksDomScheduleIdx s)\<rbrace> f \<lbrace>\<lambda>rv s. Q (ksDomScheduleIdx s)\<rbrace>"
+  assumes ds: "\<And>Q. \<lbrace>\<lambda>s. Q (ksDomSchedule s)\<rbrace> f \<lbrace>\<lambda>rv s. Q (ksDomSchedule s)\<rbrace>"
+    shows "\<lbrace>\<lambda>s. valid_dom_schedule' s\<rbrace> f \<lbrace>\<lambda>rv. valid_dom_schedule'\<rbrace>"
+   unfolding valid_dom_schedule'_def
+   by (wpsimp wp: dsi ds)
+
+lemma valid_bound_tcb_lift:
+  "(\<And>T p. f \<lbrace>typ_at' T p\<rbrace>) \<Longrightarrow> f \<lbrace>valid_bound_tcb' tcb\<rbrace>"
+  by (auto simp: valid_bound_tcb'_def valid_def typ_ats'[symmetric] split: option.splits)
+
+lemma valid_bound_sc_lift:
+  "(\<And>T p. f \<lbrace>typ_at' T p\<rbrace>) \<Longrightarrow> f \<lbrace>valid_bound_sc' tcb\<rbrace>"
+  by (auto simp: valid_bound_obj'_def valid_def typ_ats'[symmetric] split: option.splits)
+
+lemma valid_bound_reply_lift:
+  "(\<And>T p. f \<lbrace>typ_at' T p\<rbrace>) \<Longrightarrow> f \<lbrace>valid_bound_reply' tcb\<rbrace>"
+  by (auto simp: valid_bound_tcb'_def valid_def typ_ats'[symmetric] split: option.splits)
+
+lemma valid_bound_ntfn_lift:
+  "(\<And>T p. f \<lbrace>typ_at' T p\<rbrace>) \<Longrightarrow> f \<lbrace>valid_bound_ntfn' ntfn\<rbrace>"
+  by (auto simp: valid_bound_obj'_def valid_def typ_ats'[symmetric] split: option.splits)
+
+lemma valid_ntfn_lift':
+  "(\<And>T p. f \<lbrace>typ_at' T p\<rbrace>) \<Longrightarrow> f \<lbrace>valid_ntfn' ntfn\<rbrace>"
+  unfolding valid_ntfn'_def
+  apply (cases "ntfnObj ntfn"; clarsimp)
+    apply (wpsimp wp: valid_bound_tcb_lift valid_bound_sc_lift)
+   apply (wpsimp wp: valid_bound_tcb_lift valid_bound_sc_lift)
+  apply (wpsimp wp: hoare_vcg_ball_lift typ_at_lift_tcb'_strong[where P=id, simplified])
+   apply (wpsimp wp: valid_bound_tcb_lift valid_bound_sc_lift)
+  apply simp
+  done
+
+lemma valid_sc_lift':
+  "(\<And>T p. f \<lbrace>typ_at' T p\<rbrace>) \<Longrightarrow> f \<lbrace>valid_sched_context' sc\<rbrace>"
+  unfolding valid_sched_context'_def
+  by (wpsimp wp: valid_bound_ntfn_lift valid_bound_tcb_lift valid_bound_reply_lift)
+
+context begin
+\<comment>\<open>
+  We're using @{command ML_goal} here because there are two useful formulations
+  of typ_at lifting lemmas and we do not want to write all of the possibilities
+  out by hand. If we use typ_at_lift_tcb' as an example, then the first is
+  @{term "\<lbrace>\<lambda>s. P (typ_at' TCBT p s)\<rbrace> f \<lbrace>\<lambda>_ s. P (typ_at' TCBT p s)\<rbrace>
+          \<Longrightarrow> \<lbrace>\<lambda>s. P (tcb_at' p s)\<rbrace> f \<lbrace>\<lambda>_ s. P (tcb_at' p s)\<rbrace>"} and the second is
+  @{term "(\<And>P. \<lbrace>\<lambda>s. P (typ_at' TCBT p s)\<rbrace> f \<lbrace>\<lambda>_ s. P (typ_at' TCBT p s)\<rbrace>)
+          \<Longrightarrow> \<lbrace>\<lambda>s. P (tcb_at' p s)\<rbrace> f \<lbrace>\<lambda>_ s. P (tcb_at' p s)\<rbrace>"}.
+  The first form is stronger, and therefore preferred for backward reasoning
+  using rule. However, since the P in the premise is free in the first form,
+  forward unification using the OF attribute produces flex-flex pairs which
+  causes problems. The second form avoids the unification issue by demanding
+  that there is a P that is free in the lemma supplied to the OF attribute.
+  However, it can only be applied if @{term f} preserves both
+  @{term "typ_at' TCBT p s"} and @{term "\<not> typ_at' TCBT p s"}.
+  The following @{command ML_goal} generates lemmas of the second form based on
+  the previously proven stronger lemmas of the first form.
+\<close>
+ML \<open>
+local
+  val strong_thms = @{thms typ_at_lifts_strong[no_vars]};
+  fun abstract_P term = Logic.all (Free ("P", @{typ "bool \<Rightarrow> bool"})) term
+  fun abstract thm =
+    let
+      val prems = List.map abstract_P (Thm.prems_of thm);
+      fun imp [] = Thm.concl_of thm
+        | imp (p :: pms) = @{const Pure.imp} $ p $ imp pms
+    in
+      imp prems
+    end
+in
+  val typ_at_lifts_internal_goals = List.map abstract strong_thms
+end
+\<close>
+
+private ML_goal typ_at_lifts_internal:
+  \<open>typ_at_lifts_internal_goals\<close>
+  by (auto simp: typ_at_lifts_strong)
+
+lemmas typ_at_lifts = typ_at_lifts_internal
+                      typ_at_lift_cte_at'
+                      valid_pde_lift'
+                      valid_pte_lift'
+                      valid_asid_pool_lift'
+                      valid_bound_tcb_lift
+                      valid_bound_reply_lift
+                      valid_bound_sc_lift
+                      valid_bound_ntfn_lift
+                      valid_ntfn_lift'
+                      valid_sc_lift'
+end
+
 lemma typ_at_lift_valid_untyped':
   assumes P: "\<And>T p. \<lbrace>\<lambda>s. \<not>typ_at' T p s\<rbrace> f \<lbrace>\<lambda>rv s. \<not>typ_at' T p s\<rbrace>"
+  assumes sz: "\<And>p n. \<lbrace>\<lambda>s. sc_at'_n n p s\<rbrace> f \<lbrace>\<lambda>rv s. sc_at'_n n p s\<rbrace>"
   shows "\<lbrace>\<lambda>s. valid_untyped' d p n idx s\<rbrace> f \<lbrace>\<lambda>rv s. valid_untyped' d p n idx s\<rbrace>"
   apply (clarsimp simp: valid_untyped'_def split del:if_split)
   apply (rule hoare_vcg_all_lift)
@@ -2502,81 +3027,112 @@ lemma typ_at_lift_valid_untyped':
   apply (clarsimp simp: typ_at'_def ko_wp_at'_def simp del:atLeastAtMost_iff)
   apply (elim disjE)
     apply (clarsimp simp:psubset_eq simp del:atLeastAtMost_iff)
-    apply (drule_tac p=ptr' in koType_obj_range')
-    apply (erule impE)
-    apply simp
+   apply (frule_tac p=ptr' in koType_obj_range', clarsimp)
+    apply (fastforce simp: ko_wp_at'_def dest!: use_valid [OF _ sz])
    apply simp
-  apply (drule_tac p = ptr' in koType_obj_range')
-  apply (clarsimp split:if_splits)
+  apply (frule_tac p = ptr' in koType_obj_range', clarsimp)
+   apply (fastforce simp: ko_wp_at'_def dest!: use_valid [OF _ sz])
+  apply simp
   done
 
-lemma typ_at_lift_asid_at':
-  "(\<And>T p. \<lbrace>typ_at' T p\<rbrace> f \<lbrace>\<lambda>_. typ_at' T p\<rbrace>) \<Longrightarrow> \<lbrace>asid_pool_at' p\<rbrace> f \<lbrace>\<lambda>_. asid_pool_at' p\<rbrace>"
-  by assumption
-
 lemma typ_at_lift_valid_cap':
   assumes P: "\<And>P T p. \<lbrace>\<lambda>s. P (typ_at' T p s)\<rbrace> f \<lbrace>\<lambda>rv s. P (typ_at' T p s)\<rbrace>"
+  assumes sz: "\<And>p n. \<lbrace>\<lambda>s. sc_at'_n n p s\<rbrace> f \<lbrace>\<lambda>rv s. sc_at'_n n p s\<rbrace>"
   shows      "\<lbrace>\<lambda>s. valid_cap' cap s\<rbrace> f \<lbrace>\<lambda>rv s. valid_cap' cap s\<rbrace>"
   including no_pre
   apply (simp add: valid_cap'_def)
   apply wp
   apply (case_tac cap;
-         simp add: valid_cap'_def P [where P=id, simplified] typ_at_lift_tcb'
-                   hoare_vcg_prop typ_at_lift_ep'
-                   typ_at_lift_ntfn' typ_at_lift_cte_at'
-                   hoare_vcg_conj_lift [OF typ_at_lift_cte_at'])
+         wpsimp wp: valid_cap'_def P typ_at_lifts_strong
+                    hoare_vcg_prop  typ_at_lift_cte_at'
+                    hoare_vcg_conj_lift [OF typ_at_lift_cte_at']
+                    hoare_vcg_conj_lift)
      apply (rename_tac zombie_type nat)
      apply (case_tac zombie_type; simp)
-      apply (wp typ_at_lift_tcb' P hoare_vcg_all_lift typ_at_lift_cte')+
+      apply (wp typ_at_lifts_strong[where P=id, simplified] P
+                hoare_vcg_all_lift)+
     apply (rename_tac arch_capability)
     apply (case_tac arch_capability,
            simp_all add: P [where P=id, simplified] page_table_at'_def
                          hoare_vcg_prop page_directory_at'_def All_less_Ball
               split del: if_split)
-       apply (wp hoare_vcg_const_Ball_lift P typ_at_lift_valid_untyped'
-                 hoare_vcg_all_lift typ_at_lift_cte')+
+       apply (wp hoare_vcg_const_Ball_lift P typ_at_lift_valid_untyped' sz
+                 hoare_vcg_all_lift typ_at_lifts_strong)+
   done
 
-
-lemma typ_at_lift_valid_irq_node':
+lemma typ_at'_valid_obj'_lift:
   assumes P: "\<And>P T p. \<lbrace>\<lambda>s. P (typ_at' T p s)\<rbrace> f \<lbrace>\<lambda>rv s. P (typ_at' T p s)\<rbrace>"
-  shows      "\<lbrace>valid_irq_node' p\<rbrace> f \<lbrace>\<lambda>_. valid_irq_node' p\<rbrace>"
-  apply (simp add: valid_irq_node'_def)
-  apply (wp hoare_vcg_all_lift P typ_at_lift_cte')
+  assumes sz: "\<And>n p. \<lbrace>\<lambda>s. sc_at'_n n p s\<rbrace> f \<lbrace>\<lambda>rv s. sc_at'_n n p s\<rbrace>"
+  notes [wp] = hoare_vcg_all_lift hoare_vcg_imp_lift' hoare_vcg_const_Ball_lift
+               typ_at_lifts[OF P] typ_at_lift_valid_cap'[OF P]
+  shows      "\<lbrace>\<lambda>s. valid_obj' obj s\<rbrace> f \<lbrace>\<lambda>rv s. valid_obj' obj s\<rbrace>"
+  apply (cases obj; simp add: valid_obj'_def hoare_TrueI)
+        apply (rename_tac endpoint)
+        apply (case_tac endpoint; simp add: valid_ep'_def, wp)
+       apply (rename_tac notification)
+       apply (case_tac "ntfnObj notification";
+               simp add: valid_ntfn'_def split: option.splits;
+               (wpsimp|rule conjI)+)
+      apply (rename_tac tcb)
+      apply (case_tac "tcbState tcb";
+             simp add: valid_tcb'_def valid_tcb_state'_def split_def;
+             wpsimp wp: sz)
+     apply (wpsimp simp: valid_cte'_def sz)
+    apply (rename_tac arch_kernel_object)
+    apply (case_tac arch_kernel_object; wpsimp wp: sz)
+   apply wpsimp
+  apply (wpsimp simp: valid_reply'_def)
   done
 
-lemma valid_pde_lift':
-  assumes x: "\<And>T p. \<lbrace>typ_at' T p\<rbrace> f \<lbrace>\<lambda>rv. typ_at' T p\<rbrace>"
-  shows "\<lbrace>\<lambda>s. valid_pde' pde s\<rbrace> f \<lbrace>\<lambda>rv s. valid_pde' pde s\<rbrace>"
-  by (cases pde) (simp add: valid_mapping'_def|wp x typ_at_lift_page_table_at')+
+lemma typ_at'_valid_sched_context'_lift:
+  assumes P: "\<And>P T p. \<lbrace>\<lambda>s. P (typ_at' T p s)\<rbrace> f \<lbrace>\<lambda>rv s. P (typ_at' T p s)\<rbrace>"
+  assumes sz: "\<And>n p. \<lbrace>\<lambda>s. sc_at'_n n p s\<rbrace> f \<lbrace>\<lambda>rv s. sc_at'_n n p s\<rbrace>"
+  notes [wp] = hoare_vcg_all_lift hoare_vcg_imp_lift' hoare_vcg_const_Ball_lift
+               typ_at_lifts[OF P] typ_at_lift_valid_cap'[OF P]
+  shows      "\<lbrace>\<lambda>s. valid_sched_context' ko s\<rbrace> f \<lbrace>\<lambda>rv s. valid_sched_context' ko s\<rbrace>"
+  by (wpsimp simp: valid_sched_context'_def)
+
+lemmas typ_at_sc_at'_n_lifts =
+  typ_at_lift_valid_untyped' typ_at_lift_valid_cap' typ_at'_valid_obj'_lift
+  typ_at'_valid_obj'_lift[where obj="KOEndpoint ko" for ko, simplified valid_obj'_def kernel_object.case]
+  typ_at'_valid_obj'_lift[where obj="KONotification ko" for ko, simplified valid_obj'_def kernel_object.case]
+  typ_at'_valid_obj'_lift[where obj="KOTCB ko" for ko, simplified valid_obj'_def kernel_object.case]
+  typ_at'_valid_obj'_lift[where obj="KOCTE ko" for ko, simplified valid_obj'_def kernel_object.case]
+  typ_at'_valid_obj'_lift[where obj="KOArch ko" for ko, simplified valid_obj'_def kernel_object.case]
+  typ_at'_valid_obj'_lift[where obj="KOReply ko" for ko, simplified valid_obj'_def kernel_object.case]
+  typ_at'_valid_sched_context'_lift
+
+lemmas typ_at_lifts_all = typ_at_lifts typ_at_sc_at'_n_lifts
 
-lemma valid_pte_lift':
-  assumes x: "\<And>T p. \<lbrace>typ_at' T p\<rbrace> f \<lbrace>\<lambda>rv. typ_at' T p\<rbrace>"
-  shows "\<lbrace>\<lambda>s. valid_pte' pte s\<rbrace> f \<lbrace>\<lambda>rv s. valid_pte' pte s\<rbrace>"
-  by (cases pte) (simp add: valid_mapping'_def|wp x typ_at_lift_page_directory_at')+
+end
 
-lemma valid_asid_pool_lift':
-  assumes x: "\<And>T p. \<lbrace>typ_at' T p\<rbrace> f \<lbrace>\<lambda>rv. typ_at' T p\<rbrace>"
-  shows "\<lbrace>\<lambda>s. valid_asid_pool' ap s\<rbrace> f \<lbrace>\<lambda>rv s. valid_asid_pool' ap s\<rbrace>"
-  by (cases ap) (simp|wp x typ_at_lift_page_directory_at' hoare_vcg_const_Ball_lift)+
+locale typ_at_props' =
+  fixes f :: "'a kernel"
+  assumes typ': "f \<lbrace>\<lambda>s. P (typ_at' T p' s)\<rbrace>"
+begin
 
-lemma valid_bound_tcb_lift:
-  "(\<And>T p. \<lbrace>typ_at' T p\<rbrace> f \<lbrace>\<lambda>_. typ_at' T p\<rbrace>) \<Longrightarrow>
-  \<lbrace>valid_bound_tcb' tcb\<rbrace> f \<lbrace>\<lambda>_. valid_bound_tcb' tcb\<rbrace>"
-  by (auto simp: valid_bound_tcb'_def valid_def typ_at_tcb'[symmetric] split: option.splits)
+lemmas typ_at_lifts'[wp] = typ_at_lifts[REPEAT [OF typ']]
 
-lemmas typ_at_lifts = typ_at_lift_tcb' typ_at_lift_ep'
-                      typ_at_lift_ntfn' typ_at_lift_cte'
-                      typ_at_lift_cte_at'
-                      typ_at_lift_page_table_at'
-                      typ_at_lift_page_directory_at'
-                      typ_at_lift_asid_at'
-                      typ_at_lift_valid_untyped'
-                      typ_at_lift_valid_cap'
-                      valid_pde_lift'
-                      valid_pte_lift'
-                      valid_asid_pool_lift'
-                      valid_bound_tcb_lift
+end
+
+locale typ_at_all_props' = typ_at_props' +
+  assumes scs: "f \<lbrace>\<lambda>s. Q (sc_at'_n n p s)\<rbrace>"
+begin
+
+lemmas typ_at_sc_at'_n_lifts'[wp] = typ_at_sc_at'_n_lifts[OF typ' scs]
+
+context begin
+(* We want to enforce that typ_at_sc_at'_n_lifts' only contains lemmas that have no
+   assumptions. The following thm statements should fail if this is not true. *)
+private lemmas check_valid_internal = iffD1[OF refl, where P="valid p g q" for p g q]
+thm typ_at_lifts'[atomized, THEN check_valid_internal]
+thm typ_at_sc_at'_n_lifts'[atomized, THEN check_valid_internal]
+end
+
+end
+
+(* we expect typ_at' and sc_at'_n lemmas to be [wp], so this should be easy: *)
+method typ_at_props' = unfold_locales; wp?
 
 lemma mdb_next_unfold:
   "s \<turnstile> c \<leadsto> c' = (\<exists>z. s c = Some z \<and> c' = mdbNext (cteMDBNode z))"
@@ -3071,6 +3673,7 @@ lemma ex_cte_cap_to'_pres:
    apply assumption
   apply simp
   done
+
 context begin interpretation Arch . (*FIXME: arch_split*)
 lemma page_directory_pde_atI':
   "\<lbrakk> page_directory_at' p s; x < 2 ^ pageBits \<rbrakk> \<Longrightarrow> pde_at' (p + (x << 2)) s"
@@ -3278,26 +3906,10 @@ lemma objBitsT_simps:
   unfolding objBitsT_def makeObjectT_def
   by (simp_all add: makeObject_simps objBits_simps archObjSize_def pteBits_def pdeBits_def)
 
-lemma objBitsT_koTypeOf :
-  "(objBitsT (koTypeOf ko)) = objBitsKO ko"
-  apply (cases ko; simp add: objBits_simps objBitsT_simps)
-  apply (rename_tac arch_kernel_object)
-  apply (case_tac arch_kernel_object; simp add: archObjSize_def objBitsT_simps
-                                                pteBits_def pdeBits_def)
-  done
-
 lemma valid_queues_obj_at'D:
    "\<lbrakk> t \<in> set (ksReadyQueues s (d, p)); valid_queues s \<rbrakk>
         \<Longrightarrow> obj_at' (inQ d p) t s"
-  apply (unfold valid_queues_def valid_queues_no_bitmap_def)
-  apply (elim conjE)
-  apply (drule_tac x=d in spec)
-  apply (drule_tac x=p in spec)
-  apply (clarsimp)
-  apply (drule(1) bspec)
-  apply (erule obj_at'_weakenE)
-  apply (clarsimp)
-  done
+  by (fastforce simp: valid_queues_def valid_queues_no_bitmap_def)
 
 lemma obj_at'_and:
   "obj_at' (P and P') t s = (obj_at' P t s \<and> obj_at' P' t s)"

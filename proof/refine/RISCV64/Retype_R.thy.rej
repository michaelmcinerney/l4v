--- Retype_R.thy
+++ Retype_R.thy
@@ -18,11 +18,13 @@ definition
   APIType_map2 :: "kernel_object + ARM_H.object_type \<Rightarrow> Structures_A.apiobject_type"
 where
  "APIType_map2 ty \<equiv> case ty of
-      Inr (APIObjectType ArchTypes_H.Untyped) \<Rightarrow> Structures_A.Untyped
-    | Inr (APIObjectType ArchTypes_H.TCBObject) \<Rightarrow> Structures_A.TCBObject
-    | Inr (APIObjectType ArchTypes_H.EndpointObject) \<Rightarrow> Structures_A.EndpointObject
-    | Inr (APIObjectType ArchTypes_H.NotificationObject) \<Rightarrow> Structures_A.NotificationObject
-    | Inr (APIObjectType ArchTypes_H.CapTableObject) \<Rightarrow> Structures_A.CapTableObject
+      Inr (APIObjectType Untyped) \<Rightarrow> Structures_A.Untyped
+    | Inr (APIObjectType TCBObject) \<Rightarrow> Structures_A.TCBObject
+    | Inr (APIObjectType EndpointObject) \<Rightarrow> Structures_A.EndpointObject
+    | Inr (APIObjectType NotificationObject) \<Rightarrow> Structures_A.NotificationObject
+    | Inr (APIObjectType CapTableObject) \<Rightarrow> Structures_A.CapTableObject
+    | Inr (APIObjectType ReplyObject) \<Rightarrow> Structures_A.ReplyObject
+    | Inr (APIObjectType SchedContextObject) \<Rightarrow> Structures_A.SchedContextObject
     | Inr PageTableObject \<Rightarrow> ArchObject PageTableObj
     | Inr PageDirectoryObject \<Rightarrow> ArchObject PageDirectoryObj
     | Inr LargePageObject \<Rightarrow> ArchObject LargePageObj
@@ -54,22 +56,19 @@ lemma createObjects_ret:
                         shiftl_t2n power_add)
   done
 
-lemma objBitsKO_bounded2[simp]:
-  "objBitsKO ko < word_bits"
-  by (simp add: objBits_simps' word_bits_def pageBits_def archObjSize_def pdeBits_def pteBits_def
-           split: Structures_H.kernel_object.split arch_kernel_object.split)
-
 declare select_singleton_is_return[simp]
 
 definition
   APIType_capBits :: "ARM_H.object_type \<Rightarrow> nat \<Rightarrow> nat"
 where
   "APIType_capBits ty us \<equiv> case ty of
-      APIObjectType ArchTypes_H.Untyped \<Rightarrow> us
-    | APIObjectType ArchTypes_H.TCBObject \<Rightarrow> objBits (makeObject :: tcb)
-    | APIObjectType ArchTypes_H.EndpointObject \<Rightarrow> objBits (makeObject :: endpoint)
-    | APIObjectType ArchTypes_H.NotificationObject \<Rightarrow> objBits (makeObject :: Structures_H.notification)
-    | APIObjectType ArchTypes_H.CapTableObject \<Rightarrow> objBits (makeObject :: cte) + us
+      APIObjectType Untyped \<Rightarrow> us
+    | APIObjectType TCBObject \<Rightarrow> objBits (makeObject :: tcb)
+    | APIObjectType EndpointObject \<Rightarrow> objBits (makeObject :: endpoint)
+    | APIObjectType NotificationObject \<Rightarrow> objBits (makeObject :: notification)
+    | APIObjectType ReplyObject \<Rightarrow> objBits (makeObject :: reply)
+    | APIObjectType CapTableObject \<Rightarrow> objBits (makeObject :: cte) + us
+    | APIObjectType SchedContextObject \<Rightarrow> us
     | SmallPageObject \<Rightarrow> pageBitsForSize ARMSmallPage
     | LargePageObject \<Rightarrow> pageBitsForSize ARMLargePage
     | SectionObject \<Rightarrow> pageBitsForSize ARMSection
@@ -78,15 +77,19 @@ where
     | PageDirectoryObject \<Rightarrow> 14"
 
 definition
-  makeObjectKO :: "bool \<Rightarrow> (kernel_object + ARM_H.object_type) \<rightharpoonup> kernel_object"
+  makeObjectKO :: "bool \<Rightarrow> nat \<Rightarrow> domain \<Rightarrow> (kernel_object + ARM_H.object_type) \<rightharpoonup> kernel_object"
 where
-  "makeObjectKO dev ty \<equiv> case ty of
+  "makeObjectKO dev us d ty \<equiv> case ty of
       Inl KOUserData \<Rightarrow> Some KOUserData
     | Inl (KOArch (KOASIDPool _)) \<Rightarrow> Some (KOArch (KOASIDPool makeObject))
-    | Inr (APIObjectType ArchTypes_H.TCBObject) \<Rightarrow> Some (KOTCB makeObject)
+    | Inr (APIObjectType ArchTypes_H.TCBObject) \<Rightarrow> Some (KOTCB (tcbDomain_update (\<lambda>_. d) makeObject))
     | Inr (APIObjectType ArchTypes_H.EndpointObject) \<Rightarrow> Some (KOEndpoint makeObject)
     | Inr (APIObjectType ArchTypes_H.NotificationObject) \<Rightarrow> Some (KONotification makeObject)
     | Inr (APIObjectType ArchTypes_H.CapTableObject) \<Rightarrow> Some (KOCTE makeObject)
+    | Inr (APIObjectType ArchTypes_H.ReplyObject) \<Rightarrow> Some (KOReply makeObject)
+    | Inr (APIObjectType ArchTypes_H.SchedContextObject) \<Rightarrow>
+                Some (KOSchedContext (scRefills_update
+                   (\<lambda>_. replicate (refillAbsoluteMax' us) emptyRefill) makeObject))
     | Inr PageTableObject \<Rightarrow> Some (KOArch (KOPTE makeObject))
     | Inr PageDirectoryObject \<Rightarrow> Some (KOArch (KOPDE makeObject))
     | Inr SmallPageObject \<Rightarrow> Some (if dev then KOUserDataDevice else KOUserData)
@@ -175,6 +209,7 @@ lemma valid_obj_makeObject_asid_pool[simp]:
 lemmas valid_obj_makeObject_rules =
   valid_obj_makeObject_user_data valid_obj_makeObject_tcb
   valid_obj_makeObject_endpoint valid_obj_makeObject_notification
+  valid_obj_makeObject_reply valid_obj_makeObject_sched_context
   valid_obj_makeObject_cte valid_obj_makeObject_pte valid_obj_makeObject_pde
   valid_obj_makeObject_asid_pool valid_obj_makeObject_user_data_device
 
@@ -543,13 +577,14 @@ lemma cte_wp_at_retype':
      apply (simp only: cte_wp_at_obj_cases_mask foldr_update_obj_at'[OF pv pv' al])
      apply (simp    add: projectKOs the_ctes_makeObject
                          makeObjectKO_eq [OF ko]
-                         makeObject_cte dom_def
+                         makeObject_cte
               split del: if_split
                    cong: if_cong)
      apply (insert al ko)
-     apply (simp, safe, simp_all)
-      apply fastforce
-     apply fastforce
+     apply simp
+     apply (safe; simp)
+              apply ((fastforce simp: makeObjectKO_def makeObject_cte makeObject_tcb tcb_cte_cases_def
+                              split: if_split_asm)+)[10]
     apply (clarsimp elim!: obj_atE' simp: projectKOs objBits_simps)
     apply (drule ps_clearD[where y=p and n=tcbBlockSizeBits])
        apply simp
@@ -848,18 +893,20 @@ lemma obj_relation_retype_addrs_eq:
    apply (rule power_strict_increasing)
    apply (rule le_less_trans[OF diff_le_self])
   apply (clarsimp simp: range_cover_def obj_bits_api_default_object obj_bits_dev_irr
-                        not_unt word_bits_def)+
-done
+                        not_unt word_bits_def tysc)+
+  done
 
 lemma objBits_le_obj_bits_api:
-  "makeObjectKO dev ty = Some ko \<Longrightarrow>
+  "ty = Inr (APIObjectType SchedContextObject) \<longrightarrow> min_sched_context_bits \<le> us \<Longrightarrow>
+   makeObjectKO dev us d ty = Some ko \<Longrightarrow>
    objBitsKO ko \<le> obj_bits_api (APIType_map2 ty) us"
   apply (case_tac ty)
-    apply (auto simp: default_arch_object_def pageBits_def archObjSize_def pteBits_def pdeBits_def
-                      makeObjectKO_def objBits_simps' APIType_map2_def obj_bits_api_def slot_bits_def
-               split: Structures_H.kernel_object.splits arch_kernel_object.splits object_type.splits
-                      Structures_H.kernel_object.splits arch_kernel_object.splits apiobject_type.splits)
-  done
+    by (auto simp: default_arch_object_def pageBits_def archObjSize_def pteBits_def pdeBits_def
+                   makeObjectKO_def objBits_simps' APIType_map2_def obj_bits_api_def slot_bits_def
+                   scBits_simps
+            split: Structures_H.kernel_object.splits arch_kernel_object.splits object_type.splits
+                   Structures_H.kernel_object.splits arch_kernel_object.splits apiobject_type.splits
+                   if_split_asm)
 
 lemma obj_relation_retype_other_obj:
   "\<lbrakk> is_other_obj_relation_type (a_type ko); other_obj_relation ko ko' \<rbrakk>
@@ -1012,79 +1095,6 @@ lemma foldr_upd_app_if': "foldr (\<lambda>p ps. ps(p := f p)) as g = (\<lambda>x
   apply simp
   done
 
-lemma etcb_rel_makeObject: "etcb_relation default_etcb makeObject"
-  apply (simp add: etcb_relation_def default_etcb_def)
-  apply (simp add: makeObject_tcb default_priority_def default_domain_def)
-  done
-
-
-lemma ekh_at_tcb_at: "valid_etcbs_2 ekh kh \<Longrightarrow> ekh x = Some y  \<Longrightarrow> \<exists>tcb. kh x = Some (TCB tcb)"
-  apply (simp add: valid_etcbs_2_def
-                   st_tcb_at_kh_def obj_at_kh_def
-                   is_etcb_at'_def obj_at_def)
-  apply force
-  done
-
-lemma default_etcb_default_domain_futz [simp]:
-  "default_etcb\<lparr>tcb_domain := default_domain\<rparr> = default_etcb"
-unfolding default_etcb_def by simp
-
-lemma retype_ekheap_relation:
-  assumes  sr: "ekheap_relation (ekheap s) (ksPSpace s')"
-      and  sr': "pspace_relation (kheap s) (ksPSpace s')"
-      and  vs: "valid_pspace s" "valid_mdb s"
-      and et: "valid_etcbs s"
-      and vs': "pspace_aligned' s'" "pspace_distinct' s'"
-      and  pn: "pspace_no_overlap_range_cover ptr sz s"
-      and pn': "pspace_no_overlap' ptr sz s'"
-      and  ko: "makeObjectKO dev ty = Some ko"
-      and cover: "range_cover ptr sz (obj_bits_api (APIType_map2 ty) us) n"
-      and orr: "obj_relation_retype (default_object (APIType_map2 ty) dev us) ko"
-      and num_r: "m = 2 ^ (obj_bits_api (APIType_map2 ty) us - objBitsKO ko) * n"
-  shows
-  "ekheap_relation (foldr (\<lambda>p ps. ps(p := default_ext (APIType_map2 ty) default_domain))
-                              (retype_addrs ptr (APIType_map2 ty) n us) (ekheap s))
-            (foldr (\<lambda>addr. data_map_insert addr ko) (new_cap_addrs m ptr ko) (ksPSpace s'))"
-  (is "ekheap_relation ?ps ?ps'")
-  proof -
-  have not_unt: "ty \<noteq> Inr (APIObjectType ArchTypes_H.Untyped)"
-     by (rule makeObjectKO_Untyped[OF ko])
-  show ?thesis
-    apply (case_tac "ty \<noteq> Inr (APIObjectType apiobject_type.TCBObject)")
-     apply (insert ko)
-     apply (cut_tac retype_pspace_relation[OF sr' vs vs' pn pn' ko cover orr num_r])
-     apply (simp add: foldr_upd_app_if' foldr_upd_app_if[folded data_map_insert_def])
-     apply (simp add: obj_relation_retype_addrs_eq[OF not_unt num_r orr cover,symmetric])
-     apply (insert sr)
-     apply (clarsimp simp add: ekheap_relation_def
-                      pspace_relation_def default_ext_def cong: if_cong
-                      split: if_split_asm)
-      subgoal by (clarsimp simp add: makeObjectKO_def APIType_map2_def cong: if_cong
-                              split: sum.splits Structures_H.kernel_object.splits
-                                     arch_kernel_object.splits ARM_H.object_type.splits apiobject_type.splits)
-
-     apply (frule ekh_at_tcb_at[OF et])
-     apply (intro impI conjI)
-      apply clarsimp
-      apply (drule_tac x=a in bspec,force)
-      apply (clarsimp simp add: other_obj_relation_def split: if_split_asm)
-       apply (case_tac ko,simp_all)
-       apply (clarsimp simp add: makeObjectKO_def cong: if_cong split: sum.splits Structures_H.kernel_object.splits
-                                 arch_kernel_object.splits ARM_H.object_type.splits
-                                 apiobject_type.splits if_split_asm)
-      apply (drule_tac x=xa in bspec,simp)
-      subgoal by force
-     subgoal by force
-    apply (simp add: foldr_upd_app_if' foldr_upd_app_if[folded data_map_insert_def])
-    apply (simp add: obj_relation_retype_addrs_eq[OF not_unt num_r orr cover,symmetric])
-    apply (clarsimp simp add: APIType_map2_def default_ext_def ekheap_relation_def
-           default_object_def makeObjectKO_def etcb_rel_makeObject
-           cong: if_cong
-           split: if_split_asm)
-    apply force
-  done
-qed
-
 lemma pspace_no_overlapD':
   "\<lbrakk> ksPSpace s x = Some ko; pspace_no_overlap' p bits s \<rbrakk>
        \<Longrightarrow> {x .. x + 2 ^ objBitsKO ko - 1} \<inter> {p .. (p && ~~ mask bits) + 2 ^ bits - 1} = {}"
@@ -1633,237 +1795,45 @@ lemma retype_state_relation:
                                   else cns x" in exI, simp)
       apply (rule_tac x=id in exI, simp)+
     done
-qed
-
-lemma new_cap_addrs_fold':
-  "1 \<le> n \<Longrightarrow>
-   map (\<lambda>n. ptr + (n << objBitsKO ko)) [0.e.n - 1] =
-   new_cap_addrs (unat n) ptr ko"
- by (clarsimp simp:new_cap_addrs_def ptr_add_def upto_enum_red'
-           shiftl_t2n power_add field_simps)
-
-lemma objBitsKO_gt_0: "0 < objBitsKO ko"
-  apply (case_tac ko)
-        apply (simp_all add: objBits_simps' pageBits_def)
-  apply (rename_tac arch_kernel_object)
-  apply (case_tac arch_kernel_object)
-    apply (simp_all add:archObjSize_def pageBits_def pteBits_def pdeBits_def)
-  done
-
-lemma kheap_ekheap_double_gets: "(\<And>rv erv rv'. pspace_relation rv rv' \<Longrightarrow> ekheap_relation erv rv' \<Longrightarrow> corres r (R rv erv) (R' rv') (b rv erv) (d rv')) \<Longrightarrow>
-corres r (\<lambda>s. R (kheap s) (ekheap s) s) (\<lambda>s. R' (ksPSpace s) s) (do x \<leftarrow> gets kheap; xa \<leftarrow> gets ekheap; b x xa od) (gets ksPSpace >>= d)"
-  apply (rule corres_symb_exec_l)
-     apply (rule corres_guard_imp)
-       apply (rule_tac r'= "\<lambda>erv rv'. ekheap_relation erv rv' \<and> pspace_relation x rv'" in corres_split_deprecated)
-          apply clarsimp
-          apply assumption
-         apply (subst corres_gets[where P="\<lambda>s. x = kheap s" and P'=\<top>])
-         apply clarsimp
-         apply (simp add: state_relation_def)
-        apply (wp gets_exs_valid | simp)+
-  done
-
-(*
-
-Split out the extended operation that sets the etcb domains.
-
-This allows the existing corres proofs in this file to more-or-less go
-through as they stand.
-
-A more principled fix would be to change the abstract spec and
-generalise init_arch_objects to initialise other object types.
-
-*)
-
-definition retype_region2_ext :: "obj_ref list \<Rightarrow> Structures_A.apiobject_type \<Rightarrow> unit det_ext_monad" where
-  "retype_region2_ext ptrs type \<equiv> modify (\<lambda>s. ekheap_update (foldr (\<lambda>p ekh. (ekh(p := default_ext type default_domain))) ptrs) s)"
-
-crunch all_but_exst[wp]: retype_region2_ext "all_but_exst P"
-crunch (empty_fail) empty_fail[wp]: retype_region2_ext
-
-end
-
-interpretation retype_region2_ext_extended: is_extended "retype_region2_ext ptrs type"
-  by (unfold_locales; wp)
-
-context begin interpretation Arch . (*FIXME: arch_split*)
-
-definition
- "retype_region2_extra_ext ptrs type \<equiv>
-     when (type = Structures_A.TCBObject) (do
-       cdom \<leftarrow> gets cur_domain;
-       mapM_x (ethread_set (\<lambda>tcb. tcb\<lparr>tcb_domain := cdom\<rparr>)) ptrs
-      od)"
-
-crunch all_but_exst[wp]: retype_region2_extra_ext "all_but_exst P" (wp: mapM_x_wp)
-crunch (empty_fail) empty_fail[wp]: retype_region2_extra_ext (wp: mapM_x_wp)
-
-end
-
-interpretation retype_region2_extra_ext_extended: is_extended "retype_region2_extra_ext ptrs type"
-  by (unfold_locales; wp)
-
-context begin interpretation Arch . (*FIXME: arch_split*)
-
-definition
-  retype_region2 :: "obj_ref \<Rightarrow> nat \<Rightarrow> nat \<Rightarrow> Structures_A.apiobject_type \<Rightarrow> bool \<Rightarrow> (obj_ref list,'z::state_ext) s_monad"
-where
-  "retype_region2 ptr numObjects o_bits type dev \<equiv> do
-    obj_size \<leftarrow> return $ 2 ^ obj_bits_api type o_bits;
-    ptrs \<leftarrow> return $ map (\<lambda>p. ptr_add ptr (p * obj_size)) [0..< numObjects];
-    when (type \<noteq> Structures_A.Untyped) (do
-      kh \<leftarrow> gets kheap;
-      kh' \<leftarrow> return $ foldr (\<lambda>p kh. kh(p \<mapsto> default_object type dev o_bits)) ptrs kh;
-      do_extended_op (retype_region2_ext ptrs type);
-      modify $ kheap_update (K kh')
-    od);
-    return $ ptrs
-  od"
-
-lemma retype_region_ext_modify_kheap_futz:
-  "(retype_region2_extra_ext ptrs type :: (unit, det_ext) s_monad) >>= (\<lambda>_. modify (kheap_update f))
- = (modify (kheap_update f) >>= (\<lambda>_. retype_region2_extra_ext ptrs type))"
-  apply (clarsimp simp: retype_region_ext_def retype_region2_ext_def retype_region2_extra_ext_def when_def bind_assoc)
-  apply (subst oblivious_modify_swap)
-   defer
-   apply (simp add: bind_assoc)
-  apply (rule oblivious_bind)
-  apply simp
-  apply (rule oblivious_mapM_x)
-  apply (clarsimp simp: ethread_set_def set_eobject_def)
-  apply (rule oblivious_bind)
-   apply (simp add: gets_the_def)
-   apply (rule oblivious_bind)
-    apply (clarsimp simp: get_etcb_def)
-    apply simp
-   apply (simp add: modify_def[symmetric])
-done
 
-lemmas retype_region_ext_modify_kheap_futz' =
-  fun_cong[OF arg_cong[where f=NonDetMonad.bind,
-           OF retype_region_ext_modify_kheap_futz[symmetric]], simplified bind_assoc]
-
-lemma foldr_upd_app_if_eta_futz:
-  "foldr (\<lambda>p ps. ps(p \<mapsto> f p)) as = (\<lambda>g x. if x \<in> set as then Some (f x) else g x)"
-apply (rule ext)
-apply (rule foldr_upd_app_if)
-done
+  have scr: "sc_replies_relation s s'"
+    using sr by (simp add: state_relation_def)
 
-lemma modify_ekheap_update_comp_futz:
-  "modify (ekheap_update (f \<circ> g)) = modify (ekheap_update g) >>= (K (modify (ekheap_update f)))"
-by (simp add: o_def modify_def bind_def gets_def get_def put_def)
-
-lemma mapM_x_modify_futz:
-  assumes "\<forall>ptr\<in>set ptrs. ekheap s ptr \<noteq> None"
-  shows "mapM_x (ethread_set F) (rev ptrs) s
-       = modify (ekheap_update (foldr (\<lambda>p ekh. ekh(p := Some (F (the (ekh p))))) ptrs)) s" (is "?lhs ptrs s = ?rhs ptrs s")
-using assms
-proof(induct ptrs arbitrary: s)
-  case Nil thus ?case by (simp add: mapM_x_Nil return_def simpler_modify_def)
-next
-  case (Cons ptr ptrs s)
-  have "?rhs (ptr # ptrs) s
-      = (do modify (ekheap_update (foldr (\<lambda>p ekh. ekh(p \<mapsto> F (the (ekh p)))) ptrs));
-            modify (ekheap_update (\<lambda>ekh. ekh(ptr \<mapsto> F (the (ekh ptr)))))
-        od) s"
-    by (simp only: foldr_Cons modify_ekheap_update_comp_futz) simp
-  also have "... = (do ?lhs ptrs;
-                      modify (ekheap_update (\<lambda>ekh. ekh(ptr \<mapsto> F (the (ekh ptr)))))
-                    od) s"
-    apply (rule monad_eq_split_tail)
-     apply simp
-    apply (rule Cons.hyps[symmetric])
-    using Cons.prems
-    apply force
-    done
-  also have "... = ?lhs (ptr # ptrs) s"
-    apply (simp add: mapM_x_append mapM_x_singleton)
-    apply (rule monad_eq_split2[OF refl, where
-                 P="\<lambda>s. \<forall>ptr\<in>set (ptr # ptrs). ekheap s ptr \<noteq> None"
-             and Q="\<lambda>_ s. ekheap s ptr \<noteq> None"])
-      apply (simp add: ethread_set_def
-                       assert_opt_def get_etcb_def gets_the_def gets_def get_def modify_def put_def set_eobject_def
-                       bind_def fail_def return_def split_def
-                split: option.splits)
-     apply ((wp mapM_x_wp[OF _ subset_refl] | simp add: ethread_set_def set_eobject_def)+)[1]
-    using Cons.prems
-    apply force
-    done
-  finally show ?case by (rule sym)
+  thus
+    "sc_replies_relation_2 (sc_replies_of_kh ?ps) (?ps' |> sc_of' |> scReply)
+                                                     (?ps' |> reply_of' |> replyPrev)"
+    using retype_sc_replies_relation [OF _ pspr vs vs' pn pn' ko tysc cover orr num_r]
+    by clarsimp
 qed
 
-lemma awkward_fold_futz:
-  "fold (\<lambda>p ekh. ekh(p \<mapsto> the (ekh p)\<lparr>tcb_domain := cur_domain s\<rparr>)) ptrs ekh
- = (\<lambda>x. if x \<in> set ptrs then Some ((the (ekh x))\<lparr>tcb_domain := cur_domain s\<rparr>) else ekh x)"
-by (induct ptrs arbitrary: ekh) (simp_all add: fun_eq_iff)
-
-lemma retype_region2_ext_retype_region_ext_futz:
-  "retype_region2_ext ptrs type >>= (\<lambda>_. retype_region2_extra_ext ptrs type)
- = retype_region_ext ptrs type"
-proof(cases type)
-  case TCBObject
-  have complete_futz:
-    "\<And>F x. modify (ekheap_update (\<lambda>_. F (cur_domain x) (ekheap x))) x = modify (ekheap_update (\<lambda>ekh. F (cur_domain x) ekh)) x"
-    by (simp add: modify_def get_def get_etcb_def put_def bind_def return_def)
-  have second_futz:
-  "\<And>f G.
-   do modify (ekheap_update f);
-      cdom \<leftarrow> gets (\<lambda>s. cur_domain s);
-      G cdom
-   od =
-   do cdom \<leftarrow> gets (\<lambda>s. cur_domain s);
-      modify (ekheap_update f);
-      G cdom
-   od"
-    by (simp add: bind_def gets_def get_def return_def simpler_modify_def)
-  from TCBObject show ?thesis
-    apply (clarsimp simp: retype_region_ext_def retype_region2_ext_def retype_region2_extra_ext_def when_def bind_assoc)
-    apply (clarsimp simp: exec_gets fun_eq_iff)
-    apply (subst complete_futz)
-    apply (simp add: second_futz[simplified] exec_gets)
-    apply (simp add: default_ext_def exec_modify)
-    apply (subst mapM_x_modify_futz[where ptrs="rev ptrs", simplified])
-     apply (simp add: foldr_upd_app_if_eta_futz)
-    apply (simp add: modify_def exec_get put_def o_def)
-    apply (simp add: foldr_upd_app_if_eta_futz foldr_conv_fold awkward_fold_futz)
-    apply (simp cong: if_cong)
-    done
-qed (auto simp: fun_eq_iff retype_region_ext_def retype_region2_ext_def retype_region2_extra_ext_def
-                put_def gets_def get_def bind_def return_def mk_ef_def modify_def foldr_upd_app_if' when_def default_ext_def)
-
-lemma retype_region2_ext_retype_region:
-  "(retype_region ptr numObjects o_bits type dev :: (obj_ref list, det_ext) s_monad)
- = (do ptrs \<leftarrow> retype_region2 ptr numObjects o_bits type dev;
-       retype_region2_extra_ext ptrs type;
-       return ptrs
-    od)"
-apply (clarsimp simp: retype_region_def retype_region2_def when_def bind_assoc)
- apply safe
- defer
- apply (simp add: retype_region2_extra_ext_def)
-apply (subst retype_region_ext_modify_kheap_futz'[simplified bind_assoc])
-apply (subst retype_region2_ext_retype_region_ext_futz[symmetric])
-apply (simp add: bind_assoc)
-done
+lemma new_cap_addrs_fold':
+  "1 \<le> n \<Longrightarrow> map (\<lambda>n. ptr + (n << objBitsKO ko)) [0.e.n - 1] = new_cap_addrs (unat n) ptr ko"
+  by (clarsimp simp: new_cap_addrs_def ptr_add_def upto_enum_red' shiftl_t2n power_add field_simps)
+
+lemma objBitsKO_gt_0: "0 < (objBitsKO ko)"
+  apply (case_tac ko; simp add: objBits_simps' pageBits_def scBits_pos')
+  apply (rename_tac arch_kernel_object)
+  by (case_tac arch_kernel_object; simp add: archObjSize_def pageBits_def pteBits_def pdeBits_def)
 
 lemma getObject_tcb_gets:
   "getObject addr >>= (\<lambda>x::tcb. gets proj >>= (\<lambda>y. G x y))
- = gets proj >>= (\<lambda>y. getObject addr >>= (\<lambda>x. G x y))"
-by (auto simp: exec_gets fun_eq_iff intro: bind_apply_cong dest!: in_inv_by_hoareD[OF getObject_inv_tcb])
+   = gets proj >>= (\<lambda>y. getObject addr >>= (\<lambda>x. G x y))"
+  by (auto simp: exec_gets fun_eq_iff intro: bind_apply_cong
+           dest!: in_inv_by_hoareD[OF getObject_tcb_inv])
 
 lemma setObject_tcb_gets_ksCurDomain:
   "setObject addr (tcb::tcb) >>= (\<lambda>_. gets ksCurDomain >>= G)
- = gets ksCurDomain >>= (\<lambda>x. setObject addr tcb >>= (\<lambda>_. G x))"
-apply (clarsimp simp: exec_gets fun_eq_iff)
-apply (rule bind_apply_cong)
- apply simp
-apply (drule_tac P1="\<lambda>cdom. cdom = ksCurDomain x" in use_valid[OF _ setObject_cd_inv])
-apply (simp_all add: exec_gets)
-done
+   = gets ksCurDomain >>= (\<lambda>x. setObject addr tcb >>= (\<lambda>_. G x))"
+  apply (clarsimp simp: exec_gets fun_eq_iff)
+  apply (rule bind_apply_cong)
+   apply simp
+  apply (drule_tac P1="\<lambda>cdom. cdom = ksCurDomain x" in use_valid[OF _ setObject_cd_inv])
+   apply (simp_all add: exec_gets)
+  done
 
 lemma curDomain_mapM_x_futz:
   "curDomain >>= (\<lambda>cdom. mapM_x (threadSet (F cdom)) addrs)
- = mapM_x (\<lambda>addr. curDomain >>= (\<lambda>cdom. threadSet (F cdom) addr)) addrs"
+   = mapM_x (\<lambda>addr. curDomain >>= (\<lambda>cdom. threadSet (F cdom) addr)) addrs"
 proof(induct addrs)
   case Nil thus ?case
     by (simp add: curDomain_def mapM_x_def sequence_x_def bind_def gets_def get_def return_def)
@@ -1888,55 +1858,42 @@ next
     done
 qed
 
-(*
-
-The existing proof continues below.
-
-*)
-
-lemma modify_ekheap_update_ekheap:
-  "modify (\<lambda>s. ekheap_update f s) = do s \<leftarrow> gets ekheap; modify (\<lambda>s'. s'\<lparr>ekheap := f s\<rparr>) od"
-by (simp add: modify_def gets_def get_def put_def bind_def return_def split_def fun_eq_iff)
-
 lemma corres_retype':
   assumes    not_zero: "n \<noteq> 0"
   and         aligned: "is_aligned ptr (objBitsKO ko + gbits)"
-  and    obj_bits_api: "obj_bits_api (APIType_map2 ty) us =
-                        objBitsKO ko + gbits"
-  and           check: "(sz < obj_bits_api (APIType_map2 ty)  us)
-                           = (sz < objBitsKO ko + gbits)"
-  and             usv: "APIType_map2 ty = Structures_A.CapTableObject \<Longrightarrow> 0 < us"
-  and              ko: "makeObjectKO dev ty = Some ko"
+  and    obj_bits_api: "obj_bits_api (APIType_map2 ty) us = objBitsKO ko + gbits"
+  and           check: "(sz < obj_bits_api (APIType_map2 ty)  us) = (sz < objBitsKO ko + gbits)"
+  and              ko: "makeObjectKO dev us d ty = Some ko"
+  and            tysc: "ty = Inr (APIObjectType SchedContextObject) \<longrightarrow> min_sched_context_bits \<le> us"
   and             orr: "obj_bits_api (APIType_map2 ty) us \<le> sz \<Longrightarrow>
-                        obj_relation_retype
-                          (default_object (APIType_map2 ty) dev us) ko"
+                        obj_relation_retype (default_object (APIType_map2 ty) dev us d) ko"
   and           cover: "range_cover ptr sz (obj_bits_api (APIType_map2 ty) us) n"
   shows "corres (\<lambda>rv rv'. rv' = g rv)
-  (\<lambda>s. valid_pspace s \<and> pspace_no_overlap_range_cover ptr sz s
-     \<and> valid_mdb s \<and> valid_etcbs s \<and> valid_list s)
-  (\<lambda>s. pspace_aligned' s \<and> pspace_distinct' s \<and> pspace_no_overlap' ptr sz s)
-  (retype_region2 ptr n us (APIType_map2 ty) dev)
-  (do addrs \<leftarrow> createObjects ptr n ko gbits;
-      _ \<leftarrow> modify (update_gs (APIType_map2 ty) us (set addrs));
-      return (g addrs) od)"
+                (\<lambda>s. valid_pspace s \<and> pspace_no_overlap_range_cover ptr sz s
+                     \<and> valid_mdb s \<and> valid_list s)
+                (\<lambda>s. pspace_aligned' s \<and> pspace_distinct' s \<and> pspace_no_overlap' ptr sz s
+                      \<and> (ty = Inr (APIObjectType TCBObject) \<longrightarrow> d = ksCurDomain s))
+                (retype_region ptr n us (APIType_map2 ty) dev)
+                (do addrs \<leftarrow> createObjects ptr n ko gbits;
+                    _ \<leftarrow> modify (update_gs (APIType_map2 ty) us (set addrs));
+                    return (g addrs)
+                 od)"
   (is "corres ?r ?P ?P' ?C ?A")
 proof -
   note data_map_insert_def[simp del]
-  have not_zero':"((of_nat n)::word32) \<noteq> 0"
+  have not_zero':"(of_nat n::machine_word) \<noteq> 0"
     by (rule range_cover_not_zero[OF not_zero cover])
-  have shiftr_not_zero:" ((of_nat n)::word32) << gbits \<noteq> 0"
+  have shiftr_not_zero:" (of_nat n::machine_word) << gbits \<noteq> 0"
     apply (rule range_cover_not_zero_shift[OF not_zero cover])
     apply (simp add:obj_bits_api)
     done
-  have unat_of_nat_shift:"unat (((of_nat n)::word32) << gbits) =
-                          (n * 2^ gbits)"
+  have unat_of_nat_shift:"unat ((of_nat n::machine_word) << gbits) = n * 2^ gbits"
     apply (rule range_cover.unat_of_nat_n_shift[OF cover])
     using obj_bits_api
     apply simp
     done
   have unat_of_nat_shift':
-    "unat (((of_nat n)::word32) * 2^(gbits + objBitsKO ko)) =
-     n * 2^(gbits + objBitsKO ko)"
+    "unat ((of_nat n::machine_word) * 2^(gbits + objBitsKO ko)) = n * 2^(gbits + objBitsKO ko)"
     apply (subst mult.commute)
     apply (simp add:shiftl_t2n[symmetric])
     apply (rule range_cover.unat_of_nat_n_shift[OF cover])
@@ -1944,33 +1901,30 @@ proof -
     apply simp
     done
   have unat_of_nat_n':
-    "unat (((of_nat n)::word32) * 2 ^ (gbits + objBitsKO ko)) \<noteq> 0"
+    "unat (((of_nat n)::machine_word) * 2 ^ (gbits + objBitsKO ko)) \<noteq> 0"
     by (simp add:unat_of_nat_shift' not_zero)
   have bound:"obj_bits_api (APIType_map2 ty) us \<le> sz"
     using cover
     by (simp add:range_cover_def)
   have n_estimate: "n < 2 ^ (word_bits - (objBitsKO ko + gbits))"
     apply (rule le_less_trans)
-    apply (rule range_cover.range_cover_n_le(2)[OF cover])
+     apply (rule range_cover.range_cover_n_le(2)[OF cover])
     apply (rule power_strict_increasing)
-    apply (simp add:obj_bits_api ko)
-    apply (rule diff_less_mono)
+     apply (simp add:obj_bits_api ko)
+     apply (rule diff_less_mono)
     using cover obj_bits_api
-    apply (simp_all add:range_cover_def ko word_bits_def)
+      apply (simp_all add:range_cover_def ko word_bits_def)
     done
 
   have set_retype_addrs_fold:
-    "image (\<lambda>n. ptr + 2 ^ obj_bits_api (APIType_map2 ty) us * n)
-           {x. x \<le> of_nat n - 1} =
+    "image (\<lambda>n. ptr + 2 ^ obj_bits_api (APIType_map2 ty) us * n) {x. x \<le> of_nat n - 1} =
      set (retype_addrs ptr (APIType_map2 ty) n us)"
     including no_take_bit
-    apply (clarsimp simp: retype_addrs_def image_def Bex_def ptr_add_def
-                          Collect_eq)
+    apply (clarsimp simp: retype_addrs_def image_def Bex_def ptr_add_def Collect_eq)
     apply (rule iffI)
      apply (clarsimp simp: field_simps word_le_nat_alt)
      apply (rule_tac x="unat x" in exI)
-     apply (simp add: unat_sub_if_size range_cover.unat_of_nat_n[OF cover]
-                      not_le not_zero
+     apply (simp add: unat_sub_if_size range_cover.unat_of_nat_n[OF cover] not_le not_zero
                split: if_split_asm)
     apply (clarsimp simp: field_simps word_le_nat_alt)
     apply (rule_tac x="of_nat x" in exI)
@@ -2006,80 +1960,92 @@ proof -
         split del: if_split)
   apply (subst retype_addrs_fold)+
   apply (subst if_P)
-   using ko
-   apply (clarsimp simp: makeObjectKO_def)
-  apply (simp add: bind_assoc retype_region2_ext_def)
-  apply (rule corres_guard_imp)
-    apply (subst modify_ekheap_update_ekheap)
-    apply (simp only: bind_assoc)
-    apply (rule kheap_ekheap_double_gets)
-    apply (rule corres_symb_exec_r)
-       apply (simp add: not_less modify_modify bind_assoc[symmetric]
-                          obj_bits_api[symmetric] shiftl_t2n upto_enum_red'
+    using ko
+    apply (clarsimp simp: makeObjectKO_def)
+   apply (simp add: bind_assoc)
+   apply (rule corres_guard_imp)
+     apply (rule_tac r'=pspace_relation in corres_split')
+        apply (clarsimp dest!: state_relation_pspace_relation)
+       apply (simp add: gets_def)
+       apply (rule corres_symb_exec_l[rotated])
+          apply (rule exs_valid_get)
+         apply (rule get_sp)
+        apply (simp add: get_def no_fail_def)
+       apply (rule corres_symb_exec_r)
+          apply (simp add: not_less modify_modify bind_assoc[symmetric]
+                           obj_bits_api[symmetric] shiftl_t2n upto_enum_red'
                            range_cover.unat_of_nat_n[OF cover])
-       apply (rule corres_split_nor[OF corres_trivial])
+          apply (rule corres_guard_imp)
+            apply (rule corres_split_nor[OF corres_trivial])
           apply (clarsimp simp: retype_addrs_fold[symmetric] ptr_add_def upto_enum_red' not_zero'
                                 range_cover.unat_of_nat_n[OF cover] word_le_sub1
                           simp del: word_of_nat_eq_0_iff)
-          apply (rule_tac f=g in arg_cong)
-          apply clarsimp
-         apply (rename_tac x eps ps)
-         apply (rule_tac P="\<lambda>s. x = kheap s \<and> eps = ekheap (s) \<and> ?P s" and
-                         P'="\<lambda>s. ps = ksPSpace s \<and> ?P' s" in corres_modify)
-         apply (simp add: set_retype_addrs_fold new_caps_adds_fold)
-         apply (erule retype_state_relation[OF _ _ _ _ _ _ _ _ _ cover _ _ orr],
-                simp_all add: ko not_zero obj_bits_api
-                              bound[simplified obj_bits_api ko])[1]
-        apply wp+
-      apply (clarsimp split: option.splits)
-      apply (intro conjI impI)
-       apply (clarsimp|wp)+
-     apply (clarsimp split: option.splits)
-     apply wpsimp
-    apply (clarsimp split: option.splits)
-    apply (intro conjI impI)
-     apply wp
-    apply (clarsimp simp:lookupAround2_char1)
-    apply wp
-    apply (clarsimp simp: obj_bits_api ko)
-    apply (drule(1) pspace_no_overlap_disjoint')
-    apply (rule_tac x1 = a in ccontr[OF in_empty_interE])
-      apply simp
-     apply (clarsimp simp: not_less shiftL_nat)
-     apply (erule order_trans)
-     apply (subst p_assoc_help)
-     apply (subst word_plus_and_or_coroll2[symmetric,where w = "mask sz"])
-     apply (subst add.commute)
-     apply (subst add.assoc)
-     apply (rule word_plus_mono_right)
-      using cover
-      apply -
-      apply (rule iffD2[OF word_le_nat_alt])
-      apply (subst word_of_nat_minus)
-       using not_zero
-       apply simp
-      apply (rule le_trans[OF unat_plus_gt])
-      apply simp
-      apply (subst unat_minus_one)
-       apply (subst mult.commute)
-       apply (rule word_power_nonzero_32)
-         apply (rule of_nat_less_pow_32[OF n_estimate])
-         apply (simp add:word_bits_def objBitsKO_gt_0 ko)
-        apply (simp add:range_cover_def obj_bits_api ko word_bits_def)
-       apply (cut_tac not_zero',clarsimp simp:ko)
-      apply(clarsimp simp:field_simps ko)
-      apply (subst unat_sub[OF word_1_le_power])
-       apply (simp add:range_cover_def)
-      apply (subst diff_add_assoc[symmetric])
-       apply (cut_tac unat_of_nat_n',simp add:ko)
-      apply (clarsimp simp: obj_bits_api ko)
-      apply (rule diff_le_mono)
-      apply (frule range_cover.range_cover_compare_bound)
-      apply (cut_tac obj_bits_api unat_of_nat_shift')
-      apply (clarsimp simp:add.commute range_cover_def ko)
-     apply (rule is_aligned_no_wrap'[OF is_aligned_neg_mask,OF le_refl ])
-     apply (simp add:range_cover_def domI)+
-  done
+               apply (rule_tac f=g in arg_cong)
+               apply clarsimp
+              apply (rename_tac ps ps' sa)
+              apply (rule_tac P="\<lambda>s. ps = kheap s \<and> sa = s \<and> ?P s" and
+                              P'="\<lambda>s. ps' = ksPSpace s \<and> ?P' s" in corres_modify)
+              apply(frule curdomain_relation[THEN sym])
+              apply (simp add: set_retype_addrs_fold new_caps_adds_fold)
+              apply (drule retype_state_relation[OF _ _ _ _ _ _ _ _ _ tysc cover _ _ orr],
+                     simp_all add: ko not_zero obj_bits_api
+                                   bound[simplified obj_bits_api ko])[1]
+                apply (erule pspace_relation_pspace_bounded')
+               apply (cases ty; simp; rename_tac tp; case_tac tp;
+                      clarsimp simp: default_object_def APIType_map2_def
+                              split: arch_kernel_object.splits apiobject_type.splits)
+             apply wpsimp+
+           apply simp+
+         apply (clarsimp split: option.splits)
+         apply (intro conjI impI)
+          apply (clarsimp|wp)+
+        apply (clarsimp split: option.splits)
+        apply wpsimp
+       apply (clarsimp split: option.splits)
+       apply (intro conjI impI)
+        apply wp
+       apply (clarsimp simp:lookupAround2_char1)
+       apply wp
+       apply (clarsimp simp: obj_bits_api ko)
+       apply (drule(1) pspace_no_overlap_disjoint')
+       apply (rule_tac x1 = a in ccontr[OF in_empty_interE])
+         apply simp
+        apply (clarsimp simp: not_less shiftL_nat)
+        apply (erule order_trans)
+        apply (subst p_assoc_help)
+        apply (subst word_plus_and_or_coroll2[symmetric,where w = "mask sz"])
+        apply (subst add.commute)
+        apply (subst add.assoc)
+        apply (rule word_plus_mono_right)
+         using cover
+         apply -
+         apply (rule iffD2[OF word_le_nat_alt])
+         apply (subst word_of_nat_minus)
+          using not_zero
+          apply simp
+         apply (rule le_trans[OF unat_plus_gt])
+         apply simp
+         apply (subst unat_minus_one)
+          apply (subst mult.commute)
+          apply (rule word_power_nonzero_32)
+            apply (rule of_nat_less_pow_32[OF n_estimate])
+            apply (simp add:word_bits_def objBitsKO_gt_0 ko)
+           apply (simp add:range_cover_def obj_bits_api ko word_bits_def)
+          apply (cut_tac not_zero',clarsimp simp:ko)
+         apply(clarsimp simp:field_simps ko)
+         apply (subst unat_sub[OF word_1_le_power])
+          apply (simp add:range_cover_def)
+         apply (subst diff_add_assoc[symmetric])
+          apply (cut_tac unat_of_nat_n',simp add:ko)
+         apply (clarsimp simp: obj_bits_api ko)
+         apply (rule diff_le_mono)
+         apply (frule range_cover.range_cover_compare_bound)
+         apply (cut_tac obj_bits_api unat_of_nat_shift')
+         apply (clarsimp simp:add.commute range_cover_def ko)
+        apply (rule is_aligned_no_wrap'[OF is_aligned_neg_mask,OF le_refl ])
+        apply (simp add:range_cover_def domI)+
+      apply wpsimp+
+   done
 qed
 
 lemma createObjects_corres':
@@ -2151,14 +2119,14 @@ lemma retype_obj_at_disj':
     apply (simp add:ptr_add_def p_assoc_help domI)+
   done
 
-declare word_unat_power[symmetric,simp]
+declare word_unat_power[symmetric,simp] (* FIXME: remove *)
 
 lemma createObjects_ko_at_strg:
   fixes ptr :: word32
   assumes    cover: "range_cover ptr sz ((objBitsKO ko) + gbits) n"
   assumes    not_0: "n\<noteq> 0"
   assumes       pi: "projectKO_opt ko  = Some val"
-  shows "\<lbrace>\<lambda>s. pspace_no_overlap' ptr sz s \<and> pspace_aligned' s \<and> pspace_distinct' s\<rbrace>
+  shows "\<lbrace>\<lambda>s. pspace_no_overlap' ptr sz s \<and> pspace_aligned' s \<and> pspace_distinct' s \<and> pspace_bounded' s\<rbrace>
              createObjects ptr n ko gbits
          \<lbrace>\<lambda>r s. \<forall>x \<in> set r. \<forall>offs < 2 ^ gbits. ko_at' val (x + (offs << objBitsKO ko)) s\<rbrace>"
 proof -
@@ -2173,101 +2141,96 @@ proof -
     \<Longrightarrow> ptr + (idx << objBitsKO ko + gbits) + (offs << objBitsKO ko)
         \<in> set (new_cap_addrs (n * 2 ^ gbits) ptr ko)"
        including no_take_bit
-      apply (insert range_cover_not_zero[OF not_0 cover] not_0)
-      apply (clarsimp simp:new_cap_addrs_def image_def)
-      apply (rule_tac x ="unat (2 ^ gbits * idx + offs)" in bexI)
-        apply (subst add.commute)
-        apply (simp add:shiftl_shiftl[symmetric])
-        apply (simp add:shiftl_t2n distrib_left[symmetric])
-      apply simp
-      apply (rule unat_less_helper)
-      apply (rule less_le_trans)
-       apply (erule word_plus_strict_mono_right)
-       apply (subst distrib_left[where c = "1 :: 32 word",symmetric,simplified])
-       apply (subst mult.commute[where a = "2^gbits"])+
-       apply (insert cover)
-       apply (rule word_mult_le_iff[THEN iffD2])
-         apply (simp add:p2_gt_0)
-         apply (clarsimp simp:range_cover_def word_bits_def)
-         apply (drule range_cover_rel[where sbit' = "objBitsKO ko "])
-           apply simp
-          apply simp
-         apply (rule less_le_trans)
-          apply (rule range_cover.range_cover_le_n_less)
-           apply simp
-          apply (subst unat_power_lower)
-           using cover
-           apply (clarsimp simp:range_cover_def)
-          apply (simp add:field_simps)
-          apply (rule unat_le_helper)
-          apply (erule order_trans[OF _ word_sub_1_le])
-          apply (simp add:range_cover_not_zero[OF not_0 cover])
-         apply (simp add:word_bits_def)
-        apply (drule range_cover_rel[where sbit' = "objBitsKO ko "])
-          apply simp
+    apply (insert range_cover_not_zero[OF not_0 cover] not_0)
+    apply (clarsimp simp:new_cap_addrs_def image_def)
+    apply (rule_tac x ="unat (2 ^ gbits * idx + offs)" in bexI)
+     apply (subst add.commute)
+     apply (simp add:shiftl_shiftl[symmetric])
+     apply (simp add:shiftl_t2n distrib_left[symmetric])
+    apply simp
+    apply (rule unat_less_helper)
+    apply (rule less_le_trans)
+     apply (erule word_plus_strict_mono_right)
+     apply (subst distrib_left[where c = "1 :: 32 word",symmetric,simplified])
+     apply (subst mult.commute[where a = "2^gbits"])+
+     apply (insert cover)
+     apply (rule word_mult_le_iff[THEN iffD2])
+        apply (simp add:p2_gt_0)
+        apply (clarsimp simp:range_cover_def word_bits_def)
+       apply (drule range_cover_rel[where sbit' = "objBitsKO ko "])
+         apply simp
+        apply simp
+       apply (rule less_le_trans)
+        apply (rule range_cover.range_cover_le_n_less)
          apply simp
-        apply (erule less_le_trans[OF range_cover.range_cover_le_n_less(1)])
         apply (subst unat_power_lower)
          using cover
          apply (clarsimp simp:range_cover_def)
         apply (simp add:field_simps)
-        apply (rule unat_le_helper[OF inc_le])
-        apply (simp add:word_leq_minus_one_le)
+        apply (rule unat_le_helper)
+        apply (erule order_trans[OF _ word_sub_1_le])
+        apply (simp add:range_cover_not_zero[OF not_0 cover])
        apply (simp add:word_bits_def)
-      apply (rule no_plus_overflow_neg)
-      apply (rule less_le_trans[where y = "of_nat n"])
-       apply unat_arith
-      using range_cover.range_cover_n_less[OF cover]
+      apply (drule range_cover_rel[where sbit' = "objBitsKO ko "])
+        apply simp
+       apply simp
+      apply (erule less_le_trans[OF range_cover.range_cover_le_n_less(1)])
+       apply (subst unat_power_lower)
+        using cover
+        apply (clarsimp simp:range_cover_def)
+       apply (simp add:field_simps)
+       apply (rule unat_le_helper[OF inc_le])
+       apply (simp add:word_leq_minus_one_le)
+      apply (simp add:word_bits_def)
+     apply (rule no_plus_overflow_neg)
+     apply (rule less_le_trans[where y = "of_nat n"])
+      apply unat_arith
+     using range_cover.range_cover_n_less[OF cover]
      apply (simp add:word_bits_def)
     apply (subst distrib_left[where c = "1 :: 32 word",symmetric,simplified])
-   apply (subst mult.commute)
-   apply simp
-   apply (rule word_mult_le_iff[THEN iffD2])
+    apply (subst mult.commute)
+    apply simp
+    apply (rule word_mult_le_iff[THEN iffD2])
        apply (simp add:p2_gt_0)
-      apply (simp add:range_cover_def word_bits_def)
-     apply (drule range_cover_rel[where sbit' = "objBitsKO ko "])
-       apply simp
-      apply simp
-     apply (rule less_le_trans)
-     apply (rule range_cover.range_cover_le_n_less)
+       apply (simp add:range_cover_def word_bits_def)
+      apply (drule range_cover_rel[where sbit' = "objBitsKO ko "])
+        apply simp
        apply simp
-     apply (subst unat_power_lower)
-       using cover
-       apply (clarsimp simp:range_cover_def)
-      apply (simp add:field_simps)
-     apply (rule unat_le_helper)
-    apply unat_arith
-   apply (simp add:word_bits_def)
-   apply (drule range_cover_rel[where sbit' = "objBitsKO ko "])
+      apply (rule less_le_trans)
+       apply (rule range_cover.range_cover_le_n_less)
+        apply simp
+       apply (subst unat_power_lower)
+        using cover
+        apply (clarsimp simp:range_cover_def)
+       apply (simp add:field_simps)
+       apply (rule unat_le_helper)
+       apply unat_arith
+      apply (simp add:word_bits_def)
+     apply (drule range_cover_rel[where sbit' = "objBitsKO ko "])
        apply simp
       apply simp
      apply (rule less_le_trans)
       apply (erule range_cover.range_cover_le_n_less)
-     apply (simp add:range_cover.unat_of_nat_n[OF cover])
-    apply (simp add: unat_le_helper)
-   apply (simp add:word_bits_def)
-  apply unat_arith
-  done
+      apply (simp add:range_cover.unat_of_nat_n[OF cover])
+      apply (simp add: unat_le_helper)
+     apply (simp add:word_bits_def)
+    apply unat_arith
+    done
   show ?thesis
-  apply (simp add: split_def createObjects_def lookupAround2_pspace_no
-                   alignError_def unless_def createObjects'_def)
-  apply (rule hoare_pre)
-   apply (wp|simp add:data_map_insert_def[symmetric]
-     cong: if_cong del: fun_upd_apply data_map_insert_def)+
-   apply (wpc|wp|clarsimp simp del:fun_upd_apply)+
-   apply (subst new_cap_addrs_fold'[OF shiftr_not_zero])+
-   apply (subst data_map_insert_def[symmetric])+
-   apply (subst retype_obj_at_disj')
-     apply (simp add:valid_pspace'_def unat_of_nat_shiftl)+
-     apply (rule range_cover_rel[OF cover])
-     apply simp+
-   apply (subst retype_obj_at_disj')
-     apply (simp add:valid_pspace'_def unat_of_nat_shiftl)+
-     apply (rule range_cover_rel[OF cover])
-     apply simp+
-  using range_cover.unat_of_nat_n_shift[OF cover,where gbits = gbits,simplified] pi
-  apply (simp add: in_new)
-  done
+    apply (simp add: split_def createObjects_def lookupAround2_pspace_no
+                     alignError_def unless_def createObjects'_def)
+    apply (wp|simp add:data_map_insert_def[symmetric]
+                   cong: if_cong del: fun_upd_apply data_map_insert_def)+
+       apply (wpc|wp|clarsimp simp del:fun_upd_apply)+
+    apply (subst new_cap_addrs_fold'[OF shiftr_not_zero])+
+    apply (subst data_map_insert_def[symmetric])+
+    apply (subst retype_obj_at_disj'; simp add:valid_pspace'_def unat_of_nat_shiftl)+
+     apply (rule range_cover_rel[OF cover]; simp)
+    apply (subst retype_obj_at_disj'; simp add:valid_pspace'_def unat_of_nat_shiftl)
+     apply (rule range_cover_rel[OF cover]; simp)
+    using range_cover.unat_of_nat_n_shift[OF cover,where gbits = gbits,simplified] pi
+    apply (simp add: in_new)
+    done
 qed
 
 lemma createObjects_ko_at:
@@ -2425,6 +2406,7 @@ show ?thesis
       projectKO_opts_defs split: kernel_object.splits)
   done
 qed
+
 lemmas capFreeIndex_update_valid_untyped' =
   capFreeIndex_update_valid_cap'[unfolded valid_cap'_def,simplified,THEN conjunct2,THEN conjunct1]
 
@@ -2434,14 +2416,16 @@ lemma createNewCaps_valid_cap:
   assumes not_0: "n \<noteq> 0"
   assumes ct: "ty = APIObjectType ArchTypes_H.CapTableObject \<Longrightarrow> 0 < us"
               "ty = APIObjectType apiobject_type.Untyped \<Longrightarrow> minUntypedSizeBits \<le> us \<and> us \<le> maxUntypedSizeBits"
+              "ty = APIObjectType ArchTypes_H.SchedContextObject \<Longrightarrow> sc_size_bounds us"
   assumes ptr: " ptr \<noteq> 0"
   shows "\<lbrace>\<lambda>s. pspace_no_overlap' ptr sz s \<and> valid_pspace' s\<rbrace>
            createNewCaps ty ptr n us dev
          \<lbrace>\<lambda>r s. (\<forall>cap \<in> set r. s \<turnstile>' cap)\<rbrace>"
 proof -
-  note blah[simp del] = untyped_range.simps usable_untyped_range.simps atLeastAtMost_iff atLeastatMost_subset_iff atLeastLessThan_iff
-          Int_atLeastAtMost atLeastatMost_empty_iff split_paired_Ex
-  note if_split_def[split del] = if_splits
+  note [simp del] = untyped_range.simps usable_untyped_range.simps atLeastAtMost_iff
+                    atLeastatMost_subset_iff atLeastLessThan_iff Int_atLeastAtMost
+                    atLeastatMost_empty_iff split_paired_Ex
+  note [split del] = if_split
 
   show ?thesis
   proof(cases "Types_H.toAPIType ty")
@@ -2568,16 +2552,17 @@ proof -
         apply (simp_all add: ARM_H.toAPIType_def
                              fromIntegral_def toInteger_nat fromInteger_nat APIType_capBits_def curDomain_def
                       split: ARM_H.object_type.splits)
-        apply (wp mapM_x_wp' hoare_vcg_const_Ball_lift)+
-        apply (rule hoare_post_imp)
-         prefer 2
-         apply (rule createObjects_obj_at [where 'a = "tcb",OF _ not_0])
-          using cover
-          apply (clarsimp simp: ARM_H.toAPIType_def APIType_capBits_def objBits_simps
-                         split: ARM_H.object_type.splits)
-         apply (simp add: projectKOs)
-        apply (clarsimp simp: valid_cap'_def objBits_simps)
-        apply (fastforce intro: capAligned_tcbI)
+        apply wp
+         apply (rule hoare_post_imp)
+          prefer 2
+          apply (rule createObjects_obj_at [where 'a = "tcb" and sz=sz,OF _ not_0])
+        using cover
+           apply (clarsimp simp: ARM_H.toAPIType_def APIType_capBits_def objBits_simps
+                          split: ARM_H.object_type.splits)
+          apply (simp add: projectKOs)
+         apply (clarsimp simp: valid_cap'_def objBits_simps)
+         apply (fastforce intro: capAligned_tcbI)
+        apply wp
         done
     next
       case EndpointObject with Some cover ct show ?thesis
@@ -2773,7 +2819,7 @@ lemma pagetable_relation_retype:
   done
 
 lemma pagedirectory_relation_retype:
-  "obj_relation_retype (default_object (ArchObject PageDirectoryObj) dev n)
+  "obj_relation_retype (default_object (ArchObject PageDirectoryObj) dev n d)
                        (KOArch (KOPDE makeObject))"
   apply (simp add: default_object_def default_arch_object_def
                    makeObject_pde obj_relation_retype_def
@@ -2836,7 +2883,7 @@ lemma pde_relation_aligned_eq:
   done
 
 lemma copyGlobalMappings_corres:
-  "corres dc (valid_arch_state and valid_etcbs and pspace_aligned and page_directory_at pd)
+  "corres dc (valid_arch_state and pspace_aligned and page_directory_at pd)
              (valid_arch_state' and page_directory_at' pd)
           (copy_global_mappings pd)
           (copyGlobalMappings pd)"
@@ -2850,8 +2897,7 @@ lemma copyGlobalMappings_corres:
        apply (simp add: liftM_def[symmetric])
        apply (rule_tac S="(=)" and r'=dc
                    and Q="\<lambda>xs s. \<forall>x \<in> set xs. pde_at (global_pd + (x << 2)) s
-                                              \<and> pde_at (pd + (x << 2)) s \<and> pspace_aligned s \<and>
-                                              valid_etcbs s"
+                                              \<and> pde_at (pd + (x << 2)) s \<and> pspace_aligned s"
                    and Q'="\<lambda>xs s. \<forall>x \<in> set xs. pde_at' (global_pd + (x << 2)) s
                                               \<and> pde_at' (pd + (x << 2)) s"
                           in corres_mapM_list_all2, (simp add: pdeBits_def)+)
@@ -2863,7 +2909,7 @@ lemma copyGlobalMappings_corres:
               apply (drule(1) pde_relation_aligned_eq)
               apply fastforce
              apply (wp hoare_vcg_const_Ball_lift | simp)+
-       apply (simp add: kernel_base_def ARM.pptrBase_def pptrBase_def list_all2_refl pageBits_def)
+       apply (simp add: kernel_base_def pptrBase_def list_all2_refl pageBits_def)
       apply (rule corres_trivial, clarsimp simp: state_relation_def arch_state_relation_def)
      apply wp+
    apply (clarsimp simp: valid_arch_state_def)
@@ -3253,7 +3291,7 @@ proof -
     apply (frule(1) obj_range'_subset)
     apply (simp add: obj_range'_def)
     apply (cases "n = 0"; clarsimp simp:new_cap_addrs_def)
-    done
+   done
 qed
 
 lemma caps_no_overlapD'':
@@ -3276,57 +3314,62 @@ lemma valid_untyped'_helper:
   and  cover  : "range_cover ptr sz (objBitsKO val) n"
   and  range  : "caps_no_overlap'' ptr sz s"
   and  pres   : "isUntypedCap c \<longrightarrow> usableUntypedRange c \<inter>  {ptr..ptr + of_nat n * 2 ^ objBitsKO val - 1} = {}"
-  shows "\<lbrakk>pspace_aligned' s; pspace_distinct' s; pspace_no_overlap' ptr sz s\<rbrakk>
- \<Longrightarrow> valid_cap' c (s\<lparr>ksPSpace := foldr (\<lambda>addr. data_map_insert addr val) (new_cap_addrs n ptr val) (ksPSpace s)\<rparr>)"
-  proof -
+  shows "\<lbrakk>pspace_aligned' s; pspace_distinct' s;  pspace_bounded' s; pspace_no_overlap' ptr sz s\<rbrakk>
+          \<Longrightarrow> valid_cap' c (s\<lparr>ksPSpace := foldr (\<lambda>addr. data_map_insert addr val)
+                                                      (new_cap_addrs n ptr val) (ksPSpace s)\<rparr>)"
+proof -
   note blah[simp del] = atLeastAtMost_iff atLeastatMost_subset_iff atLeastLessThan_iff
-        Int_atLeastAtMost atLeastatMost_empty_iff
-  assume pn : "pspace_aligned' s" "pspace_distinct' s"
-  and   no_overlap: "pspace_no_overlap' ptr sz s"
+    Int_atLeastAtMost atLeastatMost_empty_iff
+  note cover' = range_cover_rel[where sbit' = "objBitsKO val",OF cover _ refl,simplified]
+  assume pn : "pspace_aligned' s" "pspace_distinct' s" "pspace_bounded' s"
+  and no_overlap: "pspace_no_overlap' ptr sz s"
   show ?thesis
-  using pn pres no_overlap valid cover cte_wp_at_ctes_of[THEN iffD1,OF cte_at]
-        caps_no_overlapD''[OF cte_at range]
-  apply (clarsimp simp:valid_cap'_def retype_ko_wp_at')
-  apply (case_tac "cteCap cte"; simp add: valid_cap'_def cte_wp_at_obj_cases'
-                                valid_pspace'_def retype_obj_at_disj'
-                         split: zombie_type.split_asm)
-   apply (rename_tac arch_capability)
-   apply (case_tac arch_capability;
-          simp add: retype_obj_at_disj' typ_at_to_obj_at_arches
-                    page_table_at'_def page_directory_at'_def split del: if_splits)
-    apply (fastforce simp: typ_at_to_obj_at_arches retype_obj_at_disj')
-                           unfolding valid_untyped'_def
-  apply (intro allI)
-  apply (rule ccontr)
-  apply clarify
-  using cover[unfolded range_cover_def]
-  apply (clarsimp simp:isCap_simps retype_ko_wp_at' split:if_split_asm)
-   apply (thin_tac "\<forall>x. Q x" for Q)
-   apply (frule aligned_untypedRange_non_empty)
-    apply (simp add:isCap_simps)
-   apply (elim disjE)
-    apply (frule(1) obj_range'_subset)
-    apply (erule impE)
-     apply (drule(1) psubset_subset_trans)
-     apply (drule Int_absorb1[OF psubset_imp_subset])
-     apply (drule aligned_untypedRange_non_empty)
+    using pn pres no_overlap valid cover cte_wp_at_ctes_of[THEN iffD1,OF cte_at]
+      caps_no_overlapD''[OF cte_at range]
+    apply (clarsimp simp:valid_cap'_def retype_ko_wp_at')
+    apply (case_tac "cteCap cte"; simp add: valid_cap'_def cte_wp_at_obj_cases'
+                                  valid_pspace'_def retype_obj_at_disj' retype_ko_wp_at'
+                           split: zombie_type.split_asm)
+      apply (rename_tac arch_capability)
+      apply (case_tac arch_capability;
+             simp add: retype_obj_at_disj' typ_at_to_obj_at_arches
+                       page_table_at'_def page_directory_at'_def split del: if_split)
+      apply (fastforce simp: typ_at_to_obj_at_arches retype_obj_at_disj')
+     unfolding valid_untyped'_def
+     apply (intro allI)
+     apply (rule ccontr)
+     apply clarify
+     using cover[unfolded range_cover_def]
+     apply (clarsimp simp:isCap_simps retype_ko_wp_at' split:if_split_asm)
+      apply (thin_tac "\<forall>x. Q x" for Q)
+      apply (frule aligned_untypedRange_non_empty)
+       apply (simp add:isCap_simps)
+      apply (elim disjE)
+       apply (frule(1) obj_range'_subset)
+       apply (erule impE)
+        apply (drule(1) psubset_subset_trans)
+        apply (drule Int_absorb1[OF psubset_imp_subset])
+        apply (drule aligned_untypedRange_non_empty)
+         apply (simp add:isCap_simps)
+        apply (simp add:Int_ac)
+       apply (drule(1) subset_trans)
+       apply blast
+      apply (frule(1) obj_range'_subset_strong)
+      apply (drule(1) non_disjoing_subset)
+      apply blast
+     apply (thin_tac "\<forall>x. Q x" for Q)
+     apply (frule aligned_untypedRange_non_empty)
       apply (simp add:isCap_simps)
-     apply (simp add:Int_ac)
-    apply (drule(1) subset_trans)
-    apply blast
-   apply (frule(1) obj_range'_subset_strong)
-   apply (drule(1) non_disjoing_subset)
-   apply blast
-  apply (thin_tac "\<forall>x. Q x" for Q)
-  apply (frule aligned_untypedRange_non_empty)
-   apply (simp add:isCap_simps)
-  apply (frule(1) obj_range'_subset)
-  apply (drule(1) subset_trans)
-   apply (erule impE)
+     apply (frule(1) obj_range'_subset)
+     apply (drule(1) subset_trans)
+     apply (erule impE)
+      apply clarsimp
+      apply blast
+     apply blast
     apply clarsimp
-    apply blast
-   apply blast
-  done
+    apply (drule (3) retype_ko_wp_at'_not[where gbits=0, simplified, OF _ _ _ cover])
+    apply (erule notE, simp)
+    done
 qed
 
 definition caps_overlap_reserved' :: "word32 set \<Rightarrow> kernel_state \<Rightarrow> bool"
@@ -3335,13 +3378,17 @@ where
   (isUntypedCap (cteCap cte) \<longrightarrow> usableUntypedRange (cteCap cte) \<inter> S = {})"
 
 lemma createObjects_valid_pspace':
-  assumes  mko: "makeObjectKO dev ty = Some val"
+  assumes  mko: "makeObjectKO dev us d ty = Some val"
+  and    max_d: "ty = Inr (APIObjectType TCBObject) \<longrightarrow> d \<le> maxDomain"
   and    not_0: "n \<noteq> 0"
+  and     tysc: "ty = Inr (APIObjectType SchedContextObject) \<longrightarrow> sc_size_bounds us"
   and    cover: "range_cover ptr sz (objBitsKO val + gbits) n"
   shows "\<lbrace>\<lambda>s. pspace_no_overlap' ptr sz s \<and> valid_pspace' s \<and> caps_no_overlap'' ptr sz s
             \<and> caps_overlap_reserved' {ptr .. ptr + of_nat (n * 2^gbits * 2 ^ objBitsKO val ) - 1} s
             \<and> ptr \<noteq> 0\<rbrace>
-  createObjects' ptr n val gbits \<lbrace>\<lambda>r. valid_pspace'\<rbrace>"
+         createObjects' ptr n val gbits
+         \<lbrace>\<lambda>r. valid_pspace'\<rbrace>"
+  (* FIXME: clean this up *)
   apply (cut_tac not_0)
   apply (simp add: split_def createObjects'_def
                    lookupAround2_pspace_no
@@ -3370,7 +3417,9 @@ proof (intro conjI impI)
 
   assume pn: "pspace_no_overlap' ptr sz s"
      and vo: "valid_objs' s"
+     and vr: "valid_replies' s"
      and ad: "pspace_aligned' s" "pspace_distinct' s"
+     and bd: "pspace_bounded' s"
      and pc: "caps_no_overlap'' ptr sz s"
     and mdb: "valid_mdb' s"
     and p_0: "ptr \<noteq> 0"
@@ -3441,49 +3490,73 @@ proof (intro conjI impI)
     apply (drule bspec, erule ranI)
     apply (subst mult.commute)
     apply (case_tac obj; simp add: valid_obj'_def)
-        apply (rename_tac endpoint)
-        apply (case_tac endpoint; simp add: valid_ep'_def obj_at_disj')
-       apply (rename_tac notification)
-       apply (case_tac notification; simp add: valid_ntfn'_def valid_bound_tcb'_def obj_at_disj')
-       apply (rename_tac ntfn xa)
-       apply (case_tac ntfn, simp_all, (clarsimp simp: obj_at_disj' split:option.splits)+)
-      apply (rename_tac tcb)
-      apply (case_tac tcb, clarsimp simp add: valid_tcb'_def)
-      apply (frule pspace_alignedD' [OF _ ad(1)])
-      apply (frule pspace_distinctD' [OF _ ad(2)])
-      apply (simp add: objBits_simps)
-      apply (subst mult.commute)
-      apply (intro conjI ballI)
-       apply (clarsimp elim!: ranE)
-       apply (rule valid_cap[unfolded foldr_upd_app_if[folded data_map_insert_def]])
-        apply (fastforce)
-       apply (rule_tac ptr="x + xa" in cte_wp_at_tcbI', assumption+)
-        apply fastforce
+          apply (rename_tac endpoint)
+          apply (case_tac endpoint; simp add: valid_ep'_def obj_at_disj')
+         apply (rename_tac notification)
+         apply (case_tac notification; simp add: valid_ntfn'_def valid_bound_tcb'_def obj_at_disj')
+         apply (rename_tac ntfn xa xb)
+         apply (case_tac ntfn, simp_all, (clarsimp simp: obj_at_disj' split:option.splits)+)
+        apply (rename_tac tcb)
+        apply (case_tac tcb, clarsimp simp add: valid_tcb'_def)
+        apply (frule pspace_alignedD' [OF _ ad(1)])
+        apply (frule pspace_distinctD' [OF _ ad(2)])
+        apply (simp add: objBits_simps)
+        apply (subst mult.commute)
+        apply (intro conjI ballI)
+            apply (clarsimp elim!: ranE)
+            apply (rule valid_cap[unfolded foldr_upd_app_if[folded data_map_insert_def]])
+             apply (fastforce)
+            apply (rule_tac ptr="x + xa" in cte_wp_at_tcbI', assumption+)
+             apply fastforce
+            apply simp
+           apply (rename_tac thread_state mcp priority inQ inRQ option vptr bound tcbsc tcbyt user_context)
+           apply (case_tac thread_state, simp_all add: valid_tcb_state'_def
+                                                       valid_bound_ntfn'_def obj_at_disj'
+                                                split: option.splits)[4]
+       apply (simp add: valid_cte'_def)
+       apply (frule pspace_alignedD' [OF _ ad(1)])
+       apply (frule pspace_distinctD' [OF _ ad(2)])
+       apply (simp add: objBits_simps')
+       apply (subst mult.commute)
+       apply (erule valid_cap[unfolded foldr_upd_app_if[folded data_map_insert_def]])
+       apply (erule(2) cte_wp_at_cteI'[unfolded cte_level_bits_def])
        apply simp
-      apply (rename_tac thread_state mcp priority bool option nat cptr vptr bound user_context)
-      apply (case_tac thread_state, simp_all add: valid_tcb_state'_def
-                                                  valid_bound_ntfn'_def obj_at_disj'
-                                           split: option.splits)[2]
-     apply (simp add: valid_cte'_def)
-     apply (frule pspace_alignedD' [OF _ ad(1)])
-     apply (frule pspace_distinctD' [OF _ ad(2)])
-     apply (simp add: objBits_simps')
-     apply (subst mult.commute)
-     apply (erule valid_cap[unfolded foldr_upd_app_if[folded data_map_insert_def]])
-     apply (erule(2) cte_wp_at_cteI'[unfolded cte_level_bits_def])
-     apply simp
-    apply (rename_tac arch_kernel_object)
-    apply (case_tac arch_kernel_object; simp)
-      apply (rename_tac asidpool)
-      apply (case_tac asidpool, clarsimp simp: page_directory_at'_def
-                                               typ_at_to_obj_at_arches
-                                               obj_at_disj')
-     apply (rename_tac pte)
-     apply (case_tac pte; simp add: valid_mapping'_def)
-    apply (rename_tac pde)
-    apply (case_tac pde; simp add: valid_mapping'_def page_table_at'_def
-                                   typ_at_to_obj_at_arches obj_at_disj')
+      apply (rename_tac arch_kernel_object)
+      apply (case_tac arch_kernel_object; simp)
+        apply (rename_tac asidpool)
+        apply (case_tac asidpool, clarsimp simp: page_directory_at'_def
+                                                 typ_at_to_obj_at_arches
+                                                 obj_at_disj')
+       apply (rename_tac pte)
+       apply (case_tac pte; simp add: valid_mapping'_def)
+      apply (rename_tac pde)
+      apply (case_tac pde; simp add: valid_mapping'_def page_table_at'_def
+                                     typ_at_to_obj_at_arches obj_at_disj')
+     apply (rename_tac sc)
+     apply (case_tac sc; simp add: valid_sched_context'_def valid_bound_tcb'_def obj_at_disj'
+                            split: option.splits)
+    apply (rename_tac reply)
+    apply (case_tac reply; fastforce simp: valid_reply'_def valid_bound_tcb'_def obj_at_disj'
+                    split: option.splits)
+    done
+
+  show valid_replies': "valid_replies' ?s'" using vr
+    apply (subst mult.commute)
+    apply (clarsimp simp: valid_replies'_def pred_tcb_at'_def obj_at_disj'
+                          foldr_upd_app_if[folded data_map_insert_def]
+                   elim!: ranE
+                   split: if_split_asm)
+    apply (insert sym[OF mko])[1]
+    apply (clarsimp simp: makeObjectKO_def projectKOs opt_map_def makeObject_reply
+                   split: bool.split_asm sum.split_asm
+                          ARM_H.object_type.split_asm
+                          apiobject_type.split_asm
+                          kernel_object.split_asm
+                          arch_kernel_object.split_asm
+                          if_splits option.splits)
+    apply fastforce
     done
+
   have not_0: "0 \<notin> set (new_cap_addrs (2 ^ gbits * n) ptr val)"
     using p_0
     apply clarsimp
@@ -3544,19 +3618,24 @@ proof (intro conjI impI)
     using not_0 no_0_obj'
     by (simp add: no_0_obj'_def data_map_ext field_simps foldr_upd_app_other)
 
+  show bounded': "pspace_bounded' ?s'"
+  using ad' shift range_cover.unat_of_nat_n_shift[OF cover,where gbits=gbits,simplified]
+    by (simp add: field_simps )
 qed
 
 abbreviation
  "injectKOS \<equiv> (injectKO :: ('a :: pspace_storable) \<Rightarrow> kernel_object)"
 
 lemma createObjects_valid_pspace_untyped':
-  assumes  mko: "makeObjectKO dev ty = Some val"
+  assumes  mko: "makeObjectKO dev us d ty = Some val"
+  and    max_d: "ty = Inr (APIObjectType TCBObject) \<longrightarrow> d \<le> maxDomain"
   and    not_0: "n \<noteq> 0"
+  and     tysc: "ty = Inr (APIObjectType SchedContextObject) \<longrightarrow> sc_size_bounds us"
   and    cover: "range_cover ptr sz (objBitsKO val + gbits) n"
   shows "\<lbrace>\<lambda>s. pspace_no_overlap' ptr sz s \<and> valid_pspace' s \<and> caps_no_overlap'' ptr sz s \<and> ptr \<noteq> 0
             \<and> caps_overlap_reserved' {ptr .. ptr + of_nat (n * 2^gbits * 2 ^ objBitsKO val ) - 1} s \<rbrace>
   createObjects' ptr n val gbits \<lbrace>\<lambda>r. valid_pspace'\<rbrace>"
-  apply (wp createObjects_valid_pspace' [OF mko not_0 cover])
+  apply (wp createObjects_valid_pspace' [OF mko max_d not_0 tysc cover])
   apply simp
   done
 
@@ -3565,29 +3644,28 @@ lemma getObject_valid_pde'[wp]:
   apply (rule hoare_chain)
     apply (rule hoare_vcg_conj_lift)
      apply (rule getObject_ko_at, simp)
-     apply (simp add: objBits_simps archObjSize_def pdeBits_def)
     apply (rule getObject_inv[where P=valid_objs'])
     apply (simp add: loadObject_default_inv)
-   apply simp
   apply (clarsimp simp: projectKOs valid_obj'_def dest!: obj_at_valid_objs')
   done
 
-crunch valid_objs'[wp]: copyGlobalMappings "valid_objs'"
+crunches copyGlobalMappings
+  for valid_objs'[wp]: "valid_objs'"
+  and pspace_aligned'[wp]: "pspace_aligned'"
+  and pspace_distinct'[wp]: "pspace_distinct'"
+  and pspace_bounded'[wp]: "pspace_bounded'"
+  and valid_mdb[wp]: "valid_mdb'"
+  and no_0_obj' [wp]: no_0_obj'
   (ignore: storePDE wp: crunch_wps)
-crunch pspace_aligned'[wp]: copyGlobalMappings "pspace_aligned'"
-  (wp: crunch_wps)
-crunch pspace_distinct'[wp]: copyGlobalMappings "pspace_distinct'"
-  (wp: crunch_wps)
-
-lemmas storePDE_valid_mdb[wp]
-    = storePDE_ctes[where P=valid_mdb_ctes, folded valid_mdb'_def]
-crunch valid_mdb[wp]: copyGlobalMappings "valid_mdb'"
-  (wp: crunch_wps)
 
-crunch no_0_obj' [wp]: copyGlobalMappings no_0_obj'
-  (wp: crunch_wps)
+lemma copyGlobalMappings_valid_replies'[wp]:
+  "\<lbrace>valid_replies' and pspace_aligned' and pspace_distinct'\<rbrace>
+   copyGlobalMappings pd
+   \<lbrace>\<lambda>_. valid_replies'\<rbrace>" (is "\<lbrace>?Pre\<rbrace> _ \<lbrace>_\<rbrace>")
+  unfolding copyGlobalMappings_def
+  by (wpsimp wp: mapM_x_inv_wp[where I="?Pre"])
 
-lemma copyGlobalMappings_valid_pspace[wp]:
+lemma copyGlobalMappings_valid_pspace'[wp]:
   "\<lbrace>valid_pspace'\<rbrace> copyGlobalMappings pd \<lbrace>\<lambda>rv. valid_pspace'\<rbrace>"
   by (simp add: valid_pspace'_def | wp)+
 
@@ -3602,11 +3680,14 @@ proof -
   note unat_of_nat_shift = range_cover.unat_of_nat_n_shift[OF cover,where gbits=gbits,simplified]
   have cover' :"range_cover ptr sz (objBitsKO val) (n*2^gbits)"
     by (rule range_cover_rel[OF cover],simp+)
+  have bd: "objBitsKO val < word_bits"
+    using cover
+    by (simp add: range_cover_def word_bits_def)
   have upbound:" unat ((((of_nat n)::word32) * 2 ^ gbits)) * unat ((2::word32) ^ objBitsKO val) < 2 ^ word_bits"
-    using range_cover.range_cover_le_n_less[OF cover' le_refl] cover'
+    using range_cover.range_cover_le_n_less[OF cover' le_refl] cover' bd
     apply -
-    apply (drule nat_less_power_trans)
-     apply (simp add:range_cover_def)
+      apply (drule nat_less_power_trans)
+       apply (simp add:range_cover_def)
     apply (fold word_bits_def)
     using unat_of_nat_shift not_0
     apply (simp add:field_simps shiftl_t2n)
@@ -3620,63 +3701,63 @@ proof -
     by (simp add:range_cover_def word_bits_def)
   thus ?thesis
     including no_take_bit
-    apply -
-    apply (insert not_0 cover ptr_in)
-    apply (frule range_cover.range_cover_le_n_less[OF _ le_refl])
-    apply (fold word_bits_def)
-    apply (simp add:shiftL_nat )
-    apply (simp add:range_cover.unat_of_nat_n_shift)
-    apply (clarsimp simp:new_cap_addrs_def shiftl_t2n)
-    apply (rename_tac pa)
-    apply (rule word_plus_mono_right)
-     apply (rule order_trans)
-      apply (subst mult.commute)
-      apply (rule word_mult_le_iff[THEN iffD2])
-         apply (clarsimp simp:p2_gt_0 range_cover_def word_bits_def)
-        apply (drule range_cover_rel[where sbit' = "0"])
-          apply (simp+)[2]
-        apply (erule less_le_trans[OF range_cover.range_cover_le_n_less(2)])
-         apply (clarsimp simp:field_simps power_add)
-         apply (rule unat_le_helper)
-         apply (rule of_nat_mono_maybe_le[THEN iffD1])
-           using range_cover.range_cover_le_n_less[OF cover' le_refl]
-           apply (simp_all only:word_bits_def[symmetric])
-        apply simp
-       apply (drule nat_less_power_trans)
-        apply (simp add:range_cover_def word_bits_def)
-       apply (rule less_le_trans[OF mult_less_mono1])
-         apply (rule unat_mono)
-         apply (rule_tac y1= "pa" in  of_nat_mono_maybe'[THEN iffD1,rotated -1])
-           apply (assumption)
-          apply (simp add:word_bits_def)
-         apply (simp add:word_bits_def)
-        apply simp
-       using unat_of_nat_shift
-       apply (simp add:field_simps shiftl_t2n)
+  apply -
+  apply (insert not_0 cover ptr_in bd)
+  apply (frule range_cover.range_cover_le_n_less[OF _ le_refl])
+  apply (fold word_bits_def)
+  apply (simp add:shiftL_nat )
+  apply (simp add:range_cover.unat_of_nat_n_shift)
+  apply (clarsimp simp:new_cap_addrs_def shiftl_t2n)
+  apply (rename_tac pa)
+  apply (rule word_plus_mono_right)
+    apply (rule order_trans)
+    apply (subst mult.commute)
+    apply (rule word_mult_le_iff[THEN iffD2])
+       apply (clarsimp simp:p2_gt_0 range_cover_def word_bits_def)
+      apply (drule range_cover_rel[where sbit' = "0"])
+        apply (simp+)[2]
+      apply (erule less_le_trans[OF range_cover.range_cover_le_n_less(2)])
+       apply (clarsimp simp:field_simps power_add)
+       apply (rule unat_le_helper)
+       apply (rule of_nat_mono_maybe_le[THEN iffD1])
+         using range_cover.range_cover_le_n_less[OF cover' le_refl]
+       apply (simp_all only:word_bits_def[symmetric])
       apply simp
-     apply (rule word_less_sub_1)
-     apply (simp add:power_add field_simps)
-     apply (subst mult.assoc[symmetric])
-     apply (rule word_mult_less_mono1)
-       apply (rule word_of_nat_less)
-       using unat_of_nat_shift
-       apply (simp add:shiftl_t2n field_simps)
-      apply (meson less_exp objBitsKO_bounded2 of_nat_less_pow_32 word_gt_a_gt_0)
-     using upbound
-     apply (simp add:word_bits_def)
-    apply (rule machine_word_plus_mono_right_split[where sz = sz])
-     apply (rule less_le_trans[rotated -1])
-      apply (rule range_cover.range_cover_compare_bound[OF cover'])
-     apply (simp add: unat_minus_one[OF not_0'])
-     using range_cover.unat_of_nat_n_shift[OF cover le_refl]
-     apply (simp add:shiftl_t2n power_add field_simps)
-    apply (simp add:range_cover_def word_bits_def)
-    done
+     apply (drule nat_less_power_trans)
+      apply (simp add:range_cover_def word_bits_def)
+     apply (rule less_le_trans[OF mult_less_mono1])
+       apply (rule unat_mono)
+       apply (rule_tac y1= "pa" in  of_nat_mono_maybe'[THEN iffD1,rotated -1])
+         apply (assumption)
+        apply (simp add:word_bits_def)
+       apply (simp add:word_bits_def)
+      apply simp
+        using unat_of_nat_shift
+      apply (simp add:field_simps shiftl_t2n)
+     apply simp
+    apply (rule word_less_sub_1)
+    apply (simp add:power_add field_simps)
+    apply (subst mult.assoc[symmetric])
+    apply (rule word_mult_less_mono1)
+      apply (rule word_of_nat_less)
+      using unat_of_nat_shift
+      apply (simp add:shiftl_t2n field_simps)
+      apply (meson less_exp of_nat_less_pow_32 word_gt_a_gt_0)
+   using upbound
+   apply (simp add:word_bits_def)
+   apply (rule machine_word_plus_mono_right_split[where sz = sz])
+    apply (rule less_le_trans[rotated -1])
+     apply (rule range_cover.range_cover_compare_bound[OF cover'])
+    apply (simp add: unat_minus_one[OF not_0'])
+    using range_cover.unat_of_nat_n_shift[OF cover le_refl]
+    apply (simp add:shiftl_t2n power_add field_simps)
+  apply (simp add:range_cover_def word_bits_def)
+  done
 qed
 
 lemma createObjects_orig_ko_wp_at2':
   "\<lbrace>\<lambda>s. range_cover ptr sz (objBitsKO val + gbits) n \<and> n \<noteq> 0
-      \<and> pspace_aligned' s \<and> pspace_distinct' s
+      \<and> pspace_aligned' s \<and> pspace_distinct' s \<and> pspace_bounded' s
       \<and> P (ko_wp_at' P' p s)
       \<and> (P' val \<longrightarrow> P True)
       \<and> pspace_no_overlap' ptr sz s\<rbrace>
@@ -3767,24 +3842,19 @@ lemma createNewCaps_cte_wp_at2:
                            split del: if_split cong: if_cong)
         apply (rename_tac apiobject_type)
         apply (case_tac apiobject_type; simp split del: if_split)
-            apply (rule hoare_pre, wp, simp add:createObjects_def)
-           apply ((wp createObjects_orig_cte_wp_at2'[where sz = sz]
-                     mapM_x_wp' threadSet_cte_wp_at2')+
-                   | assumption
-                   | clarsimp simp: APIType_capBits_def
-                                    projectKOs projectKO_opts_defs
-                                    makeObject_tcb tcb_cte_cases_def
-                                    pageBits_def archObjSize_def ptBits_def
-                                    pdBits_def createObjects_def curDomain_def
-                                    Let_def objBits_if_dev
-                         split del: if_split
-                   | simp add: objBits_simps pteBits_def pdeBits_def)+
-  done
+              apply (rule hoare_pre, wp, simp add:createObjects_def)
+  by (wpsimp wp: createObjects_orig_cte_wp_at2'[where sz = sz] mapM_x_wp' split_del: if_split
+           simp: createObjects_def curDomain_def objBits_simps APIType_capBits_def
+    | simp add: projectKO_opts_defs makeObject_tcb tcb_cte_cases_def Let_def
+                scBits_simps objBits_if_dev objBits_simps
+                archObjSize_def pdBits_def pdeBits_def ptBits_def pteBits_def pageBits_def
+           split del: if_split
+    | simp)+
 
 lemma createObjects_orig_obj_at':
   "\<lbrace>\<lambda>s. n \<noteq> 0
       \<and> range_cover ptr sz (objBitsKO val + gbits) n
-      \<and> pspace_aligned' s \<and> pspace_distinct' s
+      \<and> pspace_aligned' s \<and> pspace_distinct' s \<and> pspace_bounded' s
       \<and> obj_at' P p s
       \<and> pspace_no_overlap' ptr sz s\<rbrace>
   createObjects' ptr n val gbits \<lbrace>\<lambda>r. obj_at' P p\<rbrace>"
@@ -3855,7 +3927,8 @@ lemma createNewCaps_cte_wp_at':
            apply (wp createObjects_orig_cte_wp_at'[where sz = sz] mapM_x_wp'
                      threadSet_cte_wp_at'T
                   | clarsimp simp: objBits_simps APIType_capBits_def createObjects_def curDomain_def
-                    pageBits_def ptBits_def pdBits_def archObjSize_def pteBits_def pdeBits_def
+                                   pageBits_def ptBits_def pdBits_def archObjSize_def pteBits_def
+                                   pdeBits_def scBits_simps
                   | intro conjI impI
                   | force simp: tcb_cte_cases_def)+
   done
@@ -4025,21 +4107,20 @@ lemma createNewCaps_state_refs_of':
         apply (rename_tac apiobject_type)
         apply (case_tac apiobject_type; simp split del: if_split)
             apply (rule hoare_pre, wp, simp)
-           apply (insert cover not_0)
-           apply (wp mapM_x_wp' createObjects_state_refs_of'' threadSet_state_refs_of'
-                    | simp add: not_0 pspace_no_overlap'_def objBitsKO_def APIType_capBits_def
-                                valid_pspace'_def makeObject_tcb makeObject_endpoint objBits_def
-                                makeObject_notification pageBits_def ptBits_def pdBits_def
-                                archObjSize_def createObjects_def curDomain_def
-                                pdeBits_def pteBits_def
-             | intro conjI impI)+
-  done
+           apply (insert cover not_0 tysc)
+           by (wp mapM_x_wp' createObjects_state_refs_of'' threadSet_state_refs_of'
+             | simp add: not_0 pspace_no_overlap'_def objBitsKO_def APIType_capBits_def
+                         valid_pspace'_def makeObject_tcb makeObject_endpoint objBits_def
+                         makeObject_notification pageBits_def ptBits_def pdBits_def
+                         archObjSize_def createObjects_def curDomain_def scBits_simps
+                         pdeBits_def pteBits_def makeObject_sc makeObject_reply
+             | intro conjI impI )+
 
 lemma createObjects_iflive':
   "\<lbrace>\<lambda>s. if_live_then_nonz_cap' s \<and> \<not> live' val
         \<and> n \<noteq> 0
         \<and> range_cover ptr sz (objBitsKO val + gbits) n
-        \<and> pspace_aligned' s \<and> pspace_distinct' s
+        \<and> pspace_aligned' s \<and> pspace_distinct' s \<and> pspace_bounded' s
         \<and> pspace_no_overlap' ptr sz s\<rbrace>
      createObjects' ptr n val gbits
    \<lbrace>\<lambda>rv s. if_live_then_nonz_cap' s\<rbrace>"
@@ -4176,30 +4358,31 @@ crunch iflive'[wp]: copyGlobalMappings "if_live_then_nonz_cap'"
 lemma createNewCaps_iflive'[wp]:
   assumes cover: "range_cover ptr sz (APIType_capBits ty us) n"
   and     not_0: "n \<noteq> 0"
+  and     tysc : "ty = APIObjectType ArchTypes_H.apiobject_type.SchedContextObject
+                         \<longrightarrow> sc_size_bounds us"
   shows
   "\<lbrace>\<lambda>s. valid_pspace' s \<and> pspace_no_overlap' ptr sz s
         \<and> if_live_then_nonz_cap' s\<rbrace>
      createNewCaps ty ptr n us dev
    \<lbrace>\<lambda>rv s. if_live_then_nonz_cap' s\<rbrace>"
   unfolding createNewCaps_def
-  apply (insert cover)
-  apply (clarsimp simp: toAPIType_def ARM_H.toAPIType_def)
+  apply (insert cover tysc)
+  apply (clarsimp simp: toAPIType_def)
   apply (cases ty, simp_all add: createNewCaps_def Arch_createNewCaps_def
                       split del: if_split)
         apply (rename_tac apiobject_type)
         apply (case_tac apiobject_type, simp_all split del: if_split)[1]
-            apply (rule hoare_pre, wp, simp)
-           apply (wp mapM_x_wp' createObjects_iflive' threadSet_iflive'
-                | simp add: not_0 pspace_no_overlap'_def createObjects_def
-                                valid_pspace'_def makeObject_tcb makeObject_endpoint
-                                 makeObject_notification objBitsKO_def
-                                 APIType_capBits_def objBits_def pageBits_def
-                                 archObjSize_def ptBits_def pdBits_def
-                                 pteBits_def pdeBits_def
-                                 curDomain_def split del:if_split
-                | simp split: if_split
-                | fastforce)+
-  done
+              apply (rule hoare_pre, wp, simp)
+  by (wp mapM_x_wp' createObjects_iflive' threadSet_iflive'
+    | simp add: not_0 pspace_no_overlap'_def createObjects_def
+                valid_pspace'_def makeObject_tcb makeObject_endpoint
+                makeObject_notification objBitsKO_def curDomain_def scBits_simps
+                live_ntfn'_def live_sc'_def live_reply'_def makeObject_sc
+                APIType_capBits_def objBits_def pageBits_def makeObject_reply
+                archObjSize_def ptBits_def pdBits_def pteBits_def pdeBits_def
+        split del: if_split
+    | simp split: if_split
+    | fastforce)+
 
 lemma createObjects_pspace_only:
   "\<lbrakk> \<And>f s. P (ksPSpace_update f s) = P s \<rbrakk>
@@ -4301,20 +4480,20 @@ lemma threadSet_ko_wp_at2':
   "\<lbrace>\<lambda>s. P (ko_wp_at' P' p s) \<and> (\<forall>tcb_x :: tcb. P' (injectKO (F tcb_x)) = P' (injectKO tcb_x))\<rbrace>
      threadSet F ptr
    \<lbrace>\<lambda>_ s. P (ko_wp_at' P' p s)\<rbrace>"
-apply (simp add: threadSet_def split del: if_split)
-apply (wp setObject_ko_wp_at getObject_tcb_wp | simp add: objBits_simps')+
-apply (auto simp: ko_wp_at'_def obj_at'_def projectKOs)
-done
+  apply (simp add: threadSet_def split del: if_split)
+  apply (wp setObject_ko_wp_at getObject_tcb_wp | simp add: objBits_simps')+
+  apply (auto simp: ko_wp_at'_def obj_at'_def projectKOs)
+  done
 
 lemma threadSet_ko_wp_at2'_futz:
   "\<lbrace>\<lambda>s. P (ko_wp_at' P' p s) \<and> obj_at' Q ptr s
-         \<and> (\<forall>tcb_x :: tcb. Q tcb_x \<longrightarrow> P' (injectKO (F tcb_x)) = P' (injectKO tcb_x))\<rbrace>
-     threadSet F ptr
-   \<lbrace>\<lambda>_ s. P (ko_wp_at' P' p s)\<rbrace>"
-apply (simp add: threadSet_def split del: if_split)
-apply (wp setObject_ko_wp_at getObject_tcb_wp | simp add: objBits_simps')+
-apply (auto simp: ko_wp_at'_def obj_at'_def projectKOs)
-done
+           \<and> (\<forall>tcb_x :: tcb. Q tcb_x \<longrightarrow> P' (injectKO (F tcb_x)) = P' (injectKO tcb_x))\<rbrace>
+       threadSet F ptr
+     \<lbrace>\<lambda>_ s. P (ko_wp_at' P' p s)\<rbrace>"
+  apply (simp add: threadSet_def split del: if_split)
+  apply (wp setObject_ko_wp_at getObject_tcb_wp | simp add: objBits_simps')+
+  apply (auto simp: ko_wp_at'_def obj_at'_def projectKOs)
+  done
 
 lemma mapM_x_threadSet_createNewCaps_futz:
   "\<lbrace>\<lambda>s. P (ko_wp_at' P' p s) \<and> (\<forall>addr\<in>set addrs. obj_at' (\<lambda>tcb. \<not>tcbQueued tcb \<and> tcbState tcb = Inactive) addr s)
@@ -4344,29 +4523,31 @@ lemma createObjects_makeObject_not_tcbQueued:
 
 lemma createObjects_ko_wp_at2:
   "\<lbrace>\<lambda>s. range_cover ptr sz (objBitsKO ko + gbits) n \<and> n \<noteq> 0
-      \<and> pspace_aligned' s \<and> pspace_distinct' s
+      \<and> pspace_aligned' s \<and> pspace_distinct' s \<and> pspace_bounded' s
       \<and> P (ko_wp_at' P' p s)
       \<and> (P' ko \<longrightarrow> P True)
       \<and> pspace_no_overlap' ptr sz s\<rbrace>
     createObjects ptr n ko gbits
    \<lbrace>\<lambda>_ s. P (ko_wp_at' P' p s)\<rbrace>"
-apply (simp add: createObjects_def)
-apply (wp createObjects_orig_ko_wp_at2')
-apply auto
-done
+  apply (simp add: createObjects_def)
+  apply (wp createObjects_orig_ko_wp_at2')
+  apply auto
+  done
 
 lemma createNewCaps_ko_wp_atQ':
   "\<lbrace>(\<lambda>s. P (ko_wp_at' P' p s)
        \<and> range_cover ptr sz (APIType_capBits ty us) n \<and> n \<noteq> 0
-       \<and> pspace_aligned' s \<and> pspace_distinct' s
+       \<and> (ty = APIObjectType ArchTypes_H.apiobject_type.SchedContextObject
+               \<longrightarrow> sc_size_bounds us)
+       \<and> pspace_aligned' s \<and> pspace_distinct' s \<and> pspace_bounded' s
        \<and> pspace_no_overlap' ptr sz s)
        and K (\<forall>pde_x :: pde. P' (injectKO pde_x)
                    \<longrightarrow> (\<forall>pde_y :: pde. P' (injectKO pde_y)))
        and K (\<forall>d (tcb_x :: tcb). \<not>tcbQueued tcb_x \<and> tcbState tcb_x = Inactive
                    \<longrightarrow> P' (injectKO (tcb_x \<lparr> tcbDomain := d \<rparr>)) = P' (injectKO tcb_x))
-       and K (\<forall>v. makeObjectKO d (Inr ty) = Some v
+       and (\<lambda>s. \<forall>v. makeObjectKO dev us (ksCurDomain s) (Inr ty) = Some v
                  \<longrightarrow> P' v \<longrightarrow> P True)\<rbrace>
-     createNewCaps ty ptr n us d
+     createNewCaps ty ptr n us dev
    \<lbrace>\<lambda>rv s. P (ko_wp_at' P' p s)\<rbrace>"
   apply (rule hoare_name_pre_state)
   apply (clarsimp simp: createNewCaps_def ARM_H.toAPIType_def
@@ -4376,19 +4557,14 @@ lemma createNewCaps_ko_wp_atQ':
         apply (rename_tac apiobject_type)
         apply (case_tac apiobject_type, simp_all split del: if_split)[1]
             apply (rule hoare_pre, wp, simp)
-           apply ((wp mapM_x_threadSet_createNewCaps_futz
-                     mapM_x_wp'
-                     createObjects_obj_at
-                     createObjects_ko_wp_at2 createObjects_makeObject_not_tcbQueued
-                     copyGlobalMappings_ko_wp_at[where v="\<forall>pde :: pde. P' (injectKO pde)"]
-                   | simp add: makeObjectKO_def objBitsKO_def archObjSize_def APIType_capBits_def
-                               objBits_def pageBits_def pdBits_def ptBits_def curDomain_def
-                               pteBits_def pdeBits_def
-                          split del: if_split
-                   | split if_split_asm[where Q=d]
-                   | intro conjI impI | fastforce)+)
-  done
-
+  by (wpsimp wp: mapM_x_wp' createObjects_makeObject_not_tcbQueued
+                 createObjects_obj_at createObjects_ko_wp_at2[where sz=sz]
+                 copyGlobalMappings_ko_wp_at[where v="\<forall>pde :: pde. P' (injectKO pde)"]
+           split_del: if_split
+           simp: curDomain_def APIType_capBits_def objBitsKO_def objBits_def makeObjectKO_def
+                 pageBits_def pdBits_def ptBits_def scBits_simps
+                 pteBits_def pdeBits_def sc_size_bounds_def archObjSize_def
+    | split if_split_asm[where Q=dev] | fastforce)+
 
 lemmas createNewCaps_ko_wp_at'
     = createNewCaps_ko_wp_atQ'[simplified, unfolded fold_K]
@@ -4403,29 +4579,34 @@ lemmas createNewCaps_obj_at2 =
 lemma createNewCaps_obj_at'':
   "\<lbrace>\<lambda>s. obj_at' (P :: ('a :: pspace_storable) \<Rightarrow> bool) p s
        \<and> range_cover ptr sz (APIType_capBits ty us) n \<and> n \<noteq> 0
-       \<and> pspace_aligned' s \<and> pspace_distinct' s
+       \<and> pspace_aligned' s \<and> pspace_distinct' s \<and> pspace_bounded' s
        \<and> pspace_no_overlap' ptr sz s
+       \<and> (ty = APIObjectType ArchTypes_H.apiobject_type.SchedContextObject
+                \<longrightarrow> sc_size_bounds us)
        \<and> (koType(TYPE('a)) = koType(TYPE(pde))
                \<longrightarrow> (\<forall>x. P x)
                 \<and> (\<forall>pde :: pde. \<exists>x :: 'a. injectKO x = injectKO pde))
-       \<and> (\<forall>tcb d. \<not>tcbQueued tcb \<and> tcbState tcb = Inactive \<longrightarrow> ((\<exists>obj :: 'a. injectKOS obj = KOTCB (tcb\<lparr>tcbDomain := d\<rparr>) \<and> P obj) \<longleftrightarrow> (\<exists>obj :: 'a. injectKOS obj = KOTCB tcb \<and> P obj)))\<rbrace>
+       \<and> (\<forall>tcb d. \<not>tcbQueued tcb \<and> tcbState tcb = Inactive
+               \<longrightarrow> ((\<exists>obj :: 'a. injectKOS obj = KOTCB (tcb\<lparr>tcbDomain := d\<rparr>) \<and> P obj)
+                       \<longleftrightarrow> (\<exists>obj :: 'a. injectKOS obj = KOTCB tcb \<and> P obj)))\<rbrace>
      createNewCaps ty ptr n us d
    \<lbrace>\<lambda>rv s. obj_at' P p s\<rbrace>"
   apply (simp add: obj_at'_real_def)
   apply (wp createNewCaps_ko_wp_at')
   apply clarsimp
   apply (intro conjI impI)
-    apply simp+
-    apply clarsimp
-  apply (clarsimp simp: projectKOs dest!: iffD1 [OF project_koType, OF exI])
-  apply (clarsimp simp:project_inject)+
-done
+     apply simp+
+   apply (clarsimp simp: projectKOs dest!: iffD1 [OF project_koType, OF exI])
+   apply (clarsimp simp:project_inject)+
+  done
 
 lemma createNewCaps_obj_at':
   "\<lbrace>\<lambda>s. obj_at' (P :: ('a :: pspace_storable) \<Rightarrow> bool) p s
        \<and> range_cover ptr sz (APIType_capBits ty us) n \<and> n \<noteq> 0
-       \<and> pspace_aligned' s \<and> pspace_distinct' s
+       \<and> pspace_aligned' s \<and> pspace_distinct' s \<and> pspace_bounded' s
        \<and> pspace_no_overlap' ptr sz s
+       \<and> (ty = APIObjectType ArchTypes_H.apiobject_type.SchedContextObject
+                \<longrightarrow> sc_size_bounds us)
        \<and> koType(TYPE('a)) \<noteq> koType(TYPE(pde))
        \<and> (\<forall>tcb d. \<not>tcbQueued tcb \<and> tcbState tcb = Inactive \<longrightarrow> ((\<exists>obj :: 'a. injectKOS obj = KOTCB (tcb\<lparr>tcbDomain := d\<rparr>) \<and> P obj) \<longleftrightarrow> (\<exists>obj :: 'a. injectKOS obj = KOTCB tcb \<and> P obj)))\<rbrace>
      createNewCaps ty ptr n us d
@@ -4523,31 +4708,23 @@ lemma createNewCaps_idle'[wp]:
                       split del: if_split)
          apply (rename_tac apiobject_type)
          apply (case_tac apiobject_type, simp_all split del: if_split)[1]
-             apply (wp, simp)
-           including no_pre
-           apply (wp mapM_x_wp'
-                     createObjects_idle'
-                     threadSet_idle'
-                   | simp add: projectKO_opt_tcb projectKO_opt_cte
-                               makeObject_cte makeObject_tcb archObjSize_def
-                               tcb_cte_cases_def objBitsKO_def APIType_capBits_def
-                               ptBits_def pdBits_def pageBits_def objBits_def
-                               createObjects_def pteBits_def pdeBits_def
-                   | intro conjI impI
-                   | fastforce simp: curDomain_def)+
-  done
+  by (wpsimp wp: createObjects_idle'[where sz=sz] mapM_x_wp' split_del: if_split
+           simp:  curDomain_def APIType_capBits_def createObjects_def
+    | simp add: tcb_cte_cases_def projectKO_opt_tcb projectKO_opt_cte makeObject_tcb makeObject_cte
+                objBits_def objBitsKO_def ptBits_def pdBits_def pteBits_def pdeBits_def pageBits_def
+                scBits_simps archObjSize_def)+
 
 crunch ksArch[wp]: createNewCaps "\<lambda>s. P (ksArchState s)"
   (simp: crunch_simps unless_def wp: crunch_wps)
-crunch it[wp]: createNewCaps "\<lambda>s. P (ksIdleThread s)"
-  (simp: crunch_simps unless_def wp: crunch_wps updateObject_default_inv)
 crunch gsMaxObjectSize[wp]: createNewCaps "\<lambda>s. P (gsMaxObjectSize s)"
   (simp: crunch_simps unless_def wp: crunch_wps updateObject_default_inv)
 
 lemma createNewCaps_global_refs':
   "\<lbrace>\<lambda>s. range_cover ptr sz (APIType_capBits ty us) n \<and> n \<noteq> 0
-       \<and> pspace_aligned' s \<and> pspace_distinct' s
+       \<and> pspace_aligned' s \<and> pspace_distinct' s \<and> pspace_bounded' s
        \<and> pspace_no_overlap' ptr sz s \<and> valid_global_refs' s
+       \<and> (ty = APIObjectType ArchTypes_H.apiobject_type.SchedContextObject
+                \<longrightarrow> sc_size_bounds us)
        \<and> 0 < gsMaxObjectSize s\<rbrace>
      createNewCaps ty ptr n us d
    \<lbrace>\<lambda>rv. valid_global_refs'\<rbrace>"
@@ -4641,7 +4821,7 @@ lemma valid_pde_mappings'_def3:
 
 lemma createObjects'_pde_mappings'[wp]:
   "\<lbrace>\<lambda>s. valid_pde_mappings' s \<and> range_cover ptr sz (objBitsKO val + gbits) n  \<and> n \<noteq> 0
-            \<and> pspace_aligned' s \<and> pspace_distinct' s
+            \<and> pspace_aligned' s \<and> pspace_distinct' s \<and> pspace_bounded' s
             \<and> pspace_no_overlap' ptr sz s
             \<and> (\<forall>pde. projectKO_opt val = Some pde \<longrightarrow> pde = InvalidPDE)\<rbrace>
        createObjects' ptr n val gbits
@@ -4657,7 +4837,7 @@ lemma createObjects'_pde_mappings'[wp]:
 
 lemma createObjects_pde_mappings'[wp]:
   "\<lbrace>\<lambda>s. valid_pde_mappings' s \<and> range_cover ptr sz (objBitsKO ko + gbits) n  \<and> n \<noteq> 0
-            \<and> pspace_aligned' s \<and> pspace_distinct' s
+            \<and> pspace_aligned' s \<and> pspace_distinct' s \<and> pspace_bounded' s
             \<and> pspace_no_overlap' ptr sz s
             \<and> (\<forall>pde. projectKO_opt ko = Some pde \<longrightarrow> pde = InvalidPDE)\<rbrace>
        createObjects ptr n ko gbits
@@ -4703,8 +4883,10 @@ lemma mapM_x_copyGlobalMappings_pde_mappings':
 
 lemma createNewCaps_pde_mappings'[wp]:
   "\<lbrace>\<lambda>s. valid_pde_mappings' s \<and> range_cover ptr sz (APIType_capBits ty us) n \<and> n \<noteq> 0
+            \<and> (ty = APIObjectType ArchTypes_H.apiobject_type.SchedContextObject
+                 \<longrightarrow> sc_size_bounds us)
             \<and> valid_arch_state' s
-            \<and> pspace_aligned' s \<and> pspace_distinct' s
+            \<and> pspace_aligned' s \<and> pspace_distinct' s \<and> pspace_bounded' s
             \<and> pspace_no_overlap' ptr sz s\<rbrace>
        createNewCaps ty ptr n us d
    \<lbrace>\<lambda>_. valid_pde_mappings'\<rbrace>"
@@ -4728,9 +4910,8 @@ lemma createNewCaps_pde_mappings'[wp]:
   apply (case_tac ty; simp)
         apply (rename_tac apiobject_type)
         apply (case_tac apiobject_type)
-  apply (auto simp: ARM_H.toAPIType_def objBits_simps ptBits_def pageBits_def pteBits_def pdeBits_def
-                    makeObject_pde valid_arch_state'_def pdBits_def page_directory_at'_def)
-  done
+  by (auto simp: ARM_H.toAPIType_def objBits_simps ptBits_def pageBits_def pteBits_def pdeBits_def
+                 makeObject_pde valid_arch_state'_def pdBits_def page_directory_at'_def scBits_simps)
 
 lemma createObjects'_irq_states' [wp]:
   "\<lbrace>valid_irq_states'\<rbrace> createObjects' a b c d \<lbrace>\<lambda>_. valid_irq_states'\<rbrace>"
@@ -4744,12 +4925,12 @@ crunch irq_states' [wp]: createNewCaps valid_irq_states'
 
 crunch ksMachine[wp]: createObjects "\<lambda>s. P (ksMachineState s)"
   (simp: crunch_simps unless_def)
-crunch cur_domain[wp]: createObjects "\<lambda>s. P (ksCurDomain s)"
-  (simp: unless_def)
 
 lemma createNewCaps_valid_queues':
   "\<lbrace>valid_queues' and pspace_no_overlap' ptr sz
-       and pspace_aligned' and pspace_distinct'
+       and pspace_aligned' and pspace_distinct' and pspace_bounded'
+       and K (ty = APIObjectType ArchTypes_H.apiobject_type.SchedContextObject
+                \<longrightarrow> sc_size_bounds us)
        and K (range_cover ptr sz (APIType_capBits ty us) n \<and> n \<noteq> 0)\<rbrace>
      createNewCaps ty ptr n us d
    \<lbrace>\<lambda>rv. valid_queues'\<rbrace>"
@@ -4765,16 +4946,70 @@ lemma createNewCaps_valid_queues':
 
 lemma createNewCaps_valid_queues:
   "\<lbrace>valid_queues and pspace_no_overlap' ptr sz
-       and pspace_aligned' and pspace_distinct'
+       and pspace_aligned' and pspace_distinct' and pspace_bounded'
+       and K (ty = APIObjectType ArchTypes_H.apiobject_type.SchedContextObject
+                \<longrightarrow> sc_size_bounds us)
        and K (range_cover ptr sz (APIType_capBits ty us) n \<and> n \<noteq> 0)\<rbrace>
      createNewCaps ty ptr n us d
    \<lbrace>\<lambda>rv. valid_queues\<rbrace>"
-apply (rule hoare_gen_asm)
-apply (wp valid_queues_lift_asm createNewCaps_obj_at2[where sz=sz])
-apply (clarsimp simp: projectKO_opts_defs)
-apply (simp add: inQ_def)
-apply (wp createNewCaps_pred_tcb_at'[where sz=sz] | simp)+
-done
+  apply (rule hoare_gen_asm)
+  apply (wp valid_queues_lift_asm createNewCaps_obj_at2[where sz=sz])
+       apply (clarsimp simp: projectKO_opts_defs)
+       apply (simp add: inQ_def)
+      apply (wp createNewCaps_pred_tcb_at'[where sz=sz] | simp)+
+  done
+
+lemma valid_release_queue_lift_asm':
+  assumes tat: "\<And>t. \<lbrace>\<lambda>s. \<not> obj_at' tcbInReleaseQueue t s \<and> Q s\<rbrace> f \<lbrace>\<lambda>_ s. \<not> obj_at' tcbInReleaseQueue t s\<rbrace>"
+  and     prq: "\<And>P. \<lbrace>\<lambda>s. P (ksReleaseQueue s)\<rbrace> f \<lbrace>\<lambda>_ s. P (ksReleaseQueue s)\<rbrace>"
+  shows   "\<lbrace>\<lambda>s. valid_release_queue' s \<and> Q s\<rbrace> f \<lbrace>\<lambda>_. valid_release_queue'\<rbrace>"
+  apply (simp only: valid_release_queue'_def imp_conv_disj)
+  apply (wp hoare_vcg_all_lift hoare_vcg_disj_lift
+            tat prq)
+  apply simp
+  done
+
+lemma valid_release_queue_lift_asm:
+  assumes tat: "\<And>tcb. \<lbrace>obj_at' tcbInReleaseQueue tcb and Q \<rbrace> f \<lbrace>\<lambda>_. obj_at' tcbInReleaseQueue tcb\<rbrace>"
+  and     prq: "\<And>P. \<lbrace>\<lambda>s. P (ksReleaseQueue s) \<rbrace> f \<lbrace>\<lambda>_ s. P (ksReleaseQueue s)\<rbrace>"
+  shows   "\<lbrace>Invariants_H.valid_release_queue and Q\<rbrace> f \<lbrace>\<lambda>_. Invariants_H.valid_release_queue\<rbrace>"
+  apply (simp only: valid_release_queue_def imp_conv_disj)
+  apply (wp hoare_vcg_all_lift hoare_vcg_disj_lift
+            tat prq)
+  apply simp
+  done
+
+lemma createNewCaps_valid_release_queue':
+  "\<lbrace>valid_release_queue' and pspace_no_overlap' ptr sz
+       and pspace_aligned' and pspace_distinct' and pspace_bounded'
+       and K (ty = APIObjectType ArchTypes_H.apiobject_type.SchedContextObject
+                \<longrightarrow> sc_size_bounds us)
+       and K (range_cover ptr sz (APIType_capBits ty us) n \<and> n \<noteq> 0)\<rbrace>
+     createNewCaps ty ptr n us d
+   \<lbrace>\<lambda>rv. valid_release_queue'\<rbrace>"
+  apply (wp valid_release_queue_lift_asm' [OF createNewCaps_obj_at2])
+  apply (clarsimp simp: projectKOs)
+  apply (simp add: makeObjectKO_def
+            split: object_type.split_asm
+                   apiobject_type.split_asm)
+  apply (auto simp: makeObject_tcb
+             split: object_type.splits apiobject_type.splits)
+  done
+
+lemma createNewCaps_valid_release_queue:
+  "\<lbrace>valid_release_queue and pspace_no_overlap' ptr sz
+       and pspace_aligned' and pspace_distinct' and pspace_bounded'
+       and K (ty = APIObjectType ArchTypes_H.apiobject_type.SchedContextObject
+                \<longrightarrow> sc_size_bounds us)
+       and K (range_cover ptr sz (APIType_capBits ty us) n \<and> n \<noteq> 0)\<rbrace>
+     createNewCaps ty ptr n us d
+   \<lbrace>\<lambda>rv. valid_release_queue\<rbrace>"
+  apply (rule hoare_gen_asm)
+  apply (wp valid_release_queue_lift_asm createNewCaps_obj_at2[where sz=sz])
+       apply (clarsimp simp: projectKO_opts_defs)
+       apply (simp add: inQ_def)
+      apply (wp createNewCaps_pred_tcb_at'[where sz=sz] | simp)+
+  done
 
 lemma mapM_x_threadSet_valid_pspace:
   "\<lbrace>valid_pspace' and K (curdom \<le> maxDomain)\<rbrace>
@@ -4787,9 +5022,14 @@ lemma mapM_x_threadSet_valid_pspace:
 lemma createNewCaps_valid_pspace:
   assumes  not_0: "n \<noteq> 0"
   and      cover: "range_cover ptr sz (APIType_capBits ty us) n"
-  shows "\<lbrace>\<lambda>s. pspace_no_overlap' ptr sz s \<and> valid_pspace' s
-  \<and> caps_no_overlap'' ptr sz s \<and> ptr \<noteq> 0 \<and> caps_overlap_reserved' {ptr..ptr + of_nat n * 2^(APIType_capBits ty us) - 1} s \<and> ksCurDomain s \<le> maxDomain\<rbrace>
-  createNewCaps ty ptr n us dev \<lbrace>\<lambda>r. valid_pspace'\<rbrace>"
+  and       tysc: "ty = APIObjectType ArchTypes_H.apiobject_type.SchedContextObject
+                     \<longrightarrow> sc_size_bounds us"
+  shows
+  "\<lbrace>\<lambda>s. pspace_no_overlap' ptr sz s \<and> valid_pspace' s
+     \<and> caps_no_overlap'' ptr sz s \<and> ptr \<noteq> 0 \<and> caps_overlap_reserved' {ptr..ptr + of_nat n * 2^(APIType_capBits ty us) - 1} s
+     \<and> ksCurDomain s \<le> maxDomain\<rbrace>
+   createNewCaps ty ptr n us dev
+   \<lbrace>\<lambda>r. valid_pspace'\<rbrace>"
   unfolding createNewCaps_def Arch_createNewCaps_def
   using valid_obj_makeObject_rules
   apply (clarsimp simp: ARM_H.toAPIType_def
@@ -4797,17 +5037,20 @@ lemma createNewCaps_valid_pspace:
   apply (cases ty, simp_all split del: if_split)
         apply (rename_tac apiobject_type)
         apply (case_tac apiobject_type, simp_all split del: if_split)
-            apply (rule hoare_pre, wp, clarsimp)
-           apply (insert cover)
-           apply (wp createObjects_valid_pspace_untyped' [OF _ not_0 , where ty="Inr ty" and sz = sz]
-                     mapM_x_threadSet_valid_pspace mapM_x_wp'
-                 | simp add: makeObjectKO_def archObjSize_def APIType_capBits_def
-                             objBits_simps pageBits_def pdBits_def ptBits_def not_0
-                             createObjects_def curDomain_def
-                             pteBits_def pdeBits_def
-                 | intro conjI impI
-                 | simp add: power_add field_simps)+
-done
+              apply (rule hoare_pre, wp, clarsimp)
+             apply (insert cover tysc)
+             (* for TCBObject, we need to know a bit more about tcbDomain *)
+             apply (simp add: curDomain_def)
+             apply (rule hoare_seq_ext[OF _ gets_sp])
+             apply (clarsimp simp: createObjects_def)
+             apply (rule hoare_assume_pre)
+  by (wpsimp wp: createObjects_valid_pspace_untyped'[of dev us _ "Inr ty", where ptr=ptr]
+                 mapM_x_wp'
+          split_del: if_split
+          simp: createObjects_def makeObjectKO_def objBits_def objBitsKO_def scBits_simps
+                power_add not_0 APIType_capBits_def field_simps pageBits_def
+                archObjSize_def ptBits_def pdBits_def pteBits_def pdeBits_def
+    | simp)+
 
 lemma copyGlobalMappings_inv[wp]:
   "\<lbrace>\<lambda>s. P (ksMachineState s)\<rbrace>
@@ -4861,9 +5107,8 @@ lemma createNewCaps_vms:
                split del: if_split
          | assumption)+
   apply (case_tac ty)
-   apply (auto simp: APIType_capBits_def archObjSize_def objBits_simps pageBits_def ptBits_def
-                     pdBits_def ARM_H.toAPIType_def object_type.splits pteBits_def pdeBits_def)
-  done
+  by (auto simp: APIType_capBits_def archObjSize_def objBits_simps pageBits_def ptBits_def
+                 pdBits_def ARM_H.toAPIType_def object_type.splits pteBits_def pdeBits_def scBits_simps)
 
 lemma createObjects_pspace_domain_valid':
   "\<lbrace>\<lambda>s. range_cover ptr sz (objBitsKO val + gbits) n \<and> n \<noteq> 0
@@ -4921,13 +5169,8 @@ lemma createNewCaps_pspace_domain_valid[wp]:
                      split del: if_split)+
   apply (simp add: ARM_H.toAPIType_def
             split: object_type.splits)
-  apply (auto simp: objBits_simps APIType_capBits_def pageBits_def
-                    pteBits_def pdeBits_def
-                    archObjSize_def ptBits_def pdBits_def)
-  done
-
-crunch cur_domain[wp]: createNewCaps "\<lambda>s. P (ksCurDomain s)"
-  (wp: crunch_wps)
+  by (auto simp: objBits_simps APIType_capBits_def pageBits_def scBits_simps
+                 pteBits_def pdeBits_def archObjSize_def ptBits_def pdBits_def)
 
 (* FIXME: move *)
 lemma ct_idle_or_in_cur_domain'_lift_futz:
@@ -4950,22 +5193,26 @@ proof -
   show ?thesis
     apply (simp add: ct_idle_or_in_cur_domain'_def tcb_in_cur_domain'_def)
     apply (rule hoare_pre)
-    apply (wps a b c d)
-    apply (wp static_imp_wp e' hoare_vcg_disj_lift)
+     apply (wps a b c d)
+     apply (wp static_imp_wp e' hoare_vcg_disj_lift)
     apply (auto simp: obj_at'_def ct_in_state'_def projectKOs st_tcb_at'_def)
     done
 qed
 
 lemma createNewCaps_ct_idle_or_in_cur_domain':
-  "\<lbrace>ct_idle_or_in_cur_domain' and pspace_aligned' and pspace_distinct' and pspace_no_overlap' ptr sz and ct_active' and K (range_cover ptr sz (APIType_capBits ty us) n \<and> 0 < n) \<rbrace>
+  "\<lbrace>ct_idle_or_in_cur_domain' and pspace_aligned' and pspace_distinct' and pspace_bounded'
+    and pspace_no_overlap' ptr sz
+    and K (ty = APIObjectType ArchTypes_H.apiobject_type.SchedContextObject
+                \<longrightarrow> sc_size_bounds us)
+    and ct_active' and K (range_cover ptr sz (APIType_capBits ty us) n \<and> 0 < n) \<rbrace>
     createNewCaps ty ptr n us dev
    \<lbrace>\<lambda>rv. ct_idle_or_in_cur_domain'\<rbrace>"
-apply (wp ct_idle_or_in_cur_domain'_lift_futz createNewCaps_obj_at'[where sz=sz] | simp)+
-done
+  by (wp ct_idle_or_in_cur_domain'_lift_futz createNewCaps_obj_at'[where sz=sz] | simp)+
 
 lemma sch_act_wf_lift_asm_futz:
   assumes tcb: "\<And>P t. \<lbrace>st_tcb_at' P t and Q \<rbrace> f \<lbrace>\<lambda>rv. st_tcb_at' P t\<rbrace>"
-  assumes tcbDomain: "\<And>P t. \<lbrace>obj_at' (\<lambda>tcb. runnable' (tcbState tcb) \<longrightarrow> P (tcbDomain tcb)) t and Q\<rbrace> f \<lbrace>\<lambda>rv. obj_at' (\<lambda>tcb. runnable' (tcbState tcb) \<longrightarrow> P (tcbDomain tcb)) t\<rbrace>"
+  assumes tcbDomain: "\<And>P t. \<lbrace>obj_at' (\<lambda>tcb. runnable' (tcbState tcb) \<longrightarrow> P (tcbDomain tcb)) t and Q\<rbrace>
+                             f \<lbrace>\<lambda>rv. obj_at' (\<lambda>tcb. runnable' (tcbState tcb) \<longrightarrow> P (tcbDomain tcb)) t\<rbrace>"
   assumes kCT: "\<And>P. \<lbrace>\<lambda>s. P (ksCurThread s)\<rbrace> f \<lbrace>\<lambda>_ s. P (ksCurThread s)\<rbrace>"
   assumes kCD: "\<And>P. \<lbrace>\<lambda>s. P (ksCurDomain s)\<rbrace> f \<lbrace>\<lambda>_ s. P (ksCurDomain s)\<rbrace>"
   assumes ksA: "\<And>P. \<lbrace>\<lambda>s. P (ksSchedulerAction s)\<rbrace> f \<lbrace>\<lambda>_ s. P (ksSchedulerAction s)\<rbrace>"
@@ -5034,39 +5285,45 @@ crunch ksDomScheduleIdx[wp]: createNewCaps "\<lambda>s. P (ksDomScheduleIdx s)"
   (wp: mapM_x_wp' simp: crunch_simps)
 
 lemma createObjects_null_filter':
-  "\<lbrace>\<lambda>s. P (null_filter' (ctes_of s)) \<and> makeObjectKO dev ty = Some val \<and>
+  "\<lbrace>\<lambda>s. P (null_filter' (ctes_of s)) \<and> makeObjectKO dev us d ty = Some val \<and>
         range_cover ptr sz (objBitsKO val + gbits) n \<and> n \<noteq> 0 \<and>
-        pspace_aligned' s \<and> pspace_distinct' s \<and> pspace_no_overlap' ptr sz s\<rbrace>
+        pspace_aligned' s \<and> pspace_distinct' s \<and> pspace_bounded' s \<and> pspace_no_overlap' ptr sz s\<rbrace>
    createObjects' ptr n val gbits
    \<lbrace>\<lambda>addrs a. P (null_filter' (ctes_of a))\<rbrace>"
-   apply (clarsimp simp: createObjects'_def split_def)
-   apply (wp hoare_unless_wp|wpc
-          | clarsimp simp:haskell_assert_def alignError_def
-            split del: if_splits simp del:fun_upd_apply)+
-   apply (subst new_cap_addrs_fold')
-     apply (simp add:unat_1_0 unat_gt_0)
-     apply (rule range_cover_not_zero_shift)
+  apply (clarsimp simp: createObjects'_def split_def)
+  apply (wp hoare_unless_wp|wpc
+         | clarsimp simp: alignError_def split del: if_split simp del:fun_upd_apply)+
+  apply (subst new_cap_addrs_fold')
+   apply (simp add:unat_1_0 unat_gt_0)
+   apply (rule range_cover_not_zero_shift)
      apply fastforce+
-   apply (subst new_cap_addrs_fold')
-    apply (simp add:unat_1_0 unat_gt_0)
-    apply (rule range_cover_not_zero_shift)
-      apply simp
-     apply assumption
-    apply simp
-   apply (subst data_map_insert_def[symmetric])+
-   apply (frule(2) retype_aligned_distinct'[where ko = val])
-    apply (erule range_cover_rel)
-     apply simp+
-   apply (frule(2) retype_aligned_distinct'(2)[where ko = val])
-    apply (erule range_cover_rel)
-     apply simp+
-   apply (frule null_filter_ctes_retype
-     [where addrs = "(new_cap_addrs (unat (((of_nat n)::word32) << gbits)) ptr val)"])
-          apply assumption+
-     apply (clarsimp simp:field_simps foldr_upd_app_if[folded data_map_insert_def] shiftl_t2n range_cover.unat_of_nat_shift)+
+  apply (subst new_cap_addrs_fold')
+   apply (simp add:unat_1_0 unat_gt_0)
+   apply (rule range_cover_not_zero_shift)
+     apply simp
+    apply assumption
+   apply simp
+  apply (subst data_map_insert_def[symmetric])+
+  apply (frule (3) retype_aligned_distinct'[where ko = val])
+   apply (erule range_cover_rel)
+    apply simp+
+  apply (frule (3) retype_aligned_distinct'(2)[where ko = val])
+   apply (erule range_cover_rel)
+    apply simp+
+  apply (frule (3) retype_aligned_distinct'(3)[where ko = val])
+   apply (erule range_cover_rel)
+    apply simp+
+  apply (frule null_filter_ctes_retype[where addrs =
+                                       "new_cap_addrs (unat ((of_nat n::word32) << gbits)) ptr val"])
+        apply assumption+
+       apply (prop_tac "objBitsKO val < word_bits")
+        apply (clarsimp simp: range_cover_def word_bits_def)
+      apply (clarsimp simp: field_simps foldr_upd_app_if[folded data_map_insert_def] shiftl_t2n
+                            range_cover.unat_of_nat_shift)+
     apply (rule new_cap_addrs_aligned[THEN bspec])
-    apply (erule range_cover.aligned[OF range_cover_rel])
-     apply simp+
+     apply (erule range_cover.aligned[OF range_cover_rel])
+      apply simp+
+    apply (clarsimp simp: range_cover_def word_bits_def)
    apply (clarsimp simp:shiftl_t2n field_simps range_cover.unat_of_nat_shift)
    apply (drule subsetD[OF new_cap_addrs_subset,rotated])
     apply (erule range_cover_rel)
@@ -5079,36 +5336,36 @@ lemma createObjects_null_filter':
     apply (drule(1) pspace_alignedD')
     apply (clarsimp)
     apply (erule is_aligned_no_overflow)
-    apply (simp del:atLeastAtMost_iff atLeastatMost_subset_iff atLeastLessThan_iff
-        Int_atLeastAtMost atLeastatMost_empty_iff add:Int_ac ptr_add_def p_assoc_help)
+   apply (simp del:atLeastAtMost_iff atLeastatMost_subset_iff atLeastLessThan_iff
+                   Int_atLeastAtMost atLeastatMost_empty_iff add:Int_ac ptr_add_def p_assoc_help)
   apply (simp add:field_simps foldr_upd_app_if[folded data_map_insert_def] shiftl_t2n)
   apply auto
   done
 
 lemma createNewCaps_null_filter':
   "\<lbrace>(\<lambda>s. P (null_filter' (ctes_of s)))
-      and pspace_aligned' and pspace_distinct' and pspace_no_overlap' ptr sz
+      and pspace_aligned' and pspace_distinct' and pspace_bounded' and pspace_no_overlap' ptr sz
+      and K (ty = APIObjectType ArchTypes_H.apiobject_type.SchedContextObject
+                \<longrightarrow> sc_size_bounds us)
       and K (range_cover ptr sz (APIType_capBits ty us) n \<and> n \<noteq> 0) \<rbrace>
      createNewCaps ty ptr n us dev
    \<lbrace>\<lambda>_ s. P (null_filter' (ctes_of s))\<rbrace>"
   apply (rule hoare_gen_asm)
   apply (simp add: createNewCaps_def toAPIType_def
                    Arch_createNewCaps_def
-               split del: if_split cong: option.case_cong)
+            split del: if_split cong: option.case_cong)
   apply (cases ty, simp_all split del: if_split)
           apply (rename_tac apiobject_type)
           apply (case_tac apiobject_type, simp_all split del: if_split)
               apply (rule hoare_pre, wp,simp)
-             apply (simp add: createObjects_def makeObjectKO_def
-                              APIType_capBits_def objBits_def pageBits_def
-                              archObjSize_def ptBits_def pdBits_def curDomain_def
-                              objBits_if_dev
-                       split del: if_split
-                    | wp createObjects_null_filter'[where ty = "Inr ty" and sz = sz and dev=dev]
-                         copyGlobalMappings_ctes_of threadSet_ctes_of mapM_x_wp'
-                    | simp add: objBits_simps pteBits_def pdeBits_def
-                    | fastforce)+
-  done
+             by (simp add: createObjects_def makeObjectKO_def scBits_simps
+                           APIType_capBits_def objBits_def pageBits_def
+                           archObjSize_def ptBits_def pdBits_def curDomain_def objBits_if_dev
+                    split del: if_split
+                | wp createObjects_null_filter'[where ty = "Inr ty" and sz = sz and dev=dev]
+                     copyGlobalMappings_ctes_of threadSet_ctes_of mapM_x_wp'
+                | simp add: objBits_simps pteBits_def pdeBits_def
+                | fastforce)+
 
 crunch gsUntypedZeroRanges[wp]: createNewCaps "\<lambda>s. P (gsUntypedZeroRanges s)"
   (wp: crunch_wps simp: crunch_simps unless_def)
@@ -5143,42 +5402,30 @@ lemma createNewCaps_urz:
   done
 
 lemma createNewCaps_invs':
-  "\<lbrace>(\<lambda>s. invs' s \<and> ct_active' s \<and> pspace_no_overlap' ptr sz s
+  "\<lbrace>((\<lambda>s. invs' s \<and> ct_active' s \<and> pspace_no_overlap' ptr sz s
         \<and> caps_no_overlap'' ptr sz s \<and> ptr \<noteq> 0
         \<and> {ptr .. (ptr && ~~ mask sz) + 2 ^ sz - 1} \<inter> kernel_data_refs = {}
         \<and> caps_overlap_reserved' {ptr..ptr + of_nat n * 2^(APIType_capBits ty us) - 1} s
         \<and> (ty = APIObjectType ArchTypes_H.CapTableObject \<longrightarrow> us > 0)
         \<and> gsMaxObjectSize s > 0)
+        and K (ty = APIObjectType ArchTypes_H.SchedContextObject \<longrightarrow> sc_size_bounds us))
        and K (range_cover ptr sz (APIType_capBits ty us) n \<and> n \<noteq> 0)\<rbrace>
      createNewCaps ty ptr n us dev
    \<lbrace>\<lambda>rv. invs'\<rbrace>"
   (is "\<lbrace>?P and K ?Q\<rbrace> ?f \<lbrace>\<lambda>rv. invs'\<rbrace>")
 proof (rule hoare_gen_asm, erule conjE)
   assume cover: "range_cover ptr sz (APIType_capBits ty us) n" and not_0: "n \<noteq> 0"
-  have cnc_ct_not_inQ:
-    "\<lbrace>ct_not_inQ and valid_pspace' and pspace_no_overlap' ptr sz\<rbrace>
-     createNewCaps ty ptr n us dev \<lbrace>\<lambda>_. ct_not_inQ\<rbrace>"
-    unfolding ct_not_inQ_def
-    apply (rule_tac Q="\<lambda>s. ksSchedulerAction s = ResumeCurrentThread
-                             \<longrightarrow> (obj_at' (Not \<circ> tcbQueued) (ksCurThread s) s
-                                  \<and> valid_pspace' s \<and> pspace_no_overlap' ptr sz s)"
-                    in hoare_pre_imp, clarsimp)
-    apply (rule hoare_convert_imp [OF createNewCaps_nosch])
-    apply (rule hoare_weaken_pre)
-     apply (wps createNewCaps_ct)
-     apply (wp createNewCaps_obj_at')
-    using cover not_0
-    apply (fastforce simp: valid_pspace'_def)
-    done
   show "\<lbrace>?P\<rbrace>
      createNewCaps ty ptr n us dev
    \<lbrace>\<lambda>rv. invs'\<rbrace>"
-  apply (simp add: invs'_def valid_state'_def
+  apply (rule hoare_gen_asm)
+  apply (simp add: invs'_def valid_dom_schedule'_def
                    pointerInUserData_def typ_at'_def)
     apply (rule hoare_pre)
      apply (wp createNewCaps_valid_pspace [OF not_0 cover]
-               createNewCaps_state_refs_of' [OF cover not_0 ]
-               createNewCaps_iflive' [OF cover not_0 ]
+               createNewCaps_state_refs_of' [OF cover not_0]
+               createNewCaps_list_refs_of_replies' [OF cover not_0]
+               createNewCaps_iflive' [OF cover not_0]
                irqs_masked_lift
                createNewCaps_ifunsafe'
                createNewCaps_cur [OF cover not_0]
@@ -5461,10 +5735,10 @@ lemma createObjects_ct_idle_or_in_cur_domain':
        and K (range_cover ptr sz (objBitsKO val + gSize) n \<and> n \<noteq> 0)\<rbrace>
      createObjects ptr n val gSize
    \<lbrace>\<lambda>_. ct_idle_or_in_cur_domain'\<rbrace>"
-apply (rule hoare_gen_asm)
-apply (wp ct_idle_or_in_cur_domain'_lift_futz createObjects_obj_at_other[where sz=sz])
-apply simp_all
-done
+  apply (rule hoare_gen_asm)
+  apply (wp ct_idle_or_in_cur_domain'_lift_futz createObjects_obj_at_other[where sz=sz])
+    apply simp_all
+  done
 
 lemma untyped_zero_ranges_cte_def:
   "untyped_ranges_zero_inv (cteCaps_of s) rs
@@ -5475,11 +5749,8 @@ lemma untyped_zero_ranges_cte_def:
   apply (safe, metis+)
   done
 
-crunch gsUntypedZeroRanges[wp]: createObjects "\<lambda>s. P (gsUntypedZeroRanges s)"
-  (simp: unless_def)
-
 lemma createObjects_untyped_ranges_zero':
-  assumes moKO: "makeObjectKO dev ty = Some val"
+  assumes moKO: "makeObjectKO dev us d ty = Some val"
   shows
   "\<lbrace>ct_active' and valid_pspace' and pspace_no_overlap' ptr sz
        and untyped_ranges_zero'
@@ -5519,6 +5794,8 @@ lemma createObjects_no_cte_invs:
         \<and> caps_overlap_reserved' {ptr..ptr + of_nat (n * 2 ^ gbits * 2 ^ objBitsKO val) - 1} s
         \<and> caps_no_overlap'' ptr sz s \<and>
        refs_of' val = {} \<and> \<not> live' val
+        \<and> (case val of KOReply r \<Rightarrow> replyNext_of r = None \<and> replyPrev r = None
+                     | _ \<Rightarrow> True)
             \<and> (\<forall>pde. projectKO_opt val = Some pde \<longrightarrow> pde = InvalidPDE)\<rbrace>
   createObjects ptr n val gbits
   \<lbrace>\<lambda>rv. invs'\<rbrace>"
@@ -5539,133 +5816,76 @@ proof -
       apply (simp)+
     done
   show ?thesis
-  apply (rule hoare_grab_asm)+
-   apply (clarsimp simp: invs'_def valid_state'_def)
-   apply wp
-   apply (rule hoare_pre)
-   apply (rule hoare_vcg_conj_lift)
-   apply (simp add: createObjects_def,wp createObjects_valid_pspace_untyped')
-   apply (wp assms | simp add: objBits_def)+
-   apply (wp createObjects_sch createObjects_queues)
-   apply (rule hoare_vcg_conj_lift)
-    apply (simp add: createObjects_def)
-    apply (wp createObjects_state_refs_of'')
-   apply (rule hoare_vcg_conj_lift)
-    apply (simp add: createObjects_def)
-    apply (wp createObjects_iflive')
-   apply (wp createObjects_no_cte_ifunsafe' irqs_masked_lift
-             createObjects_idle' createObjects_no_cte_valid_global
-             createObjects_valid_arch createObjects_irq_state
-             createObjects_no_cte_irq_handlers createObjects_cur'
-             createObjects_queues' [OF no_tcb]
-             assms | simp add: objBits_def )+
-  apply (rule hoare_vcg_conj_lift)
-   apply (simp add: createObjects_def)
-   apply (wp createObjects_idle')
-   apply (wp createObjects_no_cte_ifunsafe' irqs_masked_lift
-             createObjects_idle' createObjects_no_cte_valid_global
-             createObjects_valid_arch createObjects_irq_state
-             createObjects_no_cte_irq_handlers createObjects_cur'
-             createObjects_queues' [OF no_tcb] assms
-             createObjects_pspace_domain_valid co_ct_not_inQ
-             createObjects_ct_idle_or_in_cur_domain'
-             createObjects_untyped_ranges_zero'[OF moKO]
-         | simp)+
-  apply clarsimp
-  apply ((intro conjI; assumption?); simp add: valid_pspace'_def objBits_def)
-  apply (fastforce simp add: no_cte no_tcb split_def split: option.splits)
-  apply (clarsimp simp: invs'_def no_tcb valid_state'_def no_cte  split: option.splits)
-  done
+    apply (rule hoare_grab_asm)+
+    apply (clarsimp simp: invs'_def valid_dom_schedule'_def)
+     apply (rule hoare_pre)
+      apply (rule hoare_vcg_conj_lift)
+       apply (simp add: createObjects_def,wp createObjects_valid_pspace_untyped')
+          apply (wp assms | simp add: objBits_def)+
+      apply (wp createObjects_sch createObjects_queues)
+      apply (rule hoare_vcg_conj_lift)
+       apply (simp add: createObjects_def)
+       apply (wp createObjects_state_refs_of'')
+       apply (wpsimp wp: createObjects_list_refs_of_replies'')
+      apply (rule hoare_vcg_conj_lift)
+       apply (simp add: createObjects_def)
+       apply (wp createObjects_iflive')
+      apply (wp createObjects_no_cte_ifunsafe' irqs_masked_lift
+                createObjects_idle' createObjects_no_cte_valid_global
+                createObjects_valid_arch createObjects_irq_state
+                createObjects_no_cte_irq_handlers createObjects_cur'
+                createObjects_queues' [OF no_tcb]
+                createObjects_release_queue' [OF no_tcb]
+                createObjects_release_queue
+                assms | simp add: objBits_def )+
+      apply (rule hoare_vcg_conj_lift)
+      apply (wp createObjects_no_cte_ifunsafe' irqs_masked_lift
+                createObjects_idle' createObjects_no_cte_valid_global
+                createObjects_valid_arch createObjects_irq_state
+                createObjects_no_cte_irq_handlers createObjects_cur'
+                createObjects_queues' [OF no_tcb] assms
+                createObjects_release_queue' [OF no_tcb]
+                createObjects_release_queue
+                createObjects_pspace_domain_valid co_ct_not_inQ
+                createObjects_ct_idle_or_in_cur_domain'
+                createObjects_untyped_ranges_zero'[OF moKO]
+            | simp)+
+    apply clarsimp
+    apply ((intro conjI; assumption?); simp add: valid_pspace'_def objBits_def)
+    done
 qed
 
 lemma corres_retype_update_gsI:
   assumes not_zero: "n \<noteq> 0"
   and      aligned: "is_aligned ptr (objBitsKO ko + gbits)"
-  and obj_bits_api: "obj_bits_api (APIType_map2 ty) us =
-                     objBitsKO ko + gbits"
-  and        check: "sz < obj_bits_api (APIType_map2 ty) us \<longleftrightarrow>
-                     sz < objBitsKO ko + gbits"
-  and          usv: "APIType_map2 ty = Structures_A.CapTableObject \<Longrightarrow> 0 < us"
-  and           ko: "makeObjectKO dev ty = Some ko"
+  and obj_bits_api: "obj_bits_api (APIType_map2 ty) us = objBitsKO ko + gbits"
+  and        check: "sz < obj_bits_api (APIType_map2 ty) us \<longleftrightarrow> sz < objBitsKO ko + gbits"
+  and           ko: "makeObjectKO dev us d ty = Some ko"
+  and            tysc: "ty = Inr (APIObjectType SchedContextObject) \<longrightarrow> min_sched_context_bits \<le> us"
   and          orr: "obj_bits_api (APIType_map2 ty) us \<le> sz \<Longrightarrow>
-                     obj_relation_retype
-                       (default_object (APIType_map2 ty) dev us) ko"
+                     obj_relation_retype (default_object (APIType_map2 ty) dev us d) ko"
   and        cover: "range_cover ptr sz (obj_bits_api (APIType_map2 ty) us) n"
   and            f: "f = update_gs (APIType_map2 ty) us"
   shows "corres (\<lambda>rv rv'. rv' = g rv)
          (\<lambda>s. valid_pspace s \<and> pspace_no_overlap_range_cover ptr sz s
-            \<and> valid_mdb s \<and> valid_etcbs s \<and> valid_list s)
+            \<and> valid_mdb s \<and>  valid_list s)
          (\<lambda>s. pspace_aligned' s \<and> pspace_distinct' s \<and>
-              pspace_no_overlap' ptr sz s)
-         (retype_region2 ptr n us (APIType_map2 ty) dev)
+              pspace_no_overlap' ptr sz s \<and>
+              (ty = Inr (APIObjectType TCBObject) \<longrightarrow> d = ksCurDomain s))
+         (retype_region ptr n us (APIType_map2 ty) dev)
          (do addrs \<leftarrow> createObjects ptr n ko gbits;
              _ \<leftarrow> modify (f (set addrs));
              return (g addrs)
           od)"
-  using corres_retype' [OF not_zero aligned obj_bits_api check usv ko orr cover]
-  by (simp add: f)
+  using corres_retype' [OF not_zero aligned obj_bits_api check ko tysc orr cover]
+  by (clarsimp simp: f)
 
 lemma gcd_corres: "corres (=) \<top> \<top> (gets cur_domain) curDomain"
   by (simp add: curDomain_def state_relation_def)
 
-lemma retype_region2_extra_ext_mapM_x_corres:
-  shows "corres dc
-           (valid_etcbs and (\<lambda>s. \<forall>addr\<in>set addrs. tcb_at addr s))
-           (\<lambda>s. \<forall>addr\<in>set addrs. tcb_at' addr s)
-           (retype_region2_extra_ext addrs Structures_A.apiobject_type.TCBObject)
-           (mapM_x (\<lambda>addr. do cdom \<leftarrow> curDomain;
-                              threadSet (tcbDomain_update (\<lambda>_. cdom)) addr
-                           od)
-             addrs)"
-  apply (rule corres_guard_imp)
-    apply (simp add: retype_region2_extra_ext_def curDomain_mapM_x_futz[symmetric] when_def)
-    apply (rule corres_split_eqr[OF _ gcd_corres])
-      apply (rule_tac S="Id \<inter> {(x, y). x \<in> set addrs}"
-                  and P="\<lambda>s. (\<forall>t \<in> set addrs. tcb_at t s) \<and> valid_etcbs s"
-                  and P'="\<lambda>s. \<forall>t \<in> set addrs. tcb_at' t s"
-                   in corres_mapM_x)
-          apply simp
-          apply (rule corres_guard_imp)
-            apply (rule ethread_set_corres, simp_all add: etcb_relation_def non_exst_same_def)[1]
-            apply (case_tac tcb')
-            apply simp
-           apply fastforce
-          apply fastforce
-         apply (wp hoare_vcg_ball_lift | simp)+
-      apply auto[1]
-     apply (wp | simp add: curDomain_def)+
-  done
-
-lemma retype_region2_extra_ext_trivial:
-  "ty \<noteq> APIType_map2 (Inr (APIObjectType apiobject_type.TCBObject))
-      \<Longrightarrow> retype_region2_extra_ext ptrs ty = return ()"
-by (simp add: retype_region2_extra_ext_def when_def APIType_map2_def)
-
-lemma retype_region2_ext_retype_region_ArchObject_PageDirectoryObj:
-  "retype_region ptr n us (APIType_map2 (Inr PageDirectoryObject)) dev =
-  (retype_region2 ptr n us (APIType_map2 (Inr PageDirectoryObject)) dev :: obj_ref list det_ext_monad)"
-by (simp add: retype_region2_ext_retype_region retype_region2_extra_ext_def when_def APIType_map2_def)
-
-lemma retype_region2_valid_etcbs[wp]:"\<lbrace>valid_etcbs\<rbrace> retype_region2 a b c d dev \<lbrace>\<lambda>_. valid_etcbs\<rbrace>"
-  apply (simp add: retype_region2_def)
-  apply (simp add: retype_region2_ext_def bind_assoc)
-  apply wp
-  apply (clarsimp simp del: fun_upd_apply)
-  apply (blast intro: valid_etcb_fold_update)
-  done
-
-lemma retype_region2_obj_at:
-  assumes tytcb: "ty = Structures_A.apiobject_type.TCBObject"
-  shows "\<lbrace>\<top>\<rbrace> retype_region2 ptr n us ty dev \<lbrace>\<lambda>rv s. \<forall>x \<in> set rv. tcb_at x s\<rbrace>"
-  using tytcb unfolding retype_region2_def
-  apply (simp only: return_bind bind_return foldr_upd_app_if fun_app_def K_bind_def)
-  apply (wp dxo_wp_weak | simp)+
-  apply (auto simp: obj_at_def default_object_def is_tcb_def)
-  done
-
 lemma createObjects_tcb_at':
   "\<lbrakk>range_cover ptr sz (objBitsKO (injectKOS (makeObject::tcb))) n; n \<noteq> 0\<rbrakk> \<Longrightarrow>
-   \<lbrace>\<lambda>s. pspace_no_overlap' ptr sz s \<and> pspace_aligned' s \<and> pspace_distinct' s\<rbrace>
+   \<lbrace>\<lambda>s. pspace_no_overlap' ptr sz s \<and> pspace_aligned' s \<and> pspace_distinct' s \<and> pspace_bounded' s\<rbrace>
    createObjects ptr n (KOTCB makeObject) 0 \<lbrace>\<lambda>ptrs s. \<forall>addr\<in>set ptrs. tcb_at' addr s\<rbrace>"
   apply (rule hoare_strengthen_post[OF createObjects_ko_at_strg[where val = "(makeObject :: tcb)"]])
   apply (auto simp: obj_at'_def projectKOs project_inject objBitsKO_def objBits_def makeObject_tcb)
@@ -5711,7 +5933,9 @@ lemma corres_retype_region_createNewCaps:
                        (obj_bits_api (APIType_map2 (Inr ty)) us) n \<and>
                      n \<noteq> 0 \<and>
                      (APIType_map2 (Inr ty) = Structures_A.CapTableObject
-                       \<longrightarrow> 0 < us)"
+                       \<longrightarrow> 0 < us)
+                     \<and> (APIType_map2 (Inr ty) = Structures_A.SchedContextObject
+                            \<longrightarrow> sc_size_bounds us)"
             in corres_req, simp)
   apply (clarsimp simp add: createNewCaps_def toAPIType_def
                  split del: if_split cong: if_cong)
@@ -5737,44 +5961,49 @@ lemma corres_retype_region_createNewCaps:
                 apply simp
                apply (clarsimp simp: range_cover_def)
                apply (arith+)[4]
-           \<comment> \<open>TCB, EP, NTFN\<close>
-           apply (simp_all add: retype_region2_ext_retype_region bind_cong[OF curDomain_mapM_x_futz refl, unfolded bind_assoc]
-                     split del: if_split)[9] (* not PageDirectoryObject *)
-           apply (rule corres_guard_imp)
-             apply (rule corres_split_eqr)
-                apply (rule corres_split_nor)
-                   apply (rule corres_trivial, simp)
-                   apply (clarsimp simp: list_all2_same list_all2_map1 list_all2_map2
-                  objBits_simps APIType_map2_def)
-                  apply (simp add: APIType_map2_def)
-                  apply (rule retype_region2_extra_ext_mapM_x_corres)
-                 apply wp
-                apply wp
-               apply (rule corres_retype[where 'a = tcb],
-                      simp_all add: obj_bits_api_def objBits_simps' pageBits_def
-                                   APIType_map2_def makeObjectKO_def
-                                   other_objs_default_relation)[1]
-               apply (fastforce simp: range_cover_def)
-              apply ((wp retype_region2_obj_at | simp add: APIType_map2_def)+)[1]
-             apply ((wp createObjects_tcb_at'[where sz=sz] | simp add: APIType_map2_def objBits_simps' obj_bits_api_def)+)[1]
-            apply simp
-           apply simp
-          apply (subst retype_region2_extra_ext_trivial)
-           apply (simp add: APIType_map2_def)
-          apply (simp add: liftM_def[symmetric] split del: if_split)
-          apply (rule corres_rel_imp)
-           apply (rule corres_guard_imp)
+           \<comment> \<open>TCB\<close>
+             apply (simp_all add: curDomain_def split del: if_split)
+             apply (rule corres_underlying_gets_pre_rhs[rotated])
+              apply (rule gets_sp)
+             apply (rule corres_guard_imp)
+               apply (rule corres_bind_return)
+               apply (rule corres_split_eqr)
+                  apply (rule corres_returnTT, simp)
+                  apply (clarsimp simp: list_all2_same list_all2_map1 list_all2_map2
+                                        objBits_simps APIType_map2_def)
+                 apply (rule corres_retype[where 'a = tcb],
+                        simp_all add: obj_bits_api_def objBits_simps' pageBits_def
+                                      APIType_map2_def makeObjectKO_def)[1]
+                  apply (fastforce simp: range_cover_def)
+                 apply (simp add: other_objs_default_relation)
+                apply ((wp | simp add: APIType_map2_def)+)[1]
+               apply ((wp createObjects_tcb_at'[where sz=sz] | simp add: APIType_map2_def objBits_simps' obj_bits_api_def)+)[1]
+              apply simp
+             apply simp
+        \<comment> \<open>CapTable\<close>
+        apply (find_goal \<open>match premises in "_ = ArchTypes_H.apiobject_type.CapTableObject" \<Rightarrow> \<open>-\<close>\<close>)
+        apply (subst bind_assoc_reverse[of "createObjects y n (KOCTE makeObject) us"])
+        apply (subst liftM_def [of "map (\<lambda>addr. capability.CNodeCap addr us 0 0)", symmetric])
+        apply simp
+        apply (rule corres_rel_imp)
+         apply (rule corres_guard_imp)
+          apply (rule corres_retype_update_gsI,
+                 simp_all add: obj_bits_api_def objBits_simps' pageBits_def
+                               APIType_map2_def makeObjectKO_def slot_bits_def
+                               field_simps ext)[1]
+             apply ((clarsimp simp : range_cover_def APIType_map2_def word_bits_def
+                                     list_all2_same list_all2_map1 list_all2_map2
+                   | rule captable_relation_retype)+)[5]
+           \<comment> \<open>EP, NTFN\<close>
+            apply (simp add: liftM_def[symmetric] split del: if_split)
+            apply (rule corres_rel_imp)
+             apply (rule corres_guard_imp)
              apply (rule corres_retype[where 'a = endpoint],
                     simp_all add: obj_bits_api_def objBits_simps' pageBits_def
                                   APIType_map2_def makeObjectKO_def
                                   other_objs_default_relation)[1]
-             apply (fastforce simp: range_cover_def)
-            apply simp
-           apply simp
-          apply (clarsimp simp: list_all2_same list_all2_map1 list_all2_map2
-                                objBits_simps APIType_map2_def)
-         apply (subst retype_region2_extra_ext_trivial)
-          apply (simp add: APIType_map2_def)
+             apply ((simp add: range_cover_def APIType_map2_def
+                            list_all2_same list_all2_map1 list_all2_map2)+)[4]
          apply (simp add: liftM_def[symmetric] split del: if_split)
          apply (rule corres_rel_imp)
           apply (rule corres_guard_imp)
@@ -5782,41 +6011,36 @@ lemma corres_retype_region_createNewCaps:
                    simp_all add: obj_bits_api_def objBits_simps' pageBits_def
                                  APIType_map2_def makeObjectKO_def
                                  other_objs_default_relation)[1]
-            apply (fastforce simp: range_cover_def)
-           apply simp
-          apply simp
-         apply (clarsimp simp: list_all2_same list_all2_map1 list_all2_map2
-                               objBits_simps APIType_map2_def)
-        \<comment> \<open>CapTable\<close>
-        apply (subst retype_region2_extra_ext_trivial)
-         apply (simp add: APIType_map2_def)
-        apply (subst bind_assoc_reverse[of "createObjects y n (KOCTE makeObject) us"])
-        apply (subst liftM_def
-               [of "map (\<lambda>addr. capability.CNodeCap addr us 0 0)", symmetric])
-        apply simp
-        apply (rule corres_rel_imp)
-         apply (rule corres_guard_imp)
-           apply (rule corres_retype_update_gsI,
-                 simp_all add: obj_bits_api_def objBits_simps' pageBits_def
-                               APIType_map2_def makeObjectKO_def slot_bits_def
-                               field_simps ext)[1]
-            apply (simp add: range_cover_def)
-           apply (rule captable_relation_retype,simp add: range_cover_def word_bits_def)
-          apply simp
-         apply simp
-        apply (clarsimp simp: list_all2_same list_all2_map1 list_all2_map2
-                              objBits_simps allRights_def APIType_map2_def
-                   split del: if_split)
+             apply ((simp add: range_cover_def APIType_map2_def
+                               list_all2_same list_all2_map1 list_all2_map2)+)[4]
+         \<comment> \<open>SchedContext\<close>
+         apply (simp add: liftM_def[symmetric] split del: if_split)
+         apply (rule corres_rel_imp)
+          apply (rule corres_guard_imp)
+            apply (rule corres_retype[where 'a = sched_context],
+                   simp_all add: obj_bits_api_def objBits_simps' pageBits_def
+                                 APIType_map2_def makeObjectKO_def scBits_simps
+                                 sc_relation_retype)[1]
+             apply ((simp add: range_cover_def APIType_map2_def sc_size_bounds_def
+                               list_all2_same list_all2_map1 list_all2_map2 sc_const_eq)+)[4]
+         \<comment> \<open>Reply\<close>
+         apply (simp add: liftM_def[symmetric] split del: if_split)
+         apply (rule corres_rel_imp)
+          apply (rule corres_guard_imp)
+            apply (rule corres_retype[where 'a = reply],
+                   simp_all add: obj_bits_api_def objBits_simps' pageBits_def
+                                 APIType_map2_def makeObjectKO_def
+                                 reply_relation_retype)[1]
+             apply ((simp add: range_cover_def APIType_map2_def
+                               list_all2_same list_all2_map1 list_all2_map2)+)[4]
           \<comment> \<open>SmallPageObject\<close>
-       apply (subst retype_region2_extra_ext_trivial)
-        apply (simp add: APIType_map2_def)
        apply (simp add: corres_liftM2_simp[unfolded liftM_def] split del: if_split)
        apply (rule corres_rel_imp)
         apply (simp add: init_arch_objects_APIType_map2_noop split del: if_split)
         apply (rule corres_guard_imp)
           apply (rule corres_retype_update_gsI,
                  simp_all add: APIType_map2_def makeObjectKO_def
-                     arch_default_cap_def obj_bits_api_def3
+                     arch_default_cap_def obj_bits_api_def
                      default_object_def default_arch_object_def pageBits_def
                      ext objBits_simps range_cover.aligned,
                      simp_all add: data_page_relation_retype)[1]
@@ -5824,15 +6048,13 @@ lemma corres_retype_region_createNewCaps:
        apply (simp add: APIType_map2_def arch_default_cap_def vmrights_map_def
                 vm_read_write_def list_all2_map1 list_all2_map2 list_all2_same)
          \<comment> \<open>LargePageObject\<close>
-      apply (subst retype_region2_extra_ext_trivial)
-       apply (simp add: APIType_map2_def)
       apply (simp add: corres_liftM2_simp[unfolded liftM_def] split del: if_split)
       apply (rule corres_rel_imp)
        apply (simp add: init_arch_objects_APIType_map2_noop split del: if_split)
        apply (rule corres_guard_imp)
          apply (rule corres_retype_update_gsI,
                 simp_all add: APIType_map2_def makeObjectKO_def
-                    arch_default_cap_def obj_bits_api_def3
+                    arch_default_cap_def obj_bits_api_def
                     default_object_def default_arch_object_def pageBits_def
                     ext objBits_simps range_cover.aligned,
                     simp_all add: data_page_relation_retype)[1]
@@ -5840,15 +6062,13 @@ lemma corres_retype_region_createNewCaps:
       apply (simp add: APIType_map2_def arch_default_cap_def vmrights_map_def
                vm_read_write_def list_all2_map1 list_all2_map2 list_all2_same)
         \<comment> \<open>SectionObject\<close>
-     apply (subst retype_region2_extra_ext_trivial)
-      apply (simp add: APIType_map2_def)
      apply (simp add: corres_liftM2_simp[unfolded liftM_def] split del: if_split)
      apply (rule corres_rel_imp)
       apply (simp add: init_arch_objects_APIType_map2_noop split del: if_split)
       apply (rule corres_guard_imp)
         apply (rule corres_retype_update_gsI,
                simp_all add: APIType_map2_def makeObjectKO_def
-                   arch_default_cap_def obj_bits_api_def3
+                   arch_default_cap_def obj_bits_api_def
                    default_object_def default_arch_object_def pageBits_def
                    ext objBits_simps range_cover.aligned,
                    simp_all add: data_page_relation_retype)[1]
@@ -5856,15 +6076,13 @@ lemma corres_retype_region_createNewCaps:
      apply (simp add: APIType_map2_def arch_default_cap_def vmrights_map_def
               vm_read_write_def list_all2_map1 list_all2_map2 list_all2_same)
     \<comment> \<open>SuperSectionObject\<close>
-    apply (subst retype_region2_extra_ext_trivial)
-     apply (simp add: APIType_map2_def)
     apply (simp add: corres_liftM2_simp[unfolded liftM_def] split del: if_split)
     apply (rule corres_rel_imp)
      apply (simp add: init_arch_objects_APIType_map2_noop split del: if_split)
      apply (rule corres_guard_imp)
        apply (rule corres_retype_update_gsI,
               simp_all add: APIType_map2_def makeObjectKO_def
-                  arch_default_cap_def obj_bits_api_def3
+                  arch_default_cap_def obj_bits_api_def
                   default_object_def default_arch_object_def pageBits_def
                   ext objBits_simps range_cover.aligned,
                   simp_all add: data_page_relation_retype)[1]
@@ -5872,8 +6090,6 @@ lemma corres_retype_region_createNewCaps:
     apply (simp add: APIType_map2_def arch_default_cap_def vmrights_map_def
              vm_read_write_def list_all2_map1 list_all2_map2 list_all2_same)
   \<comment> \<open>PageTable\<close>
-   apply (subst retype_region2_extra_ext_trivial)
-    apply (simp add: APIType_map2_def)
    apply (simp_all add: corres_liftM2_simp[unfolded liftM_def])
    apply (rule corres_guard_imp)
     apply (simp add: init_arch_objects_APIType_map2_noop)
@@ -5912,7 +6129,7 @@ lemma corres_retype_region_createNewCaps:
           apply (simp add: mapM_x_mapM)
           apply (rule corres_split'[where r' = dc])
              apply (rule_tac Q="\<lambda>xs s. (\<forall>x \<in> set xs. page_directory_at x s)
-                                    \<and> valid_arch_state s \<and> pspace_aligned s \<and> valid_etcbs s"
+                                    \<and> valid_arch_state s \<and> pspace_aligned s"
                           and Q'="\<lambda>xs s. (\<forall>x \<in> set xs. page_directory_at' x s) \<and> valid_arch_state' s"
                           in corres_mapM_list_all2[where r'=dc and S="(=)"])
                   apply simp+
@@ -5924,7 +6141,7 @@ lemma corres_retype_region_createNewCaps:
             apply simp
            apply wp+
        apply (rule corres_retype[where ty = "Inr PageDirectoryObject" and 'a = pde
-                    , simplified, folded retype_region2_ext_retype_region_ArchObject_PageDirectoryObj],
+                    , simplified],
               simp_all add: APIType_map2_def obj_bits_api_def
                             default_arch_object_def objBits_simps
                             archObjSize_def pdBits_def pageBits_def

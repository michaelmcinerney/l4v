--- EmptyFail_H.thy
+++ EmptyFail_H.thy
@@ -42,15 +63,15 @@ lemmas forME_x_empty_fail[intro!, wp, simp] = mapME_x_empty_fail[simplified forM
 
 lemma withoutPreemption_empty_fail[intro!, wp, simp]:
   "empty_fail m \<Longrightarrow> empty_fail (withoutPreemption m)"
-  by (simp add: withoutPreemption_def)
+  by simp
 
 lemma withoutFailure_empty_fail[intro!, wp, simp]:
   "empty_fail m \<Longrightarrow> empty_fail (withoutFailure m)"
-  by (simp add: withoutFailure_def)
+  by simp
 
 lemma catchFailure_empty_fail[intro!, wp, simp]:
   "\<lbrakk> empty_fail f; \<And>x. empty_fail (g x) \<rbrakk> \<Longrightarrow> empty_fail (catchFailure f g)"
-  by (simp add: catchFailure_def empty_fail_catch)
+  by (simp add: empty_fail_catch)
 
 lemma emptyOnFailure_empty_fail[intro!, wp, simp]:
   "empty_fail m \<Longrightarrow> empty_fail (emptyOnFailure m)"
@@ -162,8 +184,8 @@ lemma decodeCNodeInvocation_empty_fail[intro!, wp, simp]:
          apply (simp_all add: decodeCNodeInvocation_def
                          split_def cnode_invok_case_cleanup unlessE_whenE
                    cong: if_cong bool.case_cong list.case_cong)
-         apply (simp | wp | wpc | safe)+
-  done
+         by (simp | wp | wpc | safe)+
+
 
 lemma empty_fail_getObject_ap [intro!, wp, simp]:
   "empty_fail (getObject p :: asidpool kernel)"
@@ -184,13 +206,20 @@ lemma ignoreFailure_empty_fail[intro!, wp, simp]:
   "empty_fail x \<Longrightarrow> empty_fail (ignoreFailure x)"
   by (simp add: ignoreFailure_def empty_fail_catch)
 
+lemma empty_fail_getObject_sc [intro!, wp, simp]:
+   "empty_fail (getObject p :: sched_context kernel)"
+   by (simp add: empty_fail_getObject)
+
+crunch (empty_fail) "_H_empty_fail"[intro!, wp, simp]: "SchedContextDecls_H.postpone"
+  (simp: getSchedContext_def)
+
 context
 notes option.case_cong_weak[cong]
 begin
 crunch (empty_fail) empty_fail[intro!, wp, simp]:
-  cancelIPC, setThreadState, tcbSchedDequeue, setupReplyMaster, isStopped,
-  possibleSwitchTo, tcbSchedAppend
-  (simp: crunch_simps)
+  cancelIPC, setThreadState, tcbSchedDequeue, isStopped, possibleSwitchTo, tcbSchedAppend,
+  refillUnblockCheck, schedContextResume, ifCondRefillUnblockCheck
+  (simp: Let_def wp: empty_fail_whileLoop)
 end
 
 crunch (empty_fail) "_H_empty_fail"[intro!, wp, simp]: "ThreadDecls_H.suspend"
@@ -280,22 +309,41 @@ lemma catchError_empty_fail[intro!, wp, simp]:
   by (simp add: catchError_def handle_empty_fail)
 
 crunch (empty_fail) empty_fail[intro!, wp, simp]:
-  chooseThread, getDomainTime, nextDomain, isHighestPrio
-  (wp: empty_fail_catch)
+  chooseThread, getDomainTime, nextDomain, isHighestPrio, switchSchedContext, setNextInterrupt
+  (wp: empty_fail_catch empty_fail_setDeadline empty_fail_whileLoop)
+
+crunch (empty_fail) empty_fail[intro!, wp, simp]: tcbReleaseDequeue
+
+lemma awaken_empty_fail[intro!, wp, simp]:
+  "empty_fail awaken"
+  apply (clarsimp simp: awaken_def awakenBody_def)
+  apply (wpsimp wp: empty_fail_whileLoop)
+  done
 
 lemma ThreadDecls_H_schedule_empty_fail[intro!, wp, simp]:
   "empty_fail schedule"
-  apply (simp add: schedule_def)
+  apply (simp add: schedule_def scAndTimer_def checkDomainTime_def)
   apply (clarsimp simp: scheduleChooseNewThread_def split: if_split | wp | wpc)+
   done
 
+lemma tcbEPFindIndex_empty_fail[intro!, wp, simp]:
+  "empty_fail (tcbEPFindIndex t qs ci)"
+  by (induct ci; subst tcbEPFindIndex.simps; simp)
+
 crunch (empty_fail) empty_fail: callKernel
   (wp: empty_fail_catch)
 
 theorem call_kernel_serial:
   "\<lbrakk> (einvs and (\<lambda>s. event \<noteq> Interrupt \<longrightarrow> ct_running s) and (ct_running or ct_idle) and
-              (\<lambda>s. scheduler_action s = resume_cur_thread) and
-              (\<lambda>s. 0 < domain_time s \<and> valid_domain_list s)) s;
+                (\<lambda>s. scheduler_action s = resume_cur_thread) and
+                current_time_bounded 5 and
+                consumed_time_bounded and
+                valid_machine_time and
+                ct_not_in_release_q and
+                cur_sc_active and
+                (\<lambda>s. cur_sc_offset_ready (consumed_time s) s) and
+                (\<lambda>s. cur_sc_offset_sufficient (consumed_time s) s) and
+                (\<lambda>s. 0 < domain_time s \<and> valid_domain_list s)) s;
        \<exists>s'. (s, s') \<in> state_relation \<and>
             (invs' and (\<lambda>s. event \<noteq> Interrupt \<longrightarrow> ct_running' s) and (ct_running' or ct_idle') and
               (\<lambda>s. ksSchedulerAction s = ResumeCurrentThread) and

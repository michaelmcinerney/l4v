--- KHeap_R.thy
+++ KHeap_R.thy
@@ -6,81 +6,174 @@
 
 theory KHeap_R
 imports
-  "AInvs.ArchDetSchedSchedule_AI"
+  "AInvs.AInvs"
   Machine_R
 begin
 
+lemma obj_at_replyTCBs_of:
+  "obj_at' (\<lambda>reply. replyTCB reply = tptr_opt) rptr s
+   \<Longrightarrow> replyTCBs_of s rptr = tptr_opt"
+  by (clarsimp simp: obj_at'_def projectKOs opt_map_def)
+
+abbreviation
+  "valid_replies'_alt s \<equiv>
+     (\<forall>rptr rp. ko_at' rp rptr s \<and> ((\<exists>rp'. replyNext rp = Some (Next rp')) \<or> replyPrev rp \<noteq> None)
+                \<longrightarrow> (\<exists>tptr. replyTCB rp = Some tptr
+                            \<and> st_tcb_at' ((=) (BlockedOnReply (Some rptr))) tptr s))"
+
+lemma valid_replies'_def2:
+  "pspace_distinct' s \<Longrightarrow> pspace_aligned' s \<Longrightarrow>
+   valid_replies' s = valid_replies'_alt s"
+  unfolding valid_replies'_def
+  apply (rule iffI; clarsimp simp: obj_at'_def projectKOs valid_sz_simps)
+   apply (drule_tac x=rptr in spec, clarsimp simp: opt_map_def)
+  apply (clarsimp simp: pspace_alignedD' pspace_distinctD' opt_map_def projectKOs
+                  split: option.splits)
+  done
+
+primrec
+  same_caps' :: "Structures_H.kernel_object \<Rightarrow> Structures_H.kernel_object \<Rightarrow> bool"
+where
+  "same_caps' val (KOTCB tcb) = (\<exists>tcb'. val = KOTCB tcb' \<and>
+                                        (\<forall>(getF, t) \<in> ran tcb_cte_cases. getF tcb' = getF tcb))"
+| "same_caps' val (KOCTE cte) = (val = KOCTE cte)"
+| "same_caps' val (KOEndpoint ep) = (\<exists>ep'. val = KOEndpoint ep')"
+| "same_caps' val (KONotification ntfn) = (\<exists>ntfn'. val = KONotification ntfn')"
+| "same_caps' val (KOKernelData) = (val = KOKernelData)"
+| "same_caps' val (KOUserData) = (val = KOUserData)"
+| "same_caps' val (KOUserDataDevice) = (val = KOUserDataDevice)"
+| "same_caps' val (KOArch ao) = (\<exists>ao'. val = KOArch ao')"
+| "same_caps' val (KOSchedContext sc) = (\<exists>sc'. val = KOSchedContext sc')"
+| "same_caps' val (KOReply r) = (\<exists>r'. val = KOReply r')"
+
+lemma same_caps'_more_simps[simp]:
+  "same_caps' (KOTCB tcb) val = (\<exists>tcb'. val = KOTCB tcb' \<and>
+                                        (\<forall>(getF, t) \<in> ran tcb_cte_cases. getF tcb' = getF tcb))"
+  "same_caps' (KOCTE cte) val = (val = KOCTE cte)"
+  "same_caps' (KOEndpoint ep) val = (\<exists>ep'. val = KOEndpoint ep')"
+  "same_caps' (KONotification ntfn) val = (\<exists>ntfn'. val = KONotification ntfn')"
+  "same_caps' (KOKernelData) val = (val = KOKernelData)"
+  "same_caps' (KOUserData) val = (val = KOUserData)"
+  "same_caps' (KOUserDataDevice) val = (val = KOUserDataDevice)"
+  "same_caps' (KOArch ao) val = (\<exists>ao'. val = KOArch ao')"
+  "same_caps' (KOSchedContext sc) val = (\<exists>sc'. val = KOSchedContext sc')"
+  "same_caps' (KOReply r) val = (\<exists>r'. val = KOReply r')"
+  by (cases val; fastforce)+
+
 lemma lookupAround2_known1:
   "m x = Some y \<Longrightarrow> fst (lookupAround2 x m) = Some (x, y)"
   by (fastforce simp: lookupAround2_char1)
 
+abbreviation (input)
+  set_ko' :: "machine_word \<Rightarrow> kernel_object \<Rightarrow> kernel_state \<Rightarrow> kernel_state"
+where
+  "set_ko' ptr ko s \<equiv> s\<lparr>ksPSpace := (ksPSpace s)(ptr := Some ko)\<rparr>"
+
+abbreviation (input)
+  set_obj' :: "machine_word \<Rightarrow> ('a :: pspace_storable) \<Rightarrow> kernel_state \<Rightarrow> kernel_state"
+where
+  "set_obj' ptr obj s \<equiv> set_ko' ptr (injectKO obj) s"
+
 context begin interpretation Arch . (*FIXME: arch_split*)
 
+lemma ovalid_readObject[wp]:
+  assumes R:
+  "\<And>a n ko s obj::'a::pspace_storable.
+  \<lbrakk> loadObject t t n ko s = Some a; projectKO_opt ko = Some obj \<rbrakk> \<Longrightarrow> a = obj"
+  shows "ovalid (obj_at' P t) (readObject t) (\<lambda>(rv::'a::pspace_storable) _. P rv)"
+  by (auto simp: obj_at'_def readObject_def split_def omonad_defs obind_def
+                 lookupAround2_known1 projectKOs ovalid_def
+           dest: R)
+
 lemma obj_at_getObject:
   assumes R:
-  "\<And>a b p q n ko s obj::'a::pspace_storable.
-  \<lbrakk> (a, b) \<in> fst (loadObject t t n ko s); projectKO_opt ko = Some obj \<rbrakk> \<Longrightarrow> a = obj"
+  "\<And>a n ko s obj::'a::pspace_storable.
+  \<lbrakk> loadObject t t n ko s = Some a; projectKO_opt ko = Some obj \<rbrakk> \<Longrightarrow> a = obj"
   shows "\<lbrace>obj_at' P t\<rbrace> getObject t \<lbrace>\<lambda>(rv::'a::pspace_storable) s. P rv\<rbrace>"
-  by (auto simp: getObject_def obj_at'_def in_monad valid_def
-                 split_def projectKOs lookupAround2_known1
-           dest: R)
+  unfolding getObject_def
+  apply wpsimp
+  using R use_ovalid[OF ovalid_readObject] by blast
 
 declare projectKO_inv [wp]
 
 lemma loadObject_default_inv:
-  "\<lbrace>P\<rbrace> loadObject_default addr addr' next obj \<lbrace>\<lambda>rv. P\<rbrace>"
-  apply (simp add: loadObject_default_def magnitudeCheck_def
-                   alignCheck_def unless_def alignError_def
-          | wp hoare_vcg_split_case_option
-               hoare_drop_imps hoare_vcg_all_lift)+
-  done
+  "loadObject_default addr addr' next obj o\<lbrace> P \<rbrace>" by (simp add: ovalid_def)
 
 lemma getObject_inv:
-  assumes x: "\<And>p q n ko. \<lbrace>P\<rbrace> loadObject p q n ko \<lbrace>\<lambda>(rv :: 'a :: pspace_storable). P\<rbrace>"
-  shows      "\<lbrace>P\<rbrace> getObject p \<lbrace>\<lambda>(rv :: 'a :: pspace_storable). P\<rbrace>"
-  by (simp add: getObject_def split_def | wp x)+
-
-lemma getObject_inv_tcb [wp]: "\<lbrace>P\<rbrace> getObject l \<lbrace>\<lambda>(rv :: Structures_H.tcb). P\<rbrace>"
-  apply (rule getObject_inv)
-  apply simp
-  apply (rule loadObject_default_inv)
-  done
-end
-(* FIXME: this should go somewhere in spec *)
-translations
-  (type) "'a kernel" <=(type) "kernel_state \<Rightarrow> ('a \<times> kernel_state) set \<times> bool"
-
-context begin interpretation Arch . (*FIXME: arch_split*)
-
-lemma no_fail_loadObject_default [wp]:
-  "no_fail (\<lambda>s. \<exists>obj. projectKO_opt ko = Some (obj::'a) \<and>
+  "\<lbrace>P\<rbrace> getObject p \<lbrace>\<lambda>(rv :: 'a :: pspace_storable). P\<rbrace>"
+  unfolding getObject_def by wpsimp
+
+lemma getObject_tcb_inv [wp]: "\<lbrace>P\<rbrace> getObject l \<lbrace>\<lambda>(rv :: Structures_H.tcb). P\<rbrace>"
+  by (rule getObject_inv)
+
+lemma loadObject_default_Some [simp]:
+  "\<lbrakk>projectKO_opt ko = Some (obj::'a);
+                      is_aligned p (objBits obj); objBits obj < word_bits;
+                      case_option True (\<lambda>x. 2 ^ (objBits obj) \<le> x - p) n; q = p\<rbrakk>
+       \<Longrightarrow> bound (loadObject_default p q n ko s:: ('a::pre_storable) option)"
+  by (clarsimp simp: loadObject_default_def split_def projectKO_def obind_def
+                        alignCheck_def alignError_def magnitudeCheck_def projectKOs
+                        read_alignCheck_def read_alignError_def read_magnitudeCheck_def
+                        unless_def gets_the_def is_aligned_mask omonad_defs
+             split: option.splits) simp
+
+lemmas loadObject_default_Some'[simp, intro!] = loadObject_default_Some[simplified]
+lemmas loadObject_default_Some''[simp, intro!]
+        = loadObject_default_Some[where p=p and s=s and n="snd (lookupAround2 p (ksPSpace s))" for p s,
+                                 simplified]
+
+lemma no_ofail_loadObject_default [simp]:
+  "no_ofail (\<lambda>s. \<exists>obj. projectKO_opt ko = Some (obj::'a) \<and> objBits obj < word_bits \<and>
                       is_aligned p (objBits obj) \<and> q = p
                       \<and> case_option True (\<lambda>x. 2 ^ (objBits obj) \<le> x - p) n)
-           (loadObject_default p q n ko :: ('a::pre_storable) kernel)"
-  apply (simp add: loadObject_default_def split_def projectKO_def
-                   alignCheck_def alignError_def magnitudeCheck_def
-                   unless_def)
-  apply (rule no_fail_pre)
-   apply (wp case_option_wp)
-  apply (clarsimp simp: is_aligned_mask)
-  apply (clarsimp split: option.split_asm)
-  apply (clarsimp simp: is_aligned_mask[symmetric])
-  apply simp
-  done
-
-lemma no_fail_getObject_tcb [wp]:
+           (loadObject_default p q n ko :: ('a::pre_storable) kernel_r)"
+  by (clarsimp simp: no_ofail_def)
+
+method no_ofail_readObject_method =
+  clarsimp simp: obj_at'_def readObject_def obind_def omonad_defs split_def projectKO_eq no_ofail_def,
+  rule ps_clear_lookupAround2, assumption+, simp,
+  blast intro: is_aligned_no_overflow,
+  clarsimp simp: objBits_simps' project_inject word_bits_def split: option.splits
+
+lemma no_ofail_obj_at'_readObject_tcb[simp]:
+  "no_ofail (obj_at' (P::tcb \<Rightarrow> bool) p) (readObject p::tcb kernel_r)"
+  by no_ofail_readObject_method
+
+lemma no_ofail_obj_at'_readObject_ep[simp]:
+  "no_ofail (obj_at' (P::endpoint \<Rightarrow> bool) p) (readObject p::endpoint kernel_r)"
+  by no_ofail_readObject_method
+
+lemma no_ofail_obj_at'_readObject_ntfn[simp]:
+  "no_ofail (obj_at' (P::notification \<Rightarrow> bool) p) (readObject p::notification kernel_r)"
+  by no_ofail_readObject_method
+
+lemma no_ofail_obj_at'_readObject_reply[simp]:
+  "no_ofail (obj_at' (P::reply \<Rightarrow> bool) p) (readObject p::reply kernel_r)"
+  by no_ofail_readObject_method
+
+lemma no_ofail_obj_at'_readObject_sc[simp]:
+  "no_ofail (obj_at' (P::sched_context \<Rightarrow> bool) p) (readObject p::sched_context kernel_r)"
+  by no_ofail_readObject_method
+
+lemmas no_ofail_tcb_at'_readObject[wp] = no_ofail_obj_at'_readObject_tcb[where P=\<top>]
+lemmas no_ofail_ep_at'_readObject[wp] = no_ofail_obj_at'_readObject_ep[where P=\<top>]
+lemmas no_ofail_ntfn_at'_readObject[wp] = no_ofail_obj_at'_readObject_ntfn[where P=\<top>]
+lemmas no_ofail_reply_at'_readObject[wp] = no_ofail_obj_at'_readObject_reply[where P=\<top>]
+lemmas no_ofail_sc_at'_readObject[wp] = no_ofail_obj_at'_readObject_sc[where P=\<top>]
+
+lemma no_fail_getObject_misc[wp]:
   "no_fail (tcb_at' t) (getObject t :: tcb kernel)"
-  apply (simp add: getObject_def split_def)
-  apply (rule no_fail_pre)
-   apply wp
-  apply (clarsimp simp add: obj_at'_def projectKOs objBits_simps'
-                      cong: conj_cong)
-  apply (rule ps_clear_lookupAround2, assumption+)
-    apply simp
-   apply (simp add: field_simps)
-   apply (erule is_aligned_no_wrap')
-   apply simp
-  apply (fastforce split: option.split_asm simp: objBits_simps' archObjSize_def)
+  "no_fail (sc_at' t) (getObject t :: sched_context kernel)"
+  "no_fail (ep_at' t) (getObject t :: endpoint kernel)"
+  "no_fail (ntfn_at' t) (getObject t :: notification kernel)"
+  "no_fail (reply_at' t) (getObject t :: reply kernel)"
+  by (wpsimp simp: getObject_def wp: no_ofail_gets_the)+
+
+lemma lookupAround2_same1[simp]:
+  "(fst (lookupAround2 x s) = Some (x, y)) = (s x = Some y)"
+  apply (rule iffI)
+   apply (simp add: lookupAround2_char1)
+  apply (simp add: lookupAround2_known1)
   done
 
 lemma typ_at_to_obj_at':
@@ -90,7 +183,7 @@ lemma typ_at_to_obj_at':
 
 lemmas typ_at_to_obj_at_arches
   = typ_at_to_obj_at'[where 'a=pte, simplified]
-    typ_at_to_obj_at' [where 'a=pde, simplified]
+    typ_at_to_obj_at'[where 'a=pde, simplified]
     typ_at_to_obj_at'[where 'a=asidpool, simplified]
     typ_at_to_obj_at'[where 'a=user_data, simplified]
     typ_at_to_obj_at'[where 'a=user_data_device, simplified]
@@ -98,56 +191,126 @@ lemmas typ_at_to_obj_at_arches
 lemmas page_table_at_obj_at'
   = page_table_at'_def[unfolded typ_at_to_obj_at_arches]
 
+method readObject_obj_at'_method
+  =  clarsimp simp: readObject_def obind_def omonad_defs split_def loadObject_default_def
+                    obj_at'_def projectKOs objBits_simps' scBits_pos_power2
+             split: option.splits if_split_asm
 
-lemma corres_get_tcb [corres]:
-  "corres (tcb_relation \<circ> the) (tcb_at t) (tcb_at' t) (gets (get_tcb t)) (getObject t)"
-  apply (rule corres_no_failI)
-   apply wp
-  apply (clarsimp simp add: gets_def get_def return_def bind_def get_tcb_def)
-  apply (frule in_inv_by_hoareD [OF getObject_inv_tcb])
-  apply (clarsimp simp add: obj_at_def is_tcb obj_at'_def projectKO_def
-                            projectKO_opt_tcb split_def
-                            getObject_def loadObject_default_def in_monad)
-  apply (case_tac koa)
-   apply (simp_all add: fail_def return_def)
-  apply (case_tac bb)
-   apply (simp_all add: fail_def return_def)
-  apply (clarsimp simp add: state_relation_def pspace_relation_def)
-  apply (drule bspec)
-   apply clarsimp
-   apply blast
-  apply (clarsimp simp add: other_obj_relation_def
-                            lookupAround2_known1)
-  done
-
-lemma lookupAround2_same1[simp]:
-  "(fst (lookupAround2 x s) = Some (x, y)) = (s x = Some y)"
-  apply (rule iffI)
-   apply (simp add: lookupAround2_char1)
-  apply (simp add: lookupAround2_known1)
-  done
+lemma readObject_misc_ko_at'[simp]:
+  shows
+  readObject_ko_at'_tcb: "readObject p s = Some (tcb :: tcb) \<Longrightarrow> ko_at' tcb p s" and
+  readObject_ko_at'_ep: "readObject p s = Some (ep :: endpoint) \<Longrightarrow> ko_at' ep p s" and
+  readObject_ko_at'_ntfn: "readObject p s = Some (ntfn :: notification) \<Longrightarrow> ko_at' ntfn p s" and
+  readObject_ko_at'_reply: "readObject p s = Some (reply :: reply) \<Longrightarrow> ko_at' reply p s" and
+  readObject_ko_at'_sc: "readObject p s = Some (sc :: sched_context) \<Longrightarrow> ko_at' sc p s"
+  by readObject_obj_at'_method+
+
+lemma readObject_misc_obj_at'[simplified, simp]:
+  shows
+  readObject_tcb_at': "bound (readObject p s :: tcb option) \<Longrightarrow> tcb_at' p s" and
+  readObject_ep_at': "bound (readObject p s :: endpoint option) \<Longrightarrow> ep_at' p s" and
+  readObject_ntfn_at': "bound (readObject p s :: notification option) \<Longrightarrow> ntfn_at' p s" and
+  readObject_reply_at': "bound (readObject p s :: reply option) \<Longrightarrow> reply_at' p s" and
+  readObject_sc_at': "bound (readObject p s :: sched_context option) \<Longrightarrow> sc_at' p s"
+  by readObject_obj_at'_method+
 
 lemma getObject_tcb_at':
   "\<lbrace> \<top> \<rbrace> getObject t \<lbrace>\<lambda>r::tcb. tcb_at' t\<rbrace>"
-  by (clarsimp simp: valid_def getObject_def in_monad
-                     loadObject_default_def obj_at'_def projectKOs split_def
-                     in_magnitude_check objBits_simps')
-
-text \<open>updateObject_cte lemmas\<close>
+  unfolding getObject_def by wpsimp
 
 lemma koType_objBitsKO:
-  "koTypeOf k = koTypeOf k' \<Longrightarrow> objBitsKO k = objBitsKO k'"
+  "\<lbrakk>koTypeOf k' = koTypeOf k; koTypeOf k = SchedContextT \<longrightarrow> objBitsKO k' = objBitsKO k\<rbrakk>
+     \<Longrightarrow> objBitsKO k' = objBitsKO k"
   by (auto simp: objBitsKO_def archObjSize_def
           split: Structures_H.kernel_object.splits
                  ARM_H.arch_kernel_object.splits)
 
-lemma updateObject_objBitsKO:
-    "(ko', t') \<in> fst (updateObject (val :: 'a :: pspace_storable) ko p q n t)
-         \<Longrightarrow> objBitsKO ko' = objBitsKO ko"
-  apply (drule updateObject_type)
-  apply (erule koType_objBitsKO)
+lemma get_object_def2:
+  "get_object p = do
+     kh \<leftarrow> gets kheap;
+     assert (kh p \<noteq> None);
+     return $ the $ kh p
+   od"
+  apply (rule ext)
+  apply (rule monad_state_eqI)
+    apply ((clarsimp simp: get_object_def gets_the_def gets_def assert_opt_def in_monad
+                    split: option.splits)+)[2]
+  by (clarsimp simp: snd_bind get_object_def snd_gets_the assert_def exec_gets return_def)
+
+lemma getObject_def2:
+  "getObject ptr = do
+     map \<leftarrow> gets $ psMap \<circ> ksPSpace;
+     (before, after) \<leftarrow> return (lookupAround2 (fromPPtr ptr) map);
+     (ptr', val) \<leftarrow> assert_opt before;
+     gets_the $ loadObject (fromPPtr ptr) ptr' after val
+   od"
+  apply (rule ext)
+  apply (rule monad_state_eqI)
+    apply (force simp: getObject_def readObject_def gets_the_def exec_gets obind_def split_def
+                       omonad_defs assert_opt_def fail_def return_def in_monad ARM_H.fromPPtr_def
+                split: option.splits)+
+  by (clarsimp simp: snd_bind split_def getObject_def gets_the_def exec_gets assert_opt_def
+                     readObject_def obind_def omonad_defs return_def fail_def
+              split: option.splits)
+
+lemma loadObject_default_def2:
+  "(gets_the $ loadObject_default ptr ptr' next obj) = do
+     assert (ptr = ptr');
+     val \<leftarrow> (case projectKO_opt obj of None \<Rightarrow> fail | Some k \<Rightarrow> return k);
+     alignCheck ptr (objBits val);
+     assert (objBits val < word_bits);
+     magnitudeCheck ptr next (objBits val);
+     return val
+   od"
+  apply (rule ext)
+  apply (rule monad_state_eqI)
+    apply (force simp: loadObject_default_def gets_the_def exec_gets obind_def split_def
+                       omonad_defs assert_opt_def fail_def return_def in_monad ARM_H.fromPPtr_def
+                       read_magnitudeCheck_assert magnitudeCheck_assert projectKOs
+                split: option.splits if_splits)+
+  by (force simp: snd_bind split_def loadObject_default_def gets_the_def exec_gets assert_opt_def
+                  obind_def omonad_defs return_def fail_def projectKO_def assert_def
+                  read_magnitudeCheck_assert magnitudeCheck_assert
+                  read_alignError_def is_aligned_mask  alignCheck_def read_alignCheck_def
+           split: option.splits)
+
+lemma pspace_relation_tcb_at:
+  assumes p: "pspace_relation (kheap s) (ksPSpace s')"
+  assumes t: "tcbs_of' s' t \<noteq> None"
+  shows "tcb_at t s" using assms
+  by (fastforce elim!: pspace_dom_relatedE obj_relation_cutsE
+                 simp: other_obj_relation_def obj_at_def projectKOs is_tcb_def
+                split: Structures_A.kernel_object.split_asm if_split_asm
+                       ARM_A.arch_kernel_obj.split_asm kernel_object.splits)
+
+lemma pspace_relation_sc_at:
+  assumes p: "pspace_relation (kheap s) (ksPSpace s')"
+  assumes t: "scs_of' s' scp \<noteq> None"
+  shows "sc_at scp s" using assms
+  by (fastforce elim!: pspace_dom_relatedE obj_relation_cutsE
+                 simp: other_obj_relation_def is_sc_obj obj_at_def projectKOs
+                split: Structures_A.kernel_object.split_asm if_split_asm
+                       ARM_A.arch_kernel_obj.split_asm)
+
+lemma corres_get_tcb [corres]:
+  "corres (tcb_relation \<circ> the) (tcb_at t) (tcb_at' t) (gets (get_tcb t)) (getObject t)"
+  apply (rule corres_no_failI)
+   apply wp
+  apply (simp add: get_object_def get_tcb_def gets_def gets_the_def getObject_def)
+  apply (clarsimp simp: in_monad split_def bind_def gets_def get_def return_def
+                        assert_def fail_def obj_at_def is_tcb
+                 dest!: readObject_misc_ko_at')
+  apply (clarsimp simp: state_relation_def pspace_relation_def obj_at'_def projectKOs)
+  apply (drule bspec)
+   apply blast
+  apply (simp add: other_obj_relation_def)
   done
 
+lemmas tcbSlot_defs = tcbCTableSlot_def tcbVTableSlot_def tcbIPCBufferSlot_def
+                      tcbFaultHandlerSlot_def tcbTimeoutHandlerSlot_def
+
+text \<open>updateObject_cte lemmas\<close>
+
 lemma updateObject_cte_is_tcb_or_cte:
   fixes cte :: cte and ptr :: word32
   shows "\<lbrakk> fst (lookupAround2 p (ksPSpace s)) = Some (q, ko);
@@ -158,21 +321,24 @@ lemma updateObject_cte_is_tcb_or_cte:
   (\<exists>cte'. ko = KOCTE cte' \<and> ko' = KOCTE cte \<and> s' = s
         \<and> p = q \<and> is_aligned p cte_level_bits \<and> ps_clear p cte_level_bits s)"
   apply (clarsimp simp: updateObject_cte typeError_def alignError_def
-               tcbVTableSlot_def tcbCTableSlot_def to_bl_0 to_bl_1 rev_take objBits_simps'
-               in_monad map_bits_to_bl cte_level_bits_def in_magnitude_check field_simps
+               tcbVTableSlot_def tcbCTableSlot_def to_bl_1 rev_take objBits_simps'
+               in_monad map_bits_to_bl cte_level_bits_def in_magnitude_check
                lookupAround2_char1
          split: kernel_object.splits)
   apply (subst(asm) in_magnitude_check3, simp+)
-   apply (simp add: in_monad tcbCTableSlot_def tcbVTableSlot_def
-                    tcbReplySlot_def tcbCallerSlot_def tcbIPCBufferSlot_def
+   apply (simp add: in_monad tcbSlot_defs
              split: if_split_asm)
-  apply (simp add: in_monad tcbCTableSlot_def tcbVTableSlot_def
-                   tcbReplySlot_def tcbCallerSlot_def tcbIPCBufferSlot_def
+  apply (simp add: in_monad tcbSlot_defs
             split: if_split_asm)
   done
 
 declare plus_1_less[simp]
 
+lemma setObject_sc_at'_n[wp]:
+  "setObject ptr val \<lbrace>\<lambda>s. P (sc_at'_n n p s)\<rbrace>"
+  by (fastforce simp : valid_def setObject_def ko_wp_at'_def in_monad split_def updateObject_size
+                       ps_clear_upd lookupAround2_char1 updateObject_type word_bits_def)
+
 lemma updateObject_default_result:
   "(x, s'') \<in> fst (updateObject_default e ko p q n s) \<Longrightarrow> x = injectKO e"
   by (clarsimp simp add: updateObject_default_def in_monad)
@@ -188,13 +353,10 @@ lemma obj_at_setObject1:
   apply (rule hoare_seq_ext [OF _ hoare_gets_post])
   apply (clarsimp simp: valid_def in_monad obj_at'_def
                         projectKOs lookupAround2_char1
-                        project_inject
-                 dest!: R)
-  apply (subgoal_tac "objBitsKO (injectKO v) = objBitsKO (injectKO obj)")
+                        project_inject)
+  apply (frule updateObject_size, drule R)
    apply (intro conjI impI, simp_all)
       apply fastforce+
-  apply (fold objBits_def)
-  apply (rule Q)
   done
 
 lemma obj_at_setObject2:
@@ -219,56 +381,271 @@ lemma obj_at_setObject2:
   apply (clarsimp simp: ps_clear_upd lookupAround2_char1)
   done
 
-lemma updateObject_ep_eta:
-  "updateObject (v :: endpoint) = updateObject_default v"
-  by ((rule ext)+, simp)
+\<comment>\<open>
+  If the old and new versions of an object are the same size, then showing
+  `obj_at'` for the updated state is the same as showing the predicate for
+  the new value; we get to "reuse" the existing PSpace properties.
+\<close>
+lemma same_size_obj_at'_set_obj'_iff:
+  fixes obj :: "'a :: pspace_storable"
+  assumes "obj_at' (\<lambda>old_obj :: 'a. objBits old_obj = objBits obj) ptr s"
+  shows "obj_at' P ptr (set_obj' ptr obj s) = P obj"
+  apply (rule iffI)
+   apply (prop_tac "ko_at' obj ptr (set_obj' ptr obj s)")
+    apply (clarsimp simp: obj_at'_def projectKO_eq project_inject)
+   apply (clarsimp simp: obj_at'_def)
+  using assms
+  apply (fastforce simp: obj_at'_def inj_def projectKO_eq project_inject objBits_def)
+  done
+
+lemma tcb_at'_obj_at'_set_obj'[unfolded injectKO_tcb]:
+  assumes "P (tcb :: tcb)"
+      and "tcb_at' ptr s"
+  shows "obj_at' P ptr (set_obj' ptr tcb s)"
+  using assms
+  apply (clarsimp simp: objBits_def objBitsKO_def inj_def
+                        same_size_obj_at'_set_obj'_iff[where 'a=tcb, simplified])
+  done
+
+\<comment>\<open>
+  Keeps a generic @{term obj_at'} (rather than a specific @{term "obj_at' (\<lambda>_. True)"}) to match
+  in more simp contexts.
+\<close>
+lemma tcb_obj_at'_set_obj'_iff:
+  fixes tcb :: tcb
+    and P Q :: "tcb \<Rightarrow> bool"
+  shows "obj_at' P p s \<Longrightarrow> obj_at' Q p (set_obj' p tcb s) = Q tcb"
+  apply (rule same_size_obj_at'_set_obj'_iff)
+  apply (clarsimp simp: objBits_simps obj_at'_def)
+  done
+
+lemmas tcb_obj_at'_pred_tcb'_set_obj'_iff =
+  tcb_obj_at'_set_obj'_iff[where Q="test o proj o tcb_to_itcb'" for test proj,
+                                 simplified objBits_simps o_def, simplified,
+                                 folded pred_tcb_at'_def]
+
+lemma same_size_ko_wp_at'_set_ko'_iff:
+  assumes "ko_wp_at' (\<lambda>old_ko. objBitsKO old_ko = objBitsKO ko) ptr s"
+  shows "ko_wp_at' P ptr (set_ko' ptr ko s) = P ko"
+  apply (rule iffI)
+   apply (clarsimp simp: ko_wp_at'_def)
+  using assms
+  apply (clarsimp simp: ko_wp_at'_def)
+  apply (erule ps_clear_domE)
+  apply clarsimp
+  apply blast
+  done
+
+\<comment>\<open>
+  Moves the @{term ksPSpace_update} to the top.
+\<close>
+lemma unfold_set_ko':
+  "set_ko' ptr ko s = ksPSpace_update (\<lambda>ps. ps(ptr := Some ko)) s"
+  by clarsimp
+
+lemma ko_wp_at'_set_ko'_distinct:
+  assumes "ptr \<noteq> ptr'"
+          "ko_wp_at' \<top> ptr' s"
+  shows "ko_wp_at' P ptr (set_ko' ptr' ko s) = ko_wp_at' P ptr s"
+  using assms
+  apply (clarsimp simp: ko_wp_at'_def)
+  apply (rule iffI; clarsimp)
+   apply (erule ps_clear_domE)
+   apply clarsimp
+   apply blast
+  apply (erule ps_clear_domE)
+  apply clarsimp
+  apply blast
+  done
+
+lemma obj_at'_set_obj'_distinct:
+  assumes "p \<noteq> p'"
+          "obj_at' Q p' s"
+  shows "obj_at' P p (set_ko' p' ko s) = obj_at' P p s"
+  using assms apply -
+  apply (rule iffI; fastforce simp: obj_at'_def projectKO_eq project_inject ps_clear_upd)
+  done
+
+lemmas pred_tcb_at'_set_obj'_distinct =
+  obj_at'_set_obj'_distinct[where P="test o proj o tcb_to_itcb'" for test proj,
+                            simplified o_def, folded pred_tcb_at'_def]
+
+lemmas pred_tcb_at'_set_obj'_iff =
+  tcb_obj_at'_set_obj'_iff[where Q="test o proj o tcb_to_itcb'" for test proj,
+                           simplified o_def injectKO_tcb, folded pred_tcb_at'_def]
+
+lemma non_sc_same_typ_at'_objBits_always_the_same:
+  assumes "typ_at' t ptr s"
+          "koTypeOf ko = t"
+          "t \<noteq> SchedContextT"
+  shows "ko_wp_at' (\<lambda>old_ko. objBitsKO old_ko = objBitsKO ko) ptr s"
+  using assms
+  apply (clarsimp simp: typ_at'_def ko_wp_at'_def)
+  apply (rule koType_objBitsKO)
+  apply simp+
+  done
+
+lemmas non_sc_same_typ_at'_ko_wp_at'_set_ko'_iff =
+  same_size_ko_wp_at'_set_ko'_iff[OF non_sc_same_typ_at'_objBits_always_the_same]
+
+(* Worth adding other typ_at's? *)
+lemma typ_at'_ksPSpace_exI:
+  "pde_at' ptr s \<Longrightarrow> \<exists>pde. ksPSpace s ptr = Some (KOArch (KOPDE pde))"
+  "pte_at' ptr s \<Longrightarrow> \<exists>pte. ksPSpace s ptr = Some (KOArch (KOPTE pte))"
+  apply -
+  apply (clarsimp simp: typ_at'_def ko_wp_at'_def,
+         (case_tac ko; clarsimp),
+         (rename_tac arch, case_tac arch; clarsimp)?)+
+  done
+
+\<comment>\<open>
+  Used to show a stronger variant of @{thm obj_at_setObject2}
+  for many concrete types.
+
+  Needs to be a definition so we can easily refer to it within
+  ML as a constant.
+\<close>
+definition distinct_updateObject_types ::
+  "('a :: pspace_storable) itself \<Rightarrow> ('b :: pspace_storable) itself \<Rightarrow> bool"
+where
+  "distinct_updateObject_types t t' \<equiv>
+    (\<forall>ko' s' (v :: 'a) ko p before after s.
+      (ko', s') \<in> fst (updateObject v ko p before after s)
+      \<longrightarrow> koTypeOf ko' \<noteq> koType TYPE('b))"
 
-lemma updateObject_tcb_eta:
-  "updateObject (v :: tcb) = updateObject_default v"
-  by ((rule ext)+, simp)
+lemma setObject_distinct_types_preserves_obj_at'_pre:
+  fixes v :: "'a :: pspace_storable"
+    and P :: "'b :: pspace_storable \<Rightarrow> bool"
+  assumes distinct_types[unfolded distinct_updateObject_types_def, rule_format]:
+    "distinct_updateObject_types TYPE('a) TYPE('b)"
+  shows "setObject p v \<lbrace>\<lambda>s. P' (obj_at' P t s)\<rbrace>"
+  apply (simp add: setObject_def split_def)
+  apply (rule hoare_seq_ext [OF _ hoare_gets_post])
+  apply (clarsimp simp: valid_def in_monad)
+  apply (frule updateObject_type)
+  apply (erule_tac P="P'" in rsubst)
+  apply (drule distinct_types)
+  apply (clarsimp simp: lookupAround2_char1)
+  apply (case_tac "obj_at' P t s")
+   apply (clarsimp simp: obj_at'_def projectKOs)
+   using project_koType ps_clear_upd
+   apply fastforce
+  apply (clarsimp simp: obj_at'_def projectKOs ps_clear_upd)
+  apply (intro impI conjI iffI; metis project_koType)
+  done
 
-lemma updateObject_ntfn_eta:
-  "updateObject (v :: Structures_H.notification) = updateObject_default v"
-  by ((rule ext)+, simp)
+\<comment>\<open>
+  We're using @{command ML_goal} here because we want to show
+  `distinct_updateObject_types TYPE('a) TYPE('b)` for around
+  50 different combinations of 'a and 'b. Doing that by hand would
+  be painful, and not as clear for future readers as this comment
+  plus this ML code.
+\<close>
+ML \<open>
+local
+  val ko_types = [
+    @{typ notification},
+    @{typ tcb},
+    @{typ cte},
+    @{typ sched_context},
+    @{typ reply},
+    @{typ endpoint},
+
+    (*FIXME: arch_split*)
+    @{typ asidpool},
+    @{typ pte},
+    @{typ pde}
+  ];
+
+  val skipped_pairs = [
+    \<comment>\<open>
+      This corresponds to the case where we're inserting a CTE into
+      a TCB, which is the only case where the first two arguments
+      to `updateObject` should have different types.
+
+      See the comment on @{term updateObject} for more information.
+    \<close>
+    (@{typ cte}, @{typ tcb})
+  ];
+
+  fun skips (ts as (typ, typ')) =
+      typ = typ' orelse Library.member (op =) skipped_pairs ts;
+
+  fun mk_distinct_goal (typ, typ') =
+      Const (@{const_name distinct_updateObject_types},
+            Term.itselfT typ --> Term.itselfT typ' --> @{typ bool})
+      $ Logic.mk_type typ
+      $ Logic.mk_type typ';
+in
+  val distinct_updateObject_types_goals =
+      Library.map_product pair ko_types ko_types
+      |> Library.filter_out skips
+      |> List.map mk_distinct_goal
+end
+\<close>
 
-lemmas updateObject_eta =
-  updateObject_ep_eta updateObject_tcb_eta updateObject_ntfn_eta
+ML_goal distinct_updateObject_types: \<open>
+  distinct_updateObject_types_goals
+\<close>
+  apply -
+  \<comment>\<open>
+    The produced goals match the following pattern:
+  \<close>
+  apply (all \<open>match conclusion in \<open>distinct_updateObject_types _ _\<close> \<Rightarrow> -\<close>)
+  unfolding distinct_updateObject_types_def
+  apply safe
+  apply (clarsimp simp: distinct_updateObject_types_def
+                        setObject_def updateObject_cte updateObject_default_def
+                        typeError_def in_monad
+                 split: if_splits kernel_object.splits)+
+  done
+
+lemmas setObject_distinct_types_preserves_obj_at'[wp] =
+    distinct_updateObject_types[THEN setObject_distinct_types_preserves_obj_at'_pre]
+
+(* FIXME RT: these overlap substantially with `setObject_distinct_types_preserves_obj_at'`,
+   but fixing that requires having names for the relevant subset of lemmas. We can't do that with
+   attributes, but we might be able to do it with a new command (`lemmas_matching`?) once `match`
+   is factored.
+
+   This doesn't really matter in this case because you're never going to refer to these lemmas by
+   name. *)
+lemmas set_distinct_types_preserves_obj_at'[wp] =
+  setObject_distinct_types_preserves_obj_at'[folded setReply_def setNotification_def setCTE_def
+                                                    setSchedContext_def setEndpoint_def]
+
+lemmas set_distinct_types_preserves_pred_tcb_at'[wp] =
+  set_distinct_types_preserves_obj_at'[TRY[where P="test o proj o tcb_to_itcb'" for test proj,
+                                           simplified o_def, folded pred_tcb_at'_def, rule_format]]
+  setObject_distinct_types_preserves_obj_at'[TRY[where P="test o proj o tcb_to_itcb'" for test proj,
+                                             simplified o_def, folded pred_tcb_at'_def,
+                                             rule_format]]
 
-lemma objBits_type:
-  "koTypeOf k = koTypeOf k' \<Longrightarrow> objBitsKO k = objBitsKO k'"
-  by (erule koType_objBitsKO)
+end
 
 lemma setObject_typ_at_inv:
   "\<lbrace>typ_at' T p'\<rbrace> setObject p v \<lbrace>\<lambda>r. typ_at' T p'\<rbrace>"
-  apply (clarsimp simp: setObject_def split_def)
-  apply (clarsimp simp: valid_def typ_at'_def ko_wp_at'_def in_monad
-                        lookupAround2_char1 ps_clear_upd)
-  apply (drule updateObject_type)
-  apply clarsimp
-  apply (drule objBits_type)
-  apply (simp add: ps_clear_upd)
-  done
+  by (clarsimp simp: setObject_def split_def valid_def typ_at'_def ko_wp_at'_def in_monad
+                        lookupAround2_char1 ps_clear_upd updateObject_size updateObject_type)
 
 lemma setObject_typ_at_not:
   "\<lbrace>\<lambda>s. \<not> (typ_at' T p' s)\<rbrace> setObject p v \<lbrace>\<lambda>r s. \<not> (typ_at' T p' s)\<rbrace>"
   apply (clarsimp simp: setObject_def valid_def in_monad split_def)
   apply (erule notE)
-  apply (clarsimp simp: typ_at'_def ko_wp_at'_def lookupAround2_char1
-                 split: if_split_asm)
-   apply (drule updateObject_type)
-   apply clarsimp
-   apply (drule objBits_type)
-   apply (clarsimp elim!: ps_clear_domE)
-   apply fastforce
-  apply (clarsimp elim!: ps_clear_domE)
-  apply fastforce
-  done
+  by (clarsimp simp: typ_at'_def ko_wp_at'_def lookupAround2_char1
+                     updateObject_size updateObject_type
+              split: if_split_asm
+              elim!: ps_clear_domE)
+      fastforce+
 
 lemma setObject_typ_at'[wp]:
   "\<lbrace>\<lambda>s. P (typ_at' T p' s)\<rbrace> setObject p v \<lbrace>\<lambda>r s. P (typ_at' T p' s)\<rbrace>"
   by (blast intro: P_bool_lift setObject_typ_at_inv setObject_typ_at_not)
 
-lemmas setObject_typ_ats [wp] = typ_at_lifts [OF setObject_typ_at']
+global_interpretation setObject: typ_at_all_props' "setObject p v"
+  by typ_at_props'
+
+context begin interpretation Arch . (*FIXME: arch_split*)
 
 lemma setObject_cte_wp_at2':
   assumes x: "\<And>x n tcb s t. \<lbrakk> t \<in> fst (updateObject v (KOTCB tcb) ptr x n s); Q s;
@@ -311,49 +688,10 @@ lemma setObject_cte_wp_at':
   unfolding pred_conj_def
   by (rule setObject_cte_wp_at2'[OF x y], assumption+)
 
-lemma setObject_ep_pre:
-  assumes "\<lbrace>P and ep_at' p\<rbrace> setObject p (e::endpoint) \<lbrace>Q\<rbrace>"
-  shows "\<lbrace>P\<rbrace> setObject p (e::endpoint) \<lbrace>Q\<rbrace>" using assms
-  apply (clarsimp simp: valid_def setObject_def in_monad
-                        split_def updateObject_default_def
-                        projectKOs in_magnitude_check objBits_simps')
-  apply (drule spec, drule mp, erule conjI)
-   apply (simp add: obj_at'_def projectKOs objBits_simps')
-  apply (simp add: split_paired_Ball)
-  apply (drule spec, erule mp)
-  apply (clarsimp simp: in_monad projectKOs in_magnitude_check)
-  done
-
-lemma setObject_ntfn_pre:
-  assumes "\<lbrace>P and ntfn_at' p\<rbrace> setObject p (e::Structures_H.notification) \<lbrace>Q\<rbrace>"
-  shows "\<lbrace>P\<rbrace> setObject p (e::Structures_H.notification) \<lbrace>Q\<rbrace>" using assms
-  apply (clarsimp simp: valid_def setObject_def in_monad
-                        split_def updateObject_default_def
-                        projectKOs in_magnitude_check objBits_simps')
-  apply (drule spec, drule mp, erule conjI)
-   apply (simp add: obj_at'_def projectKOs objBits_simps')
-  apply (simp add: split_paired_Ball)
-  apply (drule spec, erule mp)
-  apply (clarsimp simp: in_monad projectKOs in_magnitude_check)
-  done
-
-lemma setObject_tcb_pre:
-  assumes "\<lbrace>P and tcb_at' p\<rbrace> setObject p (t::tcb) \<lbrace>Q\<rbrace>"
-  shows "\<lbrace>P\<rbrace> setObject p (t::tcb) \<lbrace>Q\<rbrace>" using assms
-  apply (clarsimp simp: valid_def setObject_def in_monad
-                        split_def updateObject_default_def
-                        projectKOs in_magnitude_check objBits_simps')
-  apply (drule spec, drule mp, erule conjI)
-   apply (simp add: obj_at'_def projectKOs objBits_simps')
-  apply (simp add: split_paired_Ball)
-  apply (drule spec, erule mp)
-  apply (clarsimp simp: in_monad projectKOs in_magnitude_check)
-  done
-
 lemma obj_at_setObject3:
   fixes Q::"'a::pspace_storable \<Rightarrow> bool"
   fixes P::"'a::pspace_storable \<Rightarrow> bool"
-  assumes R: "\<And>ko s x y n. (updateObject v ko p y n s)
+  assumes R: "\<And>ko s y n. (updateObject v ko p y n s)
                    = (updateObject_default v ko p y n s)"
   assumes P: "\<And>(v::'a::pspace_storable). (1 :: word32) < 2 ^ (objBits v)"
   shows "\<lbrace>(\<lambda>s. P v)\<rbrace> setObject p v \<lbrace>\<lambda>rv. obj_at' P p\<rbrace>"
@@ -382,27 +720,97 @@ lemma setObject_tcb_strongest:
                         ps_clear_upd)
   done
 
+method setObject_easy_cases =
+  clarsimp simp: setObject_def in_monad split_def valid_def lookupAround2_char1,
+  erule rsubst[where P=P'], rule ext,
+  clarsimp simp: updateObject_cte updateObject_default_def in_monad
+                 typeError_def opt_map_def projectKO_opts_defs projectKO_eq2
+          split: if_split_asm
+                 Structures_H.kernel_object.split_asm
+
+lemma setObject_endpoint_replies_of'[wp]:
+  "setObject c (endpoint::endpoint) \<lbrace>\<lambda>s. P' (replies_of' s)\<rbrace>"
+  by setObject_easy_cases
+
+lemma setObject_notification_replies_of'[wp]:
+  "setObject c (notification::notification) \<lbrace>\<lambda>s. P' (replies_of' s)\<rbrace>"
+  by setObject_easy_cases
+
+lemma setObject_tcb_replies_of'[wp]:
+  "setObject c (tcb::tcb) \<lbrace>\<lambda>s. P' (replies_of' s)\<rbrace>"
+  by setObject_easy_cases
+
+lemma setObject_sched_context_replies_of'[wp]:
+  "setObject c (sched_context::sched_context) \<lbrace>\<lambda>s. P' (replies_of' s)\<rbrace>"
+  by setObject_easy_cases
+
+lemma setObject_cte_replies_of'[wp]:
+  "setObject c (cte::cte) \<lbrace>\<lambda>s. P' (replies_of' s)\<rbrace>"
+  by setObject_easy_cases
+
+\<comment>\<open>
+  Warning: this may not be a weakest precondition. `setObject c`
+  asserts that there's already a correctly-typed object at `c`,
+  so a weaker valid precondition might be @{term
+    "\<lambda>s. replies_of' s c \<noteq> None \<longrightarrow>  P' ((replies_of' s)(c \<mapsto> reply))"
+  }
+\<close>
+lemma setObject_reply_replies_of'[wp]:
+  "\<lbrace>\<lambda>s. P' ((replies_of' s)(c \<mapsto> reply))\<rbrace>
+  setObject c (reply::reply)
+  \<lbrace>\<lambda>_ s. P' (replies_of' s)\<rbrace>"
+  by setObject_easy_cases
+
+\<comment>\<open>
+  Warning: this may not be a weakest precondition. `setObject c`
+  asserts that there's already a correctly-typed object at `c`,
+  so a weaker valid precondition might be @{term
+    "\<lambda>s. scs_of' s c \<noteq> None \<longrightarrow>  P' ((scs_of' s)(c \<mapsto> sched_context))"
+  }
+\<close>
+lemma setObject_sched_context_scs_of'[wp]:
+  "\<lbrace>\<lambda>s. P' ((scs_of' s)(c \<mapsto> sched_context))\<rbrace>
+  setObject c (sched_context::sched_context)
+  \<lbrace>\<lambda>_ s. P' (scs_of' s)\<rbrace>"
+  by setObject_easy_cases
+
+lemma setObject_scs_of'[wp]:
+  "setObject c (cte::cte) \<lbrace>\<lambda>s. P' (scs_of' s)\<rbrace>"
+  "setObject c (reply::reply) \<lbrace>\<lambda>s. P' (scs_of' s)\<rbrace>"
+  "setObject c (tcb::tcb) \<lbrace>\<lambda>s. P' (scs_of' s)\<rbrace>"
+  "setObject c (notification::notification) \<lbrace>\<lambda>s. P' (scs_of' s)\<rbrace>"
+  "setObject c (endpoint::endpoint) \<lbrace>\<lambda>s. P' (scs_of' s)\<rbrace>"
+  by setObject_easy_cases+
+
+lemmas setReply_replies_of' = setObject_reply_replies_of'[folded setReply_def]
+
+crunches setNotification, setEndpoint, setSchedContext, setCTE
+  for replies_of'[wp]: "\<lambda>s. P (replies_of' s)"
+
+lemmas setSchedContext_scs_of_of' =
+  setObject_sched_context_scs_of'[folded setSchedContext_def]
+
+crunches setNotification, setEndpoint, setCTE, setReply
+  for scs_of'[wp]: "\<lambda>s. P (scs_of' s)"
+
 lemma getObject_obj_at':
   assumes x: "\<And>q n ko. loadObject p q n ko =
-                (loadObject_default p q n ko :: ('a :: pspace_storable) kernel)"
-  assumes P: "\<And>(v::'a::pspace_storable). (1 :: word32) < 2 ^ (objBits v)"
+                (loadObject_default p q n ko :: ('a :: pspace_storable) kernel_r)"
   shows      "\<lbrace> \<top> \<rbrace> getObject p \<lbrace>\<lambda>r::'a::pspace_storable. obj_at' ((=) r) p\<rbrace>"
-  by (clarsimp simp: valid_def getObject_def in_monad
+  by (clarsimp simp: valid_def getObject_def in_monad omonad_defs readObject_def
                      loadObject_default_def obj_at'_def projectKOs
                      split_def in_magnitude_check lookupAround2_char1
-                     x P project_inject objBits_def[symmetric])
+                     x project_inject objBits_def[symmetric]
+              split: option.split_asm if_split_asm)
 
 lemma getObject_valid_obj:
   assumes x: "\<And>p q n ko. loadObject p q n ko =
-                (loadObject_default p q n ko :: ('a :: pspace_storable) kernel)"
-  assumes P: "\<And>(v::'a::pspace_storable). (1 :: word32) < 2 ^ (objBits v)"
+                (loadObject_default p q n ko :: ('a :: pspace_storable) kernel_r)"
   shows "\<lbrace> valid_objs' \<rbrace> getObject p \<lbrace>\<lambda>rv::'a::pspace_storable. valid_obj' (injectKO rv) \<rbrace>"
   apply (rule hoare_chain)
     apply (rule hoare_vcg_conj_lift)
-     apply (rule getObject_obj_at' [OF x P])
+     apply (rule getObject_obj_at' [OF x])
     apply (rule getObject_inv)
-    apply (subst x)
-    apply (rule loadObject_default_inv)
    apply (clarsimp, assumption)
   apply clarsimp
   apply (drule(1) obj_at_valid_objs')
@@ -411,25 +819,18 @@ lemma getObject_valid_obj:
 
 declare fail_inv[simp]
 
-declare return_inv[simp]
-
 lemma typeError_inv [wp]:
   "\<lbrace>P\<rbrace> typeError x y \<lbrace>\<lambda>rv. P\<rbrace>"
   by (simp add: typeError_def|wp)+
 
 lemma getObject_cte_inv [wp]: "\<lbrace>P\<rbrace> (getObject addr :: cte kernel) \<lbrace>\<lambda>rv. P\<rbrace>"
-  apply (simp add: getObject_def loadObject_cte split_def)
-  apply (clarsimp simp: valid_def in_monad)
-  apply (clarsimp simp: typeError_def in_monad magnitudeCheck_def
-                 split: kernel_object.split_asm if_split_asm option.split_asm)
-  done
+  by (wpsimp simp: getObject_def)
 
 lemma getObject_ko_at:
   assumes x: "\<And>q n ko. loadObject p q n ko =
-                (loadObject_default p q n ko :: ('a :: pspace_storable) kernel)"
-  assumes P: "\<And>(v::'a::pspace_storable). (1 :: word32) < 2 ^ (objBits v)"
+                (loadObject_default p q n ko :: ('a :: pspace_storable) kernel_r)"
   shows      "\<lbrace> \<top> \<rbrace> getObject p \<lbrace>\<lambda>r::'a::pspace_storable. ko_at' r p\<rbrace>"
-  by (subst eq_commute, rule getObject_obj_at' [OF x P])
+  by (subst eq_commute, rule getObject_obj_at' [OF x])
 
 lemma getObject_ko_at_tcb [wp]:
   "\<lbrace>\<top>\<rbrace> getObject p \<lbrace>\<lambda>rv::tcb. ko_at' rv p\<rbrace>"
@@ -448,126 +849,77 @@ lemma setObject_nosch:
   apply (wp x | simp)+
   done
 
-lemma getObject_ep_inv: "\<lbrace>P\<rbrace> (getObject addr :: endpoint kernel) \<lbrace>\<lambda>rv. P\<rbrace>"
-  apply (rule getObject_inv)
-  apply (simp add: loadObject_default_inv)
-  done
-
-lemma getObject_ntfn_inv:
-  "\<lbrace>P\<rbrace> (getObject addr :: Structures_H.notification kernel) \<lbrace>\<lambda>rv. P\<rbrace>"
-  apply (rule getObject_inv)
-  apply (simp add: loadObject_default_inv)
-  done
-
-lemma get_ep_inv'[wp]: "\<lbrace>P\<rbrace> getEndpoint ep \<lbrace>\<lambda>rv. P\<rbrace>"
-  by (simp add: getEndpoint_def getObject_ep_inv)
+context
+begin
 
-lemma get_ntfn_inv'[wp]: "\<lbrace>P\<rbrace> getNotification ntfn \<lbrace>\<lambda>rv. P\<rbrace>"
-  by (simp add: getNotification_def getObject_ntfn_inv)
+private method getObject_valid_obj =
+  rule hoare_chain,
+  rule getObject_valid_obj; clarsimp simp: objBits_simps' valid_obj'_def scBits_pos_power2
 
 lemma get_ep'_valid_ep[wp]:
-  "\<lbrace> invs' and ep_at' ep \<rbrace> getEndpoint ep \<lbrace> valid_ep' \<rbrace>"
-  apply (simp add: getEndpoint_def)
-  apply (rule hoare_chain)
-  apply (rule getObject_valid_obj)
-     apply simp
-    apply (simp add: objBits_simps')
-   apply clarsimp
-  apply (simp add: valid_obj'_def)
-  done
+  "\<lbrace> valid_objs' \<rbrace> getEndpoint ep \<lbrace> valid_ep' \<rbrace>"
+  unfolding getEndpoint_def by getObject_valid_obj
 
 lemma get_ntfn'_valid_ntfn[wp]:
-  "\<lbrace> invs' and ntfn_at' ep \<rbrace> getNotification ep \<lbrace> valid_ntfn' \<rbrace>"
-  apply (simp add: getNotification_def)
-  apply (rule hoare_chain)
-  apply (rule getObject_valid_obj)
-     apply simp
-    apply (simp add: objBits_simps')
-   apply clarsimp
-  apply (simp add: valid_obj'_def)
-  done
+  "\<lbrace> valid_objs' \<rbrace> getNotification ep \<lbrace> valid_ntfn' \<rbrace>"
+  unfolding getNotification_def by getObject_valid_obj
 
-lemma setObject_distinct[wp]:
-  shows     "\<lbrace>pspace_distinct'\<rbrace> setObject p val \<lbrace>\<lambda>rv. pspace_distinct'\<rbrace>"
-  apply (clarsimp simp: setObject_def split_def valid_def in_monad
-                        projectKOs pspace_distinct'_def ps_clear_upd
-                        objBits_def[symmetric] lookupAround2_char1
-                 split: if_split_asm
-                 dest!: updateObject_objBitsKO)
-   apply (fastforce dest: bspec[OF _ domI])
-  apply (fastforce dest: bspec[OF _ domI])
-  done
+lemma get_sc_valid_sc'[wp]:
+  "\<lbrace> valid_objs' \<rbrace> getSchedContext sc \<lbrace> valid_sched_context' \<rbrace>"
+  unfolding getSchedContext_def by getObject_valid_obj
 
-lemma setObject_aligned[wp]:
-  shows     "\<lbrace>pspace_aligned'\<rbrace> setObject p val \<lbrace>\<lambda>rv. pspace_aligned'\<rbrace>"
-  apply (clarsimp simp: setObject_def split_def valid_def in_monad
-                        projectKOs pspace_aligned'_def ps_clear_upd
-                        objBits_def[symmetric] lookupAround2_char1
-                 split: if_split_asm
-                 dest!: updateObject_objBitsKO)
-   apply (fastforce dest: bspec[OF _ domI])
-  apply (fastforce dest: bspec[OF _ domI])
-  done
+lemma get_reply_valid_reply'[wp]:
+  "\<lbrace> valid_objs'\<rbrace> getReply sc \<lbrace> valid_reply' \<rbrace>"
+  unfolding getReply_def by getObject_valid_obj
+
+end
 
-lemma set_ep_aligned' [wp]:
-  "\<lbrace>pspace_aligned'\<rbrace> setEndpoint ep v  \<lbrace>\<lambda>rv. pspace_aligned'\<rbrace>"
-  unfolding setEndpoint_def by wp
+lemma get_ep_ko':
+  "\<lbrace>\<top>\<rbrace> getEndpoint ep \<lbrace>\<lambda>rv. ko_at' rv ep\<rbrace>"
+  unfolding getEndpoint_def
+  by (rule getObject_ko_at; simp add: objBits_simps')
 
-lemma set_ep_distinct' [wp]:
-  "\<lbrace>pspace_distinct'\<rbrace> setEndpoint ep v  \<lbrace>\<lambda>rv. pspace_distinct'\<rbrace>"
-  unfolding setEndpoint_def by wp
+lemma get_ntfn_ko':
+  "\<lbrace>\<top>\<rbrace> getNotification ntfn \<lbrace>\<lambda>rv. ko_at' rv ntfn\<rbrace>"
+  unfolding getNotification_def
+  by (rule getObject_ko_at; simp add: objBits_simps')
 
+lemma get_sc_ko':
+  "\<lbrace>\<top>\<rbrace> getSchedContext sc_ptr \<lbrace>\<lambda>sc. ko_at' sc sc_ptr\<rbrace>"
+  unfolding getSchedContext_def
+  by (rule getObject_ko_at; simp add: objBits_simps' scBits_pos_power2)
 
-lemma setEndpoint_cte_wp_at':
-  "\<lbrace>cte_wp_at' P p\<rbrace> setEndpoint ptr v \<lbrace>\<lambda>rv. cte_wp_at' P p\<rbrace>"
-  unfolding setEndpoint_def
-  apply (rule setObject_cte_wp_at'[where Q="\<top>", simplified])
-   apply (clarsimp simp add: updateObject_default_def in_monad
-                             projectKOs
-                     intro!: set_eqI)+
-  done
+lemma get_reply_ko':
+  "\<lbrace>\<top>\<rbrace> getReply reply_ptr \<lbrace>\<lambda>reply. ko_at' reply reply_ptr\<rbrace>"
+  unfolding getReply_def
+  by (rule getObject_ko_at; simp add: objBits_simps')
 
-lemma setEndpoint_pred_tcb_at'[wp]:
-  "\<lbrace>pred_tcb_at' proj P t\<rbrace> setEndpoint ptr val \<lbrace>\<lambda>rv. pred_tcb_at' proj P t\<rbrace>"
-  apply (simp add: pred_tcb_at'_def setEndpoint_def)
-  apply (rule obj_at_setObject2)
-  apply (clarsimp simp: updateObject_default_def in_monad)
-  done
+context
+begin
 
-lemma get_ntfn_ko':
-  "\<lbrace>\<top>\<rbrace> getNotification ep \<lbrace>\<lambda>rv. ko_at' rv ep\<rbrace>"
-  apply (simp add: getNotification_def)
-  apply (rule getObject_ko_at)
-   apply simp
-  apply (simp add: objBits_simps')
-  done
+private method unfold_setObject_inmonad =
+  (clarsimp simp: setObject_def split_def valid_def in_monad projectKOs updateObject_size
+                  objBits_def[symmetric] lookupAround2_char1 ps_clear_upd
+            split: if_split_asm),
+    (fastforce dest: bspec[OF _ domI])+
 
-lemma set_ntfn_aligned'[wp]:
-  "\<lbrace>pspace_aligned'\<rbrace> setNotification p ntfn \<lbrace>\<lambda>rv. pspace_aligned'\<rbrace>"
-  unfolding setNotification_def by wp
+lemma setObject_distinct[wp]:
+  "setObject p val \<lbrace>pspace_distinct'\<rbrace>"
+  unfolding pspace_distinct'_def by (unfold_setObject_inmonad)
 
-lemma set_ntfn_distinct'[wp]:
-  "\<lbrace>pspace_distinct'\<rbrace> setNotification p ntfn \<lbrace>\<lambda>rv. pspace_distinct'\<rbrace>"
-  unfolding setNotification_def by wp
+lemma setObject_aligned[wp]:
+  "setObject p val \<lbrace>pspace_aligned'\<rbrace>"
+  unfolding pspace_aligned'_def by (unfold_setObject_inmonad)
 
-lemma setNotification_cte_wp_at':
-  "\<lbrace>cte_wp_at' P p\<rbrace> setNotification ptr v \<lbrace>\<lambda>rv. cte_wp_at' P p\<rbrace>"
-  unfolding setNotification_def
-  apply (rule setObject_cte_wp_at'[where Q="\<top>", simplified])
-   apply (clarsimp simp add: updateObject_default_def in_monad
-                             projectKOs
-                     intro!: set_eqI)+
-  done
+lemma setObject_bounded[wp]:
+  "setObject p val \<lbrace>pspace_bounded'\<rbrace>"
+  unfolding pspace_bounded'_def by (unfold_setObject_inmonad)
 
-lemma setObject_ntfn_tcb':
-  "\<lbrace>tcb_at' t\<rbrace> setObject p (e::Structures_H.notification) \<lbrace>\<lambda>_. tcb_at' t\<rbrace>"
-  apply (rule obj_at_setObject2)
-  apply (clarsimp simp: updateObject_default_def in_monad)
-  done
+end
+
+end
 
-lemma set_ntfn_tcb' [wp]:
-  "\<lbrace> tcb_at' t \<rbrace> setNotification ntfn v \<lbrace> \<lambda>rv. tcb_at' t \<rbrace>"
-  by (simp add: setNotification_def setObject_ntfn_tcb')
+context begin interpretation Arch . (*FIXME: arch_split*)
 
 lemma pspace_dom_update:
   "\<lbrakk> ps ptr = Some x; a_type x = a_type v \<rbrakk> \<Longrightarrow> pspace_dom (ps(ptr \<mapsto> v)) = pspace_dom ps"
@@ -790,34 +1164,25 @@ lemma real_cte_at':
                          objBits_simps' cte_level_bits_def
                     del: disjCI)
 
-lemma no_fail_getEndpoint [wp]:
+lemma no_fail_getMiscObject [wp]:
   "no_fail (ep_at' ptr) (getEndpoint ptr)"
-  apply (simp add: getEndpoint_def getObject_def
-                   split_def)
-  apply (rule no_fail_pre)
-   apply wp
-  apply (clarsimp simp add: obj_at'_def projectKOs objBits_simps'
-                            lookupAround2_known1)
-  apply (erule(1) ps_clear_lookupAround2)
-    apply simp
-   apply (simp add: field_simps)
-   apply (erule is_aligned_no_wrap')
-    apply (simp add: word_bits_conv)
-   apply (clarsimp split: option.split_asm simp: objBits_simps' archObjSize_def)
-  done
+  "no_fail (ntfn_at' ptr) (getNotification ptr)"
+  "no_fail (reply_at' ptr) (getReply ptr)"
+  "no_fail (sc_at' ptr) (getSchedContext ptr)"
+  by (wpsimp simp: getEndpoint_def getNotification_def getReply_def getSchedContext_def)+
 
 lemma getEndpoint_corres [corres]:
   "corres ep_relation (ep_at ptr) (ep_at' ptr)
      (get_endpoint ptr) (getEndpoint ptr)"
   apply (rule corres_no_failI)
    apply wp
-  apply (simp add: get_simple_ko_def getEndpoint_def get_object_def
+  apply (simp add: get_simple_ko_def getEndpoint_def get_object_def gets_the_def
                    getObject_def bind_assoc ep_at_def2)
-  apply (clarsimp simp: in_monad split_def bind_def gets_def get_def return_def)
+  apply (clarsimp simp: in_monad split_def bind_def gets_def get_def return_def
+                 dest!: readObject_misc_ko_at')
   apply (clarsimp simp: assert_def fail_def obj_at_def return_def is_ep partial_inv_def)
-  apply (clarsimp simp: loadObject_default_def in_monad projectKOs
-                        in_magnitude_check objBits_simps')
-  apply (clarsimp simp add: state_relation_def pspace_relation_def)
+  apply (rename_tac ep' ep)
+  apply (clarsimp simp: state_relation_def pspace_relation_def obj_at'_def projectKOs)
   apply (drule bspec)
    apply blast
   apply (simp add: other_obj_relation_def)
@@ -851,28 +1216,31 @@ lemma setObject_ksDomSchedule_inv:
   apply (wp updateObject_default_inv | simp)+
   done
 
-lemma projectKO_def2:
-  "projectKO ko = assert_opt (projectKO_opt ko)"
-  by (simp add: projectKO_def assert_opt_def)
+lemma read_magnitudeCheck_Some:
+  "(case y of None \<Rightarrow> True | Some z \<Rightarrow> 2 ^ n \<le> z - x)
+   \<longleftrightarrow> read_magnitudeCheck x y n s = Some ()"
+  by (fastforce simp: read_magnitudeCheck_def split: option.splits if_split_asm; simp)
 
+lemmas read_magnitudeCheck_Some'[simp, intro!] = read_magnitudeCheck_Some[THEN iffD1]
 lemma no_fail_magnitudeCheck[wp]:
   "no_fail (\<lambda>s. case y of None \<Rightarrow> True | Some z \<Rightarrow> 2 ^ n \<le> z - x)
     (magnitudeCheck x y n)"
-  apply (clarsimp simp add: magnitudeCheck_def split: option.splits)
+  apply (clarsimp simp: magnitudeCheck_def gets_the_def)
   apply (rule no_fail_pre, wp)
   apply simp
   done
 
+(* FIXME RT: can we drop the obj_at' size equality condition? *)
 lemma no_fail_setObject_other [wp]:
   fixes ob :: "'a :: pspace_storable"
   assumes x: "updateObject ob = updateObject_default ob"
   shows "no_fail (obj_at' (\<lambda>k::'a. objBits k = objBits ob) ptr)
                   (setObject ptr ob)"
-  apply (simp add: setObject_def x split_def updateObject_default_def
-                   projectKO_def2 alignCheck_def alignError_def)
+  apply (simp add: setObject_def x split_def updateObject_default_def alignError_def
+                   projectKO_def alignCheck_def read_alignCheck_def read_alignError_def)
   apply (rule no_fail_pre)
-   apply (wp )
-  apply (clarsimp simp: is_aligned_mask[symmetric] obj_at'_def
+   apply wp
+  apply (clarsimp simp: is_aligned_mask[symmetric] obj_at'_def omonad_defs
                         objBits_def[symmetric] projectKOs
                         project_inject lookupAround2_known1)
   apply (erule(1) ps_clear_lookupAround2)
@@ -950,7 +1350,6 @@ lemma setObject_other_corres:
                \<Longrightarrow> map_to_ctes ((ksPSpace s) (ptr \<mapsto> injectKO ob')) = map_to_ctes (ksPSpace s)"
   assumes t: "is_other_obj_relation_type (a_type ob)"
   assumes b: "\<And>ko. P ko \<Longrightarrow> objBits ko = objBits ob'"
-  assumes e: "\<And>ko. P ko \<Longrightarrow> exst_same' (injectKO ko) (injectKO ob')"
   assumes P: "\<And>(v::'a::pspace_storable). (1 :: word32) < 2 ^ (objBits v)"
   shows      "other_obj_relation ob (injectKO (ob' :: 'a :: pspace_storable)) \<Longrightarrow>
   corres dc (obj_at (\<lambda>ko. a_type ko = a_type ob) ptr and obj_at (same_caps ob) ptr)
@@ -990,30 +1389,26 @@ lemma setObject_other_corres:
    apply clarsimp
    apply (frule_tac ko'=ko and x'=ptr in obj_relation_cut_same_type,
            (fastforce simp add: is_other_obj_relation_type t)+)
-   apply (erule disjE)
-    apply (simp add: is_other_obj_relation_type t)
-   apply (erule disjE)
-    apply (insert t,
-      clarsimp simp: is_other_obj_relation_type_CapTable a_type_def)
-   apply (erule disjE)
-    apply (insert t,
-       clarsimp simp: is_other_obj_relation_type_UserData a_type_def)
-   apply (insert t,
-      clarsimp simp: is_other_obj_relation_type_DeviceData a_type_def)
-  apply (simp only: ekheap_relation_def)
-  apply (rule ballI, drule(1) bspec)
-  apply (drule domD)
-  apply (insert e)
-  apply atomize
-  apply (clarsimp simp: obj_at'_def)
-  apply (erule_tac x=obj in allE)
-  apply (clarsimp simp: projectKO_eq project_inject)
-  apply (case_tac ob;
-         simp_all add: a_type_def other_obj_relation_def etcb_relation_def
-                       is_other_obj_relation_type t exst_same_def)
-  by (clarsimp simp: is_other_obj_relation_type t exst_same_def
-              split: Structures_A.kernel_object.splits Structures_H.kernel_object.splits
-                     ARM_A.arch_kernel_obj.splits)+
+   apply (insert t)
+   apply ((erule disjE
+         | clarsimp simp: is_other_obj_relation_type is_other_obj_relation_type_def a_type_def)+)[1]
+  (* sc_replies_relation *)
+  apply (simp add: sc_replies_relation_def)
+  apply (clarsimp simp: sc_replies_of_scs_def map_project_def scs_of_kh_def)
+  apply (drule_tac x=p in spec)
+  apply (rule conjI; clarsimp split: Structures_A.kernel_object.split_asm if_split_asm)
+   apply(clarsimp simp: a_type_def is_other_obj_relation_type_def)
+  apply (rename_tac sc n)
+  apply (prop_tac "typ_at' (koTypeOf (injectKO ob')) ptr b")
+   apply (clarsimp simp: typ_at'_def ko_wp_at'_def obj_at'_def projectKO_opts_defs
+                         is_other_obj_relation_type_def a_type_def other_obj_relation_def
+                  split: Structures_A.kernel_object.split_asm if_split_asm
+                         arch_kernel_obj.split_asm kernel_object.split_asm arch_kernel_object.split_asm)
+  apply (drule replyPrevs_of_non_reply_update[simplified])
+   apply (clarsimp simp: other_obj_relation_def; cases ob; cases "injectKO ob'";
+          simp split: arch_kernel_obj.split_asm)
+  apply (clarsimp simp add: opt_map_def)
+  done
 
 lemmas obj_at_simps = obj_at_def obj_at'_def projectKOs map_to_ctes_upd_other
                       is_other_obj_relation_type_def
@@ -1038,20 +1433,314 @@ lemma setNotification_corres [corres]:
   apply (corressimp wp: get_object_ret get_object_wp)+
   by (fastforce simp: is_ntfn obj_at_simps objBits_defs partial_inv_def)
 
-lemma no_fail_getNotification [wp]:
-  "no_fail (ntfn_at' ptr) (getNotification ptr)"
-  apply (simp add: getNotification_def getObject_def
-                   split_def)
-  apply (rule no_fail_pre)
-   apply wp
-  apply (clarsimp simp add: obj_at'_def projectKOs objBits_simps'
-                            lookupAround2_known1)
-  apply (erule(1) ps_clear_lookupAround2)
-    apply simp
-   apply (simp add: field_simps)
-   apply (erule is_aligned_no_wrap')
-    apply (simp add: word_bits_conv)
-   apply (clarsimp split: option.split_asm simp: objBits_simps' archObjSize_def)
+lemma reply_at'_cross:
+  assumes p: "pspace_relation (kheap s) (ksPSpace s')"
+  assumes t: "reply_at' ptr s'"
+  shows "reply_at ptr s" using assms
+  apply (clarsimp simp: obj_at'_def projectKOs)
+  apply (erule (1) pspace_dom_relatedE)
+  by (clarsimp simp: obj_relation_cuts_def2 obj_at_def is_reply cte_relation_def
+                     other_obj_relation_def pte_relation_def pde_relation_def
+              split: Structures_A.kernel_object.split_asm if_split_asm
+                     ARM_A.arch_kernel_obj.split_asm)
+
+lemma set_reply_corres: (* for reply update that doesn't touch the reply stack *)
+  "reply_relation ae ae' \<Longrightarrow>
+  corres dc \<top>
+            (obj_at' (\<lambda>ko. replyPrev_same ae' ko) ptr)
+            (set_reply ptr ae) (setReply ptr ae')"
+  proof -
+  have x: "updateObject ae' = updateObject_default ae'" by clarsimp
+  have z: "\<And>s. reply_at' ptr s
+               \<Longrightarrow> map_to_ctes ((ksPSpace s) (ptr \<mapsto> injectKO ae')) = map_to_ctes (ksPSpace s)"
+    by (clarsimp simp: obj_at_simps)
+  have b: "\<And>ko. (\<lambda>_ :: reply. True) ko \<Longrightarrow> objBits ko = objBits ae'"
+    by (clarsimp simp: obj_at_simps)
+  assume r: "reply_relation ae ae'"
+  show ?thesis
+    apply (simp add: set_simple_ko_def setReply_def is_reply_def[symmetric])
+    supply image_cong_simp [cong del]
+    apply (insert r)
+    apply (rule corres_no_failI)
+     apply (rule no_fail_pre)
+      apply wp
+      apply (rule x)
+     apply (clarsimp simp: obj_at'_weakenE[OF _ b])
+    apply (unfold set_object_def setObject_def)
+    apply (clarsimp simp: in_monad split_def bind_def gets_def get_def Bex_def
+                          put_def return_def modify_def get_object_def x
+                          projectKOs obj_at_def obj_at'_def is_reply
+                          updateObject_default_def in_magnitude_check[OF _])
+    apply (prop_tac "reply_at ptr a")
+     apply (clarsimp simp: obj_at'_def projectKOs dest!: state_relation_pspace_relation reply_at'_cross[where ptr=ptr])
+    apply (clarsimp simp: obj_at_def is_reply)
+    apply (rename_tac reply)
+    apply (prop_tac "obj_at (same_caps (kernel_object.Reply ae)) ptr a")
+     apply (clarsimp simp: obj_at_def is_reply)
+    apply (clarsimp simp: state_relation_def
+                          z[simplified obj_at'_def is_reply projectKO_eq projectKO_opts_defs, simplified])
+    apply (clarsimp simp add: caps_of_state_after_update cte_wp_at_after_update
+                              swp_def fun_upd_def obj_at_def)
+    apply (subst conj_assoc[symmetric])
+    apply (rule conjI[rotated])
+     apply (clarsimp simp add: ghost_relation_def)
+     apply (erule_tac x=ptr in allE)+
+     apply (clarsimp simp: obj_at_def a_type_def
+                     split: Structures_A.kernel_object.splits if_split_asm)
+    apply (fold fun_upd_def)
+    apply (simp only: pspace_relation_def simp_thms
+                      pspace_dom_update[where x="kernel_object.Reply _"
+                                          and v="kernel_object.Reply _",
+                                        simplified a_type_def, simplified])
+    apply (simp only: dom_fun_upd2 simp_thms)
+    apply (elim conjE)
+    apply (frule bspec, erule domI)
+    apply (rule conjI)
+     apply (rule ballI, drule(1) bspec)
+     apply (drule domD)
+     apply (clarsimp simp: project_inject split: if_split_asm kernel_object.split_asm)
+     apply (rename_tac bb aa ba)
+     apply (drule_tac x="(aa, ba)" in bspec, simp)
+     apply clarsimp
+     apply (frule_tac ko'="kernel_object.Reply reply" and x'=ptr in obj_relation_cut_same_type)
+        apply simp+
+     apply clarsimp
+      (* sc_replies_relation *)
+    apply (simp add: sc_replies_relation_def)
+    apply (clarsimp simp: sc_replies_of_scs_def map_project_def scs_of_kh_def)
+    apply (drule_tac x=p in spec)
+    by (subst replyPrevs_of_replyPrev_same_update[simplified, where ob'=ae', simplified];
+        simp add: typ_at'_def ko_wp_at'_def obj_at'_def project_inject opt_map_def)
+  qed
+
+lemma setReply_not_queued_corres: (* for reply updates on replies not in fst ` replies_with_sc *)
+  "reply_relation r1 r2 \<Longrightarrow>
+  corres dc (\<lambda>s. ptr \<notin> fst ` replies_with_sc s) (reply_at' ptr)
+            (set_reply ptr r1) (setReply ptr r2)"
+  proof -
+  have x: "updateObject r2 = updateObject_default r2" by clarsimp
+  have z: "\<And>s. reply_at' ptr s
+               \<Longrightarrow> map_to_ctes ((ksPSpace s) (ptr \<mapsto> injectKO r2)) = map_to_ctes (ksPSpace s)"
+    by (clarsimp simp: obj_at_simps)
+  have b: "\<And>ko. (\<lambda>_ :: reply. True) ko \<Longrightarrow> objBits ko = objBits r2"
+    by (clarsimp simp: obj_at_simps)
+  assume r: "reply_relation r1 r2"
+  show ?thesis
+    apply (simp add: set_simple_ko_def setReply_def is_reply_def[symmetric])
+    supply image_cong_simp [cong del]
+    apply (insert r)
+    apply (rule corres_no_failI)
+     apply (rule no_fail_pre)
+      apply wp
+      apply (rule x)
+     apply (clarsimp simp: obj_at'_weakenE[OF _ b])
+    apply (unfold set_object_def setObject_def)
+    apply (clarsimp simp: in_monad split_def bind_def gets_def get_def Bex_def
+                          put_def return_def modify_def get_object_def x
+                          projectKOs obj_at_def obj_at'_def is_reply
+                          updateObject_default_def in_magnitude_check[OF _])
+    apply (prop_tac "reply_at ptr a")
+     apply (clarsimp simp: obj_at'_def projectKOs dest!: state_relation_pspace_relation reply_at'_cross[where ptr=ptr])
+    apply (clarsimp simp: obj_at_def is_reply)
+    apply (rename_tac reply)
+    apply (prop_tac "obj_at (same_caps (kernel_object.Reply _)) ptr a")
+     apply (clarsimp simp: obj_at_def is_reply)
+    apply (clarsimp simp: state_relation_def
+                          z[simplified obj_at'_def is_reply projectKO_eq projectKO_opts_defs, simplified])
+    apply (clarsimp simp add: caps_of_state_after_update cte_wp_at_after_update
+                              swp_def fun_upd_def obj_at_def)
+    apply (subst conj_assoc[symmetric])
+    apply (rule conjI[rotated])
+     apply (clarsimp simp add: ghost_relation_def)
+     apply (erule_tac x=ptr in allE)+
+     apply (clarsimp simp: obj_at_def a_type_def
+                     split: Structures_A.kernel_object.splits if_split_asm)
+    apply (fold fun_upd_def)
+    apply (simp only: pspace_relation_def simp_thms
+                      pspace_dom_update[where x="kernel_object.Reply _"
+                                          and v="kernel_object.Reply _",
+                                        simplified a_type_def, simplified])
+    apply (simp only: dom_fun_upd2 simp_thms)
+    apply (elim conjE)
+    apply (frule bspec, erule domI)
+    apply (rule conjI)
+     apply (rule ballI, drule(1) bspec)
+     apply (drule domD)
+     apply (clarsimp simp: project_inject split: if_split_asm kernel_object.split_asm)
+     apply (rename_tac bb aa ba)
+     apply (drule_tac x="(aa, ba)" in bspec, simp)
+     apply clarsimp
+     apply (frule_tac ko'="kernel_object.Reply reply" and x'=ptr in obj_relation_cut_same_type)
+        apply simp+
+     apply clarsimp
+      (* sc_replies_relation *)
+    apply (simp add: sc_replies_relation_def)
+    apply (clarsimp simp: sc_replies_of_scs_def map_project_def scs_of_kh_def)
+    apply (drule_tac x=p in spec)
+   apply (subgoal_tac "((scs_of' b)(ptr := sc_of' (KOReply r2)) |> scReply) p = scReplies_of b p")
+     apply simp
+    apply (subgoal_tac "heap_ls (replyPrevs_of b) (scReplies_of b p) (sc_replies z)")
+     apply (erule heap_path_heap_upd_not_in)
+     apply (clarsimp simp: sc_at_pred_n_def obj_at_def replies_with_sc_def image_def)
+     apply (drule_tac x=p in spec)
+     apply (simp add: typ_at'_def ko_wp_at'_def obj_at'_def project_inject opt_map_def)
+    apply (simp add: typ_at'_def ko_wp_at'_def obj_at'_def project_inject opt_map_def)
+   apply (simp add: typ_at'_def ko_wp_at'_def obj_at'_def project_inject opt_map_def)
+  done
+  qed
+
+lemma sc_at'_cross:
+  assumes p: "pspace_relation (kheap s) (ksPSpace s')"
+  assumes t: "sc_at' ptr s'"
+  shows "sc_at ptr s" using assms
+  apply (clarsimp simp: obj_at'_def projectKOs)
+  apply (erule (1) pspace_dom_relatedE)
+  by (clarsimp simp: obj_relation_cuts_def2 obj_at_def is_sc_obj cte_relation_def
+                     other_obj_relation_def pte_relation_def pde_relation_def
+              split: Structures_A.kernel_object.split_asm if_split_asm
+                     ARM_A.arch_kernel_obj.split_asm)
+
+lemma sc_obj_at'_cross:
+  assumes p: "pspace_relation (kheap s) (ksPSpace s')"
+  assumes t: "obj_at' (\<lambda>k::sched_context. objBits k = minSchedContextBits + n) ptr s'"
+  shows "sc_obj_at n ptr s" using assms
+  apply (clarsimp simp: obj_at'_def projectKOs)
+  apply (erule (1) pspace_dom_relatedE)
+  by (clarsimp simp: obj_relation_cuts_def2 obj_at_def is_sc_obj cte_relation_def
+                     objBits_simps scBits_simps
+                     other_obj_relation_def pte_relation_def pde_relation_def sc_relation_def
+              split: Structures_A.kernel_object.split_asm if_split_asm
+                     ARM_A.arch_kernel_obj.split_asm)
+
+lemma setSchedContext_corres:
+  assumes R': "sc_relation sc n sc'"
+  assumes s: " n + minSchedContextBits = objBits sc'"
+  shows "corres dc \<top>
+         (obj_at' (\<lambda>k::sched_context. objBits k = objBits sc') ptr and (\<lambda>s'. heap_ls (replyPrevs_of s') (scReply sc') (sc_replies sc)))
+            (set_object ptr (kernel_object.SchedContext sc n))
+            (setSchedContext ptr sc')"
+  proof -
+  have z: "\<And>s. sc_at' ptr s
+               \<Longrightarrow> map_to_ctes ((ksPSpace s) (ptr \<mapsto> injectKO sc')) = map_to_ctes (ksPSpace s)"
+    by (clarsimp simp: obj_at_simps)
+  show ?thesis
+    apply (insert R' s)
+    apply (clarsimp simp: setSchedContext_def)
+    apply (rule corres_no_failI)
+     apply (rule no_fail_pre)
+      apply wp
+      apply clarsimp
+     apply clarsimp
+    apply clarsimp
+    apply (rename_tac s s' rv; prop_tac "sc_obj_at n ptr s")
+     apply (fastforce intro!: sc_obj_at'_cross dest: state_relation_pspace_relation simp: obj_at'_def)
+    apply (clarsimp simp: obj_at_def is_sc_obj_def obj_at'_def projectKO_eq projectKO_opts_defs)
+    apply (unfold update_sched_context_def set_object_def setObject_def)
+    apply (clarsimp simp: in_monad split_def bind_def gets_def get_def Bex_def
+                          put_def return_def modify_def get_object_def2
+                          projectKOs obj_at_def a_type_def
+                          updateObject_default_def in_magnitude_check[OF _]
+                   split: Structures_A.kernel_object.splits)
+    apply (prop_tac "obj_at (same_caps (kernel_object.SchedContext sc n)) ptr s")
+     apply (clarsimp simp: obj_at_def)
+    apply (clarsimp simp: state_relation_def
+                          z[simplified obj_at'_def is_sc_obj_def projectKO_eq projectKO_opts_defs, simplified])
+    apply (clarsimp simp: caps_of_state_after_update cte_wp_at_after_update
+                              swp_def fun_upd_def obj_at_def)
+    apply (subst conj_assoc[symmetric])
+    apply (rule conjI[rotated])
+     apply (clarsimp simp: ghost_relation_def)
+     apply (erule_tac x=ptr in allE)+
+     apply (clarsimp simp: obj_at_def a_type_def
+                     split: Structures_A.kernel_object.splits if_split_asm)
+    apply (fold fun_upd_def)
+    apply (simp only: pspace_relation_def simp_thms
+                      pspace_dom_update[where x="kernel_object.SchedContext _ _"
+                                          and v="kernel_object.SchedContext _ _",
+                                        simplified a_type_def, simplified])
+    apply (simp only: dom_fun_upd2 simp_thms)
+    apply (elim conjE)
+    apply (frule bspec, erule domI)
+    apply (rule conjI)
+     apply (rule ballI, drule(1) bspec)
+     apply (drule domD)
+     apply (clarsimp simp: project_inject split: if_split_asm kernel_object.split_asm)
+     apply (rename_tac sc0 x bb aa ba)
+     apply (drule_tac x="(aa, ba)" in bspec, simp)
+     apply clarsimp
+     apply (frule_tac ko'="kernel_object.SchedContext sc0 n" and x'=ptr
+              in obj_relation_cut_same_type)
+        apply simp+
+     apply (clarsimp simp: a_type_def split: Structures_A.kernel_object.split_asm if_split_asm)
+      (* sc_replies_relation *)
+    apply (clarsimp simp: sc_replies_relation_def sc_replies_of_scs_def map_project_def scs_of_kh_def)
+    apply (drule_tac x=p in spec)
+    by (auto simp: typ_at'_def ko_wp_at'_def opt_map_def projectKO_opts_defs
+            split: if_splits)
+qed
+
+lemma setSchedContext_update_corres:
+  assumes R': "sc_relation sc n sc' \<longrightarrow> sc_relation (f sc) n (f' (sc'::sched_context))"
+  assumes s: "objBits sc' = objBits (f' sc')"
+  shows "corres dc
+         (\<lambda>s. kheap s ptr = Some (kernel_object.SchedContext sc n))
+         (ko_at' sc' ptr and (\<lambda>s'. heap_ls (replyPrevs_of s') (scReply (f' sc')) (sc_replies (f sc))))
+            (set_object ptr (kernel_object.SchedContext (f sc) n))
+            (setSchedContext ptr (f' sc'))"
+  apply (insert R' s)
+  apply (rule_tac F="sc_relation sc n sc'" in corres_req)
+   apply (drule state_relation_pspace_relation)
+   apply (drule (1) pspace_relation_absD)
+   apply (clarsimp simp: obj_at'_def projectKOs split: if_split_asm)
+  apply (rule corres_guard_imp)
+    apply (rule setSchedContext_corres)
+  by (clarsimp simp: obj_at'_def sc_relation_def objBits_simps scBits_simps)+
+
+lemma setSchedContext_no_stack_update_corres:
+  "\<lbrakk>sc_relation sc n sc' \<longrightarrow> sc_relation (f sc) n (f' sc');
+     sc_replies sc = sc_replies (f sc); objBits sc' = objBits (f' sc');
+     scReply sc' = scReply (f' sc')\<rbrakk>
+    \<Longrightarrow> corres dc
+         (\<lambda>s. kheap s ptr = Some (kernel_object.SchedContext sc n))
+         (ko_at' sc' ptr)
+            (set_object ptr (kernel_object.SchedContext (f sc) n))
+            (setSchedContext ptr (f' sc'))"
+  apply (rule_tac F="sc_relation sc n sc'" in corres_req)
+   apply (drule state_relation_pspace_relation)
+   apply (drule (1) pspace_relation_absD)
+   apply (clarsimp simp: obj_at'_def projectKOs split: if_split_asm)
+  apply (rule stronger_corres_guard_imp)
+    apply (rule setSchedContext_update_corres[where sc=sc and sc'=sc'])
+     apply simp+
+  apply (clarsimp dest!: state_relation_sc_replies_relation
+                   simp: obj_at'_def projectKOs)
+  apply (drule (2) sc_replies_relation_prevs_list)
+  by fastforce
+
+lemma setSchedContext_update_sched_context_no_stack_update_corres:
+  "\<lbrakk>\<forall>sc n sc'. sc_relation sc n sc' \<longrightarrow> sc_relation (f sc) n (f' sc');
+    \<forall>sc. sc_replies sc = sc_replies (f sc); objBits sc' = objBits (f' sc');
+    scReply sc' = scReply (f' sc')\<rbrakk>
+    \<Longrightarrow> corres dc
+         (\<lambda>s. sc_at ptr s)
+         (ko_at' sc' ptr)
+         (update_sched_context ptr f)
+         (setSchedContext ptr (f' sc'))"
+  apply (clarsimp simp: update_sched_context_def)
+  apply (rule corres_symb_exec_l[rotated 2, OF get_object_sp])
+    apply (find_goal \<open>match conclusion in "\<lbrace>P\<rbrace> f \<exists>\<lbrace>Q\<rbrace>" for P f Q \<Rightarrow> -\<close>)
+    apply (fastforce intro: get_object_exs_valid
+                      simp: obj_at_def)
+   apply wpsimp
+   apply (clarsimp simp: obj_at_def)
+  apply (rename_tac obj)
+  apply (case_tac obj;
+         clarsimp, (solves \<open>clarsimp simp: obj_at_def is_sc_obj_def corres_underlying_def\<close>)?)
+  apply (rule corres_guard_imp)
+    apply (rule_tac f=f and f'="f'" in setSchedContext_no_stack_update_corres)
+       apply simp+
+   apply (clarsimp simp: obj_at_def)
+  apply (clarsimp simp: obj_at_simps)
   done
 
 lemma getNotification_corres:
@@ -1060,67 +1749,99 @@ lemma getNotification_corres:
   apply (rule corres_no_failI)
    apply wp
   apply (simp add: get_simple_ko_def getNotification_def get_object_def
-                   getObject_def bind_assoc)
-  apply (clarsimp simp: in_monad split_def bind_def gets_def get_def return_def)
+                   getObject_def bind_assoc gets_the_def)
+  apply (clarsimp simp: in_monad split_def bind_def gets_def get_def return_def
+                 dest!: readObject_misc_ko_at')
   apply (clarsimp simp: assert_def fail_def obj_at_def return_def is_ntfn partial_inv_def)
-  apply (clarsimp simp: loadObject_default_def in_monad projectKOs
-                        in_magnitude_check objBits_simps')
-  apply (clarsimp simp add: state_relation_def pspace_relation_def)
+  apply (clarsimp simp add: state_relation_def pspace_relation_def obj_at'_def projectKOs)
+  apply (drule bspec)
+   apply blast
+  apply (simp add: other_obj_relation_def)
+  done
+
+lemma get_reply_corres:
+  "corres reply_relation (reply_at ptr) (reply_at' ptr)
+     (get_reply ptr) (getReply ptr)"
+  apply (rule corres_no_failI)
+   apply wp
+  apply (simp add: get_simple_ko_def getReply_def get_object_def
+                   getObject_def bind_assoc gets_the_def)
+  apply (clarsimp simp: in_monad split_def bind_def gets_def get_def return_def
+                 dest!: readObject_misc_ko_at')
+  apply (clarsimp simp: assert_def fail_def obj_at_def return_def is_reply partial_inv_def)
+  apply (clarsimp simp add: state_relation_def pspace_relation_def obj_at'_def projectKOs)
   apply (drule bspec)
    apply blast
   apply (simp add: other_obj_relation_def)
   done
 
+lemma getReply_TCB_corres:
+  "corres (=) (reply_at ptr) (reply_at' ptr)
+     (get_reply_tcb ptr) (liftM replyTCB (getReply ptr))"
+  apply clarsimp
+  apply (rule get_reply_corres[THEN corres_rel_imp])
+  apply (clarsimp simp: reply_relation_def)
+  done
+
+lemma get_sc_corres:
+  "corres (\<lambda>sc sc'. \<exists>n. sc_relation sc n sc') (sc_at ptr) (sc_at' ptr)
+     (get_sched_context ptr) (getSchedContext ptr)"
+  apply (rule corres_no_failI)
+   apply wp
+  apply (simp add: get_sched_context_def getSchedContext_def get_object_def
+                   getObject_def bind_assoc gets_the_def)
+  apply (clarsimp simp: in_monad split_def bind_def gets_def get_def return_def
+                 dest!: readObject_misc_ko_at')
+  apply (clarsimp simp: assert_def fail_def obj_at_def return_def is_sc_obj_def
+                 split: Structures_A.kernel_object.splits)
+  apply (clarsimp simp add: state_relation_def pspace_relation_def obj_at'_def projectKOs)
+  apply (drule bspec)
+   apply blast
+  apply (fastforce simp add: other_obj_relation_def)
+  done
+
+lemma get_sc_corres_size:
+  "corres (\<lambda>sc sc'. sc_relation sc n sc' \<and> n + minSchedContextBits = objBits sc')
+     (sc_obj_at n ptr) (sc_at' ptr)
+     (get_sched_context ptr) (getSchedContext ptr)"
+  apply (rule corres_no_failI)
+   apply wp
+  apply (simp add: get_sched_context_def getSchedContext_def get_object_def
+                   getObject_def bind_assoc gets_the_def)
+  apply (clarsimp simp: in_monad split_def bind_def gets_def get_def)
+  apply (clarsimp simp: assert_def fail_def obj_at_def return_def is_sc_obj
+                 split: Structures_A.kernel_object.splits
+                 dest!: readObject_misc_ko_at')
+  apply (clarsimp simp: state_relation_def pspace_relation_def obj_at'_def projectKOs)
+  apply (drule bspec)
+   apply blast
+  apply (clarsimp simp: other_obj_relation_def scBits_simps sc_relation_def objBits_simps)
+  done
+
 lemma setObject_ko_wp_at:
   fixes v :: "'a :: pspace_storable"
-  assumes R: "\<And>ko s x y n. (updateObject v ko p y n s)
+  assumes R: "\<And>ko s y n. (updateObject v ko p y n s)
                    = (updateObject_default v ko p y n s)"
-  assumes n: "\<And>v' :: 'a. objBits v' = n"
-  assumes m: "(1 :: word32) < 2 ^ n"
   shows      "\<lbrace>\<lambda>s. obj_at' (\<lambda>x :: 'a. True) p s \<longrightarrow>
                     P (ko_wp_at' (if p = p' then K (P' (injectKO v)) else P')p' s)\<rbrace>
                 setObject p v
               \<lbrace>\<lambda>rv s. P (ko_wp_at' P' p' s)\<rbrace>"
   apply (clarsimp simp: setObject_def valid_def in_monad
-                        ko_wp_at'_def split_def
+                        ko_wp_at'_def split_def in_magnitude_check
                         R updateObject_default_def
                         projectKOs obj_at'_real_def
              split del: if_split)
-  apply (clarsimp simp: project_inject objBits_def[symmetric] n
-                        in_magnitude_check [OF _ m]
+  apply (clarsimp simp: project_inject objBits_def[symmetric]
                  elim!: rsubst[where P=P]
              split del: if_split)
   apply (rule iffI)
-   apply (clarsimp simp: n ps_clear_upd objBits_def[symmetric]
+   apply (clarsimp simp: ps_clear_upd objBits_def[symmetric]
                   split: if_split_asm)
-  apply (clarsimp simp: n project_inject objBits_def[symmetric]
+  apply (clarsimp simp: project_inject objBits_def[symmetric]
                         ps_clear_upd
                  split: if_split_asm)
   done
 
-lemma typ_at'_valid_obj'_lift:
-  assumes P: "\<And>P T p. \<lbrace>\<lambda>s. P (typ_at' T p s)\<rbrace> f \<lbrace>\<lambda>rv s. P (typ_at' T p s)\<rbrace>"
-  notes [wp] = hoare_vcg_all_lift hoare_vcg_imp_lift hoare_vcg_const_Ball_lift typ_at_lifts [OF P]
-  shows      "\<lbrace>\<lambda>s. valid_obj' obj s\<rbrace> f \<lbrace>\<lambda>rv s. valid_obj' obj s\<rbrace>"
-  apply (cases obj; simp add: valid_obj'_def hoare_TrueI)
-      apply (rename_tac endpoint)
-      apply (case_tac endpoint; simp add: valid_ep'_def, wp)
-     apply (rename_tac notification)
-     apply (case_tac "ntfnObj notification";
-             simp add: valid_ntfn'_def valid_bound_tcb'_def split: option.splits,
-             (wpsimp|rule conjI)+)
-    apply (rename_tac tcb)
-    apply (case_tac "tcbState tcb";
-           simp add: valid_tcb'_def valid_tcb_state'_def split_def valid_bound_ntfn'_def
-              split: option.splits,
-           wpsimp)
-   apply (wpsimp simp: valid_cte'_def)
-  apply (rename_tac arch_kernel_object)
-  apply (case_tac arch_kernel_object; wpsimp)
-  done
-
-lemmas setObject_valid_obj = typ_at'_valid_obj'_lift [OF setObject_typ_at']
-
 lemma setObject_valid_objs':
   assumes x: "\<And>x n ko s ko' s'.
        \<lbrakk> (ko', s') \<in> fst (updateObject val ko ptr x n s); P s;
@@ -1145,10 +1866,8 @@ lemma setObject_valid_objs':
 
 lemma setObject_iflive':
   fixes v :: "'a :: pspace_storable"
-  assumes R: "\<And>ko s x y n. (updateObject v ko ptr y n s)
+  assumes R: "\<And>ko s y n. (updateObject v ko ptr y n s)
                    = (updateObject_default v ko ptr y n s)"
-  assumes n: "\<And>x :: 'a. objBits x = n"
-  assumes m: "(1 :: word32) < 2 ^ n"
   assumes x: "\<And>x n tcb s t. \<lbrakk> t \<in> fst (updateObject v (KOTCB tcb) ptr x n s); P s;
                                lookupAround2 ptr (ksPSpace s) = (Some (x, KOTCB tcb), n) \<rbrakk>
                   \<Longrightarrow> \<exists>tcb'. t = (KOTCB tcb', s) \<and> (\<forall>(getF, setF) \<in> ran tcb_cte_cases. getF tcb' = getF tcb)"
@@ -1220,30 +1939,45 @@ lemma setObject_it[wp]:
 definition idle_tcb_ps :: "('a :: pspace_storable) \<Rightarrow> bool" where
   "idle_tcb_ps val \<equiv> (\<exists>tcb. projectKO_opt (injectKO val) = Some tcb \<and> idle_tcb' tcb)"
 
+\<comment>\<open>
+  `idle_sc_ps val` asserts that `val` is a pspace_storable value
+  which corresponds to an idle SchedContext.
+\<close>
+definition idle_sc_ps :: "('a :: pspace_storable) \<Rightarrow> bool" where
+  "idle_sc_ps val \<equiv> (\<exists>sc. sc_of' (injectKO val) = Some sc \<and> idle_sc' sc)"
+
 lemma setObject_idle':
   fixes v :: "'a :: pspace_storable"
-  assumes R: "\<And>ko s x y n. (updateObject v ko ptr y n s)
-                   = (updateObject_default v ko ptr y n s)"
-  assumes n: "\<And>x :: 'a. objBits x = n"
-  assumes m: "(1 :: word32) < 2 ^ n"
+  assumes R: "\<And>ko s y n.
+              (updateObject v ko ptr y n s) = (updateObject_default v ko ptr y n s)"
   assumes z: "\<And>P p q n ko.
-       \<lbrace>\<lambda>s. P (ksIdleThread s)\<rbrace> updateObject v p q n ko
-       \<lbrace>\<lambda>rv s. P (ksIdleThread s)\<rbrace>"
-  shows      "\<lbrace>\<lambda>s. valid_idle' s \<and>
-                   (ptr = ksIdleThread s
+              \<lbrace>\<lambda>s. P (ksIdleThread s)\<rbrace>
+              updateObject v p q n ko
+              \<lbrace>\<lambda>rv s. P (ksIdleThread s)\<rbrace>"
+  shows      "\<lbrace>\<lambda>s. valid_idle' s
+                   \<and> (ptr = ksIdleThread s
                         \<longrightarrow> (\<exists>val :: 'a. idle_tcb_ps val)
-                        \<longrightarrow> idle_tcb_ps v)\<rbrace>
-                setObject ptr v
+                        \<longrightarrow> idle_tcb_ps v)
+                   \<and> (ptr = idle_sc_ptr
+                        \<longrightarrow> (\<exists>val :: 'a. idle_sc_ps val)
+                        \<longrightarrow> idle_sc_ps v)\<rbrace>
+              setObject ptr v
               \<lbrace>\<lambda>rv s. valid_idle' s\<rbrace>"
   apply (simp add: valid_idle'_def pred_tcb_at'_def o_def)
   apply (rule hoare_pre)
    apply (rule hoare_lift_Pf2 [where f="ksIdleThread"])
     apply (simp add: pred_tcb_at'_def obj_at'_real_def)
-    apply (rule setObject_ko_wp_at [OF R n m])
+    apply (wpsimp wp: setObject_ko_wp_at[OF R])
    apply (wp z)
-  apply (clarsimp simp add: pred_tcb_at'_def obj_at'_real_def ko_wp_at'_def idle_tcb_ps_def)
-  apply (clarsimp simp add: project_inject)
-  apply (drule_tac x=obja in spec, simp)
+  apply (rule conjI)
+   apply (clarsimp simp: pred_tcb_at'_def obj_at'_real_def ko_wp_at'_def idle_tcb_ps_def
+                         idle_sc_ps_def)
+   apply (rename_tac tcb sc obj)
+   apply (drule_tac x=obj and y=tcb in spec2, clarsimp simp: project_inject)
+  apply (clarsimp simp: pred_tcb_at'_def obj_at'_real_def ko_wp_at'_def idle_tcb_ps_def
+                        idle_sc_ps_def)
+  apply (rename_tac tcb sc obj)
+  apply (drule_tac x=obj and y=sc in spec2, clarsimp simp: project_inject)
   done
 
 lemma setObject_no_0_obj' [wp]:
@@ -1259,11 +1993,38 @@ lemma valid_updateCapDataI:
   apply (cases c)
   apply (simp_all add: isCap_defs valid_cap'_def capUntypedPtr_def isCap_simps
                        capAligned_def word_size word_bits_def word_bw_assocs)
+ done
+
+lemma no_ofail_threadRead[simp]:
+  "no_ofail (obj_at' (P::tcb \<Rightarrow> bool) p) (threadRead f p)"
+  unfolding threadRead_def oliftM_def no_ofail_def
+  apply clarsimp
+  apply (clarsimp simp: threadRead_def obind_def oliftM_def oreturn_def
+                  split: option.split dest!: no_ofailD[OF no_ofail_obj_at'_readObject_tcb])
   done
 
+lemmas no_ofail_threadRead_tcb_at'[wp] = no_ofail_threadRead[where P=\<top>]
+
+lemma threadRead_tcb_at'':
+  "bound (threadRead f t s) \<Longrightarrow> tcb_at' t s"
+  by (clarsimp simp: threadRead_def oliftM_def elim!: obj_at'_weakenE)
+
+lemmas threadRead_tcb_at' = threadRead_tcb_at''[simplified]
+
+lemma ovalid_threadRead:
+  "o\<lbrace>\<lambda>s. tcb_at' t s \<longrightarrow> (\<exists>tcb. ko_at' tcb t s \<and> P (f tcb) s)\<rbrace>
+    threadRead f t \<lbrace>P\<rbrace>"
+  by (clarsimp simp: threadRead_def oliftM_def obind_def obj_at'_def ovalid_def
+              dest!: readObject_misc_ko_at' split: option.split_asm)
+
+lemma ovalid_threadRead_sp:
+  "o\<lbrace>P\<rbrace> threadRead f ptr \<lbrace>\<lambda>rv s. \<exists>tcb :: tcb. ko_at' tcb ptr s \<and> f tcb = rv \<and> P s\<rbrace>"
+  by (clarsimp simp: threadRead_def oliftM_def obind_def obj_at'_def ovalid_def
+              dest!: readObject_misc_ko_at' split: option.split_asm)
+
 lemma no_fail_threadGet [wp]:
   "no_fail (tcb_at' t) (threadGet f t)"
-  by (simp add: threadGet_def, wp)
+  by (wpsimp simp: threadGet_def wp: no_ofail_gets_the)
 
 lemma no_fail_getThreadState [wp]:
   "no_fail (tcb_at' t) (getThreadState t)"
@@ -1304,123 +2065,6 @@ lemma no_fail_dmo' [wp]:
   apply (simp add: no_fail_def)
   done
 
-lemma setEndpoint_nosch[wp]:
-  "\<lbrace>\<lambda>s. P (ksSchedulerAction s)\<rbrace>
-    setEndpoint val ptr
-   \<lbrace>\<lambda>rv s. P (ksSchedulerAction s)\<rbrace>"
-  apply (simp add: setEndpoint_def)
-  apply (rule setObject_nosch)
-  apply (simp add: updateObject_default_def)
-  apply wp
-  apply simp
-  done
-
-lemma setNotification_nosch[wp]:
-  "\<lbrace>\<lambda>s. P (ksSchedulerAction s)\<rbrace>
-    setNotification val ptr
-   \<lbrace>\<lambda>rv s. P (ksSchedulerAction s)\<rbrace>"
-  apply (simp add: setNotification_def)
-  apply (rule setObject_nosch)
-  apply (simp add: updateObject_default_def)
-  apply wp
-  apply simp
-  done
-
-lemma set_ep_valid_objs':
-  "\<lbrace>valid_objs' and valid_ep' ep\<rbrace>
-  setEndpoint epptr ep
-  \<lbrace>\<lambda>r s. valid_objs' s\<rbrace>"
-  apply (simp add: setEndpoint_def)
-  apply (rule setObject_valid_objs')
-  apply (clarsimp simp: updateObject_default_def in_monad
-                        projectKOs valid_obj'_def)
-  done
-
-lemma set_ep_ctes_of[wp]:
-  "\<lbrace>\<lambda>s. P (ctes_of s)\<rbrace> setEndpoint p val \<lbrace>\<lambda>rv s. P (ctes_of s)\<rbrace>"
-  apply (simp add: setEndpoint_def)
-  apply (rule setObject_ctes_of[where Q="\<top>", simplified])
-   apply (clarsimp simp: updateObject_default_def in_monad
-                         projectKOs)
-  apply (clarsimp simp: updateObject_default_def bind_def
-                        projectKOs)
-  done
-
-lemma set_ep_valid_mdb' [wp]:
-  "\<lbrace>valid_mdb'\<rbrace>
-     setObject epptr (ep::endpoint)
-   \<lbrace>\<lambda>_. valid_mdb'\<rbrace>"
-  apply (simp add: valid_mdb'_def)
-  apply (rule set_ep_ctes_of[simplified setEndpoint_def])
-  done
-
-lemma setEndpoint_valid_mdb':
-  "\<lbrace>valid_mdb'\<rbrace> setEndpoint p v \<lbrace>\<lambda>rv. valid_mdb'\<rbrace>"
-  unfolding setEndpoint_def
-  by (rule set_ep_valid_mdb')
-
-lemma set_ep_valid_pspace'[wp]:
-  "\<lbrace>valid_pspace' and valid_ep' ep\<rbrace>
-  setEndpoint epptr ep
-  \<lbrace>\<lambda>r. valid_pspace'\<rbrace>"
-  apply (simp add: valid_pspace'_def)
-  apply (wp set_ep_aligned' [simplified] set_ep_valid_objs')
-   apply (wp hoare_vcg_conj_lift)
-    apply (simp add: setEndpoint_def)
-    apply (wp setEndpoint_valid_mdb')+
-  apply auto
-  done
-
-lemma set_ep_valid_bitmapQ[wp]:
-  "\<lbrace>Invariants_H.valid_bitmapQ\<rbrace> setEndpoint epptr ep \<lbrace>\<lambda>rv. Invariants_H.valid_bitmapQ\<rbrace>"
-  apply (unfold setEndpoint_def)
-  apply (rule setObject_ep_pre)
-  apply (simp add: bitmapQ_defs setObject_def split_def)
-  apply (wp hoare_Ball_helper hoare_vcg_all_lift updateObject_default_inv | simp add: bitmapQ_def)+
-  done
-
-lemma set_ep_bitmapQ_no_L1_orphans[wp]:
-  "\<lbrace> bitmapQ_no_L1_orphans \<rbrace> setEndpoint epptr ep \<lbrace>\<lambda>rv. bitmapQ_no_L1_orphans \<rbrace>"
-  apply (unfold setEndpoint_def)
-  apply (rule setObject_ep_pre)
-  apply (simp add: bitmapQ_defs setObject_def split_def)
-  apply (wp hoare_Ball_helper hoare_vcg_all_lift updateObject_default_inv | simp add: bitmapQ_def)+
-  done
-
-lemma set_ep_bitmapQ_no_L2_orphans[wp]:
-  "\<lbrace> bitmapQ_no_L2_orphans \<rbrace> setEndpoint epptr ep \<lbrace>\<lambda>rv. bitmapQ_no_L2_orphans \<rbrace>"
-  apply (unfold setEndpoint_def)
-  apply (rule setObject_ep_pre)
-  apply (simp add: bitmapQ_defs setObject_def split_def)
-  apply (wp hoare_Ball_helper hoare_vcg_all_lift updateObject_default_inv | simp add: bitmapQ_def)+
-  done
-
-lemma set_ep_valid_queues[wp]:
-  "\<lbrace>Invariants_H.valid_queues\<rbrace> setEndpoint epptr ep \<lbrace>\<lambda>rv. Invariants_H.valid_queues\<rbrace>"
-  apply (simp add: Invariants_H.valid_queues_def)
-  apply (wp hoare_vcg_conj_lift)
-    apply (simp add: setEndpoint_def valid_queues_no_bitmap_def)
-    apply (wp hoare_Ball_helper hoare_vcg_all_lift)
-      apply (rule obj_at_setObject2)
-      apply (clarsimp simp: updateObject_default_def in_monad)
-     apply (wp updateObject_default_inv set_ep_valid_bitmapQ[unfolded setEndpoint_def]
-            | simp add: valid_queues_no_bitmap_def)+
-  done
-
-lemma set_ep_valid_queues'[wp]:
-  "\<lbrace>valid_queues'\<rbrace> setEndpoint epptr ep \<lbrace>\<lambda>rv. valid_queues'\<rbrace>"
-  apply (unfold setEndpoint_def)
-  apply (simp only: valid_queues'_def imp_conv_disj
-                    obj_at'_real_def)
-  apply (wp hoare_vcg_all_lift hoare_vcg_disj_lift)
-    apply (rule setObject_ko_wp_at)
-      apply simp
-     apply (simp add: objBits_simps')
-    apply simp
-   apply (wp updateObject_default_inv | simp)+
-  apply (clarsimp simp: projectKOs ko_wp_at'_def)
-  done
-
 lemma ct_in_state_thread_state_lift':
   assumes ct: "\<And>P. \<lbrace>\<lambda>s. P (ksCurThread s)\<rbrace> f \<lbrace>\<lambda>_ s. P (ksCurThread s)\<rbrace>"
   assumes st: "\<And>t. \<lbrace>st_tcb_at' P t\<rbrace> f \<lbrace>\<lambda>_. st_tcb_at' P t\<rbrace>"
@@ -1483,48 +2127,24 @@ lemma ct_idle_or_in_cur_domain'_lift:
   apply (rule d)
   done
 
+lemmas cur_tcb_lift =
+  hoare_lift_Pf [where f = ksCurThread and P = tcb_at', folded cur_tcb'_def]
 
-lemma setObject_ep_obj_at'_tcb[wp]:
-  "\<lbrace>obj_at' (P :: tcb \<Rightarrow> bool) t \<rbrace> setObject ptr (e::endpoint) \<lbrace>\<lambda>_. obj_at' (P :: tcb \<Rightarrow> bool) t\<rbrace>"
-  apply (rule obj_at_setObject2)
-  apply (clarsimp simp: updateObject_default_def in_monad)
-  done
-
-lemma setObject_ep_cur_domain[wp]:
-  "\<lbrace>\<lambda>s. P (ksCurDomain s)\<rbrace> setObject ptr (e::endpoint) \<lbrace>\<lambda>_ s. P (ksCurDomain s)\<rbrace>"
-  apply (simp add: setObject_def split_def)
-  apply (wp updateObject_default_inv | simp)+
-  done
-
-lemma setEndpoint_tcb_in_cur_domain'[wp]:
-  "\<lbrace>tcb_in_cur_domain' t\<rbrace> setEndpoint epptr ep \<lbrace>\<lambda>_. tcb_in_cur_domain' t\<rbrace>"
-  apply (clarsimp simp: setEndpoint_def)
-  apply (rule tcb_in_cur_domain'_lift; wp)
-  done
-
-lemma setEndpoint_obj_at'_tcb[wp]:
-  "\<lbrace>obj_at' (P :: tcb \<Rightarrow> bool) t \<rbrace> setEndpoint ptr (e::endpoint) \<lbrace>\<lambda>_. obj_at' (P :: tcb \<Rightarrow> bool) t\<rbrace>"
-  by (clarsimp simp: setEndpoint_def, wp)
-
-lemma set_ep_sch_act_wf[wp]:
-  "\<lbrace>\<lambda>s. sch_act_wf (ksSchedulerAction s) s\<rbrace>
-     setEndpoint epptr ep
-   \<lbrace>\<lambda>rv s. sch_act_wf (ksSchedulerAction s) s\<rbrace>"
-  apply (wp sch_act_wf_lift)
-    apply (simp add: setEndpoint_def split_def setObject_def
-              | wp updateObject_default_inv)+
+lemma valid_mdb'_lift:
+  "(\<And>P. f \<lbrace>\<lambda>s. P (ctes_of s)\<rbrace>) \<Longrightarrow> f \<lbrace>valid_mdb'\<rbrace>"
+  unfolding valid_mdb'_def
+  apply simp
   done
 
 lemma setObject_state_refs_of':
   assumes x: "updateObject val = updateObject_default val"
-  assumes y: "(1 :: word32) < 2 ^ objBits val"
   shows
   "\<lbrace>\<lambda>s. P ((state_refs_of' s) (ptr := refs_of' (injectKO val)))\<rbrace>
      setObject ptr val
    \<lbrace>\<lambda>rv s. P (state_refs_of' s)\<rbrace>"
   apply (clarsimp simp: setObject_def valid_def in_monad split_def
-                        updateObject_default_def x in_magnitude_check
-                        projectKOs y
+                        updateObject_default_def x
+                        projectKOs in_magnitude_check[OF _]
                  elim!: rsubst[where P=P] intro!: ext
              split del: if_split cong: option.case_cong if_cong)
   apply (clarsimp simp: state_refs_of'_def objBits_def[symmetric]
@@ -1541,211 +2161,14 @@ lemma setObject_state_refs_of_eq:
      setObject ptr val
    \<lbrace>\<lambda>rv s. P (state_refs_of' s)\<rbrace>"
   apply (clarsimp simp: setObject_def valid_def in_monad split_def
-                        updateObject_default_def in_magnitude_check
-                        projectKOs lookupAround2_char1
+                        lookupAround2_char1
                  elim!: rsubst[where P=P] intro!: ext
              split del: if_split cong: option.case_cong if_cong)
-  apply (frule x, drule updateObject_objBitsKO)
-  apply (simp add: state_refs_of'_def ps_clear_upd
-             cong: option.case_cong if_cong)
-  done
-
-lemma set_ep_state_refs_of'[wp]:
-  "\<lbrace>\<lambda>s. P ((state_refs_of' s) (epptr := ep_q_refs_of' ep))\<rbrace>
-     setEndpoint epptr ep
-   \<lbrace>\<lambda>rv s. P (state_refs_of' s)\<rbrace>"
-  unfolding setEndpoint_def
-  by (wp setObject_state_refs_of',
-      simp_all add: objBits_simps' fun_upd_def[symmetric])
-
-lemma set_ntfn_ctes_of[wp]:
-  "\<lbrace>\<lambda>s. P (ctes_of s)\<rbrace> setNotification p val \<lbrace>\<lambda>rv s. P (ctes_of s)\<rbrace>"
-  apply (simp add: setNotification_def)
-  apply (rule setObject_ctes_of[where Q="\<top>", simplified])
-   apply (clarsimp simp: updateObject_default_def in_monad
-                         projectKOs)
-  apply (clarsimp simp: updateObject_default_def bind_def
-                        projectKOs)
-  done
-
-lemma set_ntfn_valid_mdb' [wp]:
-  "\<lbrace>valid_mdb'\<rbrace>
-    setObject epptr (ntfn::Structures_H.notification)
-   \<lbrace>\<lambda>_. valid_mdb'\<rbrace>"
-  apply (simp add: valid_mdb'_def)
-  apply (rule set_ntfn_ctes_of[simplified setNotification_def])
-  done
-
-lemma set_ntfn_valid_objs':
-  "\<lbrace>valid_objs' and valid_ntfn' ntfn\<rbrace>
-    setNotification p ntfn
-   \<lbrace>\<lambda>r s. valid_objs' s\<rbrace>"
-  apply (simp add: setNotification_def)
-  apply (rule setObject_valid_objs')
-  apply (clarsimp simp: updateObject_default_def in_monad
-                        valid_obj'_def)
-  done
-
-lemma set_ntfn_valid_pspace'[wp]:
-  "\<lbrace>valid_pspace' and valid_ntfn' ntfn\<rbrace>
-    setNotification p ntfn
-   \<lbrace>\<lambda>r. valid_pspace'\<rbrace>"
-  apply (simp add: valid_pspace'_def)
-  apply (wp set_ntfn_aligned' [simplified] set_ntfn_valid_objs')
-      apply (simp add: setNotification_def,wp)
-     apply auto
-  done
-
-lemma set_ntfn_valid_bitmapQ[wp]:
-  "\<lbrace>Invariants_H.valid_bitmapQ\<rbrace> setNotification p ntfn \<lbrace>\<lambda>rv. Invariants_H.valid_bitmapQ\<rbrace>"
-  apply (unfold setNotification_def)
-  apply (rule setObject_ntfn_pre)
-  apply (simp add: bitmapQ_defs setObject_def split_def)
-  apply (wp hoare_Ball_helper hoare_vcg_all_lift updateObject_default_inv | simp)+
-  done
-
-lemma set_ntfn_bitmapQ_no_L1_orphans[wp]:
-  "\<lbrace> bitmapQ_no_L1_orphans \<rbrace> setNotification p ntfn \<lbrace>\<lambda>rv. bitmapQ_no_L1_orphans \<rbrace>"
-  apply (unfold setNotification_def)
-  apply (rule setObject_ntfn_pre)
-  apply (simp add: bitmapQ_defs setObject_def split_def)
-  apply (wp hoare_Ball_helper hoare_vcg_all_lift updateObject_default_inv | simp)+
-  done
-
-lemma set_ntfn_bitmapQ_no_L2_orphans[wp]:
-  "\<lbrace> bitmapQ_no_L2_orphans \<rbrace> setNotification p ntfn \<lbrace>\<lambda>rv. bitmapQ_no_L2_orphans \<rbrace>"
-  apply (unfold setNotification_def)
-  apply (rule setObject_ntfn_pre)
-  apply (simp add: bitmapQ_defs setObject_def split_def)
-  apply (wp hoare_Ball_helper hoare_vcg_all_lift updateObject_default_inv | simp)+
-  done
-
-lemma set_ntfn_valid_queues[wp]:
-  "\<lbrace>Invariants_H.valid_queues\<rbrace> setNotification p ntfn \<lbrace>\<lambda>rv. Invariants_H.valid_queues\<rbrace>"
-  apply (simp add: Invariants_H.valid_queues_def)
-  apply (rule hoare_pre)
-   apply (wp hoare_vcg_conj_lift)
-    apply (simp add: setNotification_def valid_queues_no_bitmap_def)
-    apply (wp hoare_Ball_helper hoare_vcg_all_lift)
-      apply (rule obj_at_setObject2)
-      apply (clarsimp simp: updateObject_default_def in_monad)
-     apply (wp updateObject_default_inv set_ep_valid_bitmapQ[unfolded setEndpoint_def]
-            | simp add: valid_queues_no_bitmap_def)+
-  done
-
-lemma set_ntfn_valid_queues'[wp]:
-  "\<lbrace>valid_queues'\<rbrace> setNotification p ntfn \<lbrace>\<lambda>rv. valid_queues'\<rbrace>"
-  apply (unfold setNotification_def)
-  apply (rule setObject_ntfn_pre)
-  apply (simp only: valid_queues'_def imp_conv_disj
-                    obj_at'_real_def)
-  apply (wp hoare_vcg_all_lift hoare_vcg_disj_lift)
-    apply (rule setObject_ko_wp_at)
-      apply simp
-     apply (simp add: objBits_simps')
-    apply simp
-   apply (wp updateObject_default_inv | simp)+
-  apply (clarsimp simp: projectKOs ko_wp_at'_def)
-  done
-
-lemma set_ntfn_state_refs_of'[wp]:
-  "\<lbrace>\<lambda>s. P ((state_refs_of' s) (epptr := ntfn_q_refs_of' (ntfnObj ntfn)
-                                      \<union> ntfn_bound_refs' (ntfnBoundTCB ntfn)))\<rbrace>
-     setNotification epptr ntfn
-   \<lbrace>\<lambda>rv s. P (state_refs_of' s)\<rbrace>"
-  unfolding setNotification_def
-  by (wp setObject_state_refs_of',
-      simp_all add: objBits_simps' fun_upd_def)
-
-lemma setNotification_pred_tcb_at'[wp]:
-  "\<lbrace>pred_tcb_at' proj P t\<rbrace> setNotification ptr val \<lbrace>\<lambda>rv. pred_tcb_at' proj P t\<rbrace>"
-  apply (simp add: pred_tcb_at'_def setNotification_def)
-  apply (rule obj_at_setObject2)
-   apply simp
-  apply (clarsimp simp: updateObject_default_def in_monad)
-  done
-
-lemma setObject_ntfn_cur_domain[wp]:
-  "\<lbrace> \<lambda>s. P (ksCurDomain s) \<rbrace> setObject ptr (ntfn::Structures_H.notification) \<lbrace> \<lambda>_s . P (ksCurDomain s) \<rbrace>"
-  apply (clarsimp simp: setObject_def split_def)
-  apply (wp updateObject_default_inv | simp)+
-  done
-
-lemma setObject_ntfn_obj_at'_tcb[wp]:
-  "\<lbrace>obj_at' (P :: tcb \<Rightarrow> bool) t \<rbrace> setObject ptr (ntfn::Structures_H.notification) \<lbrace>\<lambda>_. obj_at' (P :: tcb \<Rightarrow> bool) t\<rbrace>"
-  apply (rule obj_at_setObject2)
-  apply (clarsimp simp: updateObject_default_def in_monad)
-  done
-
-lemma setNotification_ksCurDomain[wp]:
-  "\<lbrace> \<lambda>s. P (ksCurDomain s) \<rbrace> setNotification ptr (ntfn::Structures_H.notification) \<lbrace> \<lambda>_s . P (ksCurDomain s) \<rbrace>"
-   apply (simp add: setNotification_def)
-   apply wp
-   done
-
-lemma setNotification_tcb_in_cur_domain'[wp]:
-  "\<lbrace>tcb_in_cur_domain' t\<rbrace> setNotification epptr ep \<lbrace>\<lambda>_. tcb_in_cur_domain' t\<rbrace>"
-  apply (clarsimp simp: setNotification_def)
-  apply (rule tcb_in_cur_domain'_lift; wp)
-  done
-
-lemma set_ntfn_sch_act_wf[wp]:
-  "\<lbrace>\<lambda>s. sch_act_wf (ksSchedulerAction s) s\<rbrace>
-     setNotification ntfnptr ntfn
-   \<lbrace>\<lambda>rv s. sch_act_wf (ksSchedulerAction s) s\<rbrace>"
-  apply (wp sch_act_wf_lift | clarsimp simp: setNotification_def)+
-    apply (simp add: setNotification_def split_def setObject_def
-         | wp updateObject_default_inv)+
-  done
-
-lemmas cur_tcb_lift =
-  hoare_lift_Pf [where f = ksCurThread and P = tcb_at', folded cur_tcb'_def]
-
-lemma set_ntfn_cur_tcb'[wp]:
-  "\<lbrace>cur_tcb'\<rbrace> setNotification ptr ntfn \<lbrace>\<lambda>rv. cur_tcb'\<rbrace>"
-  apply (wp cur_tcb_lift)
-  apply (simp add: setNotification_def setObject_def split_def)
-  apply (wp updateObject_default_inv | simp)+
-  done
-
-lemma setEndpoint_typ_at'[wp]:
-  "\<lbrace>\<lambda>s. P (typ_at' T p s)\<rbrace> setEndpoint ptr val \<lbrace>\<lambda>rv s. P (typ_at' T p s)\<rbrace>"
-  unfolding setEndpoint_def
-  by (rule setObject_typ_at')
-
-lemmas setEndpoint_typ_ats[wp] = typ_at_lifts [OF setEndpoint_typ_at']
-
-lemma get_ep_sp':
-  "\<lbrace>P\<rbrace> getEndpoint r \<lbrace>\<lambda>t. P and ko_at' t r\<rbrace>"
-  by (clarsimp simp: getEndpoint_def getObject_def loadObject_default_def
-                     projectKOs in_monad valid_def obj_at'_def objBits_simps'
-                     in_magnitude_check split_def)
-
-lemma setEndpoint_cur_tcb'[wp]:
-  "\<lbrace>cur_tcb'\<rbrace> setEndpoint p v \<lbrace>\<lambda>rv. cur_tcb'\<rbrace>"
-  apply (wp cur_tcb_lift)
-  apply (simp add: setEndpoint_def setObject_def split_def)
-  apply (wp updateObject_default_inv | simp)+
-  done
-
-lemma setEndpoint_iflive'[wp]:
-  "\<lbrace>\<lambda>s. if_live_then_nonz_cap' s
-      \<and> (v \<noteq> IdleEP \<longrightarrow> ex_nonz_cap_to' p s)\<rbrace>
-     setEndpoint p v
-   \<lbrace>\<lambda>rv. if_live_then_nonz_cap'\<rbrace>"
-  unfolding setEndpoint_def
-  apply (wp setObject_iflive'[where P="\<top>"])
-       apply simp
-      apply (simp add: objBits_simps')
-     apply simp
-    apply (clarsimp simp: updateObject_default_def in_monad projectKOs)
-   apply (clarsimp simp: updateObject_default_def in_monad
-                         projectKOs bind_def)
-  apply clarsimp
+  apply (frule x)
+  apply (simp add: state_refs_of'_def ps_clear_upd updateObject_size
+             cong: option.case_cong if_cong)+
   done
 
-declare setEndpoint_cte_wp_at'[wp]
-
 lemma ex_nonz_cap_to_pres':
   assumes y: "\<And>P p. \<lbrace>cte_wp_at' P p\<rbrace> f \<lbrace>\<lambda>rv. cte_wp_at' P p\<rbrace>"
   shows      "\<lbrace>ex_nonz_cap_to' p\<rbrace> f \<lbrace>\<lambda>rv. ex_nonz_cap_to' p\<rbrace>"
@@ -1754,51 +2177,6 @@ lemma ex_nonz_cap_to_pres':
                y hoare_vcg_all_lift)
   done
 
-lemma setEndpoint_cap_to'[wp]:
-  "\<lbrace>ex_nonz_cap_to' p\<rbrace> setEndpoint p' v \<lbrace>\<lambda>rv. ex_nonz_cap_to' p\<rbrace>"
-  by (wp ex_nonz_cap_to_pres')
-
-lemma setEndpoint_ifunsafe'[wp]:
-  "\<lbrace>if_unsafe_then_cap'\<rbrace> setEndpoint p v \<lbrace>\<lambda>rv. if_unsafe_then_cap'\<rbrace>"
-  unfolding setEndpoint_def
-  apply (rule setObject_ifunsafe'[where P="\<top>", simplified])
-    apply (clarsimp simp: updateObject_default_def in_monad projectKOs
-                  intro!: equals0I)+
-  apply (simp add: setObject_def split_def)
-  apply (wp updateObject_default_inv | simp)+
-  done
-
-lemma setEndpoint_idle'[wp]:
-  "\<lbrace>\<lambda>s. valid_idle' s\<rbrace>
-   setEndpoint p v
-   \<lbrace>\<lambda>_. valid_idle'\<rbrace>"
-  unfolding setEndpoint_def
-  apply (wp setObject_idle')
-       apply (simp add: objBits_simps' updateObject_default_inv)+
-  apply (clarsimp simp: projectKOs idle_tcb_ps_def)
-  done
-
-crunch it[wp]: setEndpoint "\<lambda>s. P (ksIdleThread s)"
-  (simp: updateObject_default_inv)
-
-lemma setObject_ksPSpace_only:
-  "\<lbrakk> \<And>p q n ko. \<lbrace>P\<rbrace> updateObject val p q n ko \<lbrace>\<lambda>rv. P \<rbrace>;
-        \<And>f s. P (ksPSpace_update f s) = P s \<rbrakk>
-     \<Longrightarrow> \<lbrace>P\<rbrace> setObject ptr val \<lbrace>\<lambda>rv. P\<rbrace>"
-  apply (simp add: setObject_def split_def)
-  apply (wp | simp | assumption)+
-  done
-
-lemma setObject_ksMachine:
-  "\<lbrakk> \<And>p q n ko. \<lbrace>\<lambda>s. P (ksMachineState s)\<rbrace> updateObject val p q n ko \<lbrace>\<lambda>rv s. P (ksMachineState s)\<rbrace> \<rbrakk>
-     \<Longrightarrow> \<lbrace>\<lambda>s. P (ksMachineState s)\<rbrace> setObject ptr val \<lbrace>\<lambda>rv s. P (ksMachineState s)\<rbrace>"
-  by (simp add: setObject_ksPSpace_only)
-
-lemma setObject_ksInterrupt:
-  "\<lbrakk> \<And>p q n ko. \<lbrace>\<lambda>s. P (ksInterruptState s)\<rbrace> updateObject val p q n ko \<lbrace>\<lambda>rv s. P (ksInterruptState s)\<rbrace> \<rbrakk>
-     \<Longrightarrow> \<lbrace>\<lambda>s. P (ksInterruptState s)\<rbrace> setObject ptr val \<lbrace>\<lambda>rv s. P (ksInterruptState s)\<rbrace>"
-  by (simp add: setObject_ksPSpace_only)
-
 lemma valid_irq_handlers_lift':
   assumes x: "\<And>P. \<lbrace>\<lambda>s. P (cteCaps_of s)\<rbrace> f \<lbrace>\<lambda>rv s. P (cteCaps_of s)\<rbrace>"
   assumes y: "\<And>P. \<lbrace>\<lambda>s. P (ksInterruptState s)\<rbrace> f \<lbrace>\<lambda>rv s. P (ksInterruptState s)\<rbrace>"
@@ -1836,105 +2202,6 @@ lemma valid_arch_state_lift':
    apply (wp typs hoare_vcg_const_Ball_lift arch typ_at_lifts)+
   done
 
-lemma setObject_ep_ct:
-  "\<lbrace>\<lambda>s. P (ksCurThread s)\<rbrace> setObject p (e::endpoint) \<lbrace>\<lambda>_ s. P (ksCurThread s)\<rbrace>"
-  apply (simp add: setObject_def updateObject_ep_eta split_def)
-  apply (wp updateObject_default_inv | simp)+
-  done
-
-lemma setObject_ntfn_ct:
-  "\<lbrace>\<lambda>s. P (ksCurThread s)\<rbrace> setObject p (e::Structures_H.notification)
-   \<lbrace>\<lambda>_ s. P (ksCurThread s)\<rbrace>"
-  apply (simp add: setObject_def split_def)
-  apply (wp updateObject_default_inv | simp)+
-  done
-
-lemma get_ntfn_sp':
-  "\<lbrace>P\<rbrace> getNotification r \<lbrace>\<lambda>t. P and ko_at' t r\<rbrace>"
-  by (clarsimp simp: getNotification_def getObject_def loadObject_default_def
-                     projectKOs in_monad valid_def obj_at'_def objBits_simps'
-                     in_magnitude_check split_def)
-
-lemma set_ntfn_pred_tcb_at' [wp]:
-  "\<lbrace> pred_tcb_at' proj P t \<rbrace>
-   setNotification ep v
-   \<lbrace> \<lambda>rv. pred_tcb_at' proj P t \<rbrace>"
-  apply (simp add: setNotification_def pred_tcb_at'_def)
-  apply (rule obj_at_setObject2)
-  apply (clarsimp simp add: updateObject_default_def in_monad)
-  done
-
-lemma set_ntfn_iflive'[wp]:
-  "\<lbrace>\<lambda>s. if_live_then_nonz_cap' s
-      \<and> (live' (KONotification v) \<longrightarrow> ex_nonz_cap_to' p s)\<rbrace>
-     setNotification p v
-   \<lbrace>\<lambda>rv. if_live_then_nonz_cap'\<rbrace>"
-  apply (simp add: setNotification_def)
-  apply (wp setObject_iflive'[where P="\<top>"])
-       apply simp
-      apply (simp add: objBits_simps)
-     apply (simp add: objBits_simps')
-    apply (clarsimp simp: updateObject_default_def in_monad projectKOs)
-   apply (clarsimp simp: updateObject_default_def
-                         projectKOs bind_def)
-  apply clarsimp
-  done
-
-declare setNotification_cte_wp_at'[wp]
-
-lemma set_ntfn_cap_to'[wp]:
-  "\<lbrace>ex_nonz_cap_to' p\<rbrace> setNotification p' v \<lbrace>\<lambda>rv. ex_nonz_cap_to' p\<rbrace>"
-  by (wp ex_nonz_cap_to_pres')
-
-lemma setNotification_ifunsafe'[wp]:
-  "\<lbrace>if_unsafe_then_cap'\<rbrace> setNotification p v \<lbrace>\<lambda>rv. if_unsafe_then_cap'\<rbrace>"
-  unfolding setNotification_def
-  apply (rule setObject_ifunsafe'[where P="\<top>", simplified])
-    apply (clarsimp simp: updateObject_default_def in_monad projectKOs
-                  intro!: equals0I)+
-  apply (simp add: setObject_def split_def)
-  apply (wp updateObject_default_inv | simp)+
-  done
-
-lemma setNotification_idle'[wp]:
-  "\<lbrace>\<lambda>s. valid_idle' s\<rbrace> setNotification p v \<lbrace>\<lambda>rv. valid_idle'\<rbrace>"
-  unfolding setNotification_def
-  apply (wp setObject_idle')
-        apply (simp add: objBits_simps' updateObject_default_inv)+
-  apply (clarsimp simp: projectKOs idle_tcb_ps_def)
-  done
-
-crunch it[wp]: setNotification "\<lambda>s. P (ksIdleThread s)"
-  (wp: updateObject_default_inv)
-
-lemma set_ntfn_arch' [wp]:
-  "\<lbrace>\<lambda>s. P (ksArchState s)\<rbrace> setNotification ntfn p \<lbrace>\<lambda>_ s. P (ksArchState s)\<rbrace>"
-  apply (simp add: setNotification_def setObject_def split_def)
-  apply (wp updateObject_default_inv|simp)+
-  done
-
-lemma set_ntfn_ksInterrupt[wp]:
-  "\<lbrace>\<lambda>s. P (ksInterruptState s)\<rbrace> setNotification ptr val \<lbrace>\<lambda>rv s. P (ksInterruptState s)\<rbrace>"
-  by (simp add: setNotification_def | wp setObject_ksInterrupt updateObject_default_inv)+
-
-lemma set_ntfn_ksMachine[wp]:
-  "\<lbrace>\<lambda>s. P (ksMachineState s)\<rbrace> setNotification ptr val \<lbrace>\<lambda>rv s. P (ksMachineState s)\<rbrace>"
-  by (simp add: setNotification_def | wp setObject_ksMachine updateObject_default_inv)+
-
-lemma set_ntfn_maxObj [wp]:
-  "\<lbrace>\<lambda>s. P (gsMaxObjectSize s)\<rbrace> setNotification ptr val \<lbrace>\<lambda>rv s. P (gsMaxObjectSize s)\<rbrace>"
-  by (simp add: setNotification_def | wp setObject_ksPSpace_only updateObject_default_inv)+
-
-lemma set_ntfn_global_refs' [wp]:
-  "\<lbrace>valid_global_refs'\<rbrace> setNotification ptr val \<lbrace>\<lambda>_. valid_global_refs'\<rbrace>"
-  by (rule valid_global_refs_lift'; wp)
-
-crunch typ_at' [wp]: setNotification "\<lambda>s. P (typ_at' T p s)"
-
-lemma set_ntfn_valid_arch' [wp]:
-  "\<lbrace>valid_arch_state'\<rbrace> setNotification ptr val \<lbrace>\<lambda>_. valid_arch_state'\<rbrace>"
-  by (rule valid_arch_state_lift'; wp)
-
 lemmas valid_irq_node_lift =
     hoare_use_eq_irq_node' [OF _ typ_at_lift_valid_irq_node']
 
@@ -1951,44 +2218,6 @@ lemma valid_irq_states_lift':
   apply wp
   done
 
-lemmas set_ntfn_irq_handlers'[wp] = valid_irq_handlers_lift'' [OF set_ntfn_ctes_of set_ntfn_ksInterrupt]
-
-lemmas set_ntfn_irq_states' [wp] = valid_irq_states_lift' [OF set_ntfn_ksInterrupt set_ntfn_ksMachine]
-
-lemma valid_pde_mappings'_def2:
-  "valid_pde_mappings' =
-     (\<lambda>s. \<forall>x. pde_at' x s \<longrightarrow> obj_at' (valid_pde_mapping' (x && mask pdBits)) x s)"
-  apply (clarsimp simp: valid_pde_mappings'_def typ_at_to_obj_at_arches)
-  apply (rule ext, rule iff_allI)
-  apply (clarsimp simp: obj_at'_def projectKOs)
-  apply (auto simp add: objBits_simps archObjSize_def)
-  done
-
-lemma valid_pde_mappings_lift':
-  assumes x: "\<And>P T p. \<lbrace>\<lambda>s. P (typ_at' T p s)\<rbrace> f \<lbrace>\<lambda>rv s. P (typ_at' T p s)\<rbrace>"
-  assumes y: "\<And>x. \<lbrace>obj_at' (valid_pde_mapping' (x && mask pdBits)) x\<rbrace>
-                    f \<lbrace>\<lambda>rv. obj_at' (valid_pde_mapping' (x && mask pdBits)) x\<rbrace>"
-  shows      "\<lbrace>valid_pde_mappings'\<rbrace> f \<lbrace>\<lambda>rv. valid_pde_mappings'\<rbrace>"
-  apply (simp only: valid_pde_mappings'_def2 imp_conv_disj)
-  apply (rule hoare_vcg_all_lift hoare_vcg_disj_lift x y)+
-  done
-
-lemma set_ntfn_valid_pde_mappings'[wp]:
-  "\<lbrace>valid_pde_mappings'\<rbrace> setNotification ptr val \<lbrace>\<lambda>rv. valid_pde_mappings'\<rbrace>"
-  apply (rule valid_pde_mappings_lift')
-   apply wp
-  apply (simp add: setNotification_def)
-  apply (rule obj_at_setObject2)
-  apply (clarsimp simp: updateObject_default_def in_monad)
-  done
-
-lemma set_ntfn_vms'[wp]:
-  "\<lbrace>valid_machine_state'\<rbrace> setNotification ptr val \<lbrace>\<lambda>rv. valid_machine_state'\<rbrace>"
-  apply (simp add: setNotification_def valid_machine_state'_def pointerInDeviceData_def pointerInUserData_def)
-  apply (intro hoare_vcg_all_lift hoare_vcg_disj_lift)
-  by (wp setObject_typ_at_inv setObject_ksMachine updateObject_default_inv |
-      simp)+
-
 lemma irqs_masked_lift:
   assumes "\<And>P. \<lbrace>\<lambda>s. P (intStateIRQTable (ksInterruptState s))\<rbrace> f
                \<lbrace>\<lambda>rv s. P (intStateIRQTable (ksInterruptState s))\<rbrace>"
@@ -2810,8 +3753,7 @@ lemma ep_redux_simps':
   "ntfn_q_refs_of' (case xs of [] \<Rightarrow> IdleNtfn | y # ys \<Rightarrow> WaitingNtfn xs)
         = (set xs \<times> {NTFNSignal})"
   by (fastforce split: list.splits
-                simp: valid_ep_def valid_ntfn_def
-              intro!: ext)+
+                simp: valid_ep_def valid_ntfn_def)+
 
 
 (* There are two wp rules for preserving valid_ioc over set_object.
@@ -2888,34 +3839,1848 @@ lemma doMachineOp_invs_bits[wp]:
   "\<lbrace>if_live_then_nonz_cap'\<rbrace> doMachineOp m \<lbrace>\<lambda>rv. if_live_then_nonz_cap'\<rbrace>"
   "\<lbrace>cur_tcb'\<rbrace> doMachineOp m \<lbrace>\<lambda>rv. cur_tcb'\<rbrace>"
   "\<lbrace>if_unsafe_then_cap'\<rbrace> doMachineOp m \<lbrace>\<lambda>rv. if_unsafe_then_cap'\<rbrace>"
-  by (simp add: doMachineOp_def split_def
-                valid_pspace'_def valid_queues_def valid_queues_no_bitmap_def bitmapQ_defs
+  "\<lbrace>sch_act_simple\<rbrace> doMachineOp mop \<lbrace>\<lambda>rv. sch_act_simple\<rbrace>"
+  by (simp add: doMachineOp_def split_def sch_act_simple_def
        | wp cur_tcb_lift sch_act_wf_lift tcb_in_cur_domain'_lift
        | fastforce elim: state_refs_of'_pspaceI)+
 
-crunch cte_wp_at'[wp]: doMachineOp "\<lambda>s. P (cte_wp_at' P' p s)"
-crunch obj_at'[wp]: doMachineOp "\<lambda>s. P (obj_at' P' p s)"
+crunches doMachineOp
+  for obj_at'[wp]: "\<lambda>s. P (obj_at' P' p s)"
+  and it[wp]: "\<lambda>s. P (ksIdleThread s)"
+  and idle'[wp]: "valid_idle'"
+  and pde_mappings'[wp]: "valid_pde_mappings'"
+  and ko_wp_at'[wp]: "\<lambda>s. P (ko_wp_at' T p s)"
 
-crunch it[wp]: doMachineOp "\<lambda>s. P (ksIdleThread s)"
-crunch idle'[wp]: doMachineOp "valid_idle'"
-  (wp: crunch_wps simp: crunch_simps valid_idle'_pspace_itI)
-crunch pde_mappings'[wp]: doMachineOp "valid_pde_mappings'"
+context begin interpretation Arch . (*FIXME: arch_split*)
 
-lemma setEndpoint_ksMachine:
-  "\<lbrace>\<lambda>s. P (ksMachineState s)\<rbrace> setEndpoint ptr val \<lbrace>\<lambda>rv s. P (ksMachineState s)\<rbrace>"
-  by (simp add: setEndpoint_def | wp setObject_ksMachine updateObject_default_inv)+
+lemmas bit_simps' = pteBits_def asidHighBits_def asid_low_bits_def
+                    asid_high_bits_def minSchedContextBits_def
+                    replySizeBits_def pageBits_def pdeBits_def ptBits_def pdBits_def
+
+lemmas is_aligned_add_step_le' = is_aligned_add_step_le[simplified mask_2pm1 add_diff_eq]
+
+lemma objBitsKO_Data:
+  "objBitsKO (if dev then KOUserDataDevice else KOUserData) = pageBits"
+  by (simp add: objBits_def objBitsKO_def word_size_def)
+
+lemma of_bl_shift_cte_level_bits:
+  "(of_bl z :: machine_word) << cte_level_bits \<le> mask (cte_level_bits + length z)"
+  by word_bitwise
+     (simp add: test_bit_of_bl word_size cte_level_bits_def rev_bl_order_simps)
+
+lemma obj_relation_cuts_range_limit:
+  "\<lbrakk> (p', P) \<in> obj_relation_cuts ko p; P ko ko' \<rbrakk>
+   \<Longrightarrow> \<exists>x n. p' = p + x \<and> is_aligned x n \<and> n \<le> obj_bits ko \<and> x \<le> mask (obj_bits ko)"
+   apply (erule (1) obj_relation_cutsE; clarsimp)
+     apply (drule (1) wf_cs_nD)
+     apply (clarsimp simp: cte_map_def[simplified word_shift_by_n])
+     apply (rule_tac x=cte_level_bits in exI)
+     apply (simp add: is_aligned_shift of_bl_shift_cte_level_bits)
+       apply (rule_tac x=minSchedContextBits in exI)
+       apply (simp add: bit_simps' min_sched_context_bits_def)
+      apply (rule_tac x=replySizeBits in exI)
+      apply (simp add: replySizeBits_def)
+     apply (rule_tac x=pteBits in exI)
+     apply (simp add: bit_simps is_aligned_shift mask_def pteBits_def)
+     apply word_bitwise
+    apply (rule_tac x=pdeBits in exI)
+    apply (simp add: bit_simps is_aligned_shift mask_def pdeBits_def)
+    apply word_bitwise
+   apply (rule_tac x=pageBits in exI)
+   apply (simp add: is_aligned_shift pbfs_atleast_pageBits is_aligned_mult_triv2)
+   apply (simp add: mask_def shiftl_t2n mult_ac)
+   apply (frule word_less_power_trans2, rule pbfs_atleast_pageBits)
+    apply (simp add: pbfs_less_wb'[unfolded word_bits_def, simplified])
+   apply (simp add: pbfs_less_wb'[unfolded word_bits_def, simplified])
+  apply fastforce
+  done
 
-lemmas setEndpoint_valid_irq_states'  =
-  valid_irq_states_lift' [OF setEndpoint_ksInterruptState setEndpoint_ksMachine]
+lemma obj_relation_cuts_range_mask_range:
+  "\<lbrakk> (p', P) \<in> obj_relation_cuts ko p; P ko ko'; is_aligned p (obj_bits ko) \<rbrakk>
+   \<Longrightarrow> p' \<in> mask_range p (obj_bits ko)"
+  apply (drule (1) obj_relation_cuts_range_limit, clarsimp)
+  apply (rule conjI)
+   apply (rule word_plus_mono_right2; assumption?)
+   apply (simp add: is_aligned_no_overflow_mask)
+  apply (erule word_plus_mono_right)
+  apply (simp add: is_aligned_no_overflow_mask)
+  done
+
+lemma obj_relation_cuts_obj_bits:
+  "\<lbrakk> (p', P) \<in> obj_relation_cuts ko p; P ko ko' \<rbrakk> \<Longrightarrow> objBitsKO ko' \<le> obj_bits ko"
+  apply (erule (1) obj_relation_cutsE;
+          clarsimp simp: objBits_simps objBits_defs cte_level_bits_def sc_const_eq[symmetric]
+                         pbfs_atleast_pageBits[simplified bit_simps] archObjSize_def pteBits_def
+                         pdeBits_def)
+  apply (clarsimp simp: scBits_inverse_sc_relation[simplified])
+  apply (cases ko; simp add: other_obj_relation_def objBits_defs
+                      split: kernel_object.splits)
+  apply (rename_tac ako, case_tac ako; clarsimp)
+  apply (rename_tac ako', case_tac ako'; clarsimp simp: archObjSize_def)
+  done
+
+lemma typ_at'_same_type:
+  assumes "typ_at' T p s" "koTypeOf k = koTypeOf ko" "objBitsKO k = objBitsKO ko" "ksPSpace s p' = Some ko"
+  shows "typ_at' T p (s\<lparr>ksPSpace :=ksPSpace s(p' \<mapsto> k)\<rparr>)"
+  using assms
+  by (clarsimp simp: typ_at'_def ko_wp_at'_def ps_clear_upd)
+
+lemma cte_at'_same_type:
+  "\<lbrakk>cte_wp_at' \<top> t s; koTypeOf k = koTypeOf ko;objBitsKO k = objBitsKO ko;
+    ksPSpace s p = Some ko\<rbrakk>
+      \<Longrightarrow> cte_wp_at' \<top> t (s\<lparr>ksPSpace := ksPSpace s(p \<mapsto> k)\<rparr>)"
+  apply (simp add: cte_at_typ' typ_at'_same_type)
+  apply (elim exE disjE)
+   apply (rule disjI1, clarsimp simp: typ_at'_same_type)
+  apply (rule disjI2, rule_tac x=n in exI, clarsimp simp: typ_at'_same_type)
+  done
+
+lemma valid_ep'_ep_update:
+  "\<lbrakk> valid_objs' s; valid_ep' ep s; ep_at' epPtr s; ksPSpace s x = Some (KOEndpoint obj) \<rbrakk>
+     \<Longrightarrow> valid_ep' obj (s\<lparr>ksPSpace := ksPSpace s(epPtr \<mapsto> KOEndpoint ep)\<rparr>)"
+  apply (erule (1) valid_objsE')
+  apply (fastforce simp: valid_objs'_def valid_obj'_def obj_at'_def projectKOs valid_ep'_def
+                  split: endpoint.splits)
+  done
+
+lemma valid_cap'_ep_update:
+  "\<lbrakk> valid_cap' cap s; valid_objs' s; valid_ep' ep s; ep_at' epPtr s \<rbrakk>
+     \<Longrightarrow> valid_cap' cap (s\<lparr>ksPSpace := ksPSpace s(epPtr \<mapsto> KOEndpoint ep)\<rparr>)"
+  supply ps_clear_upd[simp]
+  apply (clarsimp simp: typ_at'_same_type ko_wp_at'_def cte_at'_same_type
+                        valid_cap'_def obj_at'_def projectKOs objBits_simps
+                 split: endpoint.splits capability.splits)
+         apply fastforce+
+       apply (clarsimp split: zombie_type.splits simp: projectKOs obj_at'_def typ_at'_same_type)
+       apply (intro conjI impI; clarsimp)
+        apply (drule_tac x=addr in spec, clarsimp)
+       apply (drule_tac x=addr in spec, clarsimp)
+      apply (clarsimp simp: ko_wp_at'_def valid_cap'_def obj_at'_def projectKOs objBits_simps
+                            page_directory_at'_def page_table_at'_def
+                            ARM_H.arch_capability.distinct ARM_H.arch_capability.inject
+                     split: ARM_H.arch_capability.splits option.splits if_split_asm
+           | rule_tac ko="KOEndpoint obj" in typ_at'_same_type[where p'=epPtr]
+           | simp)+
+     apply fastforce
+    apply (clarsimp simp: valid_untyped'_def ko_wp_at'_def obj_range'_def split: if_split_asm)
+     apply (drule_tac x=epPtr in spec, fastforce simp: objBits_simps)+
+   apply (drule_tac x=addr in spec, fastforce)
+  apply fastforce
+  done
 
-lemma setEndpoint_ct':
-  "\<lbrace>\<lambda>s. P (ksCurThread s)\<rbrace> setEndpoint a b \<lbrace>\<lambda>rv s. P (ksCurThread s)\<rbrace>"
-  apply (simp add: setEndpoint_def setObject_def split_def)
-  apply (wp updateObject_default_inv | simp)+
+lemma valid_cap'_reply_update:
+  "\<lbrakk> valid_cap' cap s; valid_objs' s; valid_reply' reply s; reply_at' rptr s \<rbrakk>
+     \<Longrightarrow> valid_cap' cap (s\<lparr>ksPSpace := ksPSpace s(rptr \<mapsto> KOReply reply)\<rparr>)"
+  supply ps_clear_upd[simp]
+  apply (clarsimp simp: typ_at'_same_type ko_wp_at'_def cte_at'_same_type
+                        valid_cap'_def obj_at'_def projectKOs objBits_simps
+                 split: endpoint.splits capability.splits)
+         apply fastforce+
+      apply (clarsimp split: zombie_type.splits simp: projectKOs obj_at'_def typ_at'_same_type)
+      apply (intro conjI impI; clarsimp)
+       apply (drule_tac x=addr in spec, clarsimp)
+      apply (drule_tac x=addr in spec, clarsimp)
+     apply (clarsimp simp: ko_wp_at'_def valid_cap'_def obj_at'_def projectKOs objBits_simps
+                           page_directory_at'_def page_table_at'_def
+                    split: ARM_H.arch_capability.splits option.splits if_split_asm
+          | rule_tac ko="KOReply obj" in typ_at'_same_type[where p'=rptr])+
+    apply (clarsimp simp: valid_untyped'_def ko_wp_at'_def obj_range'_def split: if_split_asm)
+     apply (drule_tac x=rptr in spec, fastforce simp: objBits_simps)+
+   apply (drule_tac x=addr in spec, fastforce)
+  apply fastforce
+  done
+
+lemma valid_tcb_state'_ep_update:
+  "\<lbrakk> valid_objs' s; valid_ep' ep s; ep_at' epPtr s;  ksPSpace s x = Some (KOTCB obj) \<rbrakk>
+     \<Longrightarrow> valid_tcb_state' (tcbState obj) (s\<lparr>ksPSpace := ksPSpace s(epPtr \<mapsto> KOEndpoint ep)\<rparr>)"
+  apply (rule valid_objsE', simp, simp)
+  by (fastforce simp: typ_at'_same_type ps_clear_upd objBits_simps valid_obj'_def projectKOs
+                      valid_tcb_state'_def valid_bound_obj'_def valid_tcb'_def obj_at'_def
+               split: option.splits thread_state.splits)
+
+lemma valid_tcb_state'_reply_update:
+  "\<lbrakk> valid_objs' s; valid_reply' reply s; reply_at' rptr s; ksPSpace s x = Some (KOTCB obj) \<rbrakk>
+     \<Longrightarrow> valid_tcb_state' (tcbState obj) (s\<lparr>ksPSpace := ksPSpace s(rptr \<mapsto> KOReply reply)\<rparr>)"
+  apply (rule valid_objsE', simp, simp)
+  by (fastforce simp: typ_at'_same_type ps_clear_upd objBits_simps valid_obj'_def projectKOs
+                      valid_bound_obj'_def valid_tcb'_def valid_tcb_state'_def obj_at'_def
+               split: option.splits thread_state.splits)
+
+lemma valid_tcb'_ep_update:
+  "\<lbrakk> valid_objs' s; valid_ep' ep s; ep_at' epPtr s; ksPSpace s x = Some (KOTCB obj) \<rbrakk>
+     \<Longrightarrow> valid_tcb' obj (s\<lparr>ksPSpace := ksPSpace s(epPtr \<mapsto> KOEndpoint ep)\<rparr>)"
+  apply (rule valid_objsE', simp, simp)
+  by (fastforce simp: typ_at'_same_type ps_clear_upd objBits_simps valid_obj'_def projectKOs
+                      valid_bound_obj'_def valid_tcb'_def obj_at'_def valid_tcb_state'_ep_update
+                      valid_cap'_ep_update
+              split: option.splits thread_state.splits)
+
+lemma valid_arch_obj'_ep_update:
+  "\<lbrakk> valid_objs' s; valid_ep' ep s; ep_at' epPtr s; ksPSpace s x = Some (KOArch obj) \<rbrakk>
+     \<Longrightarrow> valid_arch_obj' obj (s\<lparr>ksPSpace := ksPSpace s(epPtr \<mapsto> KOEndpoint ep)\<rparr>)"
+  apply (rule valid_objsE', simp, simp)
+  apply (cases obj; clarsimp simp: valid_arch_obj'_def valid_obj'_def obj_at'_def projectKOs
+                            split: arch_kernel_object.splits)
+    apply (rename_tac asid ep', case_tac asid, simp)
+   apply (rename_tac pte ep', case_tac pte; simp add: valid_mapping'_def)
+  apply (rename_tac pde ep', case_tac pde; simp add: valid_mapping'_def)
+  done
+
+lemma valid_arch_obj'_reply_update:
+  "\<lbrakk> valid_objs' s; valid_reply' reply s; reply_at' rptr s; ksPSpace s x = Some (KOArch obj) \<rbrakk>
+     \<Longrightarrow> valid_arch_obj' obj (s\<lparr>ksPSpace := ksPSpace s(rptr \<mapsto> KOReply reply)\<rparr>)"
+  supply ps_clear_upd[simp]
+  apply (rule valid_objsE', simp, simp)
+  apply (cases obj; clarsimp simp: valid_arch_obj'_def valid_obj'_def obj_at'_def projectKOs
+                            split: arch_kernel_object.splits)
+    apply (rename_tac asid reply', case_tac asid, simp)
+   apply (rename_tac pte reply', case_tac pte; simp add: valid_mapping'_def)
+  apply (rename_tac pde reply', case_tac pde; simp add: valid_mapping'_def)
+  done
+
+end
+
+lemma valid_obj'_ep_update:
+  "\<lbrakk> valid_objs' s; valid_ep' ep s; ep_at' epPtr s; ksPSpace s x = Some obj\<rbrakk>
+       \<Longrightarrow> valid_obj' obj (s\<lparr>ksPSpace := ksPSpace s(epPtr \<mapsto> KOEndpoint ep)\<rparr>)"
+  apply (rule valid_objsE', simp, simp)
+  by (cases obj;
+      clarsimp simp: typ_at'_same_type valid_obj'_def obj_at'_def ps_clear_upd
+                     valid_ntfn'_def  valid_bound_obj'_def valid_reply'_def valid_cte'_def
+                     valid_sched_context'_def objBits_simps projectKOs valid_cap'_ep_update
+                     valid_arch_obj'_ep_update valid_ep'_ep_update valid_tcb'_ep_update
+              split: endpoint.splits ntfn.splits option.splits)
+     fastforce+
+
+lemma valid_obj'_reply_update:
+  "\<lbrakk> valid_objs' s; valid_reply' reply s; reply_at' rptr s; ksPSpace s x = Some obj \<rbrakk>
+     \<Longrightarrow> valid_obj' obj (s\<lparr>ksPSpace := ksPSpace s(rptr \<mapsto> KOReply reply)\<rparr>)"
+  apply (rule valid_objsE', simp, simp)
+  apply (cases obj; clarsimp simp: valid_obj'_def)
+        apply (fastforce simp: valid_ep'_def obj_at'_def projectKOs split: endpoint.split)
+       apply (fastforce simp: valid_bound_obj'_def valid_ntfn'_def obj_at'_def projectKOs
+                       split: ntfn.splits option.split)
+      apply (fastforce simp: valid_bound_obj'_def valid_tcb'_def valid_tcb_state'_reply_update
+                             valid_cap'_reply_update obj_at'_def projectKOs tcb_cte_cases_def
+                      split: option.split)
+     apply (fastforce simp: valid_cap'_reply_update obj_at'_def valid_cte'_def projectKOs)
+    apply (fastforce simp: valid_arch_obj'_reply_update obj_at'_def projectKOs)
+   apply (fastforce simp: valid_sched_context'_def valid_bound_obj'_def objBitsKO_def
+                          obj_at'_def projectKOs ps_clear_upd
+                   split: option.split)
+  apply (fastforce simp: valid_reply'_def valid_bound_obj'_def obj_at'_def projectKOs objBitsKO_def
+                  split: option.split)
+  done
+
+lemma valid_objs'_ep_update:
+  "\<lbrakk> valid_objs' s; valid_ep' ep s; ep_at' epPtr s \<rbrakk>
+     \<Longrightarrow> valid_objs' (s\<lparr>ksPSpace := ksPSpace s(epPtr \<mapsto> KOEndpoint ep)\<rparr>)"
+  apply (clarsimp simp: valid_objs'_def obj_at'_def projectKOs)
+  apply (erule ranE)
+  apply (clarsimp simp: ps_clear_upd split: if_split_asm)
+   apply (fastforce simp: valid_obj'_def valid_ep'_def obj_at'_def ps_clear_upd
+                          objBits_simps projectKOs
+                   split: endpoint.splits)
+  apply (fastforce intro!: valid_obj'_ep_update simp: valid_objs'_def obj_at'_def projectKOs)
+  done
+
+lemma valid_objs'_reply_update:
+  "\<lbrakk> valid_objs' s; valid_reply' reply s; reply_at' rptr s \<rbrakk>
+     \<Longrightarrow> valid_objs' (s\<lparr>ksPSpace := ksPSpace s(rptr \<mapsto> KOReply reply)\<rparr>)"
+  apply (clarsimp simp: valid_objs'_def obj_at'_def projectKOs)
+  apply (erule ranE)
+  apply (clarsimp split: if_split_asm)
+   apply (fastforce simp: valid_bound_obj'_def valid_obj'_def valid_reply'_def
+                          obj_at'_def projectKOs objBitsKO_def
+                   split: option.splits)
+  apply (fastforce intro!: valid_obj'_reply_update simp: valid_objs'_def obj_at'_def projectKOs)
+  done
+
+lemma valid_release_queue_ksPSpace_update:
+  "\<lbrakk>valid_release_queue s;
+    ko_wp_at' (\<lambda>ko'. koTypeOf ko' = koTypeOf ko \<and> objBitsKO ko' = objBitsKO ko) ptr s;
+    koTypeOf ko \<noteq> TCBT\<rbrakk> \<Longrightarrow>
+    valid_release_queue (s\<lparr>ksPSpace := ksPSpace s(ptr \<mapsto> ko)\<rparr>)"
+  by (fastforce simp: valid_release_queue_def ko_wp_at'_def obj_at'_def projectKOs ps_clear_upd)
+
+lemma valid_release_queue'_ksPSpace_update:
+  "\<lbrakk>valid_release_queue' s;
+    ko_wp_at' (\<lambda>ko'. koTypeOf ko' = koTypeOf ko \<and> objBitsKO ko' = objBitsKO ko) ptr s;
+    koTypeOf ko \<noteq> TCBT\<rbrakk> \<Longrightarrow>
+    valid_release_queue' (s\<lparr>ksPSpace := ksPSpace s(ptr \<mapsto> ko)\<rparr>)"
+  by (fastforce simp: valid_release_queue'_def ko_wp_at'_def obj_at'_def projectKOs ps_clear_upd)
+
+lemma sym_ref_Receive_or_Reply_replyTCB':
+  "\<lbrakk> sym_refs (state_refs_of' s); ko_at' tcb tp s;
+     tcbState tcb = BlockedOnReceive ep pl (Some rp)
+     \<or> tcbState tcb = BlockedOnReply (Some rp) \<rbrakk> \<Longrightarrow>
+    \<exists>reply. ksPSpace s rp = Some (KOReply reply) \<and> replyTCB reply = Some tp"
+  apply (drule (1) sym_refs_obj_atD'[rotated, where p=tp])
+  apply (clarsimp simp: state_refs_of'_def projectKOs obj_at'_def)
+  apply (clarsimp simp: ko_wp_at'_def)
+  apply (erule disjE; clarsimp)
+  apply (rename_tac koa; case_tac koa;
+         simp add: get_refs_def2 ep_q_refs_of'_def ntfn_q_refs_of'_def
+                   tcb_st_refs_of'_def tcb_bound_refs'_def
+            split: endpoint.split_asm ntfn.split_asm thread_state.split_asm if_split_asm)+
+  done
+
+lemma sym_ref_replyTCB_Receive_or_Reply:
+  "\<lbrakk> ko_at' reply rp s; sym_refs (state_refs_of' s); replyTCB reply = Some tp \<rbrakk>
+   \<Longrightarrow> st_tcb_at' (\<lambda>st. (\<exists>ep pl. st = BlockedOnReceive ep pl (Some rp))
+                        \<or> st = BlockedOnReply (Some rp)) tp s"
+  apply (drule (1) sym_refs_obj_atD'[rotated, where p=rp])
+  apply (clarsimp simp: state_refs_of'_def projectKOs pred_tcb_at'_def obj_at'_def)
+  apply (clarsimp simp: ko_wp_at'_def)
+  apply (rename_tac tcb; case_tac tcb;
+         simp add: get_refs_def2 ntfn_q_refs_of'_def
+                   tcb_st_refs_of'_def tcb_bound_refs'_def
+            split: ntfn.split_asm thread_state.split_asm)+
+  done
+
+lemma sym_ref_BlockedOnSend_SendEP':
+  "\<lbrakk> sym_refs (state_refs_of' s); st_tcb_at' ((=) (BlockedOnSend eptr p1 p2 p3 p4)) tp s\<rbrakk>
+      \<Longrightarrow> \<exists>list. ko_wp_at' ((=) (KOEndpoint (SendEP list))) eptr s"
+  apply (simp add: pred_tcb_at'_def)
+  apply (drule (1) sym_refs_obj_atD'[rotated, where p=tp])
+  apply (clarsimp simp: state_refs_of'_def projectKOs obj_at'_def)
+  apply (drule sym[where s="BlockedOnSend _ _ _ _ _"])
+  apply (clarsimp simp: ko_wp_at'_def)
+  apply (rename_tac ko; case_tac ko;
+         simp add: get_refs_def2 ep_q_refs_of'_def ntfn_q_refs_of'_def
+                   tcb_st_refs_of'_def tcb_bound_refs'_def
+            split: endpoint.split_asm ntfn.split_asm thread_state.split_asm if_split_asm)+
+  done
+
+lemma sym_ref_BlockedOnReceive_RecvEP':
+  "\<lbrakk> sym_refs (state_refs_of' s); st_tcb_at' ((=) (BlockedOnReceive eptr pl ropt)) tp s\<rbrakk>
+     \<Longrightarrow> \<exists>list. ko_wp_at' ((=) (KOEndpoint (RecvEP list))) eptr s"
+  apply (simp add: pred_tcb_at'_def)
+  apply (drule (1) sym_refs_obj_atD'[rotated, where p=tp])
+  apply (clarsimp simp: state_refs_of'_def projectKOs obj_at'_def)
+  apply (drule sym[where s="BlockedOnReceive _ _ _"])
+  apply (clarsimp simp: ko_wp_at'_def split: if_split_asm)
+   apply (rename_tac ko koa; case_tac ko;
+          simp add: get_refs_def2 ep_q_refs_of'_def ntfn_q_refs_of'_def
+                    tcb_st_refs_of'_def tcb_bound_refs'_def
+             split: endpoint.split_asm ntfn.split_asm thread_state.split_asm if_split_asm)
+  apply (rename_tac ko; case_tac ko;
+         simp add: get_refs_def2 ep_q_refs_of'_def ntfn_q_refs_of'_def
+                   tcb_st_refs_of'_def tcb_bound_refs'_def
+            split: endpoint.split_asm ntfn.split_asm thread_state.split_asm if_split_asm)
+  done
+
+lemma Receive_or_Send_ep_at':
+  "\<lbrakk> st = BlockedOnReceive epPtr pl rp \<or> st = BlockedOnSend epPtr p1 p2 p3 p4;
+     valid_objs' s; st_tcb_at' ((=) st) t s\<rbrakk>
+       \<Longrightarrow> ep_at' epPtr s"
+  apply (drule (1) tcb_in_valid_state')
+  by (fastforce simp: obj_at'_def valid_tcb_state'_def)
+
+lemma ep_queued_st_tcb_at':
+  "\<And>P. \<lbrakk>ko_at' ep ptr s; \<exists>rt. (t, rt) \<in> ep_q_refs_of' ep;
+         valid_objs' s; sym_refs (state_refs_of' s);
+         \<And>bo bbadge bgrant breply bcall r. P (Structures_H.BlockedOnSend bo bbadge bgrant breply bcall) \<and>
+                         P (Structures_H.BlockedOnReceive bo bgrant r) \<rbrakk>
+    \<Longrightarrow> st_tcb_at' P t s"
+  apply (case_tac ep, simp_all)
+  apply (frule(1) sym_refs_ko_atD', clarsimp, erule (1) my_BallE,
+         clarsimp simp: pred_tcb_at'_def refs_of_rev' obj_at'_def ko_wp_at'_def projectKOs)+
+  done
+
+(* cross lemmas *)
+
+context begin interpretation Arch . (*FIXME: arch_split*)
+
+lemma pspace_aligned_cross:
+  "\<lbrakk> pspace_aligned s; pspace_relation (kheap s) (ksPSpace s') \<rbrakk> \<Longrightarrow> pspace_aligned' s'"
+  apply (clarsimp simp: pspace_aligned'_def pspace_aligned_def pspace_relation_def)
+  apply (rename_tac p' ko')
+  apply (prop_tac "p' \<in> pspace_dom (kheap s)", fastforce)
+  apply (thin_tac "pspace_dom k = p" for k p)
+  apply (clarsimp simp: pspace_dom_def)
+  apply (drule bspec, fastforce)+
+  apply clarsimp
+  apply (rename_tac ko' a a' P ko)
+  apply (erule (1) obj_relation_cutsE; clarsimp simp: objBits_simps)
+
+  \<comment>\<open>CNode\<close>
+     apply (clarsimp simp: cte_map_def)
+     apply (simp only: cteSizeBits_def cte_level_bits_def)
+     apply (rule is_aligned_add)
+      apply (erule is_aligned_weaken, simp)
+     apply (rule is_aligned_weaken)
+    apply (rule is_aligned_mult_triv2, simp)
+
+  \<comment>\<open>SchedContext, Reply\<close>
+     apply ((clarsimp simp: minSchedContextBits_def min_sched_context_bits_def replySizeBits_def
+                            scBits_inverse_sc_relation[simplified]
+                     elim!: is_aligned_weaken)+)[2]
+
+  \<comment>\<open>PageTable\<close>
+   apply (clarsimp simp: archObjSize_def pteBits_def)
+    apply (rule is_aligned_add)
+     apply (erule is_aligned_weaken)
+     apply simp
+    apply (rule is_aligned_shift)
+
+  \<comment>\<open>PageDirectory\<close>
+   apply (clarsimp simp: archObjSize_def pdeBits_def)
+    apply (rule is_aligned_add)
+     apply (erule is_aligned_weaken, simp)
+    apply (rule is_aligned_shift)
+
+  \<comment>\<open>DataPage\<close>
+   apply (rule is_aligned_add)
+    apply (erule is_aligned_weaken)
+    apply (clarsimp simp: pageBits_def pageBitsForSize_def)
+    apply (case_tac sz; simp)
+  apply (rule is_aligned_mult_triv2)
+
+  \<comment>\<open>other_obj_relation\<close>
+  apply (simp add: other_obj_relation_def)
+  by (clarsimp simp: bit_simps' tcbBlockSizeBits_def epSizeBits_def ntfnSizeBits_def
+              split: kernel_object.splits Structures_A.kernel_object.splits)
+     (fastforce simp: archObjSize_def split: arch_kernel_object.splits arch_kernel_obj.splits)
+
+lemma pspace_relation_pspace_bounded':
+  "\<lbrakk> pspace_relation (kheap s) (ksPSpace s') \<rbrakk> \<Longrightarrow> pspace_bounded' s'"
+  apply (clarsimp simp: pspace_bounded'_def pspace_relation_def)
+  apply (rename_tac p' ko')
+  apply (prop_tac "p' \<in> pspace_dom (kheap s)", fastforce)
+  apply (thin_tac "pspace_dom k = p" for k p)
+  apply (clarsimp simp: pspace_dom_def)
+  apply (drule bspec, fastforce)+
+  apply clarsimp
+  apply (rename_tac ko' a a' P ko)
+  apply (erule (1) obj_relation_cutsE;
+         clarsimp simp: objBits_simps' word_bits_def pageBits_def archObjSize_def pteBits_def pdeBits_def)
+
+  \<comment>\<open>SchedContext\<close>
+     apply (clarsimp simp: minSchedContextBits_def min_sched_context_bits_def replySizeBits_def
+                            scBits_inverse_sc_relation[simplified] valid_sched_context_size_def
+                            untyped_max_bits_def
+                     elim!: is_aligned_weaken)
+
+  \<comment>\<open>other_obj_relation\<close>
+  apply (simp add: other_obj_relation_def)
+  by (clarsimp simp: bit_simps' tcbBlockSizeBits_def epSizeBits_def ntfnSizeBits_def
+              split: kernel_object.splits Structures_A.kernel_object.splits)
+     (clarsimp simp: archObjSize_def pteBits_def pdeBits_def pageBits_def
+              split: arch_kernel_object.splits arch_kernel_obj.splits)
+
+lemma pspace_distinct_cross:
+  "\<lbrakk> pspace_distinct s; pspace_aligned s; pspace_relation (kheap s) (ksPSpace s') \<rbrakk> \<Longrightarrow>
+   pspace_distinct' s'"
+  apply (frule (1) pspace_aligned_cross)
+  apply (clarsimp simp: pspace_distinct'_def)
+  apply (rename_tac p' ko')
+  apply (rule pspace_dom_relatedE; assumption?)
+  apply (rename_tac p ko P)
+  apply (frule (1) pspace_alignedD')
+  apply (frule (1) pspace_alignedD)
+  apply (frule pspace_relation_pspace_bounded')
+    apply (frule (1) pspace_boundedD')
+  apply (rule ps_clearI, assumption)
+   apply (case_tac ko'; simp add: objBits_simps objBits_defs bit_simps' scBits_pos_power2)
+   apply (clarsimp split: arch_kernel_object.splits simp: bit_simps' archObjSize_def)
+  apply (rule ccontr, clarsimp)
+  apply (rename_tac x' ko_x')
+  apply (frule_tac x=x' in pspace_alignedD', assumption)
+  apply (rule_tac x=x' in pspace_dom_relatedE; assumption?)
+  apply (rename_tac x ko_x P')
+  apply (frule_tac p=x in pspace_alignedD, assumption)
+  apply (case_tac "p = x")
+   apply clarsimp
+   apply (erule (1) obj_relation_cutsE; clarsimp)
+      apply (clarsimp simp: cte_relation_def cte_map_def objBits_simps)
+      apply (rule_tac n=cteSizeBits in is_aligned_add_step_le'; assumption?)
+     apply (clarsimp simp: pte_relation_def objBits_simps archObjSize_def)
+     apply (rule_tac n=pteBits in is_aligned_add_step_le'; assumption?)
+     apply (clarsimp simp: pde_relation_def objBits_simps archObjSize_def)
+     apply (rule_tac n=pdeBits in is_aligned_add_step_le'; assumption?)
+    apply (simp add: objBitsKO_Data)
+    apply (rule_tac n=pageBits in is_aligned_add_step_le'; assumption?)
+   apply (case_tac ko;
+          simp split: if_split_asm
+                 add: is_other_obj_relation_type_CapTable
+                      is_other_obj_relation_type_SchedContext
+                      is_other_obj_relation_type_Reply
+                      a_type_def)
+   apply (rename_tac ako,
+          case_tac ako;
+          simp add: is_other_obj_relation_type_def a_type_def split: if_split_asm)
+  apply (frule (1) obj_relation_cuts_obj_bits)
+  apply (drule (2) obj_relation_cuts_range_mask_range)+
+  apply (prop_tac "x' \<in> mask_range p' (objBitsKO ko')", simp add: mask_def add_diff_eq)
+  apply (frule_tac x=p and y=x in pspace_distinctD; assumption?)
+  apply (drule (4) mask_range_subsetD)
+  apply (erule (2) in_empty_interE)
+  done
+
+lemma aligned'_distinct'_ko_at'I:
+  "\<lbrakk>ksPSpace s' x = Some ko;  pspace_aligned' s'; pspace_distinct' s';
+    (if koTypeOf ko  = SchedContextT then pspace_bounded' s' else True);
+    ko = injectKO (v:: 'a :: pspace_storable)\<rbrakk>
+      \<Longrightarrow> ko_at' v x s'"
+  apply (simp add: obj_at'_def projectKOs project_inject pspace_bounded'_def
+                   pspace_distinct'_def pspace_aligned'_def)
+  apply (drule bspec, erule domI)+
+  apply (case_tac "injectKO v"; clarsimp simp: valid_sz_simps dest!: pspace_boundedD')
+  done
+
+lemma aligned_distinct_ko_at'I:
+  assumes p: "pspace_relation (kheap s) (ksPSpace s')"
+  assumes ps: "pspace_aligned s" "pspace_distinct s"
+  shows "\<lbrakk>ksPSpace s' x = Some ko; ko = injectKO (v:: 'a :: pspace_storable)\<rbrakk>
+      \<Longrightarrow> ko_at' v x s'"
+  apply (rule aligned'_distinct'_ko_at'I[OF _ pspace_aligned_cross[OF ps(1) p]]; simp)
+  using assms by (fastforce dest!: pspace_distinct_cross simp: pspace_relation_pspace_bounded'[OF p])+
+
+lemma tcb_at_cross:
+  assumes p: "pspace_relation (kheap s) (ksPSpace s')"
+  assumes aligned: "pspace_aligned s"
+  assumes distinct: "pspace_distinct s"
+  assumes t: "tcb_at t s"
+  shows "tcb_at' t s'" using assms
+  apply (clarsimp simp: obj_at_def is_tcb)
+  apply (drule (1) pspace_relation_absD, clarsimp simp: other_obj_relation_def)
+  apply (case_tac z; simp)
+  by (fastforce dest!: aligned_distinct_ko_at'I[where 'a=tcb] elim: obj_at'_weakenE)
+
+lemma st_tcb_at_coerce_abstract:
+  assumes t: "st_tcb_at' P t c"
+  assumes sr: "(a, c) \<in> state_relation"
+  shows "st_tcb_at (\<lambda>st. \<exists>st'. thread_state_relation st st' \<and> P st') t a"
+  using assms
+  apply (clarsimp simp: state_relation_def pred_tcb_at'_def obj_at'_def
+                        projectKOs)
+  apply (erule (1) pspace_dom_relatedE)
+  apply (erule (1) obj_relation_cutsE, simp_all)
+  apply (clarsimp simp: st_tcb_at_def obj_at_def other_obj_relation_def
+                        tcb_relation_def
+                 split: Structures_A.kernel_object.split_asm if_split_asm
+                        arch_kernel_obj.split_asm)+
+  apply fastforce
+  done
+
+lemma st_tcb_at_coerce_concrete:
+  assumes t: "st_tcb_at P t s"
+  assumes sr: "(s, s') \<in> state_relation" "pspace_aligned s" "pspace_distinct s"
+  shows "st_tcb_at' (\<lambda>st'. \<exists>st. thread_state_relation st st' \<and> P st) t s'"
+  using assms
+  apply (clarsimp simp: state_relation_def pred_tcb_at_def obj_at_def projectKOs)
+  apply (frule (1) pspace_distinct_cross, fastforce simp: state_relation_def)
+  apply (frule pspace_aligned_cross, fastforce simp: state_relation_def)
+  apply (prop_tac "tcb_at t s", clarsimp simp: st_tcb_at_def obj_at_def is_tcb)
+  apply (drule (2) tcb_at_cross[rotated], fastforce simp: state_relation_def)
+  apply (clarsimp simp: state_relation_def pred_tcb_at'_def obj_at'_def projectKOs)
+  apply (erule (1) pspace_dom_relatedE)
+  apply (erule (1) obj_relation_cutsE, simp_all)
+   apply (clarsimp simp: st_tcb_at'_def obj_at'_def other_obj_relation_def tcb_relation_def
+                  split: Structures_A.kernel_object.split_asm if_split_asm)+
+  apply fastforce
+  done
+
+lemma st_tcb_at_runnable_cross:
+  "\<lbrakk> st_tcb_at runnable t s; pspace_aligned s; pspace_distinct s; (s, s') \<in> state_relation \<rbrakk>
+       \<Longrightarrow> st_tcb_at' runnable' t s'"
+  apply (drule (3) st_tcb_at_coerce_concrete)
+  by (clarsimp simp: pred_tcb_at'_def obj_at'_def sts_rel_runnable)
+
+lemma bound_sc_tcb_at_cross:
+  assumes t: "bound_sc_tcb_at P t s"
+  assumes sr: "(s, s') \<in> state_relation" "pspace_aligned s" "pspace_distinct s"
+  shows "tcb_at' t s' \<and> P (tcbSCs_of s' t)"
+  using assms
+  apply (clarsimp simp: state_relation_def pred_tcb_at_def obj_at_def projectKOs)
+  apply (frule (1) pspace_distinct_cross, fastforce simp: state_relation_def)
+  apply (frule pspace_aligned_cross, fastforce simp: state_relation_def)
+  apply (prop_tac "tcb_at t s", clarsimp simp: obj_at_def is_tcb)
+  apply (drule (2) tcb_at_cross[rotated], fastforce simp: state_relation_def)
+  apply (clarsimp simp: state_relation_def pred_tcb_at'_def obj_at'_def projectKOs opt_map_red)
+  apply (erule (1) pspace_dom_relatedE)
+  apply (erule (1) obj_relation_cutsE, simp_all)
+   apply (clarsimp simp: st_tcb_at'_def obj_at'_def other_obj_relation_def tcb_relation_def
+                  split: Structures_A.kernel_object.split_asm if_split_asm)+
+  done
+
+lemma bound_yt_tcb_at_cross:
+  assumes t: "bound_yt_tcb_at P t s"
+  assumes sr: "(s, s') \<in> state_relation" "pspace_aligned s" "pspace_distinct s"
+  shows "obj_at' (\<lambda>tcb'. \<exists>tcb. tcb_relation tcb tcb' \<and> P (tcb_yield_to tcb)) t s'"
+  using assms
+  apply (clarsimp simp: state_relation_def pred_tcb_at_def obj_at_def projectKOs)
+  apply (frule (1) pspace_distinct_cross, fastforce simp: state_relation_def)
+  apply (frule pspace_aligned_cross, fastforce simp: state_relation_def)
+  apply (prop_tac "tcb_at t s", clarsimp simp: st_tcb_at_def obj_at_def is_tcb)
+  apply (drule (2) tcb_at_cross[rotated], fastforce simp: state_relation_def)
+  apply (clarsimp simp: state_relation_def pred_tcb_at'_def obj_at'_def projectKOs)
+  apply (erule (1) pspace_dom_relatedE)
+  apply (erule (1) obj_relation_cutsE, simp_all)
+   apply (clarsimp simp: st_tcb_at'_def obj_at'_def other_obj_relation_def tcb_relation_def
+                  split: Structures_A.kernel_object.split_asm if_split_asm)+
+  apply fastforce
+  done
+
+lemma sc_tcb_sc_at_bound_cross:
+  "\<lbrakk>pspace_relation (kheap s) (ksPSpace s'); valid_objs s; pspace_aligned s; pspace_distinct s;
+    sc_tcb_sc_at ((\<noteq>) None) scp s\<rbrakk>
+  \<Longrightarrow> obj_at' (\<lambda>sc. \<exists>y. scTCB sc = Some y) scp s'"
+  apply (clarsimp simp: obj_at_def sc_tcb_sc_at_def)
+  apply (frule (1) pspace_relation_absD)
+  apply clarsimp
+  apply (prop_tac "valid_sched_context_size n")
+   apply (erule (1) valid_sched_context_size_objsI)
+  apply (clarsimp simp: if_split_asm)
+  apply (rename_tac z; case_tac z; simp)
+  apply (drule (3) aligned_distinct_ko_at'I[where 'a=sched_context], simp)
+  apply (clarsimp simp: obj_at'_def sc_relation_def projectKOs)
+  by (metis not_None_eq)
+
+lemma cur_tcb_cross:
+  "\<lbrakk> cur_tcb s; pspace_aligned s; pspace_distinct s; (s,s') \<in> state_relation \<rbrakk> \<Longrightarrow> cur_tcb' s'"
+  apply (clarsimp simp: cur_tcb'_def cur_tcb_def state_relation_def)
+  apply (erule (3) tcb_at_cross)
+  done
+
+method add_cur_tcb' =
+  rule_tac Q="\<lambda>s'. cur_tcb' s'" in corres_cross_add_guard,
+  fastforce intro!: cur_tcb_cross
+
+lemma cur_sc_tcb_cross:
+  "\<lbrakk>(s, s') \<in> state_relation; valid_objs s; pspace_aligned s; pspace_distinct s;
+    cur_sc_tcb s; schact_is_rct s\<rbrakk>
+  \<Longrightarrow> obj_at' (\<lambda>sc. scTCB sc = Some (ksCurThread s')) (ksCurSc s') s'"
+  apply (clarsimp simp: obj_at_def sc_tcb_sc_at_def cur_sc_tcb_def
+                 dest!: schact_is_rct state_relationD)
+  apply (frule (1) pspace_relation_absD)
+  apply clarsimp
+  apply (prop_tac "valid_sched_context_size n")
+   apply (erule (1) valid_sched_context_size_objsI)
+  apply (clarsimp simp: if_split_asm)
+  apply (rename_tac z; case_tac z; simp)
+  apply (drule (3) aligned_distinct_ko_at'I[where 'a=sched_context], simp)
+  apply (clarsimp simp: obj_at'_def sc_relation_def projectKOs)
+  done
+
+lemma reply_at_cross:
+  assumes p: "pspace_relation (kheap s) (ksPSpace s')"
+  assumes ps: "pspace_aligned s" "pspace_distinct s"
+  assumes t: "reply_at ptr s"
+  shows "reply_at' ptr s'"
+  using assms
+  apply (clarsimp simp: obj_at_def is_reply)
+  apply (drule (1) pspace_relation_absD, clarsimp)
+  apply (case_tac z; simp)
+  by (fastforce dest!: aligned_distinct_ko_at'I[where 'a=reply] elim: obj_at'_weakenE)
+
+lemma ep_at_cross:
+  assumes p: "pspace_relation (kheap s) (ksPSpace s')"
+  assumes ps: "pspace_aligned s" "pspace_distinct s"
+  assumes t: "ep_at ptr s"
+  shows "ep_at' ptr s'"
+  using assms
+  apply (clarsimp simp: obj_at_def is_ep)
+  apply (drule (1) pspace_relation_absD, clarsimp simp: other_obj_relation_def)
+  apply (case_tac z; simp)
+  by (fastforce dest!: aligned_distinct_ko_at'I[where 'a=endpoint] elim: obj_at'_weakenE)
+
+lemma ntfn_at_cross:
+  assumes p: "pspace_relation (kheap s) (ksPSpace s')"
+  assumes ps: "pspace_aligned s" "pspace_distinct s"
+  assumes t: "ntfn_at ptr s"
+  shows "ntfn_at' ptr s'"
+  using assms
+  apply (clarsimp simp: obj_at_def is_ntfn)
+  apply (drule (1) pspace_relation_absD, clarsimp simp: other_obj_relation_def)
+  apply (case_tac z; simp)
+  by (fastforce dest!: aligned_distinct_ko_at'I[where 'a=notification] elim: obj_at'_weakenE)
+
+lemma sc_at_cross:
+  assumes p: "pspace_relation (kheap s) (ksPSpace s')"
+  assumes ps: "pspace_aligned s" "pspace_distinct s"
+  assumes t: "sc_at ptr s"
+  shows "sc_at' ptr s'"
+  using assms
+  apply (clarsimp simp: obj_at_def is_sc_obj)
+  apply (drule (1) pspace_relation_absD, clarsimp)
+  apply (case_tac z; simp)
+  by (fastforce dest!: aligned_distinct_ko_at'I[where 'a=sched_context] elim: obj_at'_weakenE)
+
+lemma sc_at'_cross_rel:
+  "cross_rel (pspace_aligned and pspace_distinct and sc_at t) (sc_at' t)"
+  unfolding cross_rel_def state_relation_def
+  apply clarsimp
+  by (erule (3) sc_at_cross)
+
+lemma sc_obj_at_cross:
+  assumes p: "pspace_relation (kheap s) (ksPSpace s')"
+  assumes ps: "pspace_aligned s" "pspace_distinct s"
+  assumes t: "sc_obj_at n ptr s"
+  shows "obj_at' (\<lambda>sc::sched_context. objBits sc = minSchedContextBits + n) ptr s'"
+  using assms
+  apply (clarsimp simp: obj_at_def is_sc_obj)
+  apply (drule (1) pspace_relation_absD, clarsimp)
+  apply (case_tac z; simp)
+  apply (rename_tac sc')
+  apply (drule (3) aligned_distinct_ko_at'I[where 'a=sched_context], simp)
+  by (clarsimp simp: scBits_simps objBits_simps sc_relation_def obj_at'_def)
+
+lemma real_cte_at_cross:
+  assumes p: "pspace_relation (kheap s) (ksPSpace s')"
+  assumes ps: "pspace_aligned s" "pspace_distinct s"
+  assumes t: "real_cte_at ptr s"
+  shows "real_cte_at' (cte_map ptr) s'"
+  using assms
+  apply (clarsimp simp: obj_at_def is_ntfn)
+  apply (drule (1) pspace_relation_absD)
+  apply (clarsimp simp: is_cap_table other_obj_relation_def well_formed_cnode_n_def)
+  apply (prop_tac "\<exists>z. ksPSpace s' (cte_map (fst ptr, snd ptr)) = Some z \<and>
+    cte_relation (snd ptr) (CNode (length (snd ptr)) cs) z")
+  apply fastforce
+  apply (clarsimp split: kernel_object.split_asm simp: cte_relation_def)
+  by (fastforce dest!: aligned_distinct_ko_at'I[where 'a=cte] elim: obj_at'_weakenE)
+
+lemma valid_tcb_state_cross:
+  assumes "pspace_relation (kheap s) (ksPSpace s')"
+          "thread_state_relation ts ts'"
+          "pspace_aligned s"
+          "pspace_distinct s"
+          "valid_tcb_state ts s"
+  shows "valid_tcb_state' ts' s'" using assms
+  by (fastforce dest: ep_at_cross reply_at_cross ntfn_at_cross
+                simp: valid_bound_obj'_def valid_tcb_state_def valid_tcb_state'_def
+               split: Structures_A.thread_state.split_asm option.split_asm)
+
+lemma state_refs_of_cross_eq:
+  "\<lbrakk>(s, s') \<in> state_relation; pspace_aligned s; pspace_distinct s\<rbrakk>
+       \<Longrightarrow> state_refs_of' s' = state_refs_of s"
+  apply (rule sym)
+  apply (rule ext, rename_tac p)
+  apply (frule state_relation_pspace_relation)
+  apply (frule (2) pspace_distinct_cross)
+  apply (frule (1) pspace_aligned_cross)
+  apply (clarsimp simp: state_refs_of_def state_refs_of'_def
+                 split: option.split)
+  apply (rule conjI; clarsimp)
+   apply (rename_tac ko')
+   apply (erule (1) pspace_dom_relatedE)
+   apply (rename_tac ko P; case_tac ko; clarsimp split: if_split_asm simp: cte_relation_def)
+   apply (rename_tac ako; case_tac ako; clarsimp simp: pte_relation_def pde_relation_def)
+  apply (rule conjI; clarsimp)
+   apply (drule (1) pspace_relation_None; clarsimp)
+  apply (rule conjI[rotated]; clarsimp)
+   apply (frule pspace_relation_pspace_bounded'[OF state_relation_pspace_relation])
+   apply (frule pspace_alignedD'; frule pspace_boundedD'; clarsimp dest!: pspace_distinctD')
+  apply (rename_tac ko ko')
+  apply (frule (1) pspace_relation_absD)
+  apply (case_tac ko; clarsimp split: if_split_asm)
+        apply (rename_tac n sz, drule_tac x=p and y="cte_relation (replicate n False)" in spec2)
+        apply (fastforce simp: cte_relation_def cte_map_def well_formed_cnode_n_def)
+       apply (find_goal \<open>match premises in "_ = Some (ArchObj _)" \<Rightarrow> -\<close>)
+       apply (rename_tac ako; case_tac ako; simp)
+          apply (case_tac ko'; clarsimp simp: other_obj_relation_def)
+         apply ((drule_tac x=0 in spec, clarsimp simp:  pte_relation_def pde_relation_def)+)[2]
+       apply (drule_tac x=p in spec, clarsimp)
+       apply (rename_tac b sz)
+       apply (drule_tac x="\<lambda>_ obj. obj = (if b then KOUserDataDevice else KOUserData)" in spec, clarsimp)
+       apply (simp only: imp_ex)
+       apply (drule_tac x=0 in spec, clarsimp simp: pageBitsForSize_def pageBits_def split: vmpage_size.split_asm)
+      apply (all \<open>case_tac ko'; clarsimp simp: other_obj_relation_def\<close>)
+      apply (rename_tac tcb tcb';
+             clarsimp simp: tcb_relation_def arch_tcb_relation_def fault_rel_optionation_def
+                            thread_state_relation_def tcb_st_refs_of_def tcb_st_refs_of'_def;
+             rename_tac tcb'; case_tac "tcb_state tcb"; case_tac "tcbState tcb'";
+             clarsimp simp: tcb_bound_refs'_def get_refs_def2 split: option.splits)
+     apply (clarsimp simp: ep_q_refs_of_def ep_relation_def split: Structures_A.endpoint.splits)
+    apply (clarsimp simp: ntfn_q_refs_of_def ntfn_relation_def split: Structures_A.ntfn.splits)
+   apply (clarsimp simp: sc_relation_def get_refs_def2)
+   apply (drule state_relation_sc_replies_relation)
+   apply (frule sc_replies_relation_scReplies_of)
+     apply (fastforce simp: obj_at_def is_sc_obj_def)
+    apply (clarsimp simp: opt_map_def)
+   apply (clarsimp simp: opt_map_def sc_replies_of_scs_def map_project_def scs_of_kh_def)
+  apply (clarsimp simp: reply_relation_def split: Structures_A.ntfn.splits)
+  done
+
+end
+
+lemma state_refs_of_cross:
+  "\<lbrakk>P (state_refs_of s); (s, s') \<in> state_relation; pspace_aligned s; pspace_distinct s\<rbrakk>
+      \<Longrightarrow> P (state_refs_of' s')"
+  by (clarsimp simp: state_refs_of_cross_eq elim!: rsubst[where P=P])
+
+lemma ct_not_inQ_cross:
+  "\<lbrakk>(s,s') \<in> state_relation; ct_not_in_q s; valid_queues' s'; cur_tcb s; pspace_aligned s;
+    pspace_distinct s\<rbrakk>
+   \<Longrightarrow> ct_not_inQ s'"
+  apply (frule (3) cur_tcb_cross)
+  apply (clarsimp simp: ct_not_inQ_def ct_not_in_q_def)
+  apply (prop_tac "scheduler_action s = resume_cur_thread")
+   apply (clarsimp simp: state_relation_def)
+   apply (metis sched_act_relation.simps Structures_A.scheduler_action.exhaust
+                scheduler_action.simps)
+  apply (clarsimp simp: not_queued_def)
+  apply (rule ccontr)
+  apply (prop_tac "obj_at' tcbQueued (ksCurThread s') s'")
+   apply (clarsimp simp: obj_at_simps cur_tcb'_def)
+  apply (frule curthread_relation)
+  apply (frule state_relation_ready_queues_relation)
+  apply (clarsimp simp: valid_queues'_def inQ_def ready_queues_relation_def obj_at_simps)
+  by (metis Structures_H.kernel_object.case(6))
+
+lemma sch_act_wf_cross:
+  "\<lbrakk>(s,s') \<in> state_relation; valid_sched_action s; cur_tcb s; pspace_aligned s; pspace_distinct s\<rbrakk>
+   \<Longrightarrow> sch_act_wf (ksSchedulerAction s') s'"
+  apply (clarsimp simp: sch_act_wf_def)
+  apply (cases "ksSchedulerAction s'"; clarsimp)
+   apply (prop_tac "scheduler_action s = resume_cur_thread")
+    apply (clarsimp simp: state_relation_def)
+    apply (metis sched_act_relation.simps Structures_A.scheduler_action.exhaust
+                 scheduler_action.simps)
+   apply (frule curthread_relation)
+   apply (frule state_relation_pspace_relation)
+   apply (frule (2) cur_tcb_cross)
+    apply fastforce
+   apply (clarsimp simp: valid_sched_action_def is_activatable_def vs_all_heap_simps
+                         ct_in_state'_def st_tcb_at'_def)
+   apply (clarsimp simp: pspace_relation_def)
+   apply (drule_tac x="cur_thread s" in bspec, fastforce)
+   apply (drule_tac x="(cur_thread s, other_obj_relation)" in bspec, fastforce)
+   apply (clarsimp simp: other_obj_relation_def)
+   apply (rename_tac tcb)
+   apply (case_tac "tcb_state tcb"; clarsimp simp: tcb_relation_def obj_at_simps cur_tcb'_def)
+  apply (rename_tac target)
+  apply (clarsimp simp: valid_sched_action_def weak_valid_sched_action_def vs_all_heap_simps)
+  apply (prop_tac "scheduler_action s = switch_thread target")
+   apply (clarsimp simp: state_relation_def)
+   apply (metis sched_act_relation.simps Structures_A.scheduler_action.exhaust
+                scheduler_action.simps)
+  apply (prop_tac "tcb_at' target s'")
+   apply (fastforce intro!: tcb_at_cross
+                      simp: obj_at_def is_tcb_def)
+  apply (frule state_relation_pspace_relation)
+  apply (clarsimp simp: pspace_relation_def)
+  apply (drule_tac x=target in bspec, fastforce)
+  apply (drule_tac x="(target, other_obj_relation)" in bspec, fastforce)
+  apply (clarsimp simp: other_obj_relation_def)
+  apply (intro conjI)
+   apply (fastforce intro!: st_tcb_at_runnable_cross
+                      simp: obj_at_def pred_tcb_at_def)
+  apply (clarsimp simp: tcb_relation_def obj_at_simps switch_in_cur_domain_def
+                        state_relation_def in_cur_domain_def tcb_in_cur_domain'_def
+                        etcb_at'_def vs_all_heap_simps)
+  done
+
+lemma ct_idle_or_in_cur_domain'_cross:
+  "\<lbrakk>(s,s') \<in> state_relation; ct_in_cur_domain s; cur_tcb s; pspace_aligned s; pspace_distinct s\<rbrakk>
+   \<Longrightarrow> ct_idle_or_in_cur_domain' s'"
+  apply (clarsimp simp: ct_idle_or_in_cur_domain'_def tcb_in_cur_domain'_def ct_in_cur_domain_def)
+  apply (case_tac "cur_thread s = idle_thread s"; clarsimp)
+   apply (clarsimp simp: state_relation_def)
+  apply (frule curthread_relation)
+  apply (frule (2) cur_tcb_cross)
+   apply fastforce
+  apply (prop_tac "scheduler_action s = resume_cur_thread")
+   apply (clarsimp simp: state_relation_def)
+   apply (metis sched_act_relation.simps Structures_A.scheduler_action.exhaust
+                scheduler_action.simps)
+  apply (clarsimp simp: in_cur_domain_def etcb_at_def vs_all_heap_simps obj_at_simps cur_tcb'_def)
+  apply (frule state_relation_pspace_relation)
+  apply (clarsimp simp: pspace_relation_def)
+  apply (drule_tac x="cur_thread s" in bspec)
+   apply (clarsimp simp: cur_tcb_def obj_at_def)
+  apply (drule_tac x="(cur_thread s, other_obj_relation)" in bspec)
+   apply (clarsimp simp: cur_tcb_def obj_at_def is_tcb_def)
+   apply (rename_tac tcb)
+   apply (case_tac tcb; clarsimp)
+  apply (clarsimp simp: cur_tcb_def obj_at_def is_tcb_def)
+  apply (rename_tac tcb)
+  apply (case_tac tcb; clarsimp)
+  apply (clarsimp simp: other_obj_relation_def tcb_relation_def state_relation_def)
+  done
+
+lemma valid_idle'_cross:
+  "\<lbrakk>(s,s') \<in> state_relation; valid_idle s; pspace_aligned s; pspace_distinct s; valid_objs s\<rbrakk>
+   \<Longrightarrow> valid_idle' s'"
+  apply (clarsimp simp: valid_idle'_def valid_idle_def pred_tcb_at_def obj_at_def)
+  apply (prop_tac "ksIdleThread s' = idle_thread s")
+   apply (clarsimp simp: state_relation_def)
+  apply clarsimp
+  apply (prop_tac "tcb_at' (ksIdleThread s') s'")
+   apply (fastforce intro!: tcb_at_cross simp: obj_at_def state_relation_def is_tcb_def)
+  apply (prop_tac "sc_at' (idle_sc_ptr) s'")
+   apply (fastforce intro!: sc_at_cross valid_objs_valid_sched_context_size
+                      simp: obj_at_def state_relation_def is_sc_obj_def)
+  apply (frule state_relation_pspace_relation)
+  apply (clarsimp simp: pspace_relation_def)
+  apply (intro conjI)
+   apply (drule_tac x="idle_thread s" in bspec, fastforce)
+   apply (drule_tac x="(idle_thread s, other_obj_relation)" in bspec, fastforce)
+   apply (clarsimp simp: obj_at_simps idle_tcb'_def tcb_relation_def)
+  apply (drule_tac x="idle_sc_ptr" in bspec, fastforce)
+  apply (drule_tac x="(idle_sc_ptr, sc_relation_cut)" in bspec)
+   apply (fastforce intro: valid_objs_valid_sched_context_size)
+  by (fastforce dest: sc_replies_prevs_walk
+                simp: heap_walk_Nil_None obj_at_simps sc_relation_def state_relation_def)
+
+lemma ksReadyQueues_distinct_cross:
+   "\<lbrakk>(s,s') \<in> state_relation; valid_ready_qs s\<rbrakk> \<Longrightarrow> \<forall>d p. distinct (ksReadyQueues s' (d, p))"
+   by (clarsimp simp: valid_ready_qs_def state_relation_def ready_queues_relation_def)
+
+lemma ready_qs_runnable_cross:
+  "\<lbrakk>(s, s') \<in> state_relation; pspace_aligned s; pspace_distinct s; valid_ready_qs s\<rbrakk>
+   \<Longrightarrow> ready_qs_runnable s'"
+  unfolding ready_qs_runnable_def
+  by (fastforce simp: state_relation_def ready_queues_relation_def
+                      in_ready_q_def st_tcb_at_runnable_cross
+                dest: valid_ready_qs_in_ready_qD)
+
+lemma replyTCBs_of_cross:
+  "\<lbrakk>(s, s') \<in> state_relation; reply_tcb_reply_at P rptr s\<rbrakk>
+   \<Longrightarrow> P (replyTCBs_of s' rptr)"
+  apply (clarsimp simp: reply_at_ppred_def obj_at_def state_relation_def)
+  apply (drule (1) pspace_relation_absD, clarsimp simp: other_obj_relation_def)
+  apply (case_tac z; simp)
+  apply (clarsimp simp: opt_map_def reply_relation_def)
+  done
+
+lemma replySCs_of_cross:
+  "\<lbrakk>(s, s') \<in> state_relation; reply_sc_reply_at P rptr s\<rbrakk>
+   \<Longrightarrow> P (replySCs_of s' rptr)"
+  apply (clarsimp simp: reply_at_ppred_def obj_at_def is_tcb state_relation_def)
+  apply (drule (1) pspace_relation_absD, clarsimp simp: other_obj_relation_def)
+  apply (case_tac z; simp)
+  apply (clarsimp simp: opt_map_def reply_relation_def)
+  done
+
+lemma valid_replies_sc_cross:
+  "\<lbrakk>(s, s') \<in> state_relation; valid_replies s; sym_refs (state_refs_of s);
+    pspace_aligned s; pspace_distinct s; reply_at rptr s\<rbrakk>
+   \<Longrightarrow> valid_replies'_sc_asrt rptr s'"
+  apply (clarsimp simp: valid_replies_defs valid_replies'_sc_asrt_def)
+  apply (rename_tac scptr rp ko)
+  apply (prop_tac "sc_replies_sc_at (\<lambda>rs. rptr \<in> set rs) scptr s")
+   apply (frule_tac sc_ptr=scptr and reply_ptr=rptr in sym_refs_sc_replies_sc_at)
+    apply (rule ccontr)
+    apply (drule not_sk_obj_at_pred)
+     apply (fastforce simp: sk_obj_at_pred_def obj_at_def is_obj_defs)
+    apply (frule (1) replySCs_of_cross)
+    apply (clarsimp simp: obj_at'_def projectKOs opt_map_def)
+   apply (clarsimp simp: sc_at_pred_n_eq_commute sc_at_ppred_def obj_at_def)
+  apply (drule subsetD, force)
+  apply (clarsimp simp: pred_tcb_at_eq_commute[symmetric])
+  apply (frule (1) st_tcb_reply_state_refs)
+  apply (drule (3) st_tcb_at_coerce_concrete)
+  apply (drule replyTCBs_of_cross[where P="\<lambda>rtcb. rtcb = (Some tptr)" for tptr])
+   apply (fastforce simp: sk_obj_at_pred_def2)
+  apply (clarsimp simp: pred_tcb_at'_def obj_at'_def)
+  done
+
+lemma getCurThread_sp:
+  "\<lbrace>P\<rbrace> getCurThread \<lbrace>\<lambda>rv. P and (\<lambda>s. rv = ksCurThread s)\<rbrace>"
+  by (wpsimp simp: getCurThread_def)
+
+lemma getSchedulerAction_sp:
+  "\<lbrace>P\<rbrace> getSchedulerAction \<lbrace>\<lambda>rv. P and (\<lambda>s. rv = ksSchedulerAction s)\<rbrace>"
+  by (wpsimp simp: getSchedulerAction_def)
+
+lemma getReprogramTimer_sp:
+  "\<lbrace>P\<rbrace> getReprogramTimer \<lbrace>\<lambda>rv. P and (\<lambda>s. rv = ksReprogramTimer s)\<rbrace>"
+  by (wpsimp simp: getReprogramTimer_def)
+
+lemma getIdleThread_sp:
+  "\<lbrace>P\<rbrace> getIdleThread \<lbrace>\<lambda>rv. P and (\<lambda>s. rv = ksIdleThread s)\<rbrace>"
+  by wpsimp
+
+lemma getIdleSC_sp:
+  "\<lbrace>P\<rbrace> getIdleSC \<lbrace>\<lambda>rv. P and (\<lambda>s. rv = ksIdleSC s)\<rbrace>"
+  by wpsimp
+
+lemma getReprogramTimer_wp[wp]:
+  "\<lbrace>\<lambda>s. P (ksReprogramTimer s) s\<rbrace> getReprogramTimer \<lbrace>P\<rbrace>"
+  by (wpsimp simp: getReprogramTimer_def)
+
+lemma getConsumedTime_wp[wp]:
+  "\<lbrace>\<lambda>s. P (ksConsumedTime s) s\<rbrace> getConsumedTime \<lbrace>P\<rbrace>"
+  by (wpsimp simp: getConsumedTime_def)
+
+lemma isRoundRobin_wp:
+  "\<lbrace>\<lambda>s. \<forall>ko. ko_at' ko sc s \<longrightarrow> P (scPeriod ko = 0) s\<rbrace> isRoundRobin sc \<lbrace>P\<rbrace>"
+  by (wpsimp simp: isRoundRobin_def)
+
+lemma getCurSc_wp[wp]:
+  "\<lbrace>\<lambda>s. P (ksCurSc s) s\<rbrace> getCurSc \<lbrace>P\<rbrace>"
+  unfolding getCurSc_def
+  by wpsimp
+
+lemma getCurTime_wp[wp]:
+  "\<lbrace>\<lambda>s. P (ksCurTime s) s\<rbrace> getCurTime \<lbrace>P\<rbrace>"
+  unfolding getCurTime_def
+  by wpsimp
+
+lemma curDomain_wp[wp]:
+  "\<lbrace>\<lambda>s. P (ksCurDomain s) s\<rbrace> curDomain \<lbrace>P\<rbrace>"
+  unfolding curDomain_def
+  by wpsimp
+
+lemma curDomain_sp:
+  "\<lbrace>P\<rbrace> curDomain \<lbrace>\<lambda>rv. P and (\<lambda>s. rv = ksCurDomain s)\<rbrace>"
+  by wpsimp
+
+lemma getReleaseQueue_wp[wp]:
+  "\<lbrace>\<lambda>s. P (ksReleaseQueue s) s\<rbrace> getReleaseQueue \<lbrace>P\<rbrace>"
+  unfolding getReleaseQueue_def
+  by wpsimp
+
+lemma getObject_sc_wp:
+  "\<lbrace>\<lambda>s. sc_at' p s \<longrightarrow> (\<exists>t::sched_context. ko_at' t p s \<and> Q t s)\<rbrace> getObject p \<lbrace>Q\<rbrace>"
+  by (clarsimp simp: getObject_def valid_def in_monad
+                     split_def objBits_simps' loadObject_default_def
+                     projectKOs obj_at'_def in_magnitude_check
+              dest!: readObject_misc_ko_at')
+
+lemma getRefillNext_getSchedContext:
+  "getRefillNext scPtr index = do sc \<leftarrow> getSchedContext scPtr;
+                                  return $ if index = scRefillMax sc - 1 then 0 else index + 1
+                               od"
+  apply (clarsimp simp: getRefillNext_def readRefillNext_def readSchedContext_def
+                        getSchedContext_def getObject_def[symmetric])
+  done
+
+lemma getRefillNext_wp:
+  "\<lbrace>\<lambda>s. \<forall>ko. ko_at' ko scPtr s \<longrightarrow> P (if index = scRefillMax ko - Suc 0 then 0 else index + 1) s\<rbrace>
+   getRefillNext scPtr index
+   \<lbrace>P\<rbrace>"
+  apply (simp add: getRefillNext_getSchedContext)
+  apply (wpsimp wp: getObject_sc_wp)
+  done
+
+lemma getRefillSize_def2:
+  "getRefillSize scPtr = liftM scRefillCount (gets_the (readSchedContext scPtr))"
+  apply (clarsimp simp: getRefillSize_def readRefillSize_def liftM_def oliftM_def)
+  done
+
+lemma getRefillSize_wp:
+  "\<lbrace>\<lambda>s. \<forall>ko. ko_at' ko scp s \<longrightarrow> P (scRefillCount ko) s\<rbrace> getRefillSize scp \<lbrace>P\<rbrace>"
+  apply (clarsimp simp: getRefillSize_def2)
+  apply (wpsimp wp: simp: readSchedContext_def)
+  done
+
+lemma refillEmpty_wp:
+  "\<lbrace>\<lambda>s. \<forall>ko. ko_at' ko scp s \<longrightarrow> P (scRefillCount ko = 0) s\<rbrace> refillEmpty scp \<lbrace>P\<rbrace>"
+  unfolding refillEmpty_def
+  by (wpsimp wp:)
+
+lemma refillFull_wp:
+  "\<lbrace>\<lambda>s. \<forall>ko. ko_at' ko scp s \<longrightarrow> P (scRefillCount ko = scRefillMax ko) s\<rbrace> refillFull scp \<lbrace>P\<rbrace>"
+  unfolding refillFull_def
+  by (wpsimp wp:)
+
+lemma no_ofail_readCurTime[simp]:
+  "no_ofail \<top> readCurTime"
+  unfolding readCurTime_def by clarsimp
+
+lemma ovalid_readCurTime[wp]:
+  "o\<lbrace>\<lambda>s. P (ksCurTime s) s\<rbrace> readCurTime \<lbrace>\<lambda>r s. P r s \<and> r = ksCurTime s\<rbrace>"
+  by (simp add: readCurTime_def asks_def obind_def ovalid_def)
+
+lemma ovalid_readRefillReady[rule_format, simp]:
+  "ovalid (\<lambda>s. \<forall>ko. ko_at' ko scp s \<longrightarrow> P (rTime (refillHd ko) \<le> ksCurTime s + kernelWCETTicks) s)
+              (readRefillReady scp) P"
+  unfolding readRefillReady_def readSchedContext_def ovalid_def
+  by (fastforce simp: obind_def split: option.split_asm
+                dest: use_ovalid[OF ovalid_readCurTime]
+               dest!: readObject_misc_ko_at')
+
+
+lemma refillReady_wp:
+  "\<lbrace>\<lambda>s. \<forall>ko. ko_at' ko scp s \<longrightarrow> P (rTime (refillHd ko) \<le> ksCurTime s + kernelWCETTicks) s\<rbrace> refillReady scp \<lbrace>P\<rbrace>"
+  unfolding refillReady_def
+  by wpsimp (drule use_ovalid[OF ovalid_readRefillReady])
+
+lemma scActive_wp:
+  "\<lbrace>\<lambda>s. \<forall>ko. ko_at' ko scp s \<longrightarrow> P (0 < scRefillMax ko) s\<rbrace> scActive scp \<lbrace>P\<rbrace>"
+  unfolding scActive_def
+  by wpsimp
+
+lemma getRefills_wp:
+  "\<lbrace>\<lambda>s. \<forall>ko. ko_at' ko scp s \<longrightarrow> P (scRefills ko) s\<rbrace>
+   getRefills scp
+   \<lbrace>P\<rbrace>"
+  unfolding getRefills_def
+  by wpsimp
+
+lemma refillSufficient_wp:
+  "\<lbrace>\<lambda>s. \<forall>ko. ko_at' ko scp s \<longrightarrow> P (minBudget \<le> refillsCapacity k (scRefills ko) (scRefillHead ko)) s\<rbrace> refillSufficient scp k \<lbrace>P\<rbrace>"
+  unfolding refillSufficient_def
+  apply (wpsimp wp: getRefills_wp)
+  by (clarsimp simp: sufficientRefills_def obj_at'_def)
+
+(* projection rewrites *)
+
+lemma pred_map_rewrite:
+  "pred_map P proj = opt_pred P proj"
+  by (fastforce simp: pred_map_def2)
+
+abbreviation sc_of2 :: "Structures_A.kernel_object \<rightharpoonup> Structures_A.sched_context" where
+  "sc_of2 ko \<equiv> case ko of kernel_object.SchedContext sc n \<Rightarrow> Some sc | _ \<Rightarrow> None"
+
+abbreviation scs_of2 :: "'z state \<Rightarrow> obj_ref \<rightharpoonup> Structures_A.sched_context" where
+  "scs_of2 \<equiv> (\<lambda>s. kheap s |> sc_of2)"
+
+lemma scs_of_rewrite:
+  "scs_of s = scs_of2 s"
+  by (fastforce simp: sc_heap_of_state_def opt_map_def
+              split: option.splits Structures_A.kernel_object.splits)
+
+abbreviation
+  "sc_replies_of2 s \<equiv> scs_of2 s ||> sc_replies"
+
+lemma sc_replies_of_rewrite:
+  "sc_replies_of s = sc_replies_of2 s"
+  by (fastforce simp: sc_heap_of_state_def sc_replies_of_scs_def opt_map_def map_project_def
+              split: option.splits Structures_A.kernel_object.splits)
+
+definition
+  sc_replies_relation2_2 ::
+  "(obj_ref \<rightharpoonup> obj_ref list) \<Rightarrow> (obj_ref \<rightharpoonup> obj_ref) \<Rightarrow> (obj_ref \<rightharpoonup> obj_ref) \<Rightarrow> bool" where
+  "sc_replies_relation2_2 sc_repls scRepl replPrevs \<equiv>
+     \<forall>p replies. sc_repls p = Some replies \<longrightarrow> heap_ls replPrevs (scRepl p) replies"
+
+abbreviation sc_replies_relation2 :: "det_state \<Rightarrow> kernel_state \<Rightarrow> bool" where
+  "sc_replies_relation2 s s' \<equiv>
+    sc_replies_relation2_2 (sc_replies_of2 s) (scReplies_of s') (replyPrevs_of s')"
+
+lemmas sc_replies_relation2_def = sc_replies_relation2_2_def
+
+lemma sc_replies_relation_rewrite:
+  "sc_replies_relation s s' = sc_replies_relation2 s s'"
+  unfolding sc_replies_relation_def sc_replies_relation2_def sc_replies_of_rewrite
+  by simp
+
+definition is_active_sc2 where
+  "is_active_sc2 p s \<equiv> ((\<lambda>sc. 0 < sc_refill_max sc) |< scs_of2 s) p"
+
+lemma is_active_sc_rewrite:
+  "is_active_sc p s = is_active_sc2 p s"
+  by (fastforce simp: is_active_sc2_def vs_all_heap_simps is_active_sc_def
+                      active_sc_def opt_map_red opt_map_def
+               split: option.split_asm Structures_A.kernel_object.splits)
+
+lemma active_sc_at'_imp_is_active_sc':
+  "active_sc_at' scp s \<Longrightarrow> is_active_sc' scp s"
+  by (clarsimp simp: active_sc_at'_def is_active_sc'_def obj_at'_def opt_map_def projectKOs)
+
+lemma active_sc_at'_rewrite:
+  "active_sc_at' scp s = (is_active_sc' scp s \<and> sc_at' scp s)"
+  by (fastforce simp: active_sc_at'_def is_active_sc'_def obj_at'_def opt_map_def projectKOs)
+
+abbreviation
+  "valid_refills2 scp s \<equiv>
+     ((\<lambda>sc. if sc_period sc = 0 then rr_valid_refills (sc_refills sc) (sc_refill_max sc) (sc_budget sc)
+      else sp_valid_refills (sc_refills sc) (sc_refill_max sc) (sc_period sc) (sc_budget sc)) |<
+     scs_of2 s) scp"
+
+lemmas valid_refills2_def = rr_valid_refills_def sp_valid_refills_def
+
+lemma valid_refills_rewrite:
+  "valid_refills scp s = valid_refills2 scp s"
+  by (fastforce simp: opt_map_red vs_all_heap_simps valid_refills_def
+               split: option.splits Structures_A.kernel_object.splits)
+
+definition
+  round_robin2 :: "obj_ref \<Rightarrow> 'z state \<Rightarrow> bool"
+where
+  "round_robin2 sc_ptr s \<equiv> ((\<lambda>sc. sc_period sc = 0) |< scs_of2 s) sc_ptr"
+
+lemma round_robin_rewrite:
+  "round_robin scp s = round_robin2 scp s"
+  by (clarsimp simp: round_robin_def round_robin2_def vs_all_heap_simps opt_map_def
+              split: option.splits Structures_A.kernel_object.splits)
+
+abbreviation
+  sc_refills_sc_at2 where
+  "sc_refills_sc_at2 P scp s \<equiv> ((\<lambda>sc. P (sc_refills sc)) |< scs_of2 s) scp"
+
+lemma sc_refills_sc_at_rewrite:
+  "sc_refills_sc_at P scp s = sc_refills_sc_at2 P scp s"
+  by (fastforce simp: sc_refills_sc_at_def obj_at_def is_sc_obj opt_map_red
+               split: option.splits Structures_A.kernel_object.split_asm)
+
+lemmas projection_rewrites = pred_map_rewrite scs_of_rewrite is_active_sc_rewrite
+                             sc_heap_of_state_def sc_refills_sc_at_rewrite
+                             active_sc_at'_rewrite valid_refills_rewrite round_robin_rewrite
+
+lemma is_active_sc'_cross:
+  assumes p: "pspace_relation (kheap s) (ksPSpace s')"
+  assumes t: "is_active_sc2 ptr s"
+  shows "is_active_sc' ptr s'"
+  using assms
+  supply projection_rewrites[simp]
+  apply (clarsimp simp: projectKOs is_active_sc2_def is_active_sc'_def
+                 split: option.split_asm Structures_A.kernel_object.split_asm)
+  apply (drule (1) pspace_relation_absD, clarsimp split: if_split_asm)
+  by (case_tac z; simp add: sc_relation_def opt_map_red)
+
+lemma set_refills_is_active_sc2[wp]:
+  "set_refills ptr new \<lbrace>is_active_sc2 ptr'\<rbrace>"
+  apply (wpsimp simp: is_active_sc2_def wp: set_refills_wp)
+  by (clarsimp simp: obj_at_def opt_map_def)
+
+(* end : projection rewrites *)
+
+(* updateSchedContext *)
+
+context begin interpretation Arch . (*FIXME: arch_split*)
+
+lemma state_relation_sc_update:
+  assumes
+      R1: "\<forall>s s'. (s, s') \<in> state_relation \<longrightarrow>
+         P s \<longrightarrow> P' s' \<longrightarrow> sc_at ptr s \<longrightarrow> sc_at' ptr s' \<longrightarrow>
+           (\<forall>n. (((\<lambda>ko. obj_bits ko = min_sched_context_bits + n) |< kheap s) ptr) \<longrightarrow>
+           sc_relation (the ((scs_of2 s ||> f) ptr)) n (the ((scs_of' s' ||> f') ptr)))"
+  and R2: "\<forall>s s'. (s, s') \<in> state_relation \<longrightarrow>
+         P s \<longrightarrow> P' s' \<longrightarrow> sc_at ptr s \<longrightarrow> sc_at' ptr s' \<longrightarrow>
+           heap_ls (replyPrevs_of s')  (scReply (the ((scs_of' s' ||> f') ptr)))
+             (sc_replies (the ((scs_of2 s ||> f) ptr)))"
+  and sz: "\<forall>sc'::sched_context. objBits sc' = objBits (f' sc')"
+  shows
+  "\<lbrakk>(s, s') \<in> state_relation; P s; P' s'; sc_at ptr s; sc_at' ptr s'\<rbrakk> \<Longrightarrow>
+     (kheap_update (\<lambda>hp p. if p = ptr
+                           then
+                             case hp ptr of
+                                Some (kernel_object.SchedContext sc n)
+                                   \<Rightarrow> Some (kernel_object.SchedContext (f sc) n)
+                               | _ \<Rightarrow> hp ptr
+                           else hp p) s,
+     (ksPSpace_update (\<lambda>hp' p. if p = ptr
+                               then case hp' ptr of
+                                  Some (KOSchedContext sc')
+                                     \<Rightarrow> Some (KOSchedContext (f' sc'))
+                                 | _ \<Rightarrow> hp' ptr
+                                else hp' p)) s') \<in> state_relation"
+  supply pred_map_rewrite[simp] scs_of_rewrite[simp] opt_map_red[simp]
+         sc_replies_of_rewrite[simplified, simp]
+  proof -
+  have z': "\<And>s. sc_at' ptr s
+               \<Longrightarrow> \<forall>sc'::sched_context. map_to_ctes ((\<lambda>hp' p. if p = ptr then case hp' ptr of
+                              Some (KOSchedContext sc') \<Rightarrow> Some (KOSchedContext (f' sc'))
+                            | _ \<Rightarrow> hp' ptr else hp' p) (ksPSpace s)) = map_to_ctes (ksPSpace s)"
+    by (clarsimp simp: obj_at_simps fun_upd_def[symmetric])
+  have z: "\<And>s sc'::sched_context. ko_at' sc' ptr s
+               \<Longrightarrow> map_to_ctes (ksPSpace s(ptr \<mapsto> KOSchedContext (f' sc'))) = map_to_ctes (ksPSpace s)"
+    by (clarsimp simp: obj_at_simps)
+  assume H: "(s, s') \<in> state_relation" "P s" "P' s'" "sc_at ptr s" "sc_at' ptr s'"
+  show ?thesis
+    using H sz
+    apply -
+    apply (insert R1[rule_format, OF H]
+                  R2[rule_format, OF H])
+    apply (clarsimp simp: state_relation_def)
+    apply (clarsimp simp: obj_at_def is_sc_obj)
+    apply (prop_tac "obj_at (same_caps (kernel_object.SchedContext _ n)) ptr s")
+     apply (clarsimp simp: obj_at_def obj_bits_def)
+    apply (clarsimp simp: obj_at'_def projectKOs fun_upd_def[symmetric]
+                          z[simplified obj_at'_def projectKO_eq projectKO_opts_defs])
+    apply (rename_tac n sc sc')
+    apply (rule conjI)
+     (* pspace_relation *)
+     apply (simp only: pspace_relation_def simp_thms
+                       pspace_dom_update[where x="kernel_object.SchedContext _ _"
+                                           and v="kernel_object.SchedContext _ _",
+                                         simplified a_type_def, simplified])
+     apply (simp only: dom_fun_upd2 simp_thms)
+     apply (elim conjE)
+     apply (frule bspec, erule domI)
+     apply (rule ballI, drule(1) bspec)
+     apply (drule domD)
+     apply (clarsimp simp: project_inject
+                    split: if_split_asm kernel_object.split_asm)
+     apply (drule_tac x=sc' in spec)
+     apply (rename_tac bb aa ba)
+     apply (drule_tac x="(aa, ba)" in bspec, simp)
+     apply (clarsimp simp: objBits_def)
+     apply (frule_tac ko'="kernel_object.SchedContext sc n" and x'=ptr in obj_relation_cut_same_type)
+        apply simp+
+     apply (erule obj_relation_cutsE)
+            apply ((simp split: if_split_asm)+)[8]
+    (* sc_replies_relation *)
+    apply (frule (2) sc_replies_relation_prevs_list[simplified])
+    apply (subst replyPrevs_of_non_reply_update[simplified]; (simp add: typ_at'_def ko_wp_at'_def)?)
+    apply (simp add: sc_replies_relation_def)
+    apply (rule conjI)
+     (* ghost relation *)
+     apply (clarsimp simp add: ghost_relation_def)
+     apply (erule_tac x=ptr in allE)+
+     apply (clarsimp simp: obj_at_def a_type_def is_sc_obj
+                     split: Structures_A.kernel_object.splits if_split_asm)
+    apply (rule conjI)
+     (* cdt_relation *)
+     apply (clarsimp simp add: cte_wp_at_cases cdt_relation_def)
+    (* revokable_relation *)
+    apply (prop_tac "kheap_update
+                      (\<lambda>hp x.
+                          if x = ptr
+                          then case hp ptr of None \<Rightarrow> hp ptr
+                               | Some (kernel_object.SchedContext sc n) \<Rightarrow>
+                                   Some (kernel_object.SchedContext (f sc) n)
+                               | Some _ \<Rightarrow> hp ptr
+                          else hp x) s
+             = s\<lparr> kheap := (kheap s)(ptr \<mapsto> kernel_object.SchedContext (f sc) n)\<rparr>" )
+     apply (clarsimp simp: fun_upd_def cong: if_cong)
+    apply (simp only: fun_upd_def)
+    apply (simp add: caps_of_state_after_update)
+    done
+qed
+
+(* update wp rules without ko_at' *)
+lemma updateSchedContext_wp:
+  "\<lbrace> \<lambda>s. sc_at' sc_ptr s \<longrightarrow>
+       Q (s\<lparr>ksPSpace := ksPSpace s(sc_ptr \<mapsto> KOSchedContext (f' (the (scs_of' s sc_ptr))))\<rparr>) \<rbrace>
+   updateSchedContext sc_ptr f'
+   \<lbrace> \<lambda>rv. Q \<rbrace>"
+  by (wpsimp simp: updateSchedContext_def wp: set_sc'.set_wp)
+     (clarsimp simp: obj_at'_def projectKOs opt_map_red elim!: rsubst[where P=Q])
+
+lemma no_fail_setSchedContext[wp]:
+  "no_fail (sc_at' ptr and (\<lambda>s'. ((\<lambda>k::sched_context. objBits k = objBits new) |< scs_of' s') ptr)) (setSchedContext ptr new)"
+  unfolding setSchedContext_def by (wpsimp simp: opt_map_def obj_at'_def projectKOs)
+
+lemma no_fail_updateSchedContext[wp]:
+  "no_fail (sc_at' ptr and (\<lambda>s'. ((\<lambda>k::sched_context. objBits k = objBits (f k)) |< scs_of' s') ptr))
+         (updateSchedContext ptr f)"
+  by (wpsimp simp: updateSchedContext_def obj_at'_def projectKOs opt_map_def)
+
+lemma update_sched_context_rewrite:
+  "monadic_rewrite False True (sc_obj_at n scp)
+    (update_sched_context scp f)
+      (do sc \<leftarrow> get_sched_context scp;
+          set_object scp (kernel_object.SchedContext (f sc) n) od)"
+  apply (clarsimp simp: update_sched_context_def get_sched_context_def bind_assoc)
+  apply (rule monadic_rewrite_bind_tail)
+   defer
+   apply (rule get_object_sp)
+  apply (case_tac obj; clarsimp simp: monadic_rewrite_refl3 set_object_def)
+  apply (rule monadic_rewrite_bind_tail)
+   defer
+   apply (rule get_object_sp)
+  apply (clarsimp simp: monadic_rewrite_def obj_at_def is_sc_obj_def)
+  done
+
+lemma updateSchedContext_corres_gen:
+  assumes
+      R1: "\<forall>s s'. (s, s') \<in> state_relation \<longrightarrow>
+           P s \<longrightarrow> P' s' \<longrightarrow> sc_at ptr s \<longrightarrow> sc_at' ptr s' \<longrightarrow>
+           (\<forall>n. (((\<lambda>ko. obj_bits ko = min_sched_context_bits + n) |< kheap s) ptr)\<longrightarrow>
+           sc_relation (the ((scs_of2 s ||> f) ptr)) n (the ((scs_of' s' ||> f') ptr)))"
+  and R2: "\<forall>s s'. (s, s') \<in> state_relation \<longrightarrow>
+          P s \<longrightarrow> P' s' \<longrightarrow> sc_at ptr s \<longrightarrow> sc_at' ptr s' \<longrightarrow>
+           heap_ls (replyPrevs_of s')  (scReply (the ((scs_of' s' ||> f') ptr)))
+             (sc_replies (the ((scs_of2 s ||> f) ptr)))"
+  and sz: "\<forall>sc'::sched_context. objBits sc' = objBits (f' sc')"
+  shows "corres dc
+         (sc_at ptr and P)
+         (sc_at' ptr and P')
+            (update_sched_context ptr f)
+            (updateSchedContext ptr f')"
+  unfolding corres_underlying_def using sz
+  apply clarsimp
+  apply (rename_tac s s')
+  apply (drule obj_at_ko_at)
+  apply (drule obj_at_ko_at')
+  apply (clarsimp simp: is_sc_obj)
+  apply (rename_tac sc' n sc)
+  apply (rule conjI, clarsimp)
+   apply (erule use_valid[OF _ updateSchedContext_wp])
+   apply clarsimp
+   apply (rule_tac x="((), s\<lparr>kheap := kheap s(ptr \<mapsto>
+                  kernel_object.SchedContext (f sc) n)\<rparr>)" in bexI)
+    apply clarsimp
+    apply (drule state_relation_sc_update[OF R1 R2 sz, simplified])
+      apply ((fastforce simp: obj_at_def is_sc_obj obj_at'_def projectKOs)+)[4]
+    apply (clarsimp simp: obj_at_def obj_at'_def projectKOs fun_upd_def[symmetric] opt_map_red)
+    apply (case_tac s; case_tac s'; fastforce)
+   apply (clarsimp simp: update_sched_context_def obj_at_def in_monad
+                         get_object_def set_object_def a_type_def)
+  apply (clarsimp intro!: no_failD[OF no_fail_updateSchedContext]
+                    simp: obj_at'_def projectKOs opt_map_def)
   done
 
-lemmas setEndpoint_valid_globals[wp]
-    = valid_global_refs_lift' [OF set_ep_ctes_of set_ep_arch'
-                                  setEndpoint_it setEndpoint_ksInterruptState]
+lemmas updateSchedContext_corres = updateSchedContext_corres_gen[where P=\<top> and P'=\<top>, simplified]
+
+(* end : updateSchedContext *)
+
 end
+
+(* FIXME RT: rename *)
+(* this let us cross the sc size information from concrete to abstract *)
+lemma ko_at'_cross:
+  assumes p: "pspace_relation (kheap s) (ksPSpace s')"
+  assumes t: "ko_at' (sc'::sched_context) ptr s'"
+  shows "sc_obj_at (objBits sc' - minSchedContextBits) ptr s" using assms
+  apply (clarsimp simp: obj_at'_def projectKOs)
+  apply (erule (1) pspace_dom_relatedE)
+  by (clarsimp simp: obj_relation_cuts_def2 obj_at_def is_sc_obj cte_relation_def
+                     other_obj_relation_def pte_relation_def pde_relation_def
+                     scBits_simps sc_relation_def objBits_simps
+              split: Structures_A.kernel_object.split_asm if_split_asm
+                     ARM_A.arch_kernel_obj.split_asm)
+
+lemma update_sc_no_reply_stack_update_ko_at'_corres:
+  assumes x: "\<And>sc n. sc_relation sc n sc' \<longrightarrow> sc_relation (f sc) n (f' sc')"
+  assumes y: "\<And>sc. sc_replies sc = sc_replies (f sc)"
+  assumes z: "objBits sc' = objBits (f' sc')"
+  assumes r: "scReply sc' = scReply (f' sc')"
+  shows
+    "corres dc (sc_at ptr) (ko_at' sc' ptr)
+            (update_sched_context ptr f)
+            (setSchedContext ptr (f' sc'))"
+  unfolding update_sched_context_def
+  apply (rule corres_guard_imp)
+    apply (rule corres_symb_exec_l'[where Q'="\<lambda>r s. ko_at r ptr s \<and> (\<exists>n. is_sc_obj n r)",
+                                    where P="\<lambda>s. obj_at \<top> ptr s"])
+      apply (rule corres_guard_imp[where P'=R and Q'=R for R])
+        apply (rule_tac F="(\<exists>n. is_sc_obj n obj)" in corres_gen_asm)
+        apply (case_tac obj; simp add: is_sc_obj_def)
+        apply (rule setSchedContext_no_stack_update_corres[where f'=f'])
+           apply (clarsimp simp: x obj_at_def intro!: y z r)+
+     apply (fastforce simp: exs_valid_def get_object_def in_monad)
+    apply (wpsimp wp: get_object_wp)
+   apply (fastforce simp: obj_at_def)
+  apply simp
+  done
+
+lemma update_sc_no_reply_stack_update_corres:
+  "\<lbrakk>\<forall>sc n sc'. sc_relation sc n sc' \<longrightarrow> sc_relation (f sc) n (f' sc');
+    \<forall>sc. sc_replies sc = sc_replies (f sc); \<forall>sc'. objBits sc' = objBits (f' sc');
+    \<forall>sc'. scReply (f' sc') = scReply sc' \<rbrakk> \<Longrightarrow>
+   corres dc (sc_at ptr and pspace_aligned and pspace_distinct) \<top>
+          (update_sched_context ptr f)
+         (do sc' <- getSchedContext ptr;
+             setSchedContext ptr (f' sc')
+          od)"
+  apply (rule_tac Q="sc_at' ptr" in corres_cross_add_guard)
+   apply (fastforce dest!: state_relationD sc_at_cross simp: obj_at'_def)
+  apply (rule corres_symb_exec_r)
+     apply (rule corres_guard1_imp)
+      apply (rule update_sc_no_reply_stack_update_ko_at'_corres; simp)
+     apply clarsimp
+    apply (wpsimp wp: get_sched_context_exs_valid simp: is_sc_obj_def obj_at_def)
+   apply (rename_tac ko; case_tac ko; simp)
+   apply (wpsimp simp: obj_at_def is_sc_obj_def)+
+  done
+
+lemma ko_at'_inj:
+  "ko_at' ko ptr  s \<Longrightarrow> ko_at' ko' ptr s \<Longrightarrow> ko' = ko"
+  by (clarsimp simp: obj_at'_real_def ko_wp_at'_def)
+
+(* FIXME RT: Move these to AInvs where possible *)
+(* FIXME RT: Try to unify with existing notions.
+             See https://sel4.atlassian.net/browse/VER-1382 *)
+definition injective_ref where
+  "injective_ref ref heap \<equiv> (\<forall>q p1 p2. (p1, ref) \<in> heap q \<and> (p2, ref) \<in> heap q \<longrightarrow> p1 = p2)"
+
+lemma sym_refs_inj:
+  "\<lbrakk>sym_refs heap; injective_ref (symreftype ref) heap; (x, ref) \<in> heap y; (x, ref) \<in> heap y'\<rbrakk>
+   \<Longrightarrow> y = y' "
+  apply (clarsimp simp: sym_refs_def injective_ref_def)
+  apply fastforce
+  done
+
+lemma sym_refs_inj2:
+  "\<lbrakk>sym_refs heap; injective_ref ref heap; (x, ref) \<in> heap y; (y, symreftype ref) \<in> heap z\<rbrakk>
+   \<Longrightarrow> x = z "
+  apply (subgoal_tac "(y, symreftype ref) \<in> heap x")
+   apply (erule (3) sym_refs_inj[where ref="symreftype ref", simplified])
+  apply (fastforce simp: sym_refs_def)
+  done
+
+lemma injective_ref_SCTcb[simp]:
+  "injective_ref SCTcb (state_refs_of' s) "
+  apply (clarsimp simp: state_refs_of'_def injective_ref_def split: option.splits if_splits)
+  apply (clarsimp simp: refs_of'_def)
+  apply (rename_tac p0 ko p1 p2)
+  apply (prop_tac "\<exists>z. ko = KOSchedContext z")
+   apply (clarsimp split: kernel_object.splits)
+      apply (clarsimp split: Structures_H.endpoint.splits simp: ep_q_refs_of'_def)
+     apply (clarsimp split: Structures_H.ntfn.splits option.splits
+                      simp: ntfn_q_refs_of'_def get_refs_def)
+    apply (clarsimp simp: tcb_st_refs_of'_def tcb_bound_refs'_def get_refs_def
+                   split: Structures_H.thread_state.splits if_splits option.splits)
+   apply (clarsimp simp: get_refs_def split: option.splits)
+  apply (clarsimp simp: get_refs_def split: option.splits)
+  done
+
+lemma reply_at'_cross_rel:
+  "cross_rel (pspace_aligned and pspace_distinct and reply_at t) (reply_at' t)"
+  unfolding cross_rel_def state_relation_def
+  apply clarsimp
+  by (erule (3) reply_at_cross)
+
+lemma sch_act_simple_cross_rel:
+  "cross_rel simple_sched_action sch_act_simple"
+  apply (clarsimp simp: cross_rel_def)
+  by (fastforce simp: simple_sched_action_def sch_act_simple_def
+                dest: state_relation_sched_act_relation
+               split: Structures_A.scheduler_action.splits)
+
+(* FIXME RT: move to Corres_UL.thy *)
+lemma cross_relF:
+  "(s, s') \<in> state_relation \<Longrightarrow> cross_rel A B \<Longrightarrow> A s \<Longrightarrow> B s'"
+  by (clarsimp simp: cross_rel_def)
+
+lemma valid_tcb_state'_simps[simp]:
+  "valid_tcb_state' Running = \<top>"
+  "valid_tcb_state' Inactive = \<top>"
+  "valid_tcb_state' Restart = \<top>"
+  "valid_tcb_state' IdleThreadState = \<top>"
+  "valid_tcb_state' (BlockedOnSend ref b c d e) = ep_at' ref"
+  "valid_tcb_state' (BlockedOnReply r) = valid_bound_reply' r"
+  by (rule ext, simp add: valid_tcb_state'_def)+
+
+lemma tcb_at'_ex1_ko_at':
+  "tcb_at' t s \<Longrightarrow> \<exists>!tcb. ko_at' (tcb::tcb) t s"
+  by (clarsimp simp: obj_at'_def)
+
+lemma ex1_ex_eq_all:
+  "\<exists>!x. Q x \<Longrightarrow> (\<exists>x. Q x \<and> P x) = (\<forall>x. Q x \<longrightarrow> P x)"
+  by fastforce
+
+lemmas tcb_at'_ex_eq_all = ex1_ex_eq_all[OF tcb_at'_ex1_ko_at']
+
+lemma receiveBlocked_equiv:
+  "receiveBlocked st = is_BlockedOnReceive st"
+  unfolding receiveBlocked_def
+  by (case_tac st; simp)
+
+lemma threadGet_getObject:
+  "threadGet f t = do x <- getObject t;
+                         return (f x)
+                   od"
+  apply (simp add: threadGet_def threadRead_def oliftM_def getObject_def[symmetric])
+  done
+
+lemma obj_at'_typ_at'[elim!]:
+  "obj_at' (P :: ('a :: pspace_storable) \<Rightarrow> bool) p s \<Longrightarrow>
+   obj_at' (\<top> :: ('a :: pspace_storable) \<Rightarrow> bool) p s"
+  by (clarsimp simp: obj_at'_real_def ko_wp_at'_def)
+
+lemma shows
+  obj_at'_sc_tcbs_of_equiv:
+    "obj_at' (\<lambda>x. scTCB x = Some t) p s = (sc_at' p s \<and> scTCBs_of s p = Some t)"
+  and obj_at'_tcb_scs_of_equiv:
+    "obj_at' (\<lambda>x. tcbSchedContext x = Some sc) p s = (tcb_at' p s \<and> tcbSCs_of s p = Some sc)"
+  and obj_at'_replySCs_of_equiv:
+    "obj_at' (\<lambda>a. replyNext a = Some (Head sc)) p s = (reply_at' p s \<and> replySCs_of s p = Some sc)"
+  and obj_at'_scReplies_of_equiv:
+    "obj_at' (\<lambda>a. scReply a = Some sc) p s = (sc_at' p s \<and> scReplies_of s p = Some sc)"
+  by (intro iffI; clarsimp simp: obj_at'_real_def ko_wp_at'_def projectKOs opt_map_def)+
+
+lemma not_idle_scTCB:
+  "\<lbrakk>sym_heap_tcbSCs s; valid_objs' s; valid_idle' s; p \<noteq> idle_sc_ptr; sc_at' p s\<rbrakk> \<Longrightarrow>
+   obj_at' (\<lambda>x. scTCB x \<noteq> Some idle_thread_ptr) p s"
+  apply (subgoal_tac "\<not>obj_at' (\<lambda>x. scTCB x = Some idle_thread_ptr) p s")
+   apply (clarsimp simp: obj_at'_real_def ko_wp_at'_def)
+  apply (subst (asm) sym_heap_symmetric)
+  apply (clarsimp simp: obj_at'_sc_tcbs_of_equiv sym_heap_def)
+  apply (clarsimp simp: valid_idle'_def obj_at'_real_def ko_wp_at'_def idle_tcb'_def projectKOs)
+  done
+
+lemma not_idle_tcbSC:
+  "\<lbrakk>sym_heap_tcbSCs s; valid_objs' s; valid_idle' s; p \<noteq> idle_thread_ptr; tcb_at' p s\<rbrakk> \<Longrightarrow>
+   obj_at' (\<lambda>x. tcbSchedContext x \<noteq> Some idle_sc_ptr) p s"
+  apply (subgoal_tac "\<not>obj_at' (\<lambda>x. tcbSchedContext x = Some idle_sc_ptr) p s")
+   apply (clarsimp simp: obj_at'_real_def ko_wp_at'_def)
+  apply (clarsimp simp: obj_at'_tcb_scs_of_equiv sym_heap_def)
+  apply (clarsimp simp: valid_idle'_def obj_at'_real_def ko_wp_at'_def idle_tcb'_def projectKOs)
+  done
+
+lemma setObject_tcb_tcbs_of':
+  "\<lbrace>\<lambda>s. P' ((tcbs_of' s)(c \<mapsto> tcb))\<rbrace>
+  setObject c (tcb::tcb)
+  \<lbrace>\<lambda>_ s. P' (tcbs_of' s)\<rbrace>"
+  by (setObject_easy_cases, clarsimp simp: ARM_H.fromPPtr_def)
+
+lemma setObject_other_tcbs_of'[wp]:
+  "setObject c (r::reply) \<lbrace>\<lambda>s. P' (tcbs_of' s)\<rbrace>"
+  "setObject c (e::endpoint) \<lbrace>\<lambda>s. P' (tcbs_of' s)\<rbrace>"
+  "setObject c (n::notification) \<lbrace>\<lambda>s. P' (tcbs_of' s)\<rbrace>"
+  "setObject c (sc::sched_context) \<lbrace>\<lambda>s. P' (tcbs_of' s)\<rbrace>"
+  by setObject_easy_cases+
+
+lemma setObject_cte_tcbSCs_of[wp]:
+  "setObject c (reply::cte) \<lbrace>\<lambda>s. P' (tcbSCs_of s)\<rbrace>"
+  by setObject_easy_cases
+
+lemma threadSet_tcbSCs_of_inv:
+  "\<forall>x. tcbSchedContext (f x) = tcbSchedContext x \<Longrightarrow>
+  threadSet f t \<lbrace>\<lambda>s. P (tcbSCs_of s)\<rbrace>"
+  unfolding threadSet_def
+  apply (rule hoare_seq_ext[OF _ get_tcb_sp'])
+  apply (wpsimp wp: setObject_tcb_tcbs_of')
+  apply (erule subst[where P=P, rotated], rule ext)
+  apply (clarsimp simp: opt_map_def obj_at'_real_def ko_wp_at'_def projectKO_tcb
+                 split: option.splits)
+  done
+
+lemma aligned'_distinct'_obj_at'I:
+  "\<lbrakk> \<exists>y. ksPSpace s p = Some (injectKO (y:: 'a::pspace_storable));
+    pspace_aligned' s; pspace_distinct' s;
+    (if koTypeOf (the (ksPSpace s p))  = SchedContextT then pspace_bounded' s else True)\<rbrakk>
+   \<Longrightarrow> obj_at' (\<top> :: 'a::pspace_storable \<Rightarrow> bool) p s"
+  apply (clarsimp)
+  apply (frule_tac v=y in aligned'_distinct'_ko_at'I; simp?)
+  apply (case_tac "injectKO y"; clarsimp simp: valid_sz_simps dest!: pspace_boundedD')
+  done
+
+(* FIXME RT: maybe move? *)
+lemma prod_in_refsD:
+  "\<And>ref x y. (x, ref) \<in> ep_q_refs_of' y \<Longrightarrow> ref \<in> {EPRecv, EPSend}"
+  "\<And>ref x y. (x, ref) \<in> ntfn_q_refs_of' y \<Longrightarrow> ref \<in> {NTFNSignal}"
+  "\<And>ref x y. (x, ref) \<in> tcb_st_refs_of' y \<Longrightarrow> ref \<in> {TCBBlockedRecv, TCBReply, TCBSignal, TCBBlockedSend}"
+  "\<And>ref x a b c. (x, ref) \<in> tcb_bound_refs' a b c \<Longrightarrow> ref \<in> {TCBBound, TCBSchedContext, TCBYieldTo}"
+  apply (rename_tac ep; case_tac ep; simp)
+  apply (rename_tac ep; case_tac ep; simp)
+  apply (rename_tac ep; case_tac ep; clarsimp split: if_splits)
+  apply (clarsimp simp: tcb_bound_refs'_def get_refs_def2)
+  done
+
+lemma sym_refs_tcbSCs:
+  "\<lbrakk>sym_refs (state_refs_of' s); pspace_aligned' s; pspace_distinct' s; pspace_bounded' s\<rbrakk>
+   \<Longrightarrow> sym_heap_tcbSCs s"
+  apply (clarsimp simp: sym_heap_def)
+  apply (rule iffI)
+   apply (drule_tac tp=SCTcb and x=p and y=p' in sym_refsE;
+          force simp: get_refs_def2 state_refs_of'_def projectKOs opt_map_red refs_of_rev'
+                dest: pspace_alignedD' pspace_distinctD' pspace_boundedD' split: if_split_asm option.split_asm)+
+  by (drule_tac tp=TCBSchedContext and x=p' and y=p in sym_refsE;
+      force simp: get_refs_def2 state_refs_of'_def projectKOs opt_map_red refs_of_rev'
+               dest: pspace_alignedD' pspace_distinctD' pspace_boundedD' split: if_split_asm option.split_asm)+
+
+lemma sym_refs_scReplies:
+  "\<lbrakk>sym_refs (state_refs_of' s); pspace_aligned' s; pspace_distinct' s; pspace_bounded' s\<rbrakk>
+   \<Longrightarrow> sym_heap_scReplies s"
+  apply (clarsimp simp: sym_heap_def)
+  apply (rule iffI)
+   apply (drule_tac tp=ReplySchedContext and x=p and y=p' in sym_refsE;
+          force simp: get_refs_def2 state_refs_of'_def projectKOs opt_map_red refs_of_rev'
+                dest: pspace_alignedD' pspace_distinctD' pspace_boundedD' split: if_split_asm option.split_asm)+
+  by (drule_tac tp=SCReply and x=p' and y=p in sym_refsE;
+      force simp: get_refs_def2 state_refs_of'_def projectKOs opt_map_red refs_of_rev'
+               dest: pspace_alignedD' pspace_distinctD' pspace_boundedD' split: if_split_asm option.split_asm)+
+
+lemma setSchedContext_scTCBs_of:
+  "\<lbrace>\<lambda>s. P (\<lambda>a. if a = scPtr then scTCB sc else scTCBs_of s a)\<rbrace>
+   setSchedContext scPtr sc
+   \<lbrace>\<lambda>_ s. P (scTCBs_of s)\<rbrace>"
+  unfolding setSchedContext_def
+  apply (wpsimp wp: setObject_sc_wp)
+  apply (erule back_subst[where P=P], rule ext)
+  by (clarsimp simp: opt_map_def)
+
+lemma setSchedContext_scReplies_of:
+  "\<lbrace>\<lambda>s. P (\<lambda>a. if a = scPtr then scReply sc else scReplies_of s a)\<rbrace>
+   setSchedContext scPtr sc
+   \<lbrace>\<lambda>_ s. P (scReplies_of s)\<rbrace>"
+  unfolding setSchedContext_def
+  apply (wpsimp wp: setObject_sc_wp)
+  apply (erule back_subst[where P=P], rule ext)
+  by (clarsimp simp: opt_map_def)
+
+lemma getObject_tcb_wp:
+  "\<lbrace>\<lambda>s. tcb_at' p s \<longrightarrow> (\<exists>t::tcb. ko_at' t p s \<and> Q t s)\<rbrace> getObject p \<lbrace>Q\<rbrace>"
+  by (clarsimp simp: getObject_def valid_def in_monad
+                     split_def objBits_simps' loadObject_default_def
+                     projectKOs obj_at'_def in_magnitude_check
+              dest!: readObject_misc_ko_at')
+
+
+lemma threadSet_tcbSCs_of:
+  "\<lbrace>\<lambda>s. P (\<lambda>a. if a = t then tcbSchedContext (f (the (tcbs_of' s a))) else tcbSCs_of s a)\<rbrace>
+   threadSet f t
+   \<lbrace>\<lambda>_ s. P (tcbSCs_of s)\<rbrace>"
+  unfolding threadSet_def
+  apply (wpsimp wp: setObject_tcb_wp getObject_tcb_wp)
+  apply (clarsimp simp: tcb_at'_ex_eq_all)
+  apply (erule back_subst[where P=P], rule ext)
+  apply (clarsimp simp: opt_map_def obj_at'_real_def ko_wp_at'_def projectKOs)
+  done
+
+lemma shows
+  replyNexts_Some_replySCs_None:
+  "replyNexts_of s rp \<noteq> None \<Longrightarrow> replySCs_of s rp = None" and
+  replySCs_Some_replyNexts_None:
+  "replySCs_of s rp \<noteq> None \<Longrightarrow> replyNexts_of s rp = None"
+  by (clarsimp simp: opt_map_def projectKOs split: option.splits reply_next.splits)+
+
+lemma sym_heap_remove_only:
+  "\<lbrakk> sym_heap h1 h2; h2 y = Some x \<rbrakk> \<Longrightarrow>
+   sym_heap (\<lambda>a. if a = x then None else h1 a) (\<lambda>a. if a = y then None else h2 a)"
+  supply opt_mapE [rule del]
+  apply (clarsimp simp: sym_heap_def)
+  apply (subst (asm) sym_heap_symmetric[simplified sym_heap_def], simp)
+  done
+
+lemma pred_tcb_at'_equiv:
+  "pred_tcb_at' p P t s = (tcb_at' t s \<and> P (p (tcb_to_itcb' (the (tcbs_of' s t)))))"
+  by (rule iffI;
+      clarsimp simp: pred_tcb_at'_def pred_map_def obj_at'_real_def ko_wp_at'_def projectKOs
+                     opt_map_def)
+
+lemma isBlockedOnSend_equiv:
+  "isBlockedOnSend st = is_BlockedOnSend st"
+  by (case_tac st; simp add: isBlockedOnSend_def)
+
+lemma isSend_equiv:
+  "isSend st = is_BlockedOnSend st"
+  by (case_tac st; simp add: isSend_def)
+
+lemma sch_act_wf_not_runnable_sch_act_not:
+  "\<lbrakk>st_tcb_at' P t s; sch_act_wf (ksSchedulerAction s) s; \<forall>st. P st \<longrightarrow> \<not> runnable' st\<rbrakk> \<Longrightarrow>
+   sch_act_not t s"
+   by (clarsimp simp: pred_tcb_at'_def obj_at'_def)
+
+lemma isTimeoutFault_fault_map[simp]:
+  "isTimeoutFault (fault_map a) = is_timeout_fault a"
+  by (clarsimp simp: isTimeoutFault_def fault_map_def is_timeout_fault_def
+              split: ExceptionTypes_A.fault.splits)
+
+lemma valid_bound_obj_lift:
+  "f \<lbrace>P (the x)\<rbrace> \<Longrightarrow> f \<lbrace>valid_bound_obj P x\<rbrace>"
+  unfolding valid_bound_obj_def
+  by (case_tac x; wpsimp)
+
+lemma valid_bound_obj'_lift:
+  "f \<lbrace>P (the x)\<rbrace> \<Longrightarrow> f \<lbrace>valid_bound_obj' P x\<rbrace>"
+  unfolding valid_bound_obj'_def
+  by (case_tac x; wpsimp)
+
+lemma ep_at'_cross_rel:
+  "cross_rel (pspace_aligned and pspace_distinct and ep_at t) (ep_at' t)"
+  unfolding cross_rel_def state_relation_def
+  apply clarsimp
+  by (erule (3) ep_at_cross)
+
+lemma sch_act_not_cross_rel:
+  "cross_rel (scheduler_act_not t) (sch_act_not t)"
+  unfolding cross_rel_def state_relation_def
+  apply clarsimp
+  apply (case_tac "scheduler_action s"; simp)
+  by (clarsimp simp: scheduler_act_not_def sched_act_relation_def)
+
+global_interpretation set_simple_ko: typ_at_pres "set_simple_ko C ptr ep"
+  unfolding typ_at_pres_def by wpsimp
+
+global_interpretation update_sk_obj_ref: typ_at_pres "update_sk_obj_ref C update ref new"
+  unfolding typ_at_pres_def by wpsimp
+
+lemma getReprogramTimer_corres:
+  "corres (=) \<top> \<top> (gets reprogram_timer) getReprogramTimer"
+  by (clarsimp simp: getReprogramTimer_def state_relation_def)
+
+lemma setDomainTime_corres:
+  "dt = dt' \<Longrightarrow>
+  corres dc \<top> \<top> (modify (domain_time_update (\<lambda>_. dt))) (setDomainTime dt')"
+  apply (clarsimp simp: setDomainTime_def, rule corres_modify)
+  by (clarsimp simp: state_relation_def swp_def)
+
+lemma setConsumedTime_corres:
+  "ct = ct' \<Longrightarrow>
+  corres dc \<top> \<top> (modify (consumed_time_update (\<lambda>_. ct))) (setConsumedTime ct')"
+  apply (clarsimp simp: setConsumedTime_def, rule corres_modify)
+  by (clarsimp simp: state_relation_def swp_def)
+
+lemma setCurSc_corres:
+  "sc = sc' \<Longrightarrow>
+   corres dc \<top> \<top> (modify (cur_sc_update (\<lambda>_. sc))) (setCurSc sc')"
+  apply (clarsimp simp: setCurSc_def, rule corres_modify)
+  by (clarsimp simp: state_relation_def swp_def)
+
+lemma refillSingle_equiv:
+  "sc_valid_refills' sc \<Longrightarrow>
+   (length (refills_map (scRefillHead sc) (scRefillCount sc) (scRefillMax sc) (scRefills sc)) = Suc 0)
+    = (scRefillHead sc = refillTailIndex sc)"
+  apply (clarsimp simp: valid_sched_context'_def refillTailIndex_def refills_map_def)
+  apply (case_tac "scRefillCount sc = Suc 0"; simp)
+  apply (auto simp: Let_def)
+  done
+
+lemma refillSingle_corres:
+  "scp = scp' \<Longrightarrow>
+   corres (=) (sc_at scp) (obj_at' sc_valid_refills' scp')
+     (refill_single scp)
+     (refillSingle scp')"
+  unfolding refill_single_def refillSingle_def
+  apply (simp add: refill_size_def get_refills_def)
+  apply (rule stronger_corres_guard_imp)
+    apply (rule_tac R'="\<lambda>sc s. sc_valid_refills' sc" and R="\<lambda>_ _ . True" in corres_split)
+       apply (rule get_sc_corres)
+      apply simp
+      apply (metis (mono_tags, hide_lams) refillSingle_equiv sc_relation_def)
+     apply wpsimp+
+  apply (clarsimp simp: obj_at'_def)
+  done
+
+lemma active_sc_at'_cross:
+  "\<lbrakk>(s,s') \<in> state_relation; pspace_aligned s; pspace_distinct s; is_active_sc sc_ptr s;
+    sc_at sc_ptr s\<rbrakk>
+   \<Longrightarrow> active_sc_at' sc_ptr s'"
+  apply (frule state_relation_pspace_relation)
+  apply (frule (3) sc_at_cross)
+  apply (clarsimp simp: pspace_relation_def obj_at_def is_sc_obj_def)
+  apply (drule_tac x=sc_ptr in bspec, blast)
+  apply (clarsimp simp: sc_relation_def vs_all_heap_simps active_sc_at'_def obj_at'_def projectKOs
+                        active_sc_def)
+  done
+
+lemma is_active_sc'2_cross:
+  "\<lbrakk>(s,s') \<in> state_relation; pspace_aligned s; pspace_distinct s; is_active_sc sc_ptr s;
+    sc_at sc_ptr s\<rbrakk>
+   \<Longrightarrow> is_active_sc' sc_ptr s'"
+  apply (frule state_relation_pspace_relation)
+  apply (frule (3) sc_at_cross)
+  apply (clarsimp simp: pspace_relation_def obj_at_def is_sc_obj_def)
+  apply (drule_tac x=sc_ptr in bspec, blast)
+  apply (clarsimp simp: sc_relation_def vs_all_heap_simps obj_at'_def projectKOs
+                        active_sc_def opt_map_red StateRelation.is_active_sc'_def)
+  done
+
+\<comment> \<open>Some methods to add invariants to the concrete guard of a corres proof. Often used for properties
+    that are asserted to hold in the Haskell definition.\<close>
+
+method add_sym_refs =
+  rule_tac Q="\<lambda>s'. sym_refs (state_refs_of' s')" in corres_cross_add_guard,
+  (clarsimp simp: pred_conj_def)?,
+  (elim conjE)?,
+  (frule invs_sym_refs)?, (frule invs_psp_aligned)?, (frule invs_distinct)?,
+  fastforce dest: state_refs_of_cross_eq
+
+method add_ct_not_inQ =
+  rule_tac Q="\<lambda>s'. ct_not_inQ s'" in corres_cross_add_guard,
+  fastforce intro!: ct_not_inQ_cross simp: valid_sched_def
+
+method add_sch_act_wf =
+  rule_tac Q="\<lambda>s'. sch_act_wf (ksSchedulerAction s') s'" in corres_cross_add_guard,
+  fastforce intro!: sch_act_wf_cross simp: valid_sched_def
+
+method add_ct_idle_or_in_cur_domain' =
+  rule_tac Q="\<lambda>s'. ct_idle_or_in_cur_domain' s'" in corres_cross_add_guard,
+  fastforce intro!: ct_idle_or_in_cur_domain'_cross simp: valid_sched_def
+
+method add_valid_idle' =
+  rule_tac Q="\<lambda>s'. valid_idle' s'" in corres_cross_add_guard,
+  fastforce intro!: valid_idle'_cross
+
+method add_ready_qs_runnable =
+  rule_tac Q=ready_qs_runnable in corres_cross_add_guard,
+  (clarsimp simp: pred_conj_def)?,
+  (frule valid_sched_valid_ready_qs)?, (frule invs_psp_aligned)?, (frule invs_distinct)?,
+  fastforce dest: ready_qs_runnable_cross
+
+method add_valid_replies for rptr uses simp =
+  rule_tac Q="\<lambda>s. valid_replies'_sc_asrt rptr s" in corres_cross_add_guard,
+  fastforce elim: valid_replies_sc_cross simp: simp
+
 end

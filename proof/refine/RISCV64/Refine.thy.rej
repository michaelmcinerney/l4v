--- Refine.thy
+++ Refine.thy
@@ -190,140 +192,200 @@ lemma user_mem_relation:
   done
 
 lemma device_mem_relation:
-  "\<lbrakk>(s,s') \<in> state_relation; valid_state' s'; valid_state s\<rbrakk>
+  "\<lbrakk>(s,s') \<in> state_relation; invs' s'; valid_state s\<rbrakk>
    \<Longrightarrow> device_mem' s' = device_mem s"
-  apply (rule ext)
-  apply (clarsimp simp: device_mem_def device_mem'_def pointerInUserData_relation
-     pointerInDeviceData_relation)
-  done
+  unfolding device_mem_def device_mem'_def
+  by (rule ext) (clarsimp simp: pointerInUserData_relation pointerInDeviceData_relation)
 
 lemma absKState_correct:
-assumes invs: "einvs (s :: det_ext state)" and invs': "invs' s'"
-assumes rel: "(s,s') \<in> state_relation"
-shows "absKState s' = abs_state s"
+  assumes invs: "einvs (s :: det_ext state)" and invs': "invs' s'"
+  assumes rel: "(s,s') \<in> state_relation"
+  shows "absKState s' = abs_state s"
   using assms
   apply (intro state.equality, simp_all add: absKState_def abs_state_def)
-           apply (rule absHeap_correct, clarsimp+)
-           apply (clarsimp elim!: state_relationE)
-          apply (rule absCDT_correct, clarsimp+)
-         apply (rule absIsOriginalCap_correct, clarsimp+)
-        apply (simp add: state_relation_def)
-       apply (simp add: state_relation_def)
+                      apply (rule absHeap_correct; clarsimp simp: state_relation_sc_replies_relation)
+                      apply (clarsimp elim!: state_relationE)
+                     apply (rule absCDT_correct; clarsimp)
+                    apply (rule absIsOriginalCap_correct; clarsimp)
+                   apply (simp add: state_relation_def)
+                  apply (simp add: state_relation_def)
+                 apply (clarsimp simp: state_relation_def)
+                apply (simp add: state_relation_def)
+               apply (simp add: state_relation_def)
+              apply (simp add: state_relation_def)
+             apply (rule absSchedulerAction_correct, simp add: state_relation_def)
+            apply (simp add: state_relation_def)
+           apply (simp add: state_relation_def)
+          apply (simp add: state_relation_def)
+         apply (simp add: state_relation_def)
+        apply (fastforce simp: curry_def state_relation_def ready_queues_relation_def)
+       apply (simp add: state_relation_def release_queue_relation_def)
       apply (clarsimp simp:  user_mem_relation invs_def invs'_def)
       apply (simp add: state_relation_def)
      apply (rule absInterruptIRQNode_correct, simp add: state_relation_def)
     apply (rule absInterruptStates_correct, simp add: state_relation_def)
    apply (rule absArchState_correct, simp)
-  apply (rule absExst_correct, simp+)
+  apply (rule absExst_correct; simp)
   done
 
 text \<open>The top-level invariance\<close>
 
-lemma set_thread_state_sched_act:
-  "\<lbrace>(\<lambda>s. runnable state) and (\<lambda>s. P (scheduler_action s))\<rbrace>
-  set_thread_state thread state
-  \<lbrace>\<lambda>rs s. P (scheduler_action (s::det_state))\<rbrace>"
-  apply (simp add: set_thread_state_def)
-  apply wp
-    apply (simp add: set_thread_state_ext_def)
-    apply wp
-       apply (rule hoare_pre_cont)
-      apply (rule_tac Q="\<lambda>rv. (\<lambda>s. runnable ts) and (\<lambda>s. P (scheduler_action s))"
-              in hoare_strengthen_post)
-       apply wp
-      apply force
-     apply (wp gts_st_tcb_at)+
-     apply (rule_tac Q="\<lambda>rv. st_tcb_at ((=) state) thread and (\<lambda>s. runnable state) and (\<lambda>s. P (scheduler_action s))" in hoare_strengthen_post)
-     apply (simp add: st_tcb_at_def)
-     apply (wp obj_set_prop_at)+
-    apply (force simp: st_tcb_at_def obj_at_def)
-  apply wp
-  apply clarsimp
+lemma kernel_entry_invs_det_ext:
+  "\<lbrace>\<lambda>s. invs s \<and> schact_is_rct s \<and> cur_sc_active s \<and> ct_not_in_release_q s
+          \<and> (e \<noteq> Interrupt \<longrightarrow> ct_running s)\<rbrace>
+   kernel_entry e us
+   \<lbrace>\<lambda>_ s :: det_state. invs s \<and> (ct_running s \<or> ct_idle s)\<rbrace>"
+  apply (simp add: kernel_entry_def)
+  apply (wp akernel_invs_det_ext thread_set_invs_trivial thread_set_ct_in_state select_wp
+            static_imp_wp hoare_vcg_disj_lift hoare_vcg_imp_lift'
+         | clarsimp simp add: tcb_cap_cases_def)+
   done
 
-lemma activate_thread_sched_act:
-  "\<lbrace>ct_in_state activatable and (\<lambda>s. P (scheduler_action s))\<rbrace>
-  activate_thread
-  \<lbrace>\<lambda>rs s. P (scheduler_action (s::det_state))\<rbrace>"
-  by (simp add: activate_thread_def set_thread_state_def arch_activate_idle_thread_def
-      | (wp set_thread_state_sched_act gts_wp)+ | wpc)+
-
-lemma schedule_sched_act_rct[wp]:
-  "\<lbrace>\<top>\<rbrace> Schedule_A.schedule
-  \<lbrace>\<lambda>rs (s::det_state). scheduler_action s = resume_cur_thread\<rbrace>"
-  unfolding Schedule_A.schedule_def
-  by (wpsimp)
-
-lemma call_kernel_sched_act_rct[wp]:
-  "\<lbrace>einvs and (\<lambda>s. e \<noteq> Interrupt \<longrightarrow> ct_running s)
-     and (\<lambda>s. scheduler_action s = resume_cur_thread)\<rbrace>
-  call_kernel e
-  \<lbrace>\<lambda>rs (s::det_state). scheduler_action s = resume_cur_thread\<rbrace>"
-  apply (simp add: call_kernel_def)
-  apply (wp activate_thread_sched_act | simp)+
-  apply (clarsimp simp: active_from_running)
+lemma kernel_entry_valid_sched:
+  "\<lbrace>\<lambda>s. valid_sched s \<and> invs s \<and> schact_is_rct s
+        \<and> cur_sc_active s \<and> ct_not_in_release_q s
+        \<and> (ct_running s \<or> ct_idle s) \<and> (e \<noteq> Interrupt \<longrightarrow> ct_running s)
+        \<and> valid_machine_time s \<and> current_time_bounded 5 s \<and> consumed_time_bounded s
+        \<and> cur_sc_offset_ready (consumed_time s) s
+        \<and> cur_sc_offset_sufficient (consumed_time s) s\<rbrace>
+   kernel_entry e us
+   \<lbrace>\<lambda>_. valid_sched :: det_state \<Rightarrow> _\<rbrace>"
+  apply (simp add: kernel_entry_def)
+  apply (wp call_kernel_valid_sched thread_set_invs_trivial thread_set_ct_in_state
+            static_imp_wp hoare_vcg_disj_lift thread_set_not_state_valid_sched
+         | clarsimp simp add: tcb_cap_cases_def)+
   done
 
+abbreviation (input) mcs_invs where
+  "mcs_invs s \<equiv> einvs s
+                 \<and> scheduler_action s = resume_cur_thread
+                 \<and> cur_sc_active s \<and> ct_not_in_release_q s
+                 \<and> valid_machine_time s \<and> current_time_bounded 5 s \<and> consumed_time_bounded s
+                 \<and> (cur_sc_offset_ready (consumed_time s) s
+                    \<and> cur_sc_offset_sufficient (consumed_time s) s)
+                 \<and> valid_domain_list s "
+
 lemma kernel_entry_invs:
-  "\<lbrace>einvs and (\<lambda>s. e \<noteq> Interrupt \<longrightarrow> ct_running s)
-    and (\<lambda>s. 0 < domain_time s) and valid_domain_list and (ct_running or ct_idle)
-    and (\<lambda>s. scheduler_action s = resume_cur_thread)\<rbrace>
-  kernel_entry e us
-  \<lbrace>\<lambda>rv. einvs and (\<lambda>s. ct_running s \<or> ct_idle s)
-    and (\<lambda>s. 0 < domain_time s) and valid_domain_list
-    and (\<lambda>s. scheduler_action s = resume_cur_thread)\<rbrace>"
-  apply (rule_tac Q="\<lambda>rv. invs and (\<lambda>s. ct_running s \<or> ct_idle s) and valid_sched and
-                           (\<lambda>s. 0 < domain_time s) and valid_domain_list and
-                           valid_list and (\<lambda>s. scheduler_action s = resume_cur_thread)"
+  "\<lbrace>\<lambda>s. mcs_invs s \<and> (ct_running s \<or> ct_idle s) \<and> (e \<noteq> Interrupt \<longrightarrow> ct_running s)\<rbrace>
+   kernel_entry e us
+   \<lbrace>\<lambda>_ s. mcs_invs s \<and> (ct_running s \<or> ct_idle s)\<rbrace>"
+  apply (rule_tac Q="\<lambda>_ s. (invs s \<and> (ct_running s \<or> ct_idle s))
+                           \<and> (cur_sc_offset_ready (consumed_time s) s
+                              \<and> cur_sc_offset_sufficient (consumed_time s) s)
+                           \<and> valid_sched s
+                           \<and> valid_domain_list s
+                           \<and> valid_list s \<and> scheduler_action s = resume_cur_thread
+                           \<and> cur_sc_active s \<and> ct_not_in_release_q s
+                           \<and> valid_machine_time s \<and> current_time_bounded 5 s
+                           \<and> consumed_time_bounded s"
             in hoare_post_imp)
    apply clarsimp
-  apply (simp add: kernel_entry_def)
-  apply (wp akernel_invs_det_ext call_kernel_valid_sched thread_set_invs_trivial
-            thread_set_ct_running thread_set_not_state_valid_sched
-            hoare_vcg_disj_lift ct_in_state_thread_state_lift thread_set_no_change_tcb_state
-            call_kernel_domain_time_inv_det_ext call_kernel_domain_list_inv_det_ext
-            static_imp_wp
-      | clarsimp simp add: tcb_cap_cases_def active_from_running)+
+  apply (rule hoare_vcg_conj_lift_pre_fix)
+   apply (wpsimp wp: kernel_entry_invs_det_ext)
+  apply (rule hoare_vcg_conj_lift_pre_fix)
+   apply (clarsimp simp: kernel_entry_def)
+   apply (wp thread_set_invs_trivial thread_set_not_state_valid_sched hoare_vcg_disj_lift
+             ct_in_state_thread_state_lift thread_set_no_change_tcb_state
+             static_imp_wp call_kernel_cur_sc_offset_ready_and_sufficient
+          | clarsimp simp: tcb_cap_cases_def)+
+  apply (rule hoare_vcg_conj_lift_pre_fix)
+   apply (wpsimp wp: kernel_entry_valid_sched)
+  apply (rule hoare_vcg_conj_lift_pre_fix)
+   apply (clarsimp simp: kernel_entry_def)
+   apply (wpsimp wp: call_kernel_domain_list_inv_det_ext | clarsimp simp: active_from_running)+
+  apply (rule hoare_vcg_conj_lift_pre_fix)
+   apply (clarsimp simp: kernel_entry_def)
+   apply wpsimp
+  apply (rule hoare_vcg_conj_lift_pre_fix)
+   apply (clarsimp simp: kernel_entry_def)
+   apply (wp thread_set_invs_trivial thread_set_not_state_valid_sched hoare_vcg_disj_lift
+             ct_in_state_thread_state_lift thread_set_no_change_tcb_state static_imp_wp
+             call_kernel_schact_is_rct[unfolded schact_is_rct_def]
+          | clarsimp simp: tcb_cap_cases_def)+
+  apply (rule hoare_vcg_conj_lift_pre_fix)
+   apply (clarsimp simp: kernel_entry_def)
+   apply (wp thread_set_invs_trivial thread_set_not_state_valid_sched hoare_vcg_disj_lift
+             ct_in_state_thread_state_lift thread_set_no_change_tcb_state static_imp_wp
+             call_kernel_cur_sc_active
+          | clarsimp simp: tcb_cap_cases_def)+
+  apply (rule hoare_vcg_conj_lift_pre_fix)
+   apply (clarsimp simp: kernel_entry_def)
+   apply (wp thread_set_invs_trivial thread_set_not_state_valid_sched hoare_vcg_disj_lift
+             ct_in_state_thread_state_lift thread_set_no_change_tcb_state
+             static_imp_wp call_kernel_ct_not_in_release_q
+          | clarsimp simp: tcb_cap_cases_def)+
+  apply (rule hoare_vcg_conj_lift_pre_fix)
+   apply (clarsimp simp: kernel_entry_def)
+   apply wpsimp
+  apply (rule hoare_vcg_conj_lift_pre_fix)
+   apply (clarsimp simp: kernel_entry_def)
+   apply (wpsimp wp: call_kernel_current_time_bounded_5)
+  apply (clarsimp simp: kernel_entry_def)
+  apply (wpsimp wp: call_kernel_consumed_time_bounded)
   done
 
 definition
-  "full_invs \<equiv> {((tc, s :: det_ext state), m, e). einvs s \<and>
-                                 (ct_running s \<or> ct_idle s) \<and>
-                                 (m = KernelMode \<longrightarrow> e \<noteq> None) \<and>
-                                 (m = UserMode \<longrightarrow> ct_running s) \<and>
-                                 (m = IdleMode \<longrightarrow> ct_idle s) \<and>
-                                 (e \<noteq> None \<and> e \<noteq> Some Interrupt \<longrightarrow> ct_running s) \<and>
-                                 0 < domain_time s \<and> valid_domain_list s \<and>
-                                 (scheduler_action s = resume_cur_thread)}"
+  "full_invs
+     \<equiv> {((tc, s :: det_ext state), m, e). mcs_invs s
+                                          \<and> (ct_running s \<or> ct_idle s)
+                                          \<and> (m = KernelMode \<longrightarrow> e \<noteq> None)
+                                          \<and> (m = UserMode \<longrightarrow> ct_running s)
+                                          \<and> (m = IdleMode \<longrightarrow> ct_idle s)
+                                          \<and> (e \<noteq> None \<and> e \<noteq> Some Interrupt \<longrightarrow> ct_running s)}"
+
+crunches do_user_op, check_active_irq
+  for valid_list[wp]: valid_list
+  and valid_sched[wp]: valid_sched
+  and sched_act[wp]: "\<lambda>s. P (scheduler_action s)"
+  and domain_time[wp]: "\<lambda>s. P (domain_time s)"
+  and cur_sc_active[wp]: cur_sc_active
+  and ct_not_in_release_q[wp]: ct_not_in_release_q
+  and current_time_bounded[wp]: "current_time_bounded 5"
+  and cur_sc_offset_ready[wp]: "\<lambda>s. cur_sc_offset_ready (consumed_time s) s"
+  and cur_sc_offset_sufficient[wp]: "\<lambda>s. cur_sc_offset_sufficient (consumed_time s) s"
+  and consumed_time_bounded[wp]: consumed_time_bounded
+  (wp: select_wp)
+
+lemma device_update_valid_machine_time[wp]:
+  "do_machine_op (device_memory_update ds) \<lbrace>valid_machine_time\<rbrace>"
+  apply (simp add: do_machine_op_def device_memory_update_def simpler_modify_def select_f_def
+                   gets_def get_def bind_def valid_def return_def)
+  done
 
-lemma do_user_op_valid_list:"\<lbrace>valid_list\<rbrace> do_user_op f tc \<lbrace>\<lambda>_. valid_list\<rbrace>"
-  unfolding do_user_op_def
-  apply (wp select_wp | simp add: split_def)+
+lemma user_memory_update_valid_machine_time[wp]:
+  "do_machine_op (user_memory_update ds) \<lbrace>valid_machine_time\<rbrace>"
+  apply (simp add: do_machine_op_def user_memory_update_def simpler_modify_def select_f_def
+                   gets_def get_def bind_def valid_def return_def)
   done
 
-lemma do_user_op_valid_sched:"\<lbrace>valid_sched\<rbrace> do_user_op f tc \<lbrace>\<lambda>_. valid_sched\<rbrace>"
-  unfolding do_user_op_def
-  apply (wp select_wp | simp add: split_def)+
+lemma do_user_op_valid_machine_time[wp]:
+  "do_user_op f tc \<lbrace>valid_machine_time\<rbrace>"
+  apply (simp add: do_user_op_def)
+  apply (wpsimp wp: select_wp)
   done
 
-lemma do_user_op_sched_act:
-  "\<lbrace>\<lambda>s. P (scheduler_action s)\<rbrace> do_user_op f tc \<lbrace>\<lambda>_ s. P (scheduler_action s)\<rbrace>"
-  unfolding do_user_op_def
-  apply (wp select_wp | simp add: split_def)+
+lemma check_active_irq_valid_machine_time[wp]:
+  "check_active_irq \<lbrace>valid_machine_time\<rbrace>"
+  apply (clarsimp simp: check_active_irq_def)
+  apply (wpsimp wp: getActiveIRQ_inv)
   done
 
 lemma do_user_op_invs2:
-  "\<lbrace>einvs  and ct_running and (\<lambda>s. scheduler_action s = resume_cur_thread)
-    and (\<lambda>s. 0 < domain_time s) and valid_domain_list \<rbrace>
-  do_user_op f tc
-   \<lbrace>\<lambda>_. (einvs  and ct_running and (\<lambda>s. scheduler_action s = resume_cur_thread))
-        and (\<lambda>s. 0 < domain_time s) and valid_domain_list \<rbrace>"
-  apply (rule_tac Q="\<lambda>_. valid_list and valid_sched and
-   (\<lambda>s. scheduler_action s = resume_cur_thread) and (invs and ct_running) and
-   (\<lambda>s. 0 < domain_time s) and valid_domain_list"
-   in hoare_strengthen_post)
-  apply (wp do_user_op_valid_list do_user_op_valid_sched do_user_op_sched_act
-    do_user_op_invs | simp | force)+
+  "do_user_op f tc
+   \<lbrace>\<lambda>s. mcs_invs s \<and> ct_running s\<rbrace>"
+  apply (rule_tac Q="\<lambda>_ s. (invs s \<and> ct_running s) \<and> valid_list s \<and> valid_sched s
+                           \<and> scheduler_action s = resume_cur_thread
+                           \<and> valid_domain_list s
+                           \<and> cur_sc_active s \<and> ct_not_in_release_q s
+                           \<and> valid_machine_time s \<and> current_time_bounded 5 s
+                           \<and> consumed_time_bounded s
+                           \<and> cur_sc_offset_ready (consumed_time s) s
+                           \<and> cur_sc_offset_sufficient (consumed_time s) s"
+               in hoare_post_imp, fastforce)
+  apply (rule hoare_vcg_conj_lift_pre_fix)
+   apply (wpsimp wp: do_user_op_invs[simplified pred_conj_def])
+  apply (wp do_user_op_valid_list do_user_op_valid_sched do_user_op_sched_act do_user_op_domain_time
+         | fastforce)+
   done
 
 lemmas ext_init_def = ext_init_det_ext_ext_def ext_init_unit_def
@@ -337,16 +399,68 @@ lemmas valid_list_inits[simp] = valid_list_init[simplified]
 lemma valid_sched_init[simp]:
   "valid_sched init_A_st"
   apply (simp add: valid_sched_def init_A_st_def ext_init_def)
-  apply (clarsimp simp: valid_etcbs_def init_kheap_def st_tcb_at_kh_def obj_at_kh_def
-                    obj_at_def is_etcb_at_def idle_thread_ptr_def init_globals_frame_def
-                    init_global_pd_def valid_queues_2_def ct_not_in_q_def not_queued_def
-                    valid_sched_action_def is_activatable_def
-                    ct_in_cur_domain_2_def valid_blocked_2_def valid_idle_etcb_def etcb_at'_def default_etcb_def)
-  done
+  apply (insert getCurrentTime_buffer_bound MIN_BUDGET_le_MAX_PERIOD')
+  apply (clarsimp simp: init_kheap_def obj_at_def idle_thread_ptr_def init_globals_frame_def
+                        init_global_pd_def ct_not_in_q_def valid_sched_action_def is_activatable_def
+                        ct_in_cur_domain_2_def valid_idle_etcb_def etcb_at'_def
+                        valid_ready_qs_def ready_or_release_2_def in_queues_2_def
+                        idle_sc_ptr_def valid_blocked_defs default_domain_def minBound_word
+                        released_ipc_queues_defs active_reply_scs_def active_if_reply_sc_at_def
+                        active_sc_def MIN_REFILLS_def)
+  by (auto simp: vs_all_heap_simps active_sc_valid_refills_def cfg_valid_refills_def
+                 rr_valid_refills_def MIN_REFILLS_def bounded_release_time_def
+                 default_sched_context_def MAX_PERIOD_def
+          intro: order_trans[OF mult_left_mono, OF us_to_ticks_helper])
 
 lemma valid_domain_list_init[simp]:
   "valid_domain_list init_A_st"
-  by (simp add: init_A_st_def ext_init_def valid_domain_list_def)
+  apply (insert domain_time_pos)
+  apply (simp add: init_A_st_def ext_init_def valid_domain_list_def)
+  done
+
+lemma cur_sc_active_init[simp]:
+  "cur_sc_active init_A_st"
+  apply (clarsimp simp: init_A_st_def init_kheap_def vs_all_heap_simps active_sc_def MIN_REFILLS_def)
+  done
+
+lemma ct_not_in_release_q_init[simp]:
+  "ct_not_in_release_q init_A_st"
+  apply (clarsimp simp: init_A_st_def init_kheap_def not_in_release_q_def in_queue_2_def)
+  done
+
+lemma valid_machine_time_init[simp]:
+  "valid_machine_time init_A_st"
+  apply (clarsimp simp: init_A_st_def valid_machine_time_def init_machine_state_def)
+  done
+
+lemma current_time_bounded_init[simp]:
+  "current_time_bounded 5 init_A_st"
+  apply (insert getCurrentTime_buffer_no_overflow)
+  apply (clarsimp simp: current_time_bounded_def init_A_st_def)
+  done
+
+lemma consumed_time_bounded_init[simp]:
+  "consumed_time_bounded init_A_st"
+  apply (clarsimp simp: init_kheap_def init_A_st_def)
+  done
+
+lemma cur_sc_offset_ready_and_sufficient[simp]:
+  "cur_sc_offset_ready (consumed_time init_A_st) init_A_st
+   \<and> cur_sc_offset_sufficient (consumed_time init_A_st) init_A_st"
+  apply (clarsimp simp: init_A_st_def)
+  done
+
+lemma check_active_irq_invs:
+  "check_active_irq \<lbrace>\<lambda>s. mcs_invs s \<and> (ct_running s \<or> ct_idle s)\<rbrace>"
+  by (wpsimp simp: check_active_irq_def ct_in_state_def)
+
+lemma check_active_irq_invs_just_running:
+  "check_active_irq \<lbrace>\<lambda>s. mcs_invs s \<and> ct_running s\<rbrace>"
+  by (wpsimp simp: check_active_irq_def ct_in_state_def)
+
+lemma check_active_irq_invs_just_idle:
+  "check_active_irq \<lbrace>\<lambda>s. mcs_invs s \<and> ct_idle s\<rbrace>"
+  by (wpsimp simp: check_active_irq_def ct_in_state_def)
 
 lemma akernel_invariant:
   "ADT_A uop \<Turnstile> full_invs"
@@ -357,44 +471,54 @@ lemma akernel_invariant:
    apply (simp add: Let_def Init_A_def)
    apply (simp add: init_A_st_def ext_init_def)
   apply (clarsimp simp: ADT_A_def global_automaton_def)
-
   apply (rename_tac tc' s' mode' e' tc s mode e)
   apply (elim disjE)
              apply ((clarsimp simp: kernel_call_A_def
-                   | drule use_valid[OF _ kernel_entry_invs])+)[2]
+                    | drule use_valid[OF _ kernel_entry_invs])+)[2]
            apply ((clarsimp simp: do_user_op_A_def monad_to_transition_def
                                   check_active_irq_A_def
-                 | drule use_valid[OF _ do_user_op_invs2]
-                 | drule use_valid[OF _ check_active_irq_invs_just_running])+)[2]
+                  | drule use_valid[OF _ do_user_op_invs2]
+                  | drule use_valid[OF _ check_active_irq_invs_just_running]
+                  | drule use_valid[OF _ do_user_op_cur_sc_active])+)[2]
          apply ((clarsimp simp add: check_active_irq_A_def
-               | drule use_valid[OF _ check_active_irq_invs])+)[1]
+                | drule use_valid[OF _ check_active_irq_invs])+)[1]
         apply (clarsimp simp: ct_in_state_def st_tcb_at_def obj_at_def)
        apply ((clarsimp simp add: do_user_op_A_def check_active_irq_A_def
-             | drule use_valid[OF _ do_user_op_invs2]
-             | drule use_valid[OF _ check_active_irq_invs_just_running])+)[1]
+              | drule use_valid[OF _ do_user_op_invs2]
+              | drule use_valid[OF _ check_active_irq_invs_just_running])+)[1]
       apply (clarsimp simp: ct_in_state_def st_tcb_at_def obj_at_def)
      apply (clarsimp simp: ct_in_state_def st_tcb_at_def obj_at_def)
     apply ((clarsimp simp add: check_active_irq_A_def
-         | drule use_valid[OF _ check_active_irq_invs])+)[1]
+           | drule use_valid[OF _ check_active_irq_invs])+)[1]
    apply ((clarsimp simp add: check_active_irq_A_def
-        | drule use_valid[OF _ check_active_irq_invs_just_idle])+)[1]
+          | drule use_valid[OF _ check_active_irq_invs_just_idle])+)[1]
   apply ((clarsimp simp add: check_active_irq_A_def
-        | drule use_valid[OF _ check_active_irq_invs])+)[1]
+         | drule use_valid[OF _ check_active_irq_invs])+)[1]
   done
 
 lemma ckernel_invs:
-  "\<lbrace>invs' and (\<lambda>s. vs_valid_duplicates' (ksPSpace s)) and
-               (\<lambda>s. e \<noteq> Interrupt \<longrightarrow> ct_running' s) and
-               (\<lambda>s. ksSchedulerAction s = ResumeCurrentThread)\<rbrace>
-  callKernel e
-  \<lbrace>\<lambda>rs. (\<lambda>s. ksSchedulerAction s = ResumeCurrentThread)
-    and (invs' and (ct_running' or ct_idle'))\<rbrace>"
-  apply (simp add: callKernel_def)
+  "\<lbrace>invs' and (\<lambda>s. vs_valid_duplicates' (ksPSpace s))
+    and (\<lambda>s. e \<noteq> Interrupt \<longrightarrow> ct_running' s) and (ct_running' or ct_idle')
+    and (\<lambda>s. is_active_sc' (ksCurSc s) s) and sym_heap_tcbSCs
+    and (\<lambda>s. obj_at' (\<lambda>sc. scTCB sc = Some (ksCurThread s)) (ksCurSc s) s)
+    and (\<lambda>s. pred_map (\<lambda>tcb. \<not> tcbInReleaseQueue tcb) (tcbs_of' s) (ksCurThread s))
+    and (\<lambda>s. ksSchedulerAction s = ResumeCurrentThread)\<rbrace>
+   callKernel e
+   \<lbrace>\<lambda>_. invs'\<rbrace>"
+  apply (simp add: callKernel_def mcsPreemptionPoint_def)
   apply (rule hoare_pre)
-   apply (wp activate_invs' activate_sch_act schedule_sch
-             schedule_sch_act_simple he_invs' schedule_invs'
-             hoare_drop_imp[where R="\<lambda>_. kernelExitAssertions"]
-          | simp add: no_irq_getActiveIRQ)+
+   apply (wpsimp wp: hoare_drop_imp[where R="\<lambda>_. kernelExitAssertions"] activate_invs')
+     apply (rule hoare_drop_imp)
+     apply (wpsimp wp: schedule_invs')
+    apply (wpsimp wp: stateAssert_wp)
+   apply (wpsimp wp: isSchedulable_wp hoare_drop_imp)
+    apply (intro iffI; clarsimp simp: isScActive_def isSchedulable_bool_def)
+   apply (rule hoare_post_impErr[where E="\<lambda>_. invs'" and Q=Q and R=Q for Q])
+     apply wpsimp
+    apply (clarsimp simp: active_from_running')+
+  apply (clarsimp simp: sym_heap_def pred_map_def)
+  apply (rule_tac x="ksCurSc s" in exI)
+  apply (clarsimp simp: obj_at_simps is_active_sc'_def isScActive_def opt_map_red pred_map_def)
   done
 
 (* abstract and haskell have identical domain list fields *)
@@ -404,52 +528,59 @@ abbreviation valid_domain_list' :: "'a kernel_state_scheme \<Rightarrow> bool" w
 lemmas valid_domain_list'_def = valid_domain_list_2_def
 
 defs kernelExitAssertions_def:
-  "kernelExitAssertions s \<equiv> 0 < ksDomainTime s \<and> valid_domain_list' s"
+  "kernelExitAssertions s \<equiv> valid_domain_list' s"
 
 lemma callKernel_domain_time_left:
-  "\<lbrace> \<top> \<rbrace> callKernel e \<lbrace>\<lambda>_ s. 0 < ksDomainTime s \<and> valid_domain_list' s \<rbrace>"
+  "\<lbrace> \<top> \<rbrace> callKernel e \<lbrace>\<lambda>_ s. valid_domain_list' s \<rbrace>"
   unfolding callKernel_def kernelExitAssertions_def by wpsimp
 
+lemma threadSet_is_active_sc'[wp]:
+  "threadSet f tp \<lbrace>\<lambda>s. is_active_sc' scp s\<rbrace>"
+  by (wpsimp simp: is_active_sc'_def)
+
+lemma threadSet_sym_heap_tcbSCs:
+  "\<forall>x. tcbSchedContext (f x) = tcbSchedContext x \<Longrightarrow>
+  threadSet f t \<lbrace>\<lambda>s. P (tcbSCs_of s) (scTCBs_of s)\<rbrace>"
+  unfolding threadSet_def
+  apply (rule hoare_seq_ext[OF _ get_tcb_sp'])
+  apply (wpsimp wp: setObject_tcb_tcbs_of' | wps)+
+  apply (prop_tac "((\<lambda>a. if a = t then Some (f tcb) else tcbs_of' s a) |>
+              tcbSchedContext) = tcbSCs_of s")
+   apply (rule ext)
+   apply (clarsimp simp: obj_at'_def projectKOs opt_map_def)
+  apply simp
+  done
+
 lemma kernelEntry_invs':
-  "\<lbrace> invs' and (\<lambda>s. e \<noteq> Interrupt \<longrightarrow> ct_running' s) and
-           (ct_running' or ct_idle') and
-           (\<lambda>s. vs_valid_duplicates' (ksPSpace s)) and
-           (\<lambda>s. ksSchedulerAction s = ResumeCurrentThread) and
-           (\<lambda>s. 0 < ksDomainTime s) and valid_domain_list' \<rbrace>
+  "\<lbrace> invs' and (\<lambda>s. e \<noteq> Interrupt \<longrightarrow> ct_running' s)
+    and (ct_running' or ct_idle')
+    and (\<lambda>s. vs_valid_duplicates' (ksPSpace s))
+    and (\<lambda>s. is_active_sc' (ksCurSc s) s) and sym_heap_tcbSCs
+    and (\<lambda>s. obj_at' (\<lambda>sc. scTCB sc = Some (ksCurThread s)) (ksCurSc s) s)
+    and (\<lambda>s. pred_map (\<lambda>tcb. \<not> tcbInReleaseQueue tcb) (tcbs_of' s) (ksCurThread s))
+    and (\<lambda>s. ksSchedulerAction s = ResumeCurrentThread)
+    and valid_domain_list' \<rbrace>
   kernelEntry e tc
-  \<lbrace>\<lambda>rs. (\<lambda>s. ksSchedulerAction s = ResumeCurrentThread) and
-         (invs' and (ct_running' or ct_idle')) and
-         (\<lambda>s. vs_valid_duplicates' (ksPSpace s)) and
-         (\<lambda>s. 0 < ksDomainTime s) and valid_domain_list' \<rbrace>"
+  \<lbrace>\<lambda>_. invs' and (\<lambda>s. vs_valid_duplicates' (ksPSpace s))\<rbrace>"
+  apply (rule_tac R1="\<lambda>s. obj_at' (\<lambda>tcb. tcbSchedContext tcb = Some (ksCurSc s)) (ksCurThread s) s"
+         in hoare_pre_add[THEN iffD2])
+   apply (clarsimp simp: obj_at'_tcb_scs_of_equiv obj_at'_sc_tcbs_of_equiv sym_heap_def)
+   apply (fastforce simp: ct_in_state'_def pred_tcb_at'_def obj_at'_def)
   apply (simp add: kernelEntry_def)
-  apply (wp ckernel_invs callKernel_valid_duplicates' callKernel_domain_time_left
-            threadSet_invs_trivial threadSet_ct_running' select_wp
-            TcbAcc_R.dmo_invs' static_imp_wp
-            callKernel_domain_time_left
-         | clarsimp simp: user_memory_update_def no_irq_def tcb_at_invs'
-                          valid_domain_list'_def)+
+  apply (wpsimp wp: ckernel_invs callKernel_valid_duplicates' threadSet_invs_trivial
+                    threadSet_ct_in_state' static_imp_wp hoare_vcg_disj_lift threadSet_sym_heap_tcbSCs
+         | wps)+
+    apply (rule hoare_vcg_conj_lift)
+     apply (wpsimp wp: threadSet_wp)
+    apply (wpsimp wp: threadSet_invs_trivial; simp?)
+    apply (wpsimp wp: threadSet_ct_running' static_imp_wp)+
+  apply (fastforce simp: obj_at'_def projectKOs  pred_map_def opt_map_red)
   done
 
 lemma absKState_correct':
   "\<lbrakk>einvs s; invs' s'; (s,s') \<in> state_relation\<rbrakk>
    \<Longrightarrow> absKState s' = abs_state s"
-  apply (intro state.equality, simp_all add: absKState_def abs_state_def)
-           apply (rule absHeap_correct)
-               apply (clarsimp simp: valid_state_def valid_pspace_def)+
-           apply (clarsimp dest!: state_relationD)
-          apply (rule absCDT_correct)
-                apply (clarsimp simp: valid_state_def valid_pspace_def
-                                      valid_state'_def valid_pspace'_def)+
-         apply (rule absIsOriginalCap_correct, clarsimp+)
-        apply (simp add: state_relation_def)
-       apply (simp add: state_relation_def)
-      apply (clarsimp simp: user_mem_relation invs_def invs'_def)
-      apply (simp add: state_relation_def)
-     apply (rule absInterruptIRQNode_correct, simp add: state_relation_def)
-    apply (rule absInterruptStates_correct, simp add: state_relation_def)
-   apply (erule absArchState_correct)
-  apply (rule absExst_correct, simp, assumption+)
-  done
+  by (rule absKState_correct)
 
 lemma ptable_lift_abs_state[simp]:
   "ptable_lift t (abs_state s) = ptable_lift t s"
@@ -883,43 +1279,49 @@ lemma device_mem_corres:
                          invs_def invs'_def
                          corres_underlying_def device_mem_relation)
 
+crunch domain_time_inv[wp]: thread_set "\<lambda>s. P (domain_time s)"
+
 lemma entry_corres:
-  "corres (=) (einvs and (\<lambda>s. event \<noteq> Interrupt \<longrightarrow> ct_running s) and
-                  (\<lambda>s. 0 < domain_time s) and valid_domain_list and (ct_running or ct_idle) and
-                  (\<lambda>s. scheduler_action s = resume_cur_thread))
-                 (invs' and (\<lambda>s. event \<noteq> Interrupt \<longrightarrow> ct_running' s) and
-                  (\<lambda>s. 0 < ksDomainTime s) and valid_domain_list' and (ct_running' or ct_idle') and
-                  (\<lambda>s. ksSchedulerAction s = ResumeCurrentThread) and
-                  (\<lambda>s. vs_valid_duplicates' (ksPSpace s)))
-          (kernel_entry event tc) (kernelEntry event tc)"
+  "corres (=)
+      (\<lambda>s. mcs_invs s \<and> (ct_running s \<or> ct_idle s) \<and> (event \<noteq> Interrupt \<longrightarrow> ct_running s))
+      (invs' and (\<lambda>s. event \<noteq> Interrupt \<longrightarrow> ct_running' s) and (ct_running' or ct_idle')
+       and valid_domain_list'
+       and (\<lambda>s. ksSchedulerAction s = ResumeCurrentThread)
+       and (\<lambda>s. vs_valid_duplicates' (ksPSpace s)))
+      (kernel_entry event tc) (kernelEntry event tc)"
   apply (simp add: kernel_entry_def kernelEntry_def)
+  apply add_cur_tcb'
   apply (rule corres_guard_imp)
     apply (rule corres_split_deprecated [OF _ getCurThread_corres])
-      apply (rule corres_split_deprecated)
-         prefer 2
+      apply (rule corres_split)
          apply simp
          apply (rule threadset_corresT)
-            apply (simp add: tcb_relation_def arch_tcb_relation_def
-                             arch_tcb_context_set_def atcbContextSet_def)
-           apply (clarsimp simp: tcb_cap_cases_def)
-          apply (clarsimp simp: tcb_cte_cases_def)
-         apply (simp add: exst_same_def)
-        apply (rule corres_split_deprecated [OF _ kernel_corres])
-          apply (rule corres_split_eqr [OF _ getCurThread_corres])
-            apply (rule threadGet_corres)
-            apply (simp add: tcb_relation_def arch_tcb_relation_def
-                             arch_tcb_context_get_def atcbContextGet_def)
-           apply wp+
+           apply (simp add: tcb_relation_def arch_tcb_relation_def
+                            arch_tcb_context_set_def atcbContextSet_def)
+          apply (clarsimp simp: tcb_cap_cases_def)
+         apply (clarsimp simp: tcb_cte_cases_def)
+        apply (rule corres_split [OF kernel_corres])
+          apply (rule_tac P=invs and P'=\<top> in corres_inst)
+          apply add_cur_tcb'
+          apply (rule corres_guard_imp)
+            apply (rule corres_split_eqr [OF _ getCurThread_corres])
+              apply (rule threadGet_corres)
+              apply (simp add: tcb_relation_def arch_tcb_relation_def
+                               arch_tcb_context_get_def atcbContextGet_def)
+             apply wp+
+           apply clarsimp
+          apply (clarsimp simp: cur_tcb'_def)
          apply (rule hoare_strengthen_post, rule akernel_invs_det_ext, simp add: invs_def cur_tcb_def)
-        apply (rule hoare_strengthen_post, rule ckernel_invs, simp add: invs'_def cur_tcb'_def)
-       apply (wp thread_set_invs_trivial thread_set_ct_running
+        apply wpsimp
+       apply (wp thread_set_invs_trivial
                  threadSet_invs_trivial threadSet_ct_running'
                  select_wp thread_set_not_state_valid_sched static_imp_wp
                  hoare_vcg_disj_lift ct_in_state_thread_state_lift
               | simp add: tcb_cap_cases_def ct_in_state'_def thread_set_no_change_tcb_state
               | (wps, wp threadSet_st_tcb_at2) )+
    apply (clarsimp simp: invs_def cur_tcb_def)
-  apply (clarsimp simp: ct_in_state'_def)
+  apply (clarsimp simp: ct_in_state'_def cur_tcb'_def invs'_def valid_release_queue'_def
+                        projectKOs obj_at'_def)
   done
 
 lemma corres_gets_machine_state:
@@ -986,25 +1387,22 @@ lemma ct_idle_related:
   done
 
 definition
-  "full_invs' \<equiv> {((tc,s),m,e). invs' s \<and> vs_valid_duplicates' (ksPSpace s) \<and>
-                          ex_abs (einvs::det_ext state \<Rightarrow> bool) s \<and>
-                          ksSchedulerAction s = ResumeCurrentThread \<and>
-                          (ct_running' s \<or> ct_idle' s) \<and>
-                          (m = KernelMode \<longrightarrow> e \<noteq> None) \<and>
-                          (m = UserMode \<longrightarrow> ct_running' s) \<and>
-                          (m = IdleMode \<longrightarrow> ct_idle' s) \<and>
-                          (e \<noteq> None \<and> e \<noteq> Some Interrupt \<longrightarrow> ct_running' s) \<and>
-                          0 < ksDomainTime s \<and> valid_domain_list' s}"
+  "full_invs'
+     \<equiv> {((tc,s),m,e). invs' s \<and> vs_valid_duplicates' (ksPSpace s)
+                      \<and> ex_abs (\<lambda>s :: det_state. mcs_invs s
+                                                  \<and> (ct_running s \<or> ct_idle s)
+                                                  \<and> (e \<noteq> None \<and> e \<noteq> Some Interrupt \<longrightarrow> ct_running s)) s
+                      \<and> (m = KernelMode \<longrightarrow> e \<noteq> None)
+                      \<and> (m = UserMode \<longrightarrow> ct_running' s)
+                      \<and> (m = IdleMode \<longrightarrow> ct_idle' s)}"
 
 lemma checkActiveIRQ_valid_duplicates':
-  "\<lbrace>\<lambda>s. vs_valid_duplicates' (ksPSpace s)\<rbrace>
-   checkActiveIRQ
-   \<lbrace>\<lambda>_ s. vs_valid_duplicates' (ksPSpace s)\<rbrace>"
+  "checkActiveIRQ \<lbrace>\<lambda>s. vs_valid_duplicates' (ksPSpace s)\<rbrace>"
   apply (simp add: checkActiveIRQ_def)
   apply wp
   done
 
-lemma check_active_irq_corres':
+lemma checkActiveIRQ_corres':
   "corres (=) \<top> \<top> (check_active_irq) (checkActiveIRQ)"
   apply (simp add: check_active_irq_def checkActiveIRQ_def)
   apply (rule corres_guard_imp)
@@ -1014,48 +1412,43 @@ lemma check_active_irq_corres':
      apply (wp | simp )+
   done
 
-lemma check_active_irq_corres:
+lemma checkActiveIRQ_corres:
   "corres (=)
     (invs and (ct_running or ct_idle) and einvs and (\<lambda>s. scheduler_action s = resume_cur_thread)
-     and (\<lambda>s. 0 < domain_time s) and valid_domain_list)
-    (invs' and (\<lambda>s. ksSchedulerAction s = ResumeCurrentThread)
-      and (\<lambda>s. 0 < ksDomainTime s) and valid_domain_list' and (ct_running' or ct_idle')
-      and (\<lambda>s. vs_valid_duplicates' (ksPSpace s)))
+     and valid_domain_list)
+    (invs' and (\<lambda>s. vs_valid_duplicates' (ksPSpace s)))
     (check_active_irq) (checkActiveIRQ)"
   apply (rule corres_guard_imp)
-    apply (rule check_active_irq_corres', auto)
+    apply (rule checkActiveIRQ_corres', auto)
   done
 
 lemma checkActiveIRQ_just_running_corres:
   "corres (=)
     (invs and ct_running and einvs and (\<lambda>s. scheduler_action s = resume_cur_thread)
-      and (\<lambda>s. 0 < domain_time s) and valid_domain_list)
-    (invs' and ct_running' and (\<lambda>s. vs_valid_duplicates' (ksPSpace s))
-      and (\<lambda>s. 0 < ksDomainTime s) and valid_domain_list'
-      and (\<lambda>s. ksSchedulerAction s = ResumeCurrentThread))
+      and valid_domain_list)
+    (invs' and (\<lambda>s. vs_valid_duplicates' (ksPSpace s)))
     (check_active_irq) (checkActiveIRQ)"
   apply (rule corres_guard_imp)
-    apply (rule check_active_irq_corres', auto)
+    apply (rule checkActiveIRQ_corres', auto)
   done
 
 lemma checkActiveIRQ_just_idle_corres:
   "corres (=)
     (invs and ct_idle and einvs and (\<lambda>s. scheduler_action s = resume_cur_thread)
-      and (\<lambda>s. 0 < domain_time s)  and valid_domain_list)
+      and valid_domain_list)
     (invs' and ct_idle' and (\<lambda>s. vs_valid_duplicates' (ksPSpace s))
-      and (\<lambda>s. 0 < ksDomainTime s) and valid_domain_list'
+      and valid_domain_list'
       and (\<lambda>s. ksSchedulerAction s = ResumeCurrentThread))
     (check_active_irq) (checkActiveIRQ)"
   apply (rule corres_guard_imp)
-    apply (rule check_active_irq_corres', auto)
+    apply (rule checkActiveIRQ_corres', auto)
   done
 
 lemma checkActiveIRQ_invs':
   "\<lbrace>invs' and ex_abs invs and (ct_running' or ct_idle')
     and (\<lambda>s. ksSchedulerAction s = ResumeCurrentThread)\<rbrace>
    checkActiveIRQ
-   \<lbrace>\<lambda>_. invs' and (ct_running' or ct_idle')
-    and (\<lambda>s. ksSchedulerAction s = ResumeCurrentThread)\<rbrace>"
+   \<lbrace>\<lambda>_. invs' and (ct_running' or ct_idle') and (\<lambda>s. ksSchedulerAction s = ResumeCurrentThread)\<rbrace>"
   apply (simp add: checkActiveIRQ_def ex_abs_def)
   apply (wp dmo_invs' | simp)+
   done
@@ -1134,28 +1552,65 @@ lemma ckernel_invariant:
     apply (frule akernel_init_invs[THEN bspec])
     apply (rule_tac x = s in exI)
     apply (clarsimp simp: Init_A_def)
+
+    apply (clarsimp simp: Init_A_def init_A_st_def)
+
    apply (insert ckernel_init_invs)[1]
    apply clarsimp
    apply (frule ckernel_init_sch_norm)
    apply (frule ckernel_init_ctr)
    apply (frule ckernel_init_domain_time)
    apply (frule ckernel_init_domain_list)
+   apply (clarsimp simp: ex_abs_def)
    apply (fastforce simp: Init_H_def valid_domain_list'_def)
+
   apply (clarsimp simp: ADT_A_def ADT_H_def global_automaton_def)
 
   apply (erule_tac P="a \<and> (\<exists>x. b x)" for a b in disjE)
+   apply (clarsimp simp: ex_abs_def kernel_call_H_def)
+   apply (rename_tac uc' conc_state' uc conc_state abs_state event)
+   apply (drule use_valid[OF _ valid_corres_combined])
+       apply (rule kernel_entry_invs)
+      apply (rule corres_guard_imp)
+        apply (rule entry_corres)
+       apply force
+      apply force
+     apply (rule hoare_weaken_pre)
+      apply (rule kernelEntry_invs')
+     apply clarsimp
+     apply (rename_tac s' s; intro conjI)
+        apply (prop_tac "cur_sc s = ksCurSc s'", fastforce dest!: state_relationD)
+        apply (prop_tac "sc_at (cur_sc s) s")
+         apply (rule cur_sc_tcb_sc_at_cur_sc[OF invs_valid_objs invs_cur_sc_tcb]; simp)
+        apply (prop_tac "sc_at' (ksCurSc s') s'")
+         apply (rule sc_at_cross[OF state_relation_pspace_relation invs_psp_aligned invs_distinct]; simp)
+        apply (prop_tac "is_active_sc' (ksCurSc s') s'")
+         apply (rule is_active_sc'2_cross[OF _ invs_psp_aligned invs_distinct], simp+)
+
+       apply (clarsimp simp: invs'_def valid_pspace'_def, rule sym_refs_tcbSCs; simp?)
+       apply (clarsimp simp: invs_def valid_state_def valid_pspace_def state_refs_of_cross_eq)
+      apply (fastforce dest!: cur_sc_tcb_cross[simplified schact_is_rct_def]
+                        simp: invs_def valid_state_def valid_pspace_def)
+     apply (clarsimp simp: invs'_def valid_release_queue'_def)
+     apply (prop_tac "cur_tcb' s'")
+      apply (rule cur_tcb_cross[OF invs_cur invs_psp_aligned invs_distinct]; simp?)
+     apply (clarsimp simp: cur_tcb'_def)
+     apply (clarsimp simp: pred_map_def obj_at'_def projectKOs opt_map_red not_in_release_q_def
+                           release_queue_relation_def
+                    dest!: state_relationD)
 
-  apply (clarsimp simp: kernel_call_H_def)
+    apply clarsimp
+    apply (rule_tac x=abs_state in exI)
+    apply (intro conjI; (clarsimp; fail)?)
+      subgoal by (fastforce intro: ct_running_cross)
+     apply (rule ct_running_or_idle_cross; simp?; fastforce)
+    subgoal by (fastforce intro!: resume_cur_thread_cross)
 
-   apply (drule use_valid[OF _ valid_corres_combined
-                            [OF kernel_entry_invs entry_corres],
-                            OF _ kernelEntry_invs'[THEN hoare_weaken_pre]])
-     subgoal by fastforce
-    apply (fastforce simp: ex_abs_def sch_act_simple_def ct_running_related ct_idle_related
-                           sched_act_rct_related)
-   apply (clarsimp simp: kernel_call_H_def)
-   subgoal by (fastforce simp: ex_abs_def sch_act_simple_def ct_running_related ct_idle_related
-                              sched_act_rct_related)
+   apply clarsimp
+   apply (intro conjI impI)
+     apply metis
+    apply metis
+   apply (fastforce dest!: ct_running_or_idle_cross)
 
   apply (erule_tac P="a \<and> b" for a b in disjE)
    apply (clarsimp simp add: do_user_op_H_def monad_to_transition_def)
@@ -1165,11 +1620,13 @@ lemma ckernel_invariant:
      apply (rule valid_corres_combined[OF do_user_op_invs2 corres_guard_imp2[OF do_user_op_corres]])
       apply clarsimp
      apply (rule doUserOp_invs'[THEN hoare_weaken_pre])
-     apply (fastforce simp: ex_abs_def)
+     apply (clarsimp simp: ex_abs_def)
+     apply (rule conjI)
+      apply metis
+     apply (fastforce intro: resume_cur_thread_cross ct_running_cross)
     apply (clarsimp simp: ex_abs_def, rule_tac x=s in exI,
-            clarsimp simp: ct_running_related sched_act_rct_related)
-   apply (clarsimp simp: ex_abs_def)
-   apply (fastforce simp: ex_abs_def ct_running_related sched_act_rct_related)
+           clarsimp simp: ct_running_related sched_act_rct_related)
+   apply (fastforce simp: ex_abs_def)
 
   apply (erule_tac P="a \<and> b \<and> c \<and> (\<exists>x. d x)" for a b c d in disjE)
    apply (clarsimp simp add: do_user_op_H_def monad_to_transition_def)
@@ -1191,9 +1651,13 @@ lemma ckernel_invariant:
    apply (drule use_valid)
      apply (rule hoare_vcg_conj_lift)
       apply (rule checkActiveIRQ_valid_duplicates')
-     apply (rule valid_corres_combined[OF check_active_irq_invs_just_running checkActiveIRQ_just_running_corres])
+     apply (rule valid_corres_combined[OF check_active_irq_invs_just_running corres_guard_imp2[OF checkActiveIRQ_just_running_corres]])
+      apply clarsimp
      apply (rule checkActiveIRQ_invs'_just_running[THEN hoare_weaken_pre])
-     apply (fastforce simp: ex_abs_def)
+     apply (clarsimp simp: ex_abs_def)
+     apply (rule conjI)
+      apply blast
+     apply (fastforce intro: resume_cur_thread_cross ct_running_cross)
     apply (fastforce simp: ex_abs_def ct_running_related sched_act_rct_related)
    apply (fastforce simp: ex_abs_def)
 
@@ -1202,22 +1666,32 @@ lemma ckernel_invariant:
    apply (drule use_valid)
      apply (rule hoare_vcg_conj_lift)
       apply (rule checkActiveIRQ_valid_duplicates')
-     apply (rule valid_corres_combined[OF check_active_irq_invs_just_idle checkActiveIRQ_just_idle_corres])
+     apply (rule valid_corres_combined[OF check_active_irq_invs_just_idle corres_guard_imp2[OF checkActiveIRQ_just_idle_corres]])
+      apply clarsimp
      apply (rule checkActiveIRQ_invs'_just_idle[THEN hoare_weaken_pre])
-     apply clarsimp
      apply (fastforce simp: ex_abs_def)
-    apply (fastforce simp: ex_abs_def ct_idle_related sched_act_rct_related)
+    apply (clarsimp simp: ex_abs_def)
+    apply (rule_tac x=s in exI)
+    apply clarsimp
+    apply (intro conjI)
+     apply (fastforce intro: ct_idle_related)
+    apply (fastforce intro: resume_cur_thread_cross)
    apply (fastforce simp: ex_abs_def)
 
   apply (clarsimp simp: check_active_irq_H_def)
    apply (drule use_valid)
-     apply (rule hoare_vcg_conj_lift)
+    apply (rule hoare_vcg_conj_lift)
      apply (rule checkActiveIRQ_valid_duplicates')
-    apply (rule valid_corres_combined[OF check_active_irq_invs check_active_irq_corres])
-    apply (rule checkActiveIRQ_invs'[THEN hoare_weaken_pre])
-    apply clarsimp
-     apply (fastforce simp: ex_abs_def)
-   apply (fastforce simp: ex_abs_def ct_running_related ct_idle_related sched_act_rct_related)
+    apply (rule valid_corres_combined[OF check_active_irq_invs_just_idle corres_guard_imp2[OF checkActiveIRQ_just_idle_corres]])
+     apply clarsimp
+    apply (rule checkActiveIRQ_invs'_just_idle[THEN hoare_weaken_pre])
+    apply (fastforce simp: ex_abs_def)
+   apply (clarsimp simp: ex_abs_def)
+   apply (rule_tac x=s in exI)
+   apply clarsimp
+   apply (intro conjI)
+    apply (fastforce intro: ct_idle_related)
+   apply (fastforce intro: resume_cur_thread_cross)
   apply (fastforce simp: ex_abs_def)
   done
 

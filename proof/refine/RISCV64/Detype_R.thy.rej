--- Detype_R.thy
+++ Detype_R.thy
@@ -88,13 +84,12 @@ lemma descendants_range'_def2:
   "descendants_range' cap p = descendants_range_in' (capRange cap) p"
   by (simp add: descendants_range_in'_def descendants_range'_def)
 
-
 defs deletionIsSafe_def:
-  "deletionIsSafe \<equiv> \<lambda>ptr bits s. \<forall>p t m r.
-       (cte_wp_at' (\<lambda>cte. cteCap cte = capability.ReplyCap t m r) p s \<longrightarrow>
-       t \<notin> {ptr .. ptr + 2 ^ bits - 1}) \<and>
-       (\<forall>ko. ksPSpace s p = Some (KOArch ko) \<and> p \<in> {ptr .. ptr + 2 ^ bits - 1}
-        \<longrightarrow> 6 \<le> bits)"
+  "deletionIsSafe \<equiv> \<lambda>ptr bits s. \<forall>p.
+        (ko_wp_at' live' p s \<longrightarrow> p \<notin> {ptr .. ptr + 2 ^ bits - 1})
+        \<and> (p \<in> set (ksReleaseQueue s) \<longrightarrow> obj_at' (runnable' \<circ> tcbState) p s)
+        \<and> (\<forall>ko. ksPSpace s p = Some (KOArch ko) \<and> p \<in> {ptr .. ptr + 2 ^ bits - 1}
+                \<longrightarrow> 6 \<le> bits)"
 
 defs ksASIDMapSafe_def:
   "ksASIDMapSafe \<equiv> \<lambda>s. \<forall>asid hw_asid pd.
@@ -385,7 +386,7 @@ lemma cte_wp_at_delete':
               del: atLeastAtMost_iff)
   apply (simp add: objBits_simps)
   apply (frule(1) tcb_cte_cases_aligned_helpers)
-  apply (simp add: is_aligned_neg_mask_eq)
+  apply (simp)
   done
 
 lemma map_to_ctes_delete:
@@ -426,291 +427,18 @@ next
     apply (subst card_Un_disjoint; simp)
      apply (clarsimp simp: field_simps)
     apply (subst suc)
-     apply (erule word_plus_mono_right2)
+    apply (erule word_plus_mono_right2)
      apply (simp add: field_simps)
-    apply simp
+     apply simp
     apply (simp add: unatSuc)
     done
 qed
 
 end
-locale detype_locale' = detype_locale + constrains s::"det_state"
 
-lemma (in detype_locale') deletionIsSafe:
-  assumes sr: "(s, s') \<in> state_relation"
-  and    cap: "cap = cap.UntypedCap d base magnitude idx"
-  and      vs: "valid_pspace s"
-  and      al: "is_aligned base magnitude"
-  and      vu: "valid_untyped (cap.UntypedCap d base magnitude idx) s"
-  shows       "deletionIsSafe base magnitude s'"
-proof -
-  interpret Arch . (* FIXME: arch_split *)
-  note blah[simp del] =  atLeastatMost_subset_iff atLeastLessThan_iff
-          Int_atLeastAtMost atLeastatMost_empty_iff split_paired_Ex
-          atLeastAtMost_iff
-  have "\<And>t m r. \<exists>ptr. cte_wp_at ((=) (cap.ReplyCap t m r)) ptr s
-        \<Longrightarrow> t \<notin> {base .. base + 2 ^ magnitude - 1}"
-    by (fastforce dest!: valid_cap2 simp: cap obj_reply_refs_def)
-  hence "\<forall>ptr t m r. cte_wp_at ((=) (cap.ReplyCap t m r)) ptr s
-         \<longrightarrow> t \<notin> {base .. base + 2 ^ magnitude - 1}"
-    by (fastforce simp del: split_paired_All)
-  hence "\<forall>t. t \<in> {base .. base + 2 ^ magnitude - 1} \<longrightarrow>
-          (\<forall>ptr m r. \<not> cte_wp_at ((=) (cap.ReplyCap t m r)) ptr s)"
-    by fastforce
-  hence cte: "\<forall>t. t \<in> {base .. base + 2 ^ magnitude - 1} \<longrightarrow>
-          (\<forall>ptr m r. \<not> cte_wp_at' (\<lambda>cte. cteCap cte = ReplyCap t m r) ptr s')"
-    unfolding deletionIsSafe_def
-    apply -
-    apply (erule allEI)
-    apply (rule impI, drule(1) mp)
-    apply (thin_tac "t \<in> S" for S)
-    apply (intro allI)
-    apply (clarsimp simp: cte_wp_at_neg2 cte_wp_at_ctes_of
-                simp del: split_paired_All)
-    apply (frule pspace_relation_cte_wp_atI [rotated])
-      apply (rule invs_valid_objs [OF invs])
-     apply (rule state_relation_pspace_relation [OF sr])
-    apply (clarsimp simp: cte_wp_at_neg2 simp del: split_paired_All)
-    apply (drule_tac x="(a,b)" in spec)
-    apply (clarsimp simp: cte_wp_cte_at cte_wp_at_caps_of_state)
-    apply (case_tac c, simp_all)
-    apply fastforce
-    done
+locale detype_locale' = detype_locale + constrains s::"det_state"
 
-  have arch: "\<And> ko p. \<lbrakk> ksPSpace s' p = Some (KOArch ko); p \<in> {base..base + 2 ^ magnitude - 1} \<rbrakk>
-             \<Longrightarrow> 6 \<le> magnitude"
-    using sr vs vu
-    apply (clarsimp simp: state_relation_def)
-    apply (erule(1) pspace_dom_relatedE)
-    apply (frule obj_relation_cuts_eqv_base_in_detype_range[symmetric])
-        apply simp
-       apply (clarsimp simp:valid_pspace_def)+
-      apply simp
-    apply (clarsimp simp:valid_untyped_def)
-    apply (drule spec)+
-    apply (erule(1) impE)
-    apply (erule impE)
-     apply (drule p_in_obj_range)
-       apply (clarsimp)+
-     apply blast
-    apply clarsimp
-    apply (drule card_mono[rotated])
-     apply fastforce
-    apply (clarsimp simp:valid_pspace_def obj_range_def p_assoc_help)
-    apply (subst (asm) word_range_card)
-     apply (rule is_aligned_no_overflow')
-     apply (erule(1) pspace_alignedD)
-    apply (subst (asm) word_range_card)
-     apply (rule is_aligned_no_overflow'[OF al])
-    apply (rule ccontr)
-    apply (simp add:not_le)
-    apply (subgoal_tac "obj_bits koa < 32")
-     prefer 2
-     apply (case_tac koa,simp_all add:objBits_simps word_bits_def)
-      apply (drule(1) valid_cs_size_objsI)
-      apply (clarsimp simp:valid_cs_size_def word_bits_def cte_level_bits_def)
-     apply (rename_tac arch_kernel_obj)
-     apply (case_tac arch_kernel_obj,simp_all add:pageBits_def word_bits_def)
-     apply (simp add:pageBitsForSize_def split:vmpage_size.splits)
-    apply (subgoal_tac "6 \<le> obj_bits koa")
-     apply simp
-    apply (case_tac koa, simp_all add: other_obj_relation_def
-                                       objBits_simps cte_relation_def
-                                split: if_splits)
-    apply (rename_tac arch_kernel_obj,
-           case_tac arch_kernel_obj;
-           simp add: arch_kobj_size_def pageBits_def pageBitsForSize_def)+
-    done
-  thus ?thesis using cte by (auto simp: deletionIsSafe_def)
-qed
 context begin interpretation Arch . (*FIXME: arch_split*)
-lemma ksASIDMapSafeI:
-  "\<lbrakk> (s,s') \<in> state_relation; invs s; pspace_aligned' s' \<and> pspace_distinct' s' \<rbrakk>
-  \<Longrightarrow> ksASIDMapSafe s'"
-  apply (clarsimp simp: ksASIDMapSafe_def)
-  apply (subgoal_tac "valid_asid_map s")
-   prefer 2
-   apply fastforce
-  apply (clarsimp simp: valid_asid_map_def graph_of_def)
-  apply (subgoal_tac "arm_asid_map (arch_state s) asid = Some (hw_asid, pd)")
-   prefer 2
-   apply (clarsimp simp: state_relation_def arch_state_relation_def)
-  apply (erule allE)+
-  apply (erule (1) impE)
-  apply clarsimp
-  apply (drule find_pd_for_asid_eq_helper)
-     apply fastforce
-    apply assumption
-   apply fastforce
-  apply clarsimp
-  apply (rule pspace_relation_pd)
-      apply (fastforce simp: state_relation_def)
-     apply fastforce
-    apply assumption
-   apply assumption
-  apply simp
-  done
-
-(* FIXME: generalizes lemma SubMonadLib.corres_submonad *)
-(* FIXME: generalizes lemma SubMonad_R.corres_machine_op *)
-(* FIXME: move *)
-lemma corres_machine_op:
-  assumes P: "corres_underlying Id False True r P Q x x'"
-  shows      "corres r (P \<circ> machine_state) (Q \<circ> ksMachineState)
-                       (do_machine_op x) (doMachineOp x')"
-  apply (rule corres_submonad3
-              [OF submonad_do_machine_op submonad_doMachineOp _ _ _ _ P])
-   apply (simp_all add: state_relation_def swp_def)
-  done
-
-lemma ekheap_relation_detype:
-  "ekheap_relation ekh kh \<Longrightarrow>
-   ekheap_relation (\<lambda>x. if P x then None else (ekh x)) (\<lambda>x. if P x then None else (kh x))"
-  by (fastforce simp add: ekheap_relation_def split: if_split_asm)
-
-lemma cap_table_at_gsCNodes_eq:
-  "(s, s') \<in> state_relation
-    \<Longrightarrow> (gsCNodes s' ptr = Some bits) = cap_table_at bits ptr s"
-  apply (clarsimp simp: state_relation_def ghost_relation_def
-                        obj_at_def is_cap_table)
-  apply (drule_tac x = ptr in spec)+
-  apply (drule_tac x = bits in spec)+
-  apply fastforce
-  done
-
-lemma cNodeNoPartialOverlap:
-  "corres dc (\<lambda>s. \<exists>cref. cte_wp_at ((=) (cap.UntypedCap d base magnitude idx)) cref s
-                     \<and> valid_objs s \<and> pspace_aligned s)
-     \<top>
-    (return x) (stateAssert (\<lambda>s. \<not> cNodePartialOverlap (gsCNodes s)
-       (\<lambda>x. base \<le> x \<and> x \<le> base + 2 ^ magnitude - 1)) [])"
-  apply (simp add: stateAssert_def assert_def)
-  apply (rule corres_symb_exec_r[OF _ get_sp])
-    apply (rule corres_req[rotated], subst if_P, assumption)
-     apply simp
-    apply (clarsimp simp: cNodePartialOverlap_def)
-    apply (drule(1) cte_wp_valid_cap)
-    apply (clarsimp simp: valid_cap_def valid_untyped_def cap_table_at_gsCNodes_eq
-                          obj_at_def is_cap_table)
-    apply (frule(1) pspace_alignedD)
-    apply simp
-    apply (elim allE, drule(1) mp, simp add: obj_range_def valid_obj_def cap_aligned_def)
-    apply (erule is_aligned_get_word_bits[where 'a=32, folded word_bits_def])
-     apply (clarsimp simp: is_aligned_no_overflow)
-     apply (blast intro: order_trans)
-    apply (simp add: is_aligned_no_overflow power_overflow word_bits_def)
-   apply wp+
-  done
-
-
-declare wrap_ext_det_ext_ext_def[simp]
-
-(* Just for ARM *)
-lemma sym_refs_hyp_refs_triv[simp]: "sym_refs (state_hyp_refs_of s)"
-  apply (auto simp: state_hyp_refs_of_def sym_refs_def)
-  apply (case_tac "kheap s x"; simp add: hyp_refs_of_def)
-  apply (rename_tac ko)
-  apply (case_tac ko; clarsimp)
-  done
-
-lemma deleteObjects_corres:
-  "is_aligned base magnitude \<Longrightarrow> magnitude \<ge> 2 \<Longrightarrow>
-   corres dc
-      (\<lambda>s. einvs s
-           \<and> s \<turnstile> (cap.UntypedCap d base magnitude idx)
-           \<and> (\<exists>cref. cte_wp_at ((=) (cap.UntypedCap d base magnitude idx)) cref s
-                     \<and> descendants_range (cap.UntypedCap d base magnitude idx) cref s)
-           \<and> untyped_children_in_mdb s \<and> if_unsafe_then_cap s
-           \<and> valid_mdb s \<and> valid_global_refs s \<and> ct_active s)
-      (\<lambda>s. s \<turnstile>' (UntypedCap d base magnitude idx)
-           \<and> valid_pspace' s)
-      (delete_objects base magnitude) (deleteObjects base magnitude)"
-  apply (simp add: deleteObjects_def2)
-  apply (rule corres_stateAssert_implied[where P'=\<top>, simplified])
-   prefer 2
-   apply clarsimp
-   apply (rule_tac cap="cap.UntypedCap d base magnitude idx" and ptr="(a,b)" and
-                   s=s in detype_locale'.deletionIsSafe,
-          simp_all add: detype_locale'_def
-     detype_locale_def p_assoc_help invs_valid_pspace)[1]
-   apply (simp add:valid_cap_simps)
-  apply (simp add: bind_assoc[symmetric])
-  apply (rule corres_stateAssert_implied2)
-     defer
-     apply (erule ksASIDMapSafeI, assumption, assumption)
-    apply (rule hoare_pre)
-     apply (rule delete_objects_invs)
-    apply fastforce
-   apply (simp add: doMachineOp_def split_def)
-   apply wp
-   apply (clarsimp simp: valid_pspace'_def pspace_distinct'_def
-                         pspace_aligned'_def)
-   apply (rule conjI)
-    subgoal by fastforce
-   apply (clarsimp simp add: pspace_distinct'_def ps_clear_def
-                             dom_if_None Diff_Int_distrib)
-  apply (simp add: delete_objects_def)
-  apply (rule_tac Q="\<lambda>_ s. valid_objs s \<and> valid_list s \<and>
-           (\<exists>cref. cte_wp_at ((=) (cap.UntypedCap d base magnitude idx)) cref s \<and>
-                   descendants_range (cap.UntypedCap d base magnitude idx) cref s ) \<and>
-           s \<turnstile> cap.UntypedCap d base magnitude idx \<and> pspace_aligned s \<and>
-           valid_mdb s \<and> pspace_distinct s \<and> if_live_then_nonz_cap s \<and>
-           zombies_final s \<and> sym_refs (state_refs_of s) \<and>
-           untyped_children_in_mdb s \<and> if_unsafe_then_cap s \<and>
-           valid_global_refs s" and
-         Q'="\<lambda>_ s. s \<turnstile>' capability.UntypedCap d base magnitude idx \<and>
-                        valid_pspace' s" in corres_split')
-     apply (rule corres_bind_return)
-     apply (rule corres_guard_imp[where r=dc])
-       apply (rule corres_split_deprecated[OF cNodeNoPartialOverlap])
-         apply (rule corres_machine_op[OF corres_Id], simp+)
-         apply (rule no_fail_freeMemory, simp+)
-        apply (wp hoare_vcg_ex_lift)+
-      apply auto[1]
-     apply (auto elim: is_aligned_weaken)
-    apply (rule corres_modify)
-    apply (simp add: valid_pspace'_def)
-    apply (rule state_relation_null_filterE, assumption,
-           simp_all add: pspace_aligned'_cut pspace_distinct'_cut)[1]
-           apply (simp add: detype_def, rule state.equality; simp add: detype_ext_def)
-          apply (intro exI, fastforce)
-         apply (rule ext, clarsimp simp add: null_filter_def)
-         apply (rule sym, rule ccontr, clarsimp)
-         apply (drule(4) cte_map_not_null_outside')
-          apply (fastforce simp add: cte_wp_at_caps_of_state)
-         apply simp
-        apply (rule ext, clarsimp simp add: null_filter'_def
-                           map_to_ctes_delete[simplified field_simps])
-        apply (rule sym, rule ccontr, clarsimp)
-        apply (frule(2) pspace_relation_cte_wp_atI
-                        [OF state_relation_pspace_relation])
-        apply (elim exE)
-        apply (frule(4) cte_map_not_null_outside')
-         apply (rule cte_wp_at_weakenE, erule conjunct1)
-         apply (case_tac y, clarsimp)
-         apply (clarsimp simp: valid_mdb'_def valid_mdb_ctes_def
-                               valid_nullcaps_def)
-        apply clarsimp
-        apply (frule_tac cref="(aa, ba)" in cte_map_untyped_range,
-               erule cte_wp_at_weakenE[OF _ TrueI], assumption+)
-        apply simp
-       apply (rule detype_pspace_relation[simplified],
-              simp_all add: state_relation_pspace_relation valid_pspace_def)[1]
-        apply (simp add: valid_cap'_def capAligned_def)
-       apply (clarsimp simp: valid_cap_def, assumption)
-      apply (fastforce simp add: detype_def detype_ext_def intro!: ekheap_relation_detype)
-     apply (clarsimp simp: state_relation_def ghost_relation_of_heap
-                           detype_def)
-     apply (drule_tac t="gsUserPages s'" in sym)
-     apply (drule_tac t="gsCNodes s'" in sym)
-     apply (auto simp add: ups_of_heap_def cns_of_heap_def ext
-                 split: option.splits kernel_object.splits)[1]
-    apply (simp add: valid_mdb_def)
-   apply (wp hoare_vcg_ex_lift hoare_vcg_ball_lift | wps |
-          simp add: invs_def valid_state_def valid_pspace_def
-                    descendants_range_def | wp (once) hoare_drop_imps)+
-  done
-
 
 text \<open>Invariant preservation across concrete deletion\<close>
 
@@ -750,89 +478,97 @@ lemma zobj_refs_capRange:
   "capAligned c \<Longrightarrow> zobj_refs' c \<subseteq> capRange c"
   by (cases c, simp_all add: capRange_def capAligned_def is_aligned_no_overflow)
 end
+
 locale delete_locale =
-  fixes s and base and bits and ptr and idx and d
-  assumes cap: "cte_wp_at' (\<lambda>cte. cteCap cte = UntypedCap d base bits idx) ptr s"
-  and  nodesc: "descendants_range' (UntypedCap d base bits idx) ptr (ctes_of s)"
-  and    invs: "invs' s"
-  and  ct_act: "ct_active' s"
-  and sa_simp: "sch_act_simple s"
-  and     bwb: "bits < word_bits"
-  and      al: "is_aligned base bits"
-  and    safe: "deletionIsSafe base bits s"
+  fixes s' and base and bits and ptr and idx and d
+  assumes     cap: "cte_wp_at' (\<lambda>cte. cteCap cte = UntypedCap d base bits idx) ptr s'"
+  and      nodesc: "descendants_range' (UntypedCap d base bits idx) ptr (ctes_of s')"
+  and        invs: "invs' s'"
+  and    sym_refs: "sym_refs (state_refs_of' s')"
+  and valid_idle': "valid_idle' s'"
+  and      ct_act: "ct_active' s'"
+  and     sa_simp: "sch_act_simple s'"
+  and          al: "is_aligned base bits"
+  and      rlqrun: "\<forall>p. p \<in> set (ksReleaseQueue s') \<longrightarrow> obj_at' (runnable' \<circ> tcbState) p s'"
 
 context delete_locale
 begin
 interpretation Arch . (*FIXME: arch_split*)
-lemma valid_objs: "valid_objs' s"
-  and        pa: "pspace_aligned' s"
-  and        pd: "pspace_distinct' s"
-  and        vq: "valid_queues s"
-  and       vq': "valid_queues' s"
-  and  sym_refs: "sym_refs (state_refs_of' s)"
-  and    iflive: "if_live_then_nonz_cap' s"
-  and  ifunsafe: "if_unsafe_then_cap' s"
-  and     dlist: "valid_dlist (ctes_of s)"
-  and      no_0: "no_0 (ctes_of s)"
-  and   chain_0: "mdb_chain_0 (ctes_of s)"
-  and    badges: "valid_badges (ctes_of s)"
-  and contained: "caps_contained' (ctes_of s)"
-  and   chunked: "mdb_chunked (ctes_of s)"
-  and      umdb: "untyped_mdb' (ctes_of s)"
-  and      uinc: "untyped_inc' (ctes_of s)"
-  and  nullcaps: "valid_nullcaps (ctes_of s)"
-  and    ut_rev: "ut_revocable' (ctes_of s)"
-  and    dist_z: "distinct_zombies (ctes_of s)"
-  and  irq_ctrl: "irq_control (ctes_of s)"
-  and    clinks: "class_links (ctes_of s)"
-  and  rep_r_fb: "reply_masters_rvk_fb (ctes_of s)"
-  and      idle: "valid_idle' s"
-  and      refs: "valid_global_refs' s"
-  and      arch: "valid_arch_state' s"
-  and      virq: "valid_irq_node' (irq_node' s) s"
-  and     virqh: "valid_irq_handlers' s"
-  and     virqs: "valid_irq_states' s"
-  and no_0_objs: "no_0_obj' s"
-  and  ctnotinQ: "ct_not_inQ s"
-  and  pde_maps: "valid_pde_mappings' s"
-  and irqs_masked: "irqs_masked' s"
-  and      ctcd: "ct_idle_or_in_cur_domain' s"
-  and       cdm: "ksCurDomain s \<le> maxDomain"
-  and       vds: "valid_dom_schedule' s"
+lemma  valid_objs: "valid_objs' s'"
+  and    vreplies: "valid_replies' s'"
+  and      pspace: "valid_pspace' s'"
+  and          pa: "pspace_aligned' s'"
+  and          pd: "pspace_distinct' s'"
+  and          bd: "pspace_bounded' s'"
+  and          vq: "valid_queues s'"
+  and         vq': "valid_queues' s'"
+  and        vrlq: "valid_release_queue s'"
+  and       vrlq': "valid_release_queue' s'"
+  and   list_refs: "sym_refs (list_refs_of_replies' s')"
+  and      iflive: "if_live_then_nonz_cap' s'"
+  and    ifunsafe: "if_unsafe_then_cap' s'"
+  and       dlist: "valid_dlist (ctes_of s')"
+  and        no_0: "no_0 (ctes_of s')"
+  and     chain_0: "mdb_chain_0 (ctes_of s')"
+  and      badges: "valid_badges (ctes_of s')"
+  and   contained: "caps_contained' (ctes_of s')"
+  and     chunked: "mdb_chunked (ctes_of s')"
+  and        umdb: "untyped_mdb' (ctes_of s')"
+  and        uinc: "untyped_inc' (ctes_of s')"
+  and    nullcaps: "valid_nullcaps (ctes_of s')"
+  and      ut_rev: "ut_revocable' (ctes_of s')"
+  and      dist_z: "distinct_zombies (ctes_of s')"
+  and    irq_ctrl: "irq_control (ctes_of s')"
+  and      clinks: "class_links (ctes_of s')"
+  and        refs: "valid_global_refs' s'"
+  and        arch: "valid_arch_state' s'"
+  and        virq: "valid_irq_node' (irq_node' s') s'"
+  and       virqh: "valid_irq_handlers' s'"
+  and       virqs: "valid_irq_states' s'"
+  and   no_0_objs: "no_0_obj' s'"
+  and    pde_maps: "valid_pde_mappings' s'"
+  and irqs_masked: "irqs_masked' s'"
+  and         cdm: "ksCurDomain s' \<le> maxDomain"
+  and         vds: "valid_dom_schedule' s'"
   using invs
-  by (auto simp add: invs'_def valid_state'_def valid_pspace'_def
-                    valid_mdb'_def valid_mdb_ctes_def)
+  by (auto simp add: invs'_def valid_pspace'_def valid_mdb'_def valid_mdb_ctes_def)
 
 abbreviation
   "base_bits \<equiv> {base .. base + (2 ^ bits - 1)}"
 
 abbreviation
-  "state' \<equiv> (s \<lparr> ksPSpace := \<lambda>x. if base \<le> x \<and> x \<le> base + (2 ^ bits - 1) then None else ksPSpace s x \<rparr>)"
+  "pspace' \<equiv> \<lambda>x. if base \<le> x \<and> x \<le> base + (2 ^ bits - 1) then None else ksPSpace s' x"
+
+abbreviation
+  "state' \<equiv> (s' \<lparr> ksPSpace := pspace' \<rparr>)"
+
+abbreviation
+  "replies' \<equiv> pspace' |> reply_of'"
 
 lemma ko_wp_at'[simp]:
-  "\<And>P p. (ko_wp_at' P p state') = (ko_wp_at' P p s \<and> p \<notin> base_bits)"
+  "\<And>P p. (ko_wp_at' P p state') = (ko_wp_at' P p s' \<and> p \<notin> base_bits)"
   by (fastforce simp add: ko_wp_at_delete'[OF pd])
 
 lemma obj_at'[simp]:
-  "\<And>P p. (obj_at' P p state') = (obj_at' P p s \<and> p \<notin> base_bits)"
+  "\<And>P p. (obj_at' P p state') = (obj_at' P p s' \<and> p \<notin> base_bits)"
   by (fastforce simp add: obj_at'_real_def)
 
 lemma typ_at'[simp]:
-  "\<And>T p. (typ_at' P p state') = (typ_at' P p s \<and> p \<notin> base_bits)"
+  "typ_at' P p state' = (typ_at' P p s' \<and> p \<notin> base_bits)"
   by (simp add: typ_at'_def)
 
 lemma valid_untyped[simp]:
-  "s \<turnstile>' UntypedCap d base bits idx"
+  "s' \<turnstile>' UntypedCap d base bits idx"
   using cte_wp_at_valid_objs_valid_cap' [OF cap valid_objs]
   by clarsimp
 
 lemma cte_wp_at'[simp]:
-  "\<And>P p. (cte_wp_at' P p state') = (cte_wp_at' P p s \<and> p \<notin> base_bits)"
+  "\<And>P p. (cte_wp_at' P p state') = (cte_wp_at' P p s' \<and> p \<notin> base_bits)"
   by (fastforce simp:cte_wp_at_delete'[where idx = idx,OF valid_untyped pd ])
 
 (* the bits of caps they need for validity argument are within their capRanges *)
 lemma valid_cap_ctes_pre:
-    "\<And>c. s \<turnstile>' c \<Longrightarrow> case c of CNodeCap ref bits g gs
+    "\<And>c. s' \<turnstile>' c \<Longrightarrow> case c of CNodeCap ref bits g gs
                       \<Rightarrow> \<forall>x. ref + (x && mask bits) * 2^cteSizeBits \<in> capRange c
                     | Zombie ref (ZombieCNode bits) n
                       \<Rightarrow> \<forall>x. ref + (x && mask bits) * 2^cteSizeBits \<in> capRange c
@@ -855,20 +591,14 @@ lemma valid_cap_ctes_pre:
   apply (clarsimp simp add: capRange_def capAligned_def objBits_simps field_simps)
   done
 
-lemma replycap_argument:
-  "\<And>p t m r. cte_wp_at' (\<lambda>cte. cteCap cte = ReplyCap t m r) p s
-   \<Longrightarrow> t \<notin> {base .. base + (2 ^ bits - 1)}"
-  using safe
-  by (fastforce simp add: deletionIsSafe_def cte_wp_at_ctes_of field_simps)
-
 lemma valid_cap':
-    "\<And>p c. \<lbrakk> s \<turnstile>' c; cte_wp_at' (\<lambda>cte. cteCap cte = c) p s;
+    "\<And>p c. \<lbrakk> s' \<turnstile>' c; cte_wp_at' (\<lambda>cte. cteCap cte = c) p s';
              capRange c \<inter> {base .. base + (2 ^ bits - 1)} = {} \<rbrakk> \<Longrightarrow> state' \<turnstile>' c"
   apply (subgoal_tac "capClass c = PhysicalClass \<longrightarrow> capUntypedPtr c \<in> capRange c")
    apply (subgoal_tac "capClass c = PhysicalClass \<longrightarrow>
                         capUntypedPtr c \<notin> {base .. base + (2 ^ bits - 1)}")
     apply (frule valid_cap_ctes_pre)
-    apply (case_tac c, simp_all add: valid_cap'_def replycap_argument
+    apply (case_tac c, simp_all add: valid_cap'_def
                                 del: atLeastAtMost_iff
                               split: zombie_type.split_asm)
        apply (simp add: field_simps del: atLeastAtMost_iff)
@@ -954,70 +684,523 @@ lemma ex_nonz_cap_notRange:
   apply simp
   done
 
-lemma live_notRange:
-  "\<lbrakk> ko_wp_at' P p s; \<And>ko. P ko \<Longrightarrow> live' ko \<rbrakk> \<Longrightarrow> p \<notin> base_bits"
-  apply (drule if_live_then_nonz_capE' [OF iflive ko_wp_at'_weakenE])
-   apply simp
-  apply (erule ex_nonz_cap_notRange)
-  done
-
-lemma refs_notRange:
-  "(x, tp) \<in> state_refs_of' s y \<Longrightarrow> y \<notin> base_bits"
-  apply (drule state_refs_of'_elemD)
-  apply (erule live_notRange)
-  apply (rule refs_of_live')
+lemma live_notRange:
+  "\<lbrakk> ko_wp_at' P p s'; \<And>ko. P ko \<Longrightarrow> live' ko \<rbrakk> \<Longrightarrow> p \<notin> base_bits"
+  apply (drule if_live_then_nonz_capE' [OF iflive ko_wp_at'_weakenE])
+   apply simp
+  apply (erule ex_nonz_cap_notRange)
+  done
+
+lemma deletionIsSafe_holds:
+  assumes sr: "(s, s') \<in> state_relation"
+  and    cap: "cap = cap.UntypedCap d base bits idx"
+  and     vs: "valid_pspace s"
+  and     al: "is_aligned base bits"
+  and     vu: "valid_untyped (cap.UntypedCap d base bits idx) s"
+  shows "deletionIsSafe base bits s'"
+proof -
+  interpret Arch . (* FIXME: arch_split *)
+
+  have arch: "\<And> ko p. \<lbrakk> ksPSpace s' p = Some (KOArch ko); p \<in> {base..base + 2 ^ bits - 1} \<rbrakk>
+                       \<Longrightarrow> 6 \<le> bits"
+    using sr vs vu
+    apply (clarsimp simp: state_relation_def)
+    apply (erule (1) pspace_dom_relatedE)
+    apply (frule obj_relation_cuts_eqv_base_in_detype_range[symmetric]; simp?)
+      apply (clarsimp simp: valid_pspace_def)+
+    apply (clarsimp simp: valid_untyped_def)
+    apply (drule spec)+
+    apply (erule(1) impE)
+    apply (erule impE)
+     apply (drule p_in_obj_range; fastforce)
+    apply clarsimp
+    apply (drule card_mono[rotated])
+     apply fastforce
+    apply (clarsimp simp: valid_pspace_def obj_range_def p_assoc_help)
+    apply (subst (asm) word_range_card)
+     apply (rule is_aligned_no_overflow')
+     apply (erule(1) pspace_alignedD)
+    apply (subst (asm) word_range_card)
+     apply (rule is_aligned_no_overflow'[OF al])
+    apply (rule ccontr)
+    apply (simp add: not_le)
+    apply (prop_tac "obj_bits koa < 32")
+     apply (case_tac koa, simp_all add: objBits_simps word_bits_def)
+       apply (drule(1) valid_cs_size_objsI)
+       apply (clarsimp simp: valid_cs_size_def word_bits_def cte_level_bits_def)
+      apply (clarsimp split: if_splits)
+     apply (rename_tac arch_kernel_obj)
+     apply (case_tac arch_kernel_obj; simp add: pageBits_def word_bits_def)
+     apply (simp add: pageBitsForSize_def split: vmpage_size.splits)
+    apply (case_tac koa
+           ; simp add: other_obj_relation_def objBits_simps cte_relation_def
+                split: if_splits)
+     apply (rename_tac arch_kernel_obj
+            , case_tac arch_kernel_obj
+            ; simp add: arch_kobj_size_def pageBits_def pageBitsForSize_def)+
+    done
+
+  thus ?thesis
+  apply -
+  apply (clarsimp simp: deletionIsSafe_def)
+  apply (intro conjI; blast?)
+   apply (fastforce simp: x_power_minus_1 dest!: live_notRange)
+  apply (insert rlqrun)
+  apply simp
+  done
+qed
+end
+
+context begin interpretation Arch . (*FIXME: arch_split*)
+lemma ksASIDMapSafeI:
+  "\<lbrakk> (s,s') \<in> state_relation; invs s; pspace_aligned' s' \<and> pspace_distinct' s' \<rbrakk>
+  \<Longrightarrow> ksASIDMapSafe s'"
+  apply (clarsimp simp: ksASIDMapSafe_def)
+  apply (subgoal_tac "valid_asid_map s")
+   prefer 2
+   apply fastforce
+  apply (clarsimp simp: valid_asid_map_def graph_of_def)
+  apply (subgoal_tac "arm_asid_map (arch_state s) asid = Some (hw_asid, pd)")
+   prefer 2
+   apply (clarsimp simp: state_relation_def arch_state_relation_def)
+  apply (erule allE)+
+  apply (erule (1) impE)
+  apply clarsimp
+  apply (drule find_pd_for_asid_eq_helper)
+     apply fastforce
+    apply assumption
+   apply fastforce
+  apply clarsimp
+  apply (rule pspace_relation_pd)
+      apply (fastforce simp: state_relation_def)
+     apply fastforce
+    apply assumption
+   apply assumption
+  apply simp
+  done
+
+(* FIXME: generalizes lemma SubMonadLib.corres_submonad *)
+(* FIXME: generalizes lemma SubMonad_R.corres_machine_op *)
+(* FIXME: move *)
+lemma corres_machine_op:
+  assumes P: "corres_underlying Id False True r P Q x x'"
+  shows      "corres r (P \<circ> machine_state) (Q \<circ> ksMachineState)
+                       (do_machine_op x) (doMachineOp x')"
+  apply (rule corres_submonad3
+              [OF submonad_do_machine_op submonad_doMachineOp _ _ _ _ P])
+   apply (simp_all add: state_relation_def swp_def)
+  done
+
+lemma cap_table_at_gsCNodes_eq:
+  "(s, s') \<in> state_relation
+    \<Longrightarrow> (gsCNodes s' ptr = Some bits) = cap_table_at bits ptr s"
+  apply (clarsimp simp: state_relation_def ghost_relation_def
+                        obj_at_def is_cap_table)
+  apply (drule_tac x = ptr in spec)+
+  apply (drule_tac x = bits in spec)+
+  apply fastforce
+  done
+
+lemma cNodeNoPartialOverlap:
+  "corres dc (\<lambda>s. \<exists>cref. cte_wp_at ((=) (cap.UntypedCap d base magnitude idx)) cref s
+                     \<and> valid_objs s \<and> pspace_aligned s)
+     \<top>
+    (return x) (stateAssert (\<lambda>s. \<not> cNodePartialOverlap (gsCNodes s)
+       (\<lambda>x. base \<le> x \<and> x \<le> base + 2 ^ magnitude - 1)) [])"
+  apply (simp add: stateAssert_def assert_def)
+  apply (rule corres_symb_exec_r[OF _ get_sp])
+    apply (rule corres_req[rotated], subst if_P, assumption)
+     apply simp
+    apply (clarsimp simp: cNodePartialOverlap_def)
+    apply (drule(1) cte_wp_valid_cap)
+    apply (clarsimp simp: valid_cap_def valid_untyped_def cap_table_at_gsCNodes_eq
+                          obj_at_def is_cap_table)
+    apply (frule(1) pspace_alignedD)
+    apply simp
+    apply (elim allE, drule(1) mp, simp add: obj_range_def valid_obj_def cap_aligned_def)
+    apply (erule is_aligned_get_word_bits[where 'a=32, folded word_bits_def])
+     apply (clarsimp simp: is_aligned_no_overflow)
+     apply (blast intro: order_trans)
+    apply (simp add: is_aligned_no_overflow power_overflow word_bits_def)
+   apply wp+
+  done
+
+
+declare wrap_ext_det_ext_ext_def[simp]
+
+(* Just for ARM *)
+lemma sym_refs_hyp_refs_triv[simp]: "sym_refs (state_hyp_refs_of s)"
+  apply (auto simp: state_hyp_refs_of_def sym_refs_def)
+  apply (case_tac "kheap s x"; simp add: hyp_refs_of_def)
+  apply (rename_tac ko)
+  apply (case_tac ko; clarsimp)
+  done
+
+lemma freeMemory_deletionIsSafe[wp]:
+  "doMachineOp (freeMemory base magnitude) \<lbrace>deletionIsSafe base magnitude\<rbrace>"
+  apply (clarsimp simp: doMachineOp_def)
+  apply wpsimp
+  apply (clarsimp simp: deletionIsSafe_def)
+  done
+
+lemma detype_ReplyPrevs_of:
+  "\<lbrakk>pspace_aligned' s'; pspace_distinct' s'; pspace_bounded' s'; \<forall>p. p \<in> S \<longrightarrow> \<not> ko_wp_at' live' p s'\<rbrakk>
+   \<Longrightarrow> ((\<lambda>x. if x \<in> S then None else ksPSpace s' x) |> reply_of' |> replyPrev)
+       = replyPrevs_of s'"
+  apply (prop_tac "\<And>p reply_ptr. (replyPrevs_of s' p = Some reply_ptr) \<Longrightarrow> p \<notin> S")
+   apply (clarsimp simp: opt_map_def split: option.splits)
+   apply (drule_tac x=p in spec)
+   apply (clarsimp simp: ko_wp_at'_def pred_neg_def live'_def projectKOs live_reply'_def
+                  split: Structures_H.kernel_object.splits)
+  using pspace_alignedD' pspace_distinctD' pspace_boundedD' apply clarsimp
+  apply (rule ext)
+  apply (clarsimp simp: vs_all_heap_simps opt_map_def in_opt_map_eq
+                  split: option.splits)
+  by force
+
+lemma detype_sc_replies_relation:
+  "\<lbrakk>pspace_aligned' s'; pspace_distinct' s'; pspace_bounded' s'; \<forall>p. p \<in> {lower..upper} \<longrightarrow> \<not> ko_wp_at' live' p s';
+    sc_replies_relation s s'\<rbrakk>
+   \<Longrightarrow> sc_replies_relation_2 (sc_replies_of (detype {lower..upper} s))
+                         ((\<lambda>x. if lower \<le> x \<and> x \<le> upper
+                               then None else ksPSpace s' x) |> sc_of' |> scReply)
+                         ((\<lambda>x. if lower \<le> x \<and> x \<le> upper
+                               then None else ksPSpace s' x) |> reply_of' |> replyPrev)"
+  apply (clarsimp simp: sc_replies_relation_def detype_def)
+  apply (frule detype_ReplyPrevs_of[where S="{lower..upper}"]; simp)
+  apply (clarsimp simp: vs_all_heap_simps opt_map_def in_opt_map_eq
+                 split: if_splits Structures_A.kernel_object.splits)
+  done
+
+lemma deleteObjects_corres:
+  "is_aligned base magnitude \<Longrightarrow> magnitude \<ge> 2 \<Longrightarrow>
+   corres dc
+      (\<lambda>s. einvs s
+           \<and> s \<turnstile> (cap.UntypedCap d base magnitude idx)
+           \<and> (\<exists>cref. cte_wp_at ((=) (cap.UntypedCap d base magnitude idx)) cref s
+                     \<and> descendants_range (cap.UntypedCap d base magnitude idx) cref s)
+           \<and> untyped_children_in_mdb s \<and> if_unsafe_then_cap s
+           \<and> valid_mdb s \<and> valid_global_refs s \<and> ct_active s
+           \<and> scheduler_action s = resume_cur_thread)
+      (\<lambda>s'. invs' s'
+           \<and> cte_wp_at' (\<lambda>cte. cteCap cte = UntypedCap d base magnitude idx) ptr s'
+           \<and> descendants_range' (UntypedCap d base magnitude idx) ptr (ctes_of s')
+           \<and> ct_active' s'
+           \<and> s' \<turnstile>' (UntypedCap d base magnitude idx))
+      (delete_objects base magnitude) (deleteObjects base magnitude)"
+    (is "_ \<Longrightarrow> _ \<Longrightarrow> corres _ _ ?conc_guard _ _")
+  apply (rule corres_cross_over_guard
+                 [where Q="?conc_guard
+                           and (\<lambda>s'. \<forall>p. p \<in> set (ksReleaseQueue s')
+                                         \<longrightarrow> obj_at' (runnable' \<circ> tcbState) p s')"])
+   apply (simp add: pred_conj_def)
+   apply (erule ksReleaseQueue_runnable_thread_state; fastforce?)
+  apply add_sym_refs
+  apply add_valid_idle'
+  apply (simp add: deleteObjects_def2)
+  apply (rule corres_stateAssert_add_assertion[rotated])
+   apply (clarsimp simp: sym_refs_asrt_def)
+  apply (rule corres_stateAssert_add_assertion[rotated])
+   apply (clarsimp simp: valid_idle'_asrt_def)
+  apply (rule corres_stateAssert_add_assertion)
+   prefer 2
+   apply clarsimp
+   apply (rule delete_locale.deletionIsSafe_holds
+          ; (fastforce simp: delete_locale_def valid_cap_simps sch_act_simple_def state_relation_def
+                             sched_act_relation_def pred_conj_def)?)
+  apply (simp add: bind_assoc[symmetric])
+  apply (rule corres_stateAssert_implied2)
+     defer
+     apply (erule ksASIDMapSafeI, assumption, assumption)
+    apply (rule hoare_pre)
+     apply (rule delete_objects_invs)
+    apply fastforce
+   apply (simp add: doMachineOp_def split_def)
+   apply wpsimp
+   apply (frule invs_valid_pspace')
+   apply (rule conjI
+          ; clarsimp simp: pspace_distinct'_def ps_clear_def dom_if_None Diff_Int_distrib
+                           valid_pspace'_def pspace_aligned'_def)
+  apply (simp add: delete_objects_def)
+  apply (rule_tac Q="\<lambda>_ s. valid_objs s \<and> valid_list s \<and>
+                           (\<exists>cref. cte_wp_at ((=) (cap.UntypedCap d base magnitude idx)) cref s \<and>
+                                   descendants_range (cap.UntypedCap d base magnitude idx) cref s) \<and>
+                           s \<turnstile> cap.UntypedCap d base magnitude idx \<and> pspace_aligned s \<and>
+                           valid_mdb s \<and> pspace_distinct s \<and> if_live_then_nonz_cap s \<and>
+                           zombies_final s \<and> sym_refs (state_refs_of s) \<and>
+                           untyped_children_in_mdb s \<and> if_unsafe_then_cap s \<and>
+                           valid_global_refs s \<and> valid_replies s \<and> fault_tcbs_valid_states s" and
+                  Q'="\<lambda>_ s. s \<turnstile>' UntypedCap d base magnitude idx \<and>
+                            valid_pspace' s \<and> deletionIsSafe base magnitude s"
+               in corres_split')
+     apply (rule corres_bind_return)
+     apply (rule corres_guard_imp[where r=dc])
+       apply (rule corres_split_deprecated[OF cNodeNoPartialOverlap])
+         apply (rule corres_machine_op[OF corres_Id], simp+)
+         apply (rule no_fail_freeMemory, simp+)
+        apply (wp hoare_vcg_ex_lift)+
+      apply auto[1]
+     apply (auto elim: is_aligned_weaken)
+    apply (rule corres_modify)
+    apply (simp add: valid_pspace'_def)
+    apply (rule state_relation_null_filterE, assumption,
+           simp_all add: pspace_aligned'_cut pspace_distinct'_cut)[1]
+           apply (simp add: detype_def)
+          apply (intro exI, fastforce)
+         apply (rule ext, clarsimp simp add: null_filter_def)
+         apply (rule sym, rule ccontr, clarsimp)
+         apply (drule(4) cte_map_not_null_outside')
+          apply (fastforce simp add: cte_wp_at_caps_of_state)
+         apply simp
+        apply (rule ext, clarsimp simp add: null_filter'_def
+                           map_to_ctes_delete[simplified field_simps])
+        apply (rule sym, rule ccontr, clarsimp)
+        apply (frule(2) pspace_relation_cte_wp_atI
+                        [OF state_relation_pspace_relation])
+        apply (elim exE)
+        apply (frule(4) cte_map_not_null_outside')
+         apply (rule cte_wp_at_weakenE, erule conjunct1)
+         apply (case_tac y, clarsimp)
+         apply (clarsimp simp: valid_mdb'_def valid_mdb_ctes_def
+                               valid_nullcaps_def)
+        apply clarsimp
+        apply (frule_tac cref="(aa, ba)" in cte_map_untyped_range,
+               erule cte_wp_at_weakenE[OF _ TrueI], assumption+)
+        apply simp
+       apply (rule detype_pspace_relation[simplified],
+              simp_all add: state_relation_pspace_relation valid_pspace_def)[1]
+        apply (simp add: valid_cap'_def capAligned_def)
+       apply (clarsimp simp: valid_cap_def, assumption)
+      apply (rule detype_sc_replies_relation; blast?)
+       apply (clarsimp simp: deletionIsSafe_def)
+      apply (erule state_relation_sc_replies_relation)
+     apply (clarsimp simp: state_relation_def ghost_relation_of_heap detype_def)
+     apply (drule_tac t="gsUserPages s'" in sym)
+     apply (drule_tac t="gsCNodes s'" in sym)
+     apply (auto simp: ups_of_heap_def cns_of_heap_def ext
+                split: option.splits kernel_object.splits)[1]
+    apply (simp add: valid_mdb_def)
+   apply (wp hoare_vcg_ex_lift hoare_vcg_ball_lift
+          | wps
+          | simp add: invs_def valid_state_def valid_pspace_def descendants_range_def
+                      valid_cap_simps
+          | wp (once) hoare_drop_imps)+
+  apply (rule invs_valid_pspace')
+  apply simp
+  done
+end
+
+context delete_locale
+begin
+interpretation Arch . (*FIXME: arch_split*)
+lemma live_idle_untyped_range':
+  "\<lbrakk> ko_wp_at' P p s' \<or> p = idle_thread_ptr \<or> p = idle_sc_ptr; \<And>ko. P ko \<Longrightarrow> live' ko \<rbrakk>
+   \<Longrightarrow> p \<notin> base_bits"
+  apply (case_tac "ko_wp_at' P p s'")
+   apply (drule if_live_then_nonz_capE'[OF iflive ko_wp_at'_weakenE])
+    apply simp
+   apply (erule ex_nonz_cap_notRange)
   apply clarsimp
-  done
+  apply (insert invs_valid_global'[OF invs] cap valid_idle'
+                idle_is_global[where s = s])
+  apply (clarsimp simp: cte_wp_at_ctes_of)
+  apply (drule (1) valid_global_refsD')
+  apply (clarsimp simp: valid_idle'_def)
+  using atLeastAtMost_iff apply (simp add: p_assoc_help)
+  by fastforce
+
+lemma untyped_range_live_idle':
+  "p \<in> base_bits \<Longrightarrow> \<not> (ko_wp_at' live' p s' \<or> p = idle_thread_ptr \<or> p = idle_sc_ptr)"
+  using live_idle_untyped_range' by blast
+
+lemma refs_of':
+  "\<And>ko p. ko_wp_at' ((=) (injectKOS ko)) p s' \<Longrightarrow> sym_refs (state_refs_of' s')
+   \<Longrightarrow> refs_of' (injectKOS ko) \<subseteq> (UNIV - base_bits \<times> UNIV)"
+  apply (case_tac "p = idle_sc_ptr \<or> p = idle_thread_ptr")
+   apply (insert valid_idle')
+   apply (clarsimp simp: valid_idle'_def)
+   apply (elim disjE)
+    apply (clarsimp simp: obj_at'_def ko_wp_at'_def projectKOs)
+    using live_idle_untyped_range' apply simp
+   apply (clarsimp simp: obj_at'_def ko_wp_at'_def projectKOs idle_tcb'_def)
+   using live_idle_untyped_range' apply simp
+  apply (prop_tac "ko_at' ko p s'")
+   apply (fastforce simp: ko_wp_at'_def obj_at'_def projectKOs project_inject)
+  apply (frule sym_refs_ko_atD')
+   apply (fastforce intro: refs_of_live' dest!: live_notRange)+
+  done
+
+lemma list_refs_of_replies_live':
+  "\<lbrakk> (x, tp) \<in> list_refs_of_replies' s' p; pspace_aligned' s'; pspace_distinct' s'; pspace_bounded' s' \<rbrakk>
+   \<Longrightarrow> ko_wp_at' live' p s'"
+  apply (clarsimp simp: ko_wp_at'_def list_refs_of_replies'_def list_refs_of_reply'_def pspace_bounded'_def
+                        pspace_aligned'_def pspace_distinct'_def get_refs_def projectKOs
+                 split: option.splits)
+    by (metis live_reply'_def not_in_domIff option.discI option.sel)+
+
+lemma replyPrev_list_refs_of_replies:
+  "\<lbrakk>ko_at' reply p s'; replyPrev reply = Some reply_ptr\<rbrakk>
+   \<Longrightarrow> (reply_ptr, ReplyPrev) \<in> list_refs_of_replies' s' p"
+  by (clarsimp simp: list_refs_of_replies'_def list_refs_of_reply'_def opt_map_def projectKOs
+                     obj_at'_def
+              split: option.splits)
+
+lemma replyNext_list_refs_of_replies:
+  "\<lbrakk>ko_at' reply p s'; replyNext reply = Some next_ptr; next_ptr = Next reply_ptr\<rbrakk>
+   \<Longrightarrow> (reply_ptr, ReplyNext) \<in> list_refs_of_replies' s' p"
+  by (clarsimp simp: list_refs_of_replies'_def list_refs_of_reply'_def opt_map_def projectKOs
+                     obj_at'_def
+              split: option.splits)
 
 lemma valid_obj':
-  "\<lbrakk> valid_obj' obj s; ko_wp_at' ((=) obj) p s \<rbrakk> \<Longrightarrow> valid_obj' obj state'"
+  "\<lbrakk> valid_obj' obj s'; ko_wp_at' ((=) obj) p s'; sym_refs (state_refs_of' s');
+     sym_refs (list_refs_of_replies' s'); pspace_aligned' s'; pspace_distinct' s'; pspace_bounded' s'\<rbrakk>
+   \<Longrightarrow> valid_obj' obj state'"
   apply (case_tac obj, simp_all add: valid_obj'_def)
-      apply (rename_tac endpoint)
-      apply (case_tac endpoint, simp_all add: valid_ep'_def)[1]
-       apply (clarsimp dest!: sym_refs_ko_wp_atD [OF _ sym_refs])
-       apply (drule(1) bspec)+
-       apply (clarsimp dest!: refs_notRange)
-      apply (clarsimp dest!: sym_refs_ko_wp_atD [OF _ sym_refs])
-      apply (drule(1) bspec)+
-      apply (clarsimp dest!: refs_notRange)
-     apply (rename_tac notification)
-     apply (case_tac notification, simp_all add: valid_ntfn'_def valid_bound_tcb'_def)[1]
-     apply (rename_tac ntfn bound)
-     apply (case_tac ntfn, simp_all split:option.splits)[1]
-        apply ((clarsimp dest!: sym_refs_ko_wp_atD [OF _ sym_refs] refs_notRange)+)[4]
-      apply (drule(1) bspec)+
-      apply (clarsimp dest!: refs_notRange)
-     apply (clarsimp dest!: sym_refs_ko_wp_atD [OF _ sym_refs] refs_notRange)
-    apply (frule sym_refs_ko_wp_atD [OF _ sym_refs])
-    apply (clarsimp simp: valid_tcb'_def ko_wp_at'_def
-                          objBits_simps)
-    apply (rule conjI)
-     apply (erule ballEI, clarsimp elim!: ranE)
-     apply (rule_tac p="p + x" in valid_cap2)
-     apply (erule(2) cte_wp_at_tcbI')
-      apply fastforce
+        apply (clarsimp dest!: refs_of' simp flip: injectKO_ep)
+        apply (fastforce simp: valid_ep'_def split: endpoint.splits)
+       apply (clarsimp dest!: refs_of' simp flip: injectKO_ntfn)
+       apply (fastforce simp: valid_ntfn'_def valid_bound_obj'_def split: option.splits ntfn.splits)
+      apply (clarsimp simp flip: injectKO_tcb)
+      apply (frule refs_of')
+      apply (frule (2) sym_refs_ko_wp_atD)
+      apply (clarsimp simp: valid_tcb'_def ko_wp_at'_def objBits_simps)
+      apply (rule conjI)
+       apply (erule ballEI, clarsimp elim!: ranE)
+       apply (rule_tac p="p + x" in valid_cap2)
+       apply (erule (2) cte_wp_at_tcbI')
+        apply fastforce
+       apply simp
+      apply (clarsimp simp: valid_tcb_state'_def valid_bound_reply'_def
+                     split: option.splits thread_state.splits)
+     apply (clarsimp simp: valid_cte'_def)
+     apply (rule_tac p=p in valid_cap2)
+     apply (clarsimp simp: ko_wp_at'_def objBits_simps' cte_level_bits_def[symmetric])
+     apply (erule(2) cte_wp_at_cteI')
      apply simp
-    apply (rename_tac tcb)
-    apply (case_tac "tcbState tcb";
-           clarsimp simp: valid_tcb_state'_def valid_bound_ntfn'_def
-                   dest!: refs_notRange split: option.splits)
-   apply (clarsimp simp: valid_cte'_def)
-   apply (rule_tac p=p in valid_cap2)
-   apply (clarsimp simp: ko_wp_at'_def objBits_simps' cte_level_bits_def[symmetric])
-   apply (erule(2) cte_wp_at_cteI')
-   apply simp
-  apply (rename_tac arch_kernel_object)
-  apply (case_tac "arch_kernel_object", simp_all)
-    apply (rename_tac asidpool)
-    apply (case_tac asidpool, clarsimp simp: page_directory_at'_def)
-   apply (rename_tac pte)
-   apply (case_tac pte, simp_all add: valid_mapping'_def)
-  apply(rename_tac pde)
-  apply (case_tac pde, simp_all add: valid_mapping'_def)
+    apply (rename_tac arch_kernel_object)
+    apply (case_tac "arch_kernel_object", simp_all)
+      apply (rename_tac asidpool)
+      apply (case_tac asidpool, clarsimp simp: page_directory_at'_def)
+     apply (rename_tac pte)
+     apply (case_tac pte, simp_all add: valid_mapping'_def)
+    apply (rename_tac pde)
+    apply (case_tac pde, simp_all add: valid_mapping'_def)
+   apply (clarsimp dest!: refs_of' simp flip: injectKO_sc)
+   apply (clarsimp simp: valid_sched_context'_def valid_bound_obj'_def split: option.splits)
+  apply (rename_tac reply)
+  apply (clarsimp simp flip: injectKO_reply)
+  apply (frule (1) refs_of')
+  apply (clarsimp simp: ko_wp_at'_def valid_reply'_def valid_bound_tcb'_def)
+  apply (rule conjI; (solves \<open>clarsimp split: option.splits\<close>)?)+
+   apply (case_tac "replyPrev reply = None"; clarsimp?)
+   apply (frule replyPrev_list_refs_of_replies[rotated])
+    apply (simp add: obj_at'_def projectKOs)
+  using sym_refs_def live_notRange list_refs_of_replies_live' apply fastforce
+  apply (case_tac "replyNext reply = None"; clarsimp?)
+  apply (rename_tac reply_next)
+  apply (case_tac reply_next; clarsimp)
+  apply (frule replyNext_list_refs_of_replies[rotated], simp)
+   apply (simp add: obj_at'_def projectKOs)
+  using sym_refs_def live_notRange list_refs_of_replies_live' apply fastforce
+  done
+
+lemma state_refs_for_state':
+  "\<lbrakk> pspace_aligned' s'; pspace_distinct' s'; pspace_distinct' state' \<rbrakk>
+   \<Longrightarrow> state_refs_of' state' = (\<lambda>x. if x \<in> base_bits then {} else state_refs_of' s' x)"
+  apply (rule ext)
+  by (auto simp: state_refs_of'_def intro!: pspace_distinctD' split: option.splits)
+
+lemma sc_tcb_not_idle_thread'_helper:
+  "\<lbrakk> pspace_aligned' s'; pspace_distinct' s'; pspace_bounded' s'; scTCB sc = Some tp;
+     ksPSpace s' scp = Some (KOSchedContext sc); sym_refs (state_refs_of' s') \<rbrakk>
+   \<Longrightarrow> (scp, TCBSchedContext) \<in> state_refs_of' s' tp"
+  apply (clarsimp simp: state_refs_of'_def
+                 elim!: sym_refsE)
+  by (simp add: pspace_alignedD' pspace_distinctD' pspace_boundedD')
+
+lemma sc_tcb_not_idle_thread':
+  "\<lbrakk> pspace_aligned' s'; pspace_distinct' s'; ksPSpace s' scp = Some (KOSchedContext sc);
+     scp \<noteq> idle_sc_ptr; valid_global_refs' s'; valid_pspace' s';
+     if_live_then_nonz_cap' s'; sym_refs (state_refs_of' s')\<rbrakk>
+   \<Longrightarrow> scTCB sc \<noteq> Some (ksIdleThread s')"
+  apply (frule (1) global'_no_ex_cap)
+  apply (rule valid_objsE'; fastforce?)
+  apply (clarsimp simp: valid_obj_def valid_sched_context_def is_tcb obj_at_def)
+  apply (frule sc_tcb_not_idle_thread'_helper; blast?)
+  apply (insert valid_idle')
+  apply (clarsimp simp: valid_idle'_def pred_tcb_at'_def obj_at'_def projectKOs state_refs_of'_def
+                        live'_def idle_tcb'_def
+                 dest!: sc_tcb_not_idle_thread'_helper if_live_then_nonz_capD')
+  done
+
+lemma thread_not_idle_implies_sc_not_idle'_helper:
+  "\<lbrakk> pspace_aligned' s'; pspace_distinct' s'; pspace_bounded' s'; tcbSchedContext tcb = Some scp;
+     ksPSpace s' tp = Some (KOTCB tcb); sym_refs (state_refs_of' s') \<rbrakk>
+   \<Longrightarrow> (tp, SCTcb) \<in> state_refs_of' s' scp"
+  apply (clarsimp simp: state_refs_of'_def
+                 elim!: sym_refsE)
+  by (simp add: pspace_alignedD' pspace_distinctD' pspace_boundedD')
+
+lemma thread_not_idle_implies_sc_not_idle':
+  "\<lbrakk> pspace_aligned' s'; pspace_distinct' s'; pspace_bounded' s'; ksPSpace s' tp = Some (KOTCB tcb);
+     tp \<noteq> idle_thread_ptr; valid_global_refs' s'; valid_objs' s';
+     valid_idle' s'; if_live_then_nonz_cap' s'; sym_refs (state_refs_of' s') \<rbrakk>
+   \<Longrightarrow> tcbSchedContext tcb \<noteq> Some idle_sc_ptr"
+  apply (frule global'_sc_no_ex_cap)
+   apply (blast intro: pspace)
+  apply (rule valid_objsE'; simp?)
+  apply (clarsimp simp: valid_obj'_def valid_tcb'_def is_sc_obj_def obj_at'_def)
+  apply (rename_tac ko obj)
+  apply (case_tac ko; clarsimp simp: projectKOs)
+   apply (drule (5) thread_not_idle_implies_sc_not_idle'_helper)
+   apply (drule if_live_then_nonz_capE'[where p=idle_sc_ptr])
+    apply (fastforce simp: ko_wp_at'_def  live_sc'_def state_refs_of'_def
+                    dest!: thread_not_idle_implies_sc_not_idle_helper)
+   apply fastforce
+  done
+
+lemma state_refs:
+  "\<lbrakk>pspace_aligned' s'; pspace_distinct' s'; pspace_bounded' s';
+    pspace_distinct' state'; sym_refs (state_refs_of' s')\<rbrakk>
+  \<Longrightarrow> (state_refs_of' state') = (state_refs_of' s')"
+  apply (rule ext)
+  apply (clarsimp simp: state_refs_for_state')
+  apply (rename_tac x)
+  apply (prop_tac "x \<in> base_bits", simp)
+  apply (frule untyped_range_live_idle')
+  apply (clarsimp simp: state_refs_of'_def split: option.splits)
+  apply (rename_tac ko)
+  apply (case_tac ko; simp)
+      apply (fastforce simp: ep_q_refs_of'_def ko_wp_at'_def)
+     apply (fastforce simp: ntfn_q_refs_of'_def ko_wp_at'_def live_ntfn'_def state_refs_of'_def
+                     split: ntfn.splits)
+    apply (insert refs valid_objs valid_idle' iflive pspace)
+    apply (frule (8) thread_not_idle_implies_sc_not_idle')
+     apply (fastforce simp: state_refs_of'_def)
+    apply (fastforce simp: ko_wp_at'_def)
+   apply (frule (6) sc_tcb_not_idle_thread')
+    apply (fastforce simp: state_refs_of'_def)
+   apply (clarsimp simp: ko_wp_at'_def live_sc'_def  valid_idle'_def)
+  apply (clarsimp simp: ko_wp_at'_def live_reply'_def)
+  done
+
+
+lemma list_refs_of_reply'_state':
+  "\<lbrakk>pspace_aligned' s'; pspace_distinct' s'; pspace_bounded' s'; pspace_distinct' state'\<rbrakk>
+   \<Longrightarrow> (map_set (replies' ||> list_refs_of_reply')) = (list_refs_of_replies' s')"
+  apply (rule ext)
+  apply (clarsimp simp: list_refs_of_replies'_def list_refs_of_reply'_def opt_map_def
+                 split: option.splits)
+  apply (rename_tac x reply_ptr reply)
+  apply (prop_tac "x \<in> base_bits", simp)
+  apply (frule untyped_range_live_idle')
+  apply (clarsimp simp: live'_def ko_wp_at'_def live_reply'_def projectKOs)
+  using pspace_alignedD' pspace_distinctD' pspace_boundedD' apply clarsimp
   done
 
 lemma st_tcb:
-    "\<And>P p. \<lbrakk> st_tcb_at' P p s; \<not> P Inactive; \<not> P IdleThreadState \<rbrakk> \<Longrightarrow> st_tcb_at' P p state'"
+    "\<And>P p. \<lbrakk> st_tcb_at' P p s'; \<not> P Inactive; \<not> P IdleThreadState \<rbrakk> \<Longrightarrow> st_tcb_at' P p state'"
     by (fastforce simp: pred_tcb_at'_def obj_at'_real_def
                        projectKOs
                  dest: live_notRange)
@@ -1035,20 +1218,20 @@ lemma global_refs:
   done
 
 lemma global_refs2:
-  "global_refs' s \<subseteq> (- base_bits)"
+  "global_refs' s' \<subseteq> (- base_bits)"
   using global_refs by blast
 
 lemma irq_nodes_range:
-    "\<forall>irq :: 10 word. irq_node' s + (ucast irq) * 16 \<notin> base_bits"
+    "\<forall>irq :: 10 word. irq_node' s' + (ucast irq) * 16 \<notin> base_bits"
   using irq_nodes_global global_refs
   by blast
 
 lemma cte_refs_notRange:
-  assumes asms: "ctes_of s p = Some c"
-  shows "cte_refs' (cteCap c) (irq_node' s) \<inter> base_bits = {}"
+  assumes asms: "ctes_of s' p = Some c"
+  shows "cte_refs' (cteCap c) (irq_node' s') \<inter> base_bits = {}"
 proof -
   from cap obtain node
-    where ctes_of: "ctes_of s ptr = Some (CTE (UntypedCap d base bits idx) node)"
+    where ctes_of: "ctes_of s' ptr = Some (CTE (UntypedCap d base bits idx) node)"
     apply (clarsimp simp: cte_wp_at_ctes_of)
     apply (case_tac cte, simp)
     done
@@ -1093,37 +1276,37 @@ lemma cte_cap:
   done
 
 lemma idle_notRange:
-  "\<forall>cref. \<not> cte_wp_at' (\<lambda>c. ksIdleThread s \<in> capRange (cteCap c)) cref s
-  \<Longrightarrow> ksIdleThread s \<notin> base_bits"
+  "\<forall>cref. \<not> cte_wp_at' (\<lambda>c. ksIdleThread s' \<in> capRange (cteCap c)) cref s'
+  \<Longrightarrow> ksIdleThread s' \<notin> base_bits"
   apply (insert cap)
   apply (clarsimp simp: cte_wp_at_ctes_of)
   apply (erule_tac x=ptr in allE, clarsimp simp: field_simps)
   done
 
 abbreviation
-  "ctes' \<equiv> map_to_ctes (\<lambda>x. if base \<le> x \<and> x \<le> base + (2 ^ bits - 1) then None else ksPSpace s x)"
+  "ctes' \<equiv> map_to_ctes (\<lambda>x. if base \<le> x \<and> x \<le> base + (2 ^ bits - 1) then None else ksPSpace s' x)"
 
 lemmas tree_to_ctes = map_to_ctes_delete [OF valid_untyped pd]
 
 lemma map_to_ctesE[elim!]:
-  "\<lbrakk> ctes' x = Some cte; \<lbrakk> ctes_of s x = Some cte; x \<notin> base_bits \<rbrakk> \<Longrightarrow> P \<rbrakk> \<Longrightarrow> P"
+  "\<lbrakk> ctes' x = Some cte; \<lbrakk> ctes_of s' x = Some cte; x \<notin> base_bits \<rbrakk> \<Longrightarrow> P \<rbrakk> \<Longrightarrow> P"
   by (clarsimp simp: tree_to_ctes split: if_split_asm)
 
 lemma not_nullMDBNode:
-  "\<lbrakk> ctes_of s x = Some cte; cteCap cte = NullCap; cteMDBNode cte = nullMDBNode \<Longrightarrow> P \<rbrakk> \<Longrightarrow> P"
+  "\<lbrakk> ctes_of s' x = Some cte; cteCap cte = NullCap; cteMDBNode cte = nullMDBNode \<Longrightarrow> P \<rbrakk> \<Longrightarrow> P"
   using nullcaps
   apply (cases cte)
   apply (simp add: valid_nullcaps_def)
   done
 
-lemma mdb_src: "\<lbrakk> ctes_of s \<turnstile> x \<leadsto> y; y \<noteq> 0 \<rbrakk> \<Longrightarrow> x \<notin> base_bits"
+lemma mdb_src: "\<lbrakk> ctes_of s' \<turnstile> x \<leadsto> y; y \<noteq> 0 \<rbrakk> \<Longrightarrow> x \<notin> base_bits"
   apply (rule non_null_present)
   apply (clarsimp simp: next_unfold' cte_wp_at_ctes_of)
   apply (erule(1) not_nullMDBNode)
   apply (simp add: nullMDBNode_def nullPointer_def)
   done
 
-lemma mdb_dest: "\<lbrakk> ctes_of s \<turnstile> x \<leadsto> y; y \<noteq> 0 \<rbrakk> \<Longrightarrow> y \<notin> base_bits"
+lemma mdb_dest: "\<lbrakk> ctes_of s' \<turnstile> x \<leadsto> y; y \<noteq> 0 \<rbrakk> \<Longrightarrow> y \<notin> base_bits"
   apply (case_tac "x = 0")
    apply (insert no_0, simp add: next_unfold')[1]
   apply (drule(1) vdlist_nextD0 [OF _ _ dlist])
@@ -1305,23 +1519,10 @@ proof (simp add: invs'_def valid_state'_def valid_pspace'_def
                intro!: cte_cap)
 
   from idle_notRange refs
-  have "ksIdleThread s \<notin> ?ran"
+  have "ksIdleThread s' \<notin> ?ran"
     apply (simp add: cte_wp_at_ctes_of valid_global_refs'_def valid_refs'_def)
     apply blast
     done
-  with idle show "valid_idle' ?s"
-    apply (clarsimp simp: valid_idle'_def pred_tcb_at'_def obj_at'_def projectKOs)
-    apply (clarsimp simp add: ps_clear_def dom_if_None Diff_Int_distrib)
-    done
-
-  from tcb_at_invs' [OF invs] ct_act
-  show "cur_tcb' ?s" unfolding cur_tcb'_def
-    apply (clarsimp simp: cur_tcb'_def ct_in_state'_def)
-    apply (drule st_tcb)
-      apply simp
-     apply simp
-    apply (simp add: pred_tcb_at'_def)
-    done
 
   let ?ctes' = ctes'
 
@@ -1489,44 +1678,12 @@ proof (simp add: invs'_def valid_state'_def valid_pspace'_def
     apply (auto simp add: x_power_minus_1)
     done
 
-  from sa_simp ctnotinQ
-  show "ct_not_inQ state'"
-    apply (clarsimp simp: ct_not_inQ_def pred_tcb_at'_def)
-    apply (drule obj_at'_and
-                   [THEN iffD2, OF conjI,
-                    OF ct_act [unfolded ct_in_state'_def pred_tcb_at'_def]])
-    apply (clarsimp simp: obj_at'_real_def)
-    apply (frule if_live_then_nonz_capE'[OF iflive, OF ko_wp_at'_weakenE])
-     apply (clarsimp simp: projectKOs)
-     apply (case_tac "tcbState obj")
-            apply (clarsimp simp: projectKOs)+
-    apply (clarsimp dest!: ex_nonz_cap_notRange)
-    done
-
-  from ctcd show "ct_idle_or_in_cur_domain' state'"
-    apply (simp add: ct_idle_or_in_cur_domain'_def tcb_in_cur_domain'_def)
-    apply (intro impI)
-    apply (elim disjE impE)
-     apply simp+
-    apply (intro impI)
-    apply (rule disjI2)
-    apply (drule obj_at'_and
-                   [THEN iffD2, OF conjI,
-                    OF ct_act [unfolded ct_in_state'_def st_tcb_at'_def]])
-    apply (clarsimp simp: obj_at'_real_def)
-    apply (frule if_live_then_nonz_capE'[OF iflive, OF ko_wp_at'_weakenE])
-     apply (clarsimp simp: projectKOs)
-     apply (case_tac "tcbState obj")
-            apply (clarsimp simp: projectKOs)+
-    apply (clarsimp dest!: ex_nonz_cap_notRange elim!: ko_wp_at'_weakenE)
-    done
-
-  from cdm show "ksCurDomain s \<le> maxDomain" .
+  from cdm show "ksCurDomain s' \<le> maxDomain" .
 
   from invs
-  have urz: "untyped_ranges_zero' s" by (simp add: invs'_def valid_state'_def)
+  have urz: "untyped_ranges_zero' s'" by (simp add: invs'_def)
   show "untyped_ranges_zero_inv (cteCaps_of state')
-    (gsUntypedZeroRanges s)"
+    (gsUntypedZeroRanges s')"
     apply (simp add: untyped_zero_ranges_cte_def
                      urz[unfolded untyped_zero_ranges_cte_def, rule_format, symmetric])
     apply (clarsimp simp: fun_eq_iff intro!: arg_cong[where f=Ex])
@@ -1611,6 +1768,7 @@ lemma doMachineOp_modify:
   apply (rule ext)
   apply (simp add: simpler_gets_def simpler_modify_def bind_def)
   done
+
 context begin interpretation Arch . (*FIXME: arch_split*)
 lemma deleteObjects_invs':
   "\<lbrace>cte_wp_at' (\<lambda>c. cteCap c = UntypedCap d ptr bits idx) p
@@ -1633,8 +1791,11 @@ proof -
   apply (simp cong: if_cong)
   apply (subgoal_tac "is_aligned ptr bits \<and> 2 \<le> bits \<and> bits < word_bits",simp)
    apply clarsimp
-   apply (frule(2) delete_locale.intro, simp_all)[1]
-   apply (rule subst[rotated, where P=invs'], erule delete_locale.delete_invs')
+   apply (frule delete_locale.intro; simp add: deletionIsSafe_def sym_refs_asrt_def valid_idle'_asrt_def)
+    apply (rule subst[rotated, where P=invs'], erule delete_locale.delete_invs')
+     apply (clarsimp simp: deletionIsSafe_def)
+     apply blast
+    apply blast
    apply (simp add: field_simps)
   apply clarsimp
   apply (drule invs_valid_objs')
@@ -1664,12 +1825,12 @@ lemma deleteObjects_st_tcb_at':
      apply (fastforce elim: ko_wp_at'_weakenE)
     apply (erule if_live_then_nonz_capD' [rotated])
      apply (clarsimp simp: projectKOs)
-    apply (clarsimp simp: invs'_def valid_state'_def)
+    apply (clarsimp simp: invs'_def)
    apply (clarsimp simp: pred_tcb_at'_def obj_at'_real_def
                   field_simps ko_wp_at'_def ps_clear_def
                   cong:if_cong
                   split: option.splits)
-  apply (simp add: delete_locale_def)
+  apply (simp add: delete_locale_def deletionIsSafe_def sym_refs_asrt_def valid_idle'_asrt_def)
   done
 
 lemma deleteObjects_cap_to':
@@ -1695,14 +1856,14 @@ lemma deleteObjects_cap_to':
                          else ksPSpace s x\<rparr>)",erule ssubst)
     apply (simp add: field_simps ex_cte_cap_wp_to'_def cong:if_cong)
    apply simp
-  apply (simp add: delete_locale_def)
+  apply (simp add: delete_locale_def deletionIsSafe_def sym_refs_asrt_def valid_idle'_asrt_def)
   done
 
 lemma valid_untyped_no_overlap:
   "\<lbrakk> valid_untyped' d ptr bits idx s; is_aligned ptr bits; valid_pspace' s \<rbrakk>
   \<Longrightarrow> pspace_no_overlap' ptr bits (s\<lparr>ksPSpace := ksPSpace s |` (- {ptr .. ptr + 2 ^ bits - 1})\<rparr>)"
   apply (clarsimp simp del: atLeastAtMost_iff
-            simp: pspace_no_overlap'_def valid_cap'_def valid_untyped'_def is_aligned_neg_mask_eq)
+                  simp: pspace_no_overlap'_def valid_cap'_def valid_untyped'_def)
   apply (drule_tac x=x in spec)
   apply (drule restrict_map_Some_iff[THEN iffD1])
   apply clarsimp
@@ -1997,36 +2170,19 @@ lemma locateCTE_case:
   done
 
 lemma cte_wp_at_top:
-  "(cte_wp_at' \<top> src s)
-  = (\<exists>a b. ( fst (lookupAround2 src (ksPSpace s)) = Some (a, b) \<and>
-  cte_check b src a (snd (lookupAround2 src (ksPSpace s)))))"
-  apply (simp add:cte_wp_at'_def getObject_def gets_def
-    get_def bind_def return_def split_def
-    assert_opt_def fail_def
-    split:option.splits)
-  apply (clarsimp simp:loadObject_cte)
-  apply (case_tac b,simp_all)
-       apply ((simp add: typeError_def fail_def cte_check_def
-                  split: Structures_H.kernel_object.splits)+)[5]
-    apply (simp add:loadObject_cte cte_check_def
-      tcbIPCBufferSlot_def tcbCallerSlot_def
-      tcbReplySlot_def tcbCTableSlot_def
-      tcbVTableSlot_def objBits_simps cteSizeBits_def)
-    apply (simp add:alignCheck_def bind_def
-      alignError_def fail_def return_def objBits_simps
-      magnitudeCheck_def in_monad is_aligned_mask
-      when_def split:option.splits)
-    apply (intro conjI impI allI,simp_all add:not_le)
-   apply (clarsimp simp:cte_check_def)
-   apply (simp add:alignCheck_def bind_def
-     alignError_def fail_def return_def objBits_simps
-     magnitudeCheck_def in_monad is_aligned_mask
-     when_def split:option.splits)
-    apply (intro conjI impI allI,simp_all add:not_le)
-  apply (simp add:typeError_def fail_def
-         cte_check_def split:Structures_H.kernel_object.splits)+
-  done
-
+  "cte_wp_at' \<top> src s
+   = (\<exists>a b. fst (lookupAround2 src (ksPSpace s)) = Some (a, b) \<and>
+            cte_check b src a (snd (lookupAround2 src (ksPSpace s))))"
+  apply (simp add: cte_wp_at'_def getObject_def gets_def get_def bind_def return_def split_def
+                   assert_opt_def fail_def gets_the_def readObject_def omonad_defs obind_def
+            split: option.splits)
+  apply (clarsimp simp: loadObject_cte)
+  by (case_tac b;
+      simp add: typeError_def read_typeError_def obind_def omonad_defs cte_check_def
+                read_alignCheck_def read_magnitudeCheck_def read_alignError_def is_aligned_mask
+                objBits_simps tcbSlot_defs cteSizeBits_def
+         split: option.split;
+      fastforce)
 
 lemma neq_out_intv:
   "\<lbrakk>a \<noteq> b; b \<notin> {a..a + c - 1} - {a} \<rbrakk> \<Longrightarrow> b \<notin> {a..a + c - 1}"
@@ -2118,10 +2278,11 @@ proof -
   apply (drule(1) src_in_range)+
   apply (drule base_member_set[OF pspace_alignedD'])
     apply simp
-   apply (simp add:objBitsKO_bounded2[unfolded word_bits_def,simplified])
-  apply (drule base_member_set[OF pspace_alignedD'])
+   apply (simp add: word_bits_def)
+  apply (frule base_member_set[OF pspace_alignedD'])
     apply simp
-   apply (simp add:objBitsKO_bounded2[unfolded word_bits_def,simplified])
+   apply (fold word_bits_def)
+   apply (erule (1) pspace_boundedD')
   apply (clarsimp simp:field_simps)
   apply blast
   done
@@ -2233,31 +2398,28 @@ lemma createObject_cte_wp_at':
   "\<lbrace>\<lambda>s. Types_H.getObjectSize ty us < word_bits \<and>
         is_aligned ptr (Types_H.getObjectSize ty us) \<and>
         pspace_no_overlap' ptr (Types_H.getObjectSize ty us) s \<and>
-        cte_wp_at' (\<lambda>c. P c) slot s \<and> pspace_aligned' s \<and>
-        pspace_distinct' s\<rbrace>
+        (ty = APIObjectType SchedContextObject \<longrightarrow> sc_size_bounds us) \<and>
+        cte_wp_at' (\<lambda>c. P c) slot s \<and> pspace_aligned' s \<and> pspace_distinct' s \<and> pspace_bounded' s\<rbrace>
    RetypeDecls_H.createObject ty ptr us d
    \<lbrace>\<lambda>r s. cte_wp_at' (\<lambda>c. P c) slot s \<rbrace>"
   apply (simp add:createObject_def)
   apply (rule hoare_pre)
-   apply (wpc
-        | wp createObjects_orig_cte_wp_at'[where sz = "(Types_H.getObjectSize ty us)"]
-             threadSet_cte_wp_at'
-        | simp add: ARM_H.createObject_def placeNewDataObject_def
-                    unless_def placeNewObject_def2 objBits_simps range_cover_full
-                    curDomain_def pageBits_def ptBits_def
-                    pdBits_def getObjSize_simps archObjSize_def
-                    apiGetObjectSize_def tcbBlockSizeBits_def
-                    epSizeBits_def ntfnSizeBits_def
-                    cteSizeBits_def pteBits_def pdeBits_def
-        | intro conjI impI | clarsimp dest!: arch_toAPIType_simps)+
-  done
+  by (wpc
+    | wp createObjects_orig_cte_wp_at'[where sz = "(Types_H.getObjectSize ty us)"]
+         threadSet_cte_wp_at'
+    | simp add: ARM_H.createObject_def placeNewDataObject_def unless_def placeNewObject_def2
+                objBits_simps range_cover_full curDomain_def pageBits_def ptBits_def pdBits_def
+                getObjSize_simps archObjSize_def apiGetObjectSize_def tcbBlockSizeBits_def
+                epSizeBits_def ntfnSizeBits_def scBits_simps cteSizeBits_def pteBits_def pdeBits_def
+    | intro conjI impI | clarsimp dest!: arch_toAPIType_simps)+
 
 lemma createObject_getCTE_commute:
   "monad_commute
-     (cte_wp_at' (\<lambda>_. True) dests and pspace_aligned' and pspace_distinct' and
+     (cte_wp_at' (\<lambda>_. True) dests and pspace_aligned' and pspace_distinct' and pspace_bounded' and
       pspace_no_overlap' ptr (Types_H.getObjectSize ty us) and
       K (ptr \<noteq> dests) and K (Types_H.getObjectSize ty us < word_bits) and
-      K (is_aligned ptr (Types_H.getObjectSize ty us)))
+      K (is_aligned ptr (Types_H.getObjectSize ty us)) and
+      K (ty = APIObjectType SchedContextObject \<longrightarrow> sc_size_bounds us))
      (RetypeDecls_H.createObject ty ptr us d) (getCTE dests)"
   apply (rule monad_commute_guard_imp[OF commute_commute])
    apply (rule getCTE_commute)
@@ -2285,7 +2447,7 @@ lemma simpler_placeNewObject_def:
     apply clarsimp
     apply (drule(1) pspace_alignedD')
     apply (simp add:is_aligned_no_overflow)
-   apply (clarsimp simp: is_aligned_neg_mask_eq shiftL_nat p_assoc_help)
+   apply (clarsimp simp: shiftL_nat p_assoc_help)
   apply simp
   done
 
@@ -2536,8 +2715,7 @@ lemma placeNewObject_modify_commute:
     apply simp
    apply (drule_tac x = ptr' in in_empty_interE)
      apply (clarsimp simp:is_aligned_no_overflow)
-    apply (clarsimp simp:range_cover_def ptr_add_def
-     is_aligned_neg_mask_eq obj_range'_def p_assoc_help)
+    apply (clarsimp simp:range_cover_def ptr_add_def obj_range'_def p_assoc_help)
    apply simp
   done
 
@@ -2563,9 +2741,9 @@ lemma locateCTE_ko_wp_at':
    \<lbrace>\<lambda>rv. ko_wp_at' \<top> rv \<rbrace>"
   apply (clarsimp simp:locateCTE_def split_def)
   apply wp
-  apply (clarsimp simp:cte_wp_at'_def getObject_def
-    gets_def split_def get_def bind_def return_def
-    ko_wp_at'_def lookupAround2_char1 assert_opt_def)
+  apply (clarsimp simp: cte_wp_at'_def getObject_def gets_the_def  obind_def omonad_defs
+                        gets_def split_def get_def bind_def return_def readObject_def
+                        ko_wp_at'_def lookupAround2_char1 assert_opt_def)
   apply (clarsimp split:option.splits
     simp:fail_def return_def lookupAround2_char1)
   apply (case_tac ba)
@@ -2573,10 +2751,10 @@ lemma locateCTE_ko_wp_at':
     apply (clarsimp simp:lookupAround2_char1
       objBits_simps cte_update_def)
     apply (drule(1) pspace_distinctD')+
-    apply (simp add:objBits_simps)
+    apply (simp add: objBits_simps' word_bits_def)
   apply (clarsimp simp:objBits_simps cte_update_def)
   apply (drule(1) pspace_distinctD')+
-  apply (simp add:objBits_simps)
+  apply (simp add: objBits_simps' word_bits_def)
   done
 
 
@@ -2605,65 +2783,29 @@ lemma doMachineOp_upd_heap_commute:
   done
 
 lemma magnitudeCheck_det:
-  "\<lbrakk>ksPSpace s ptr = Some ko; is_aligned ptr (objBitsKO ko);
+  "\<lbrakk>ksPSpace s ptr = Some ko; is_aligned ptr (objBitsKO ko); objBitsKO ko < word_bits;
     ps_clear ptr (objBitsKO ko) s\<rbrakk>
-   \<Longrightarrow> magnitudeCheck ptr (snd (lookupAround2 ptr (ksPSpace s)))
-                          (objBitsKO ko) s =
+   \<Longrightarrow> magnitudeCheck ptr (snd (lookupAround2 ptr (ksPSpace s))) (objBitsKO ko) s =
        ({((), s)},False)"
-  apply (frule in_magnitude_check'[THEN iffD2])
-   apply (case_tac ko)
-     apply (simp add: objBits_simps' pageBits_def)+
-    apply (rename_tac arch_kernel_object)
-    apply (case_tac arch_kernel_object)
-     apply (simp add:archObjSize_def pageBits_def pteBits_def pdeBits_def)+
-  apply (subgoal_tac
-    "\<not> snd (magnitudeCheck ptr (snd (lookupAround2 ptr (ksPSpace s))) (objBitsKO ko) s)")
+  apply (frule in_magnitude_check'[THEN iffD2]; simp)
+  apply (subgoal_tac "\<not> snd (magnitudeCheck ptr (snd (lookupAround2 ptr (ksPSpace s))) (objBitsKO ko) s)")
    apply (drule singleton_in_magnitude_check)
    apply (drule_tac x = s in spec)
-   apply (case_tac
-    "(magnitudeCheck ptr (snd (lookupAround2 ptr (ksPSpace s))) (objBitsKO ko) s)")
-    apply simp
+   apply (case_tac "(magnitudeCheck ptr (snd (lookupAround2 ptr (ksPSpace s))) (objBitsKO ko) s)")
+   apply simp
   apply (rule ccontr)
-  apply (clarsimp simp:magnitudeCheck_assert assert_def fail_def return_def
-    split:if_splits option.splits)
+  apply (clarsimp simp: magnitudeCheck_assert assert_def fail_def return_def
+                  split: if_splits option.splits)
   done
 
 lemma getPDE_det:
   "ko_wp_at' ((=) (KOArch (KOPDE pde))) p s
    \<Longrightarrow> getObject p s = ({((pde::ARM_H.pde),s)},False)"
-  apply (clarsimp simp:ko_wp_at'_def getObject_def split_def
-                       bind_def gets_def return_def get_def
-                       assert_opt_def split:if_splits)
-
-  apply (clarsimp simp: fail_def return_def lookupAround2_known1)
-   apply (simp add: loadObject_default_def)
-  apply (clarsimp simp:projectKO_def projectKO_opt_pde alignCheck_def
-    is_aligned_mask objBits_simps unless_def)
-  apply (clarsimp simp:bind_def return_def)
-  apply (intro conjI)
-   apply (intro set_eqI iffI)
-    apply clarsimp
-    apply (subst (asm) in_magnitude_check')
-     apply (simp add:archObjSize_def is_aligned_mask pteBits_def pdeBits_def)+
-    apply (rule bexI[rotated])
-     apply (rule in_magnitude_check'[THEN iffD2])
-      apply (simp add:is_aligned_mask)+
-   apply (clarsimp simp:image_def)
-  apply (clarsimp simp:magnitudeCheck_assert assert_def
-    objBits_def archObjSize_def
-    return_def fail_def lookupAround2_char2 split:option.splits if_split_asm)
-  apply (rule ccontr)
-  apply (simp add:ps_clear_def field_simps pteBits_def pdeBits_def)
-  apply (erule_tac x = x2 in in_empty_interE)
-   apply (clarsimp simp:less_imp_le)
-   apply (rule conjI)
-    apply (subst add.commute)
-    apply (rule word_diff_ls')
-     apply (clarsimp simp:field_simps not_le plus_one_helper)
-    apply (simp add:field_simps is_aligned_no_wrap' is_aligned_mask)
-   apply simp
-  apply auto
-  done
+  by (clarsimp simp: getObject_def split_def gets_the_def ko_wp_at'_def obj_at'_def
+                     bind_def gets_def return_def get_def projectKOs
+                     assert_opt_def fail_def typ_at'_def
+                     no_ofailD[OF no_ofail_pde_at'_readObject]
+              split: if_splits option.splits)
 
 lemma in_dom_eq:
   "m a = Some obj \<Longrightarrow> dom (\<lambda>b. if b = a then Some g else m b) = dom m"
@@ -2742,7 +2884,7 @@ lemma getPDE_doMachineOp_commute:
 
 lemma getPDE_placeNewObject_commute:
   "monad_commute
-     (pde_at' src and pspace_distinct' and pspace_aligned' and
+     (pde_at' src and pspace_distinct' and pspace_aligned' and pspace_bounded' and
       pspace_no_overlap' ptr (objBitsKO (injectKOS val) + sz) and
       K (is_aligned ptr (objBitsKO (injectKOS val) + sz) \<and>
          objBitsKO (injectKOS val) + sz < word_bits) )
@@ -2778,15 +2920,15 @@ lemma storePDE_det:
    \<Longrightarrow> storePDE ptr (new_pde::ARM_H.pde) s =
        modify
          (ksPSpace_update (\<lambda>_. ksPSpace s(ptr \<mapsto> KOArch (KOPDE new_pde)))) s"
-  apply (clarsimp simp:ko_wp_at'_def storePDE_def split_def
-                       bind_def gets_def return_def
-                       get_def setObject_def
-                       assert_opt_def split:if_splits)
-  apply (clarsimp simp:lookupAround2_known1 return_def alignCheck_def
-                       updateObject_default_def split_def
-                       archObjSize_def unless_def projectKO_def
-                       projectKO_opt_pde bind_def when_def
-                       is_aligned_mask[symmetric] objBits_simps)
+  apply (clarsimp simp: ko_wp_at'_def storePDE_def split_def
+                        bind_def gets_def return_def
+                        get_def setObject_def
+                        assert_opt_def split:if_splits)
+  apply (clarsimp simp: lookupAround2_known1 return_def alignCheck_def
+                        updateObject_default_def split_def gets_the_def
+                        archObjSize_def unless_def projectKO_def read_alignCheck_def
+                        projectKO_opt_pde bind_def when_def omonad_defs
+                        is_aligned_mask[symmetric] objBits_simps)
   apply (drule magnitudeCheck_det)
     apply (simp add:objBits_simps archObjSize_def)+
   apply (simp add:simpler_modify_def)
@@ -2869,6 +3011,22 @@ lemma modify_pde_pspace_aligned':
   apply simp
   done
 
+lemma modify_pde_pspace_bounded':
+  "\<lbrace>pde_at' ptr and pspace_bounded'\<rbrace>
+   modify (ksPSpace_update (\<lambda>ps. ps(ptr \<mapsto> KOArch (KOPDE new_pde))))
+   \<lbrace>\<lambda>a. pspace_bounded'\<rbrace>"
+  apply (clarsimp simp: simpler_modify_def ko_wp_at'_def valid_def typ_at'_def)
+  apply (case_tac ko,simp_all)
+  apply (rename_tac arch_kernel_object)
+  apply (case_tac arch_kernel_object,simp_all)
+  apply (subst pspace_bounded'_def)
+  apply (intro ballI)
+  apply (erule domE)
+  apply (clarsimp split:if_splits)
+   apply (simp add:objBits_simps archObjSize_def)
+  apply (fastforce dest!: pspace_boundedD')
+  done
+
 lemma modify_pde_psp_no_overlap':
   "\<lbrace>pde_at' ptr and pspace_no_overlap' ptr' sz\<rbrace>
    modify (ksPSpace_update (\<lambda>ps. ps(ptr \<mapsto> KOArch (KOPDE new_pde))))
@@ -2958,7 +3116,7 @@ lemma doMachineOp_storePDE_commute:
 
 lemma storePDE_placeNewObject_commute:
   "monad_commute
-     (pde_at' src and pspace_distinct' and pspace_aligned' and
+     (pde_at' src and pspace_distinct' and pspace_aligned' and pspace_bounded' and
       pspace_no_overlap' ptr (objBitsKO (injectKOS val) + sz) and
       K (is_aligned ptr (objBitsKO (injectKOS val) + sz) \<and>
       objBitsKO (injectKOS val) + sz < word_bits) )
@@ -3032,11 +3190,9 @@ lemma cte_wp_at_modify_pde:
    apply (rule disjI1)
    apply (clarsimp simp add:ko_wp_at'_def)
    apply (intro conjI impI)
-      apply (simp add:objBits_simps archObjSize_def)
-     apply (clarsimp simp:projectKO_opt_cte)
-    apply (simp add:ps_clear_def)+
-    apply (clarsimp simp:objBits_simps archObjSize_def)
-   apply (simp add:ps_clear_def)
+       apply (simp add:objBits_simps archObjSize_def)
+      apply (clarsimp simp:projectKO_opt_cte)
+     apply (clarsimp simp: ps_clear_def objBits_simps archObjSize_def)+
    apply (rule ccontr)
    apply simp
    apply (erule in_emptyE, blast)
@@ -3044,11 +3200,9 @@ lemma cte_wp_at_modify_pde:
   apply (rule disjI2)
   apply (clarsimp simp:ko_wp_at'_def)
   apply (intro conjI impI)
-     apply (simp add:objBits_simps archObjSize_def)+
-    apply (clarsimp simp:projectKO_opt_cte projectKO_opt_tcb)
-    apply (simp add:ps_clear_def)+
-   apply (clarsimp simp:objBits_simps archObjSize_def)
-  apply (simp add:ps_clear_def)
+      apply (simp add:objBits_simps archObjSize_def)+
+     apply (clarsimp simp:projectKO_opt_cte projectKO_opt_tcb)
+    apply (clarsimp simp: ps_clear_def objBits_simps archObjSize_def)+
   apply (rule ccontr)
   apply simp
   apply (erule in_emptyE)
@@ -3060,7 +3214,7 @@ lemma storePDE_setCTE_commute:
           Int_atLeastAtMost atLeastatMost_empty_iff split_paired_Ex
           atLeastAtMost_iff
   shows "monad_commute
-     (pde_at' ptr and pspace_distinct' and pspace_aligned' and
+     (pde_at' ptr and pspace_distinct' and pspace_aligned' and pspace_bounded' and
       cte_wp_at' (\<lambda>_. True) src)
      (setCTE src cte) (storePDE ptr (new_pde::ARM_H.pde))"
   apply (rule commute_name_pre_state)
@@ -3082,33 +3236,38 @@ lemma storePDE_setCTE_commute:
    apply (rule monad_commute_split)
      apply (subst modify_specify)
      apply (rule modify_obj_commute')
+    apply (subst modify_specify)
     apply (rule commute_commute[OF locateCTE_commute])
-         apply (wp locateCTE_cte_no_fail non_fail_modify
-                   modify_pde_pspace_distinct'
-                   modify_pde_pspace_aligned'| subst modify_specify)+
-     apply (clarsimp simp:simpler_modify_def valid_def typ_at'_def)
-     apply (clarsimp simp:ko_wp_at'_def dest!: koTypeOf_pde)
-     apply (intro conjI impI)
-        apply (clarsimp simp:objBits_simps archObjSize_def)+
-      apply (simp add:ps_clear_def in_dom_eq)
-     apply (simp add:ps_clear_def in_dom_eq)
-    apply (clarsimp simp:simpler_modify_def valid_def)
-    apply (clarsimp simp:typ_at'_def ko_wp_at'_def)
-    apply (case_tac ko,simp_all add:koTypeOf_def )[1]
-    apply (rename_tac arch_kernel_object)
-    apply (case_tac arch_kernel_object,simp_all add:archTypeOf_def)[1]
-    apply (erule(2) cte_wp_at_modify_pde)
+          apply (rule non_fail_modify)
+         apply (rule locateCTE_cte_no_fail)
+        apply (rule modify_pde_pspace_distinct')
+       apply (rule modify_pde_pspace_aligned')
+      apply (rule modify_pde_pspace_bounded')
+     apply (wpsimp wp: modify_wp)
+     apply (case_tac "dest = ptr"; clarsimp?)
+      apply (subst non_sc_same_typ_at'_ko_wp_at'_set_ko'_iff[unfolded unfold_set_ko',
+                                                             unfolded fun_upd_def];
+             force?)
+      apply (clarsimp simp: ko_wp_at'_def typ_at'_def)
+      apply (erule_tac P=Q in rsubst)
+      apply (rule koType_objBitsKO; simp)
+     apply (subst ko_wp_at'_set_ko'_distinct[simplified unfold_set_ko',
+                                                   unfolded fun_upd_def];
+            clarsimp simp: ko_wp_at'_def typ_at'_def)
+    apply (clarsimp simp: simpler_modify_def valid_def)
+    apply (frule typ_at'_ksPSpace_exI, clarsimp)
+    apply (rule cte_wp_at_modify_pde[unfolded unfold_set_ko']; simp)
    apply wp
    apply (thin_tac "cte_wp_at' P src s" for P s)+
    apply (clarsimp simp: typ_at'_def cte_wp_at_obj_cases_mask obj_at'_real_def)
    apply (wp locateCTE_ret_neq locateCTE_ko_wp_at')
-  apply (clarsimp simp:ko_wp_at'_def objBits_simps archObjSize_def typ_at'_def)
+  apply (clarsimp simp: ko_wp_at'_def objBits_simps archObjSize_def typ_at'_def)
   apply fastforce
   done
 
 lemma setCTE_gets_globalPD_commute:
   "monad_commute
-     (cte_wp_at' (\<lambda>_. True) src and pspace_distinct' and pspace_aligned')
+     (cte_wp_at' (\<lambda>_. True) src and pspace_distinct' and pspace_aligned' and pspace_bounded')
      (setCTE src cte) (gets (armKSGlobalPD \<circ> ksArchState))"
   apply (simp add:setCTE_def2)
   apply (rule monad_commute_guard_imp)
@@ -3118,7 +3277,6 @@ lemma setCTE_gets_globalPD_commute:
          apply (wp locateCTE_cte_no_fail)+
      apply clarsimp
     apply (wp|clarsimp)+
-  apply fastforce
   done
 
 lemma placeNewObject_gets_globalPD_commute:
@@ -3142,7 +3300,7 @@ lemma placeNewObject_gets_globalPD_commute:
 
 lemma copyGlobalMappings_setCTE_commute:
   "monad_commute
-     (valid_arch_state' and pspace_distinct' and pspace_aligned' and
+     (valid_arch_state' and pspace_distinct' and pspace_aligned' and pspace_bounded' and
       cte_wp_at' (\<lambda>_. True) src and page_directory_at' ptr)
      (copyGlobalMappings ptr) (setCTE src cte)"
   apply (clarsimp simp:copyGlobalMappings_def)
@@ -3201,7 +3366,7 @@ lemma placeNewObject_valid_arch_state:
 
 lemma placeNewObject_pd_at':
   "\<lbrace>K (is_aligned ptr pdBits) and pspace_no_overlap' ptr pdBits and
-    pspace_aligned' and pspace_distinct'\<rbrace>
+    pspace_aligned' and pspace_distinct' and pspace_bounded'\<rbrace>
    placeNewObject ptr (makeObject::ARM_H.pde)
                       (pdBits - objBits (makeObject::ARM_H.pde))
    \<lbrace>\<lambda>rv s. page_directory_at' ptr s\<rbrace>"
@@ -3238,38 +3403,10 @@ lemma setCTE_modify_gsUserPages_commute:
 lemma getTCB_det:
   "ko_wp_at' ((=) (KOTCB tcb)) p s
    \<Longrightarrow> getObject p s = ({(tcb,s)},False)"
-  apply (clarsimp simp:ko_wp_at'_def getObject_def split_def
-                       bind_def gets_def return_def get_def
-                       assert_opt_def split:if_splits)
-  apply (clarsimp simp: fail_def return_def lookupAround2_known1)
-   apply (simp add:loadObject_default_def)
-  apply (clarsimp simp:projectKO_def projectKO_opt_tcb alignCheck_def
-    is_aligned_mask objBits_simps' unless_def)
-  apply (clarsimp simp:bind_def return_def)
-  apply (intro conjI)
-   apply (intro set_eqI iffI)
-    apply clarsimp
-    apply (subst (asm) in_magnitude_check')
-     apply (simp add:archObjSize_def is_aligned_mask)+
-    apply (rule bexI[rotated])
-     apply (rule in_magnitude_check'[THEN iffD2])
-      apply (simp add:is_aligned_mask)+
-   apply (clarsimp simp:image_def)
-  apply (clarsimp simp:magnitudeCheck_assert assert_def
-    objBits_def archObjSize_def
-    return_def fail_def lookupAround2_char2 split:option.splits if_split_asm)
-  apply (rule ccontr)
-  apply (simp add:ps_clear_def field_simps)
-  apply (erule_tac x = x2 in in_empty_interE)
-   apply (clarsimp simp:less_imp_le)
-   apply (rule conjI)
-    apply (subst add.commute)
-    apply (rule word_diff_ls')
-     apply (clarsimp simp:field_simps not_le plus_one_helper)
-    apply (simp add:field_simps is_aligned_no_wrap' is_aligned_mask)
-   apply simp
-  apply auto
-  done
+  by (clarsimp simp: ko_wp_at'_def getObject_def split_def gets_the_def
+                     bind_def gets_def return_def get_def fail_def assert_opt_def
+                     no_ofailD[OF no_ofail_tcb_at'_readObject] obj_at'_def projectKOs
+              split: if_splits option.split dest!: readObject_misc_ko_at')
 
 lemma threadSet_det:
   "tcb_at' ptr s
@@ -3283,10 +3420,10 @@ lemma threadSet_det:
   apply (clarsimp simp:setObject_def gets_def get_def)
   apply (subst bind_def)
   apply (clarsimp simp:split_def)
-  apply (simp add:lookupAround2_known1 bind_assoc projectKO_def
-    assert_opt_def updateObject_default_def projectKO_opt_tcb)
-  apply (clarsimp simp add:
-    alignCheck_def unless_def when_def
+  apply (simp add:lookupAround2_known1 bind_assoc projectKO_def gets_the_def
+    assert_opt_def updateObject_default_def projectKO_opt_tcb omonad_defs)
+  apply (clarsimp simp: read_alignCheck_def omonad_defs
+    alignCheck_def unless_def when_def gets_the_def
     is_aligned_mask objBits_simps)
   apply (clarsimp simp:magnitudeCheck_det bind_def)
   apply (cut_tac ko = "KOTCB obj" in magnitudeCheck_det)
@@ -3297,7 +3434,8 @@ lemma threadSet_det:
 
 lemma setCTE_modify_tcbDomain_commute:
  " monad_commute
-    (tcb_at' ptr and cte_wp_at' (\<lambda>_. True) src and pspace_distinct' and pspace_aligned') (setCTE src cte)
+    (tcb_at' ptr and cte_wp_at' (\<lambda>_. True) src and pspace_distinct' and pspace_aligned' and pspace_bounded')
+    (setCTE src cte)
     (threadSet (tcbDomain_update (\<lambda>_. ra)) ptr)"
   proof -
     note blah[simp del] =  atLeastatMost_subset_iff atLeastLessThan_iff
@@ -3315,15 +3453,16 @@ lemma setCTE_modify_tcbDomain_commute:
       prefer 2
        apply (clarsimp simp:obj_at'_def)
        apply (intro conjI impI)
-           apply simp
-          apply (clarsimp simp:projectKO_eq
-            projectKO_opt_tcb split:Structures_H.kernel_object.split_asm)
-          apply (simp add:cte_update_def)
-         apply (clarsimp simp:projectKO_eq
-           projectKO_opt_tcb split:Structures_H.kernel_object.split_asm)
-         apply (simp add:ps_clear_def)
-        apply (clarsimp simp:projectKO_eq
-          projectKO_opt_tcb split:Structures_H.kernel_object.split_asm)
+            apply simp
+           apply (clarsimp simp: projectKO_eq projectKO_opt_tcb
+                          split: Structures_H.kernel_object.split_asm)
+           apply (simp add:cte_update_def)
+          apply (clarsimp simp: projectKO_eq projectKO_opt_tcb
+                         split: Structures_H.kernel_object.split_asm)
+          apply (simp add:ps_clear_def)
+         apply clarsimp
+        apply (clarsimp simp: projectKO_eq projectKO_opt_tcb
+                       split: Structures_H.kernel_object.split_asm)
        apply (simp add:ps_clear_def)
        apply (rule ccontr,simp)
        apply (erule in_emptyE)
@@ -3386,25 +3525,29 @@ lemma curDomain_commute:
 
 crunch inv[wp]: curDomain P
 
+(* FIXME RT: move to first occurence of atLeastatMost_subset_iff; usually the "notes" can just be removed *)
+lemmas atLeastAtMost_simps =
+  atLeastatMost_subset_iff atLeastLessThan_iff Int_atLeastAtMost atLeastatMost_empty_iff
+  atLeastAtMost_iff split_paired_Ex
+
 lemma placeNewObject_tcb_at':
-  notes [simp del] = atLeastatMost_subset_iff atLeastLessThan_iff
-                     Int_atLeastAtMost atLeastatMost_empty_iff split_paired_Ex atLeastAtMost_iff
-  shows "\<lbrace> pspace_aligned' and pspace_distinct'
-             and pspace_no_overlap' ptr (objBits (makeObject::tcb))
-             and  K(is_aligned ptr  (objBits (makeObject::tcb))) \<rbrace>
-         placeNewObject ptr (makeObject::tcb) 0
-         \<lbrace>\<lambda>_ s. tcb_at' ptr s \<rbrace>"
+  "\<lbrace>pspace_aligned' and pspace_distinct'
+    and pspace_no_overlap' ptr (objBits (makeObject::tcb))
+    and  K (is_aligned ptr (objBits (makeObject::tcb))) \<rbrace>
+   placeNewObject ptr (makeObject::tcb) 0
+   \<lbrace>\<lambda>rv s. tcb_at' ptr s \<rbrace>"
   apply (simp add: placeNewObject_def placeNewObject'_def split_def)
-  apply (wp hoare_unless_wp |wpc | simp add:alignError_def)+
-  by (auto simp: obj_at'_def is_aligned_mask lookupAround2_None1
-                    lookupAround2_char1 field_simps objBits_simps
-                    projectKO_opt_tcb projectKO_def return_def ps_clear_def
-           split: if_splits
-           dest!: pspace_no_overlap_disjoint')
+  apply (wp hoare_unless_wp | wpc | simp add:alignError_def)+
+  apply (auto simp: obj_at'_def is_aligned_mask lookupAround2_None1 lookupAround2_char1 field_simps
+                    projectKO_opt_tcb projectKO_def return_def ps_clear_def objBits_simps' oassert_opt_def
+                    word_bits_def
+              split: if_splits
+             dest!: pspace_no_overlap_disjoint')
+  done
 
 lemma monad_commute_if_weak_r:
-"\<lbrakk>monad_commute P1 f h1; monad_commute P2 f h2\<rbrakk> \<Longrightarrow>
-  monad_commute (P1 and P2) f (if d then h1 else h2)"
+  "\<lbrakk>monad_commute P1 f h1; monad_commute P2 f h2\<rbrakk> \<Longrightarrow>
+    monad_commute (P1 and P2) f (if d then h1 else h2)"
   apply (clarsimp)
   apply (intro conjI impI)
    apply (erule monad_commute_guard_imp,simp)+
@@ -3431,45 +3576,45 @@ lemma createObject_setCTE_commute:
          simp_all add: ARM_H.toAPIType_def)
         apply (rename_tac apiobject_type)
         apply (case_tac apiobject_type)
-            apply (simp_all add:
-                       ARM_H.getObjectSize_def apiGetObjectSize_def
-                       tcbBlockSizeBits_def epSizeBits_def ntfnSizeBits_def
-                       cteSizeBits_def)
-            \<comment> \<open>Untyped\<close>
-            apply (simp add: monad_commute_guard_imp[OF return_commute])
-           \<comment> \<open>TCB, EP, NTFN\<close>
-           apply (rule monad_commute_guard_imp[OF commute_commute])
-            apply (rule monad_commute_split[OF monad_commute_split])
-                apply (rule monad_commute_split[OF commute_commute[OF return_commute]])
-                 apply (rule setCTE_modify_tcbDomain_commute)
+              apply (simp_all add: ARM_H.getObjectSize_def apiGetObjectSize_def
+                                   tcbBlockSizeBits_def epSizeBits_def ntfnSizeBits_def
+                                   cteSizeBits_def)
+              \<comment> \<open>Untyped\<close>
+              apply (simp add: monad_commute_guard_imp[OF return_commute])
+             \<comment> \<open>TCB\<close>
+             apply (rule monad_commute_guard_imp[OF commute_commute])
+              apply (rule monad_commute_split[OF monad_commute_split[OF commute_commute]])
+                  apply (rule return_commute)
+                 apply (rule setCTE_placeNewObject_commute)
                 apply wp
                apply (rule curDomain_commute)
-               apply wp+
-             apply (rule setCTE_placeNewObject_commute)
-            apply (wp  placeNewObject_tcb_at' placeNewObject_cte_wp_at'
-              placeNewObject_pspace_distinct'
-              placeNewObject_pspace_aligned'
-              | clarsimp simp: objBits_simps')+
-           apply (rule monad_commute_guard_imp[OF commute_commute]
-            ,rule monad_commute_split[OF commute_commute[OF return_commute]]
-            ,rule setCTE_placeNewObject_commute
-            ,(wp|clarsimp simp: objBits_simps')+)+
-        \<comment> \<open>CNode\<close>
-        apply (rule monad_commute_guard_imp[OF commute_commute])
-         apply (rule monad_commute_split)+
-             apply (rule return_commute[THEN commute_commute])
-            apply (rule setCTE_modify_gsCNode_commute[of \<top>])
-           apply (rule hoare_triv[of \<top>])
-           apply wp
-          apply (rule setCTE_placeNewObject_commute)
-         apply (wp|clarsimp simp: objBits_simps')+
+               apply (wpsimp simp: objBits_simps')+
+             \<comment> \<open>EP, NTFN\<close>
+             apply (rule monad_commute_guard_imp[OF commute_commute],
+                    rule monad_commute_split[OF commute_commute[OF return_commute]],
+                    rule setCTE_placeNewObject_commute,
+                    (wpsimp simp: objBits_simps')+)+
+          \<comment> \<open>CNode\<close>
+          apply (rule monad_commute_guard_imp[OF commute_commute])
+           apply (rule monad_commute_split)+
+               apply (rule return_commute[THEN commute_commute])
+              apply (rule setCTE_modify_gsCNode_commute[of \<top>])
+             apply (rule hoare_triv[of \<top>])
+             apply wp
+            apply (rule setCTE_placeNewObject_commute)
+         apply (wpsimp simp: objBits_simps')+
+           \<comment> \<open>SchedContext, Reply\<close>
+           apply (rule monad_commute_guard_imp[OF commute_commute],
+                  rule monad_commute_split[OF commute_commute[OF return_commute]],
+                  rule setCTE_placeNewObject_commute,
+                  (wpsimp simp: objBits_simps' scBits_simps)+)+
        \<comment> \<open>Arch Objects\<close>
-       apply ((rule monad_commute_guard_imp[OF commute_commute]
-              , rule monad_commute_split[OF commute_commute[OF return_commute]]
-              , clarsimp simp: ARM_H.createObject_def
-                               placeNewDataObject_def bind_assoc split
-                          del: if_splits
-              ,(rule monad_commute_split return_commute[THEN commute_commute]
+       apply ((rule monad_commute_guard_imp[OF commute_commute],
+               rule monad_commute_split[OF commute_commute[OF return_commute]],
+               clarsimp simp: ARM_H.createObject_def
+                              placeNewDataObject_def bind_assoc split
+                         del: if_splits,
+               (rule monad_commute_split return_commute[THEN commute_commute]
                      setCTE_modify_gsUserPages_commute[of \<top>]
                      modify_wp[of "%_. \<top>"]
                      setCTE_doMachineOp_commute
@@ -3636,12 +3785,13 @@ lemma copyGlobalMappings_gsUntypedZeroRanges_commute':
   apply (rule monad_commute_guard_imp)
    apply (rule commute_commute[OF monad_commute_split[where P="\<top>"]])
      apply (rule mapM_x_commute[where f = id and P="\<top>\<top>"])
-      apply (simp add: storePDE_def getObject_def setObject_def cong: bind_cong)
+      apply (simp add: storePDE_def getObject_def setObject_def readObject_def cong: bind_cong)
       apply (strengthen monad_commute_guard_imp[OF monad_commute_split[where P="\<top>" and Q="\<top>\<top>"], OF _ _ hoare_vcg_prop]
          | simp add: modify_commute updateObject_default_def alignCheck_assert
                      magnitudeCheck_assert return_commute return_commute[THEN commute_commute]
-                     projectKO_def2 assert_commute2 assert_commute2[THEN commute_commute]
-                     assert_opt_def2 loadObject_default_def
+                     projectKO_def assert_commute2 assert_commute2[THEN commute_commute]
+                     assert_opt_def2 loadObject_default_def gets_the_def
+                     read_magnitudeCheck_assert omonad_defs obind_def
               split: option.split prod.split)+
       apply (simp add: monad_commute_def exec_gets exec_modify)
      apply wp
@@ -3768,11 +3922,13 @@ lemma new_cap_object_comm_helper:
    apply clarsimp
   done
 
-crunch pspace_aligned'[wp]: updateNewFreeIndex "pspace_aligned'"
-crunch pspace_distinct'[wp]: updateNewFreeIndex "pspace_distinct'"
-crunch valid_arch_state'[wp]: updateNewFreeIndex "valid_arch_state'"
-crunch pspace_no_overlap'[wp]: updateNewFreeIndex "pspace_no_overlap' ptr n"
-crunch ctes_of[wp]: updateNewFreeIndex "\<lambda>s. P (ctes_of s)"
+crunches updateNewFreeIndex
+  for pspace_aligned'[wp]: "pspace_aligned'"
+  and pspace_distinct'[wp]: "pspace_distinct'"
+  and pspace_bounded'[wp]: "pspace_bounded'"
+  and valid_arch_state'[wp]: "valid_arch_state'"
+  and pspace_no_overlap'[wp]: "pspace_no_overlap' ptr n"
+  and ctes_of[wp]: "\<lambda>s. P (ctes_of s)"
 
 lemma updateNewFreeIndex_cte_wp_at[wp]:
   "\<lbrace>\<lambda>s. P (cte_wp_at' P' p s)\<rbrace> updateNewFreeIndex slot \<lbrace>\<lambda>rv s. P (cte_wp_at' P' p s)\<rbrace>"
@@ -3921,13 +4079,13 @@ lemma createNewCaps_not_nc:
   by (wpsimp simp: Arch_createNewCaps_def split_del: if_split)
 
 lemma doMachineOp_psp_no_overlap:
-  "\<lbrace>\<lambda>s. pspace_no_overlap' ptr sz s \<and> pspace_aligned' s \<and> pspace_distinct' s \<rbrace>
+  "\<lbrace>\<lambda>s. pspace_no_overlap' ptr sz s \<and> pspace_aligned' s \<and> pspace_distinct' s \<and> pspace_bounded' s\<rbrace>
    doMachineOp f
    \<lbrace>\<lambda>y s. pspace_no_overlap' ptr sz s\<rbrace>"
-  by (wp pspace_no_overlap'_lift,simp)
+  by (wpsimp wp: pspace_no_overlap'_lift2)
 
 lemma createObjects'_psp_distinct:
-  "\<lbrace>pspace_aligned' and pspace_distinct' and
+  "\<lbrace>pspace_aligned' and pspace_distinct' and pspace_bounded' and
     pspace_no_overlap' ptr sz and
     K (range_cover ptr sz ((objBitsKO ko) + us) n \<and> n \<noteq> 0
     \<and> is_aligned ptr (objBitsKO ko + us) \<and> objBitsKO ko + us < word_bits)\<rbrace>
@@ -3952,7 +4110,7 @@ lemma createObjects'_psp_distinct:
   done
 
 lemma createObjects'_psp_aligned:
-  "\<lbrace>pspace_aligned' and pspace_distinct' and
+  "\<lbrace>pspace_aligned' and pspace_distinct' and pspace_bounded' and
     pspace_no_overlap' ptr sz and
     K (range_cover ptr sz ((objBitsKO ko) + us) n \<and> n \<noteq> 0
     \<and> is_aligned ptr (objBitsKO ko + us) \<and> objBitsKO ko + us < word_bits)\<rbrace>
@@ -4095,19 +4278,22 @@ lemma createNewCaps_pspace_no_overlap':
                               createObjects_def)
         apply (rule hoare_pre)
          apply wpc
-    apply (clarsimp simp: apiGetObjectSize_def  curDomain_def
-                          ARM_H.toAPIType_def tcbBlockSizeBits_def
-                          ARM_H.getObjectSize_def objBits_simps epSizeBits_def ntfnSizeBits_def
-                          cteSizeBits_def pageBits_def ptBits_def archObjSize_def pdBits_def
-                          createObjects_def Arch_createNewCaps_def
-                    split: apiobject_type.splits
-           | wp doMachineOp_psp_no_overlap createObjects'_pspace_no_overlap[where sz = sz]
-                createObjects'_psp_aligned[where sz = sz] createObjects'_psp_distinct[where sz = sz]
-                copyGlobalMappings_pspace_aligned' mapM_x_wp_inv
-                copyGlobalMappings_pspace_no_overlap'[where sz = sz] | assumption)+
-           apply (intro conjI range_cover_le[where n = "Suc n"] | simp)+
-            apply ((simp add:objBits_simps pageBits_def range_cover_def word_bits_def)+)[5]
-       by ((clarsimp simp: apiGetObjectSize_def
+               apply (clarsimp simp: apiGetObjectSize_def curDomain_def ARM_H.toAPIType_def
+                                     tcbBlockSizeBits_def ARM_H.getObjectSize_def objBits_simps
+                                     epSizeBits_def ntfnSizeBits_def cteSizeBits_def pageBits_def
+                                     ptBits_def archObjSize_def pdBits_def createObjects_def
+                                     Arch_createNewCaps_def scBits_simps word_bits_def
+                                     range_cover_le[where n = "Suc n"] range_cover.aligned
+                              split: apiobject_type.splits
+                     | wp doMachineOp_psp_no_overlap
+                          createObjects'_pspace_no_overlap[where sz = sz]
+                          createObjects'_psp_aligned[where sz = sz]
+                          createObjects'_psp_distinct[where sz = sz]
+                          copyGlobalMappings_pspace_aligned' mapM_x_wp_inv
+                          copyGlobalMappings_pspace_no_overlap'[where sz = sz]
+                     | (frule range_cover_sz'; fastforce simp: untypedBits_defs)
+                     | assumption)+
+       apply ((clarsimp simp: apiGetObjectSize_def
                               ARM_H.toAPIType_def tcbBlockSizeBits_def
                               ARM_H.getObjectSize_def objBits_simps epSizeBits_def ntfnSizeBits_def
                               cteSizeBits_def pageBits_def ptBits_def archObjSize_def pdBits_def
@@ -4117,10 +4303,12 @@ lemma createNewCaps_pspace_no_overlap':
                         split: apiobject_type.splits
                | wp doMachineOp_psp_no_overlap createObjects'_pspace_no_overlap
                     createObjects'_psp_aligned createObjects'_psp_distinct
+                    createObjects'_psp_bounded
                     copyGlobalMappings_pspace_aligned' mapM_x_wp_inv
                     copyGlobalMappings_pspace_no_overlap'
                | assumption | clarsimp simp: word_bits_def
                | intro conjI range_cover_le[where n = "Suc n"] range_cover.aligned)+)[6]
+  done
 
 lemma objSize_eq_capBits:
   "Types_H.getObjectSize ty us = APIType_capBits ty us"
@@ -4149,8 +4337,7 @@ lemma createNewCaps_ret_len:
           erule hoare_strengthen_post[OF createObjects_ret],clarsimp+ | intro conjI impI)+
        apply (rule hoare_pre,
           ((wp+)
-              | simp add: Arch_createNewCaps_def toAPIType_def
-                          ARM_H.toAPIType_def unat_of_nat_minus_1
+              | simp add: Arch_createNewCaps_def toAPIType_def unat_of_nat_minus_1
               | erule hoare_strengthen_post[OF createObjects_ret],clarsimp+
               | intro conjI impI)+)+
    done
@@ -4322,7 +4509,7 @@ qed
 
 lemma placeNewObject_copyGlobalMapping_commute:
   "monad_commute
-     (valid_arch_state' and pspace_distinct' and pspace_aligned' and
+     (valid_arch_state' and pspace_distinct' and pspace_aligned' and pspace_bounded' and
       page_directory_at' r and
       pspace_no_overlap' ptr (objBitsKO (injectKOS val) + us) and
       K (objBitsKO (injectKOS val) + us < word_bits \<and>
@@ -4335,7 +4522,7 @@ lemma placeNewObject_copyGlobalMapping_commute:
       apply (rule monad_commute_split[OF _ getPDE_placeNewObject_commute])
        apply (rule storePDE_placeNewObject_commute)
       apply wp
-      apply (wp pspace_no_overlap'_lift | clarsimp)+
+      apply (wp pspace_no_overlap'_lift2 | clarsimp)+
     apply (rule placeNewObject_gets_globalPD_commute)
    apply wp
   apply clarsimp
@@ -4445,7 +4632,7 @@ lemma placeNewObject_doMachineOp_commute:
   "monad_commute
      (K (us < word_bits \<and> is_aligned ptr (objBitsKO (injectKOS ty) + us) \<and>
          objBitsKO (injectKOS ty) + us < word_bits) and
-      pspace_aligned' and pspace_distinct' and
+      pspace_aligned' and pspace_distinct' and pspace_bounded' and
       pspace_no_overlap' ptr ((objBitsKO (injectKOS ty)) +  us))
      (placeNewObject ptr ty us) (doMachineOp f)"
   apply (rule commute_name_pre_state)
@@ -4502,7 +4689,7 @@ lemma doMachineOp_copyGlobalMapping_commute:
 
 lemma createObjects'_page_directory_at':
   "\<lbrace>K (range_cover ptr sz 14 (Suc n)) and
-    pspace_aligned' and pspace_distinct' and pspace_no_overlap' ptr sz\<rbrace>
+    pspace_aligned' and pspace_distinct' and pspace_bounded' and pspace_no_overlap' ptr sz\<rbrace>
    createObjects' ptr (Suc n) (KOArch (KOPDE makeObject)) 12
    \<lbrace>\<lambda>rv s. (\<forall>x\<le>of_nat n. page_directory_at' (ptr + (x << 14)) s)\<rbrace>"
   apply (rule createObjects'_wp_subst)
@@ -4746,15 +4933,14 @@ lemma createTCBs_tcb_at':
   apply clarsimp
   apply (subgoal_tac "(\<forall>x\<le>of_nat n.
     tcb_at' (ptr + x * 2^tcbBlockSizeBits) (s\<lparr>ksPSpace :=
-    foldr (\<lambda>addr. data_map_insert addr (KOTCB makeObject))
-    (new_cap_addrs (Suc n) ptr (KOTCB makeObject))
+    foldr (\<lambda>addr. data_map_insert addr (KOTCB (tcbDomain_update (\<lambda>_. curdom) makeObject)))
+    (new_cap_addrs (Suc n) ptr (KOTCB (tcbDomain_update (\<lambda>_. curdom) makeObject)))
     (ksPSpace s)\<rparr>))")
   apply (subst (asm) new_cap_addrs_def2)
    apply (drule range_cover.weak)
     apply simp
    apply simp
   apply (clarsimp simp: retype_obj_at_disj')
-  apply (clarsimp simp: projectKO_opt_tcb)
   apply (clarsimp simp: new_cap_addrs_def image_def)
   apply (drule_tac x = "unat x" in bspec)
    apply (simp add:objBits_simps' shiftl_t2n)
@@ -4879,126 +5094,87 @@ proof -
                          Arch_createNewCaps_def)
         apply (rename_tac apiobject_type)
         apply (case_tac apiobject_type)
-            apply (simp_all add: bind_assoc ARM_H.toAPIType_def
-                                 )
-            \<comment> \<open>Untyped\<close>
-            apply (simp add:
-              bind_assoc ARM_H.getObjectSize_def
-              mapM_def sequence_def Retype_H.createObject_def
-              ARM_H.toAPIType_def
-              createObjects_def ARM_H.createObject_def
-              Arch_createNewCaps_def comp_def
-              apiGetObjectSize_def shiftl_t2n field_simps
-              shiftL_nat mapM_x_def sequence_x_def append
-              fromIntegral_def integral_inv[unfolded Fun.comp_def])
-           \<comment> \<open>TCB, EP, NTFN\<close>
-           apply (simp add: bind_assoc
-                      ARM_H.getObjectSize_def
-                      sequence_def Retype_H.createObject_def
-                      ARM_H.toAPIType_def
-                      createObjects_def ARM_H.createObject_def
-                      Arch_createNewCaps_def comp_def
-                      apiGetObjectSize_def shiftl_t2n field_simps
-                      shiftL_nat append mapM_x_append2
-                      fromIntegral_def integral_inv[unfolded Fun.comp_def])+
-           apply (subst monad_eq)
-            apply (rule createObjects_Cons)
-                 apply (simp add: field_simps shiftl_t2n bind_assoc pageBits_def
-                               objBits_simps placeNewObject_def2)+
-           apply (rule_tac Q = "\<lambda>r s. pspace_aligned' s \<and>
-               pspace_distinct' s \<and>
-               pspace_no_overlap' (ptr + (2^tcbBlockSizeBits + of_nat n * 2^tcbBlockSizeBits)) (objBitsKO (KOTCB makeObject)) s \<and>
-               range_cover (ptr + 2^tcbBlockSizeBits) sz
-               (objBitsKO (KOTCB makeObject)) (Suc n)
-               \<and> (\<forall>x\<in>set [0.e.of_nat n]. tcb_at' (ptr + x * 2^tcbBlockSizeBits) s)"
-               in monad_eq_split2)
-              apply simp
-             apply (subst monad_commute_simple[symmetric])
-               apply (rule commute_commute[OF curDomain_commute])
-               apply (wpsimp+)[2]
-             apply (rule_tac Q = "\<lambda>r s. r = (ksCurDomain s) \<and>
-               pspace_aligned' s \<and>
-               pspace_distinct' s \<and>
-               pspace_no_overlap' (ptr + (2^tcbBlockSizeBits + of_nat n * 2^tcbBlockSizeBits)) (objBitsKO (KOTCB makeObject)) s \<and>
-               range_cover (ptr + 2^tcbBlockSizeBits) sz
-               (objBitsKO (KOTCB makeObject)) (Suc n)
-               \<and> (\<forall>x\<in>set [0.e.of_nat n]. tcb_at' (ptr + x * 2^tcbBlockSizeBits) s)
-             " in  monad_eq_split)
-               apply (subst monad_commute_simple[symmetric])
-                 apply (rule createObjects_setDomains_commute)
-                apply (clarsimp simp:objBits_simps)
-                apply (rule conj_impI)
-                 apply (erule aligned_add_aligned)
-                  apply (rule aligned_add_aligned[where n = tcbBlockSizeBits])
-                    apply (simp add:is_aligned_def objBits_defs)
-                   apply (cut_tac is_aligned_shift[where m = tcbBlockSizeBits and k = "of_nat n",
-                     unfolded shiftl_t2n,simplified])
-                   apply (simp add:field_simps)+
-                apply (erule range_cover_full)
-                apply (simp add: word_bits_conv objBits_defs)
-               apply (rule_tac Q = "\<lambda>x s. (ksCurDomain s) = ra" in monad_eq_split2)
-                  apply simp
-                 apply (rule_tac Q = "\<lambda>x s. (ksCurDomain s) = ra" in monad_eq_split)
-                   apply (subst rewrite_step[where f = curDomain and
-                     P ="\<lambda>s. ksCurDomain s = ra" and f' = "return ra"])
-                     apply (simp add:curDomain_def bind_def gets_def get_def)
-                    apply simp
-                   apply (simp add:mapM_x_singleton)
-                  apply wp
-                 apply simp
-                apply (wp mapM_x_wp')
-               apply simp
-              apply (simp add:curDomain_def,wp)
-             apply simp
-            apply (wp createObjects'_psp_aligned[where sz = sz]
-              createObjects'_psp_distinct[where sz = sz])
-            apply (rule hoare_vcg_conj_lift)
-             apply (rule hoare_post_imp[OF _ createObjects'_pspace_no_overlap
-                [unfolded shiftl_t2n,where gz = tcbBlockSizeBits and sz = sz,simplified]])
-              apply (simp add:objBits_simps field_simps)
-             apply (simp add: objBits_simps)
-            apply (wp createTCBs_tcb_at')
-           apply (clarsimp simp:objBits_simps word_bits_def field_simps)
-           apply (frule range_cover_le[where n = "Suc n"],simp+)
-           apply (drule range_cover_offset[where p = 1,rotated])
-            apply simp
-           apply (simp add: objBits_defs)
-          apply (((simp add:
-                      ARM_H.getObjectSize_def
-                      mapM_def sequence_def Retype_H.createObject_def
-                      ARM_H.toAPIType_def
-                      createObjects_def ARM_H.createObject_def
-                      Arch_createNewCaps_def comp_def
-                      apiGetObjectSize_def shiftl_t2n field_simps
-                      shiftL_nat mapM_x_def sequence_x_def append
-                      fromIntegral_def integral_inv[unfolded Fun.comp_def])+
-                   , subst monad_eq, rule createObjects_Cons
-                   , (simp add: field_simps shiftl_t2n bind_assoc pageBits_def
-                               objBits_simps' placeNewObject_def2)+)+)[2]
-        \<comment> \<open>CNode\<close>
-        apply (simp add: cteSizeBits_def pageBits_def tcbBlockSizeBits_def
-                      epSizeBits_def ntfnSizeBits_def pdBits_def bind_assoc
-                      ARM_H.getObjectSize_def
-                      mapM_def sequence_def Retype_H.createObject_def
-                      ARM_H.toAPIType_def
-                      createObjects_def ARM_H.createObject_def
-                      Arch_createNewCaps_def comp_def
-                      apiGetObjectSize_def shiftl_t2n field_simps
-                      shiftL_nat mapM_x_def sequence_x_def append
-                      fromIntegral_def integral_inv[unfolded Fun.comp_def])+
-        apply (subst monad_eq, rule createObjects_Cons)
-              apply (simp add: field_simps shiftl_t2n bind_assoc pageBits_def
-                               objBits_simps' placeNewObject_def2)+
-        apply (subst gsCNodes_update gsCNodes_upd_createObjects'_comm)+
-        apply (simp add: modify_modify_bind)
-        apply (rule fun_cong[where x=s])
-        apply (rule arg_cong_bind[OF refl ext])+
-        apply (rule arg_cong_bind[OF _ refl])
-        apply (rule arg_cong[where f=modify, OF ext], simp)
-        apply (rule arg_cong2[where f=gsCNodes_update, OF ext refl])
-        apply (rule ext)
-        apply simp
-
+              apply (simp_all add: bind_assoc ARM_H.toAPIType_def)
+              \<comment> \<open>Untyped\<close>
+              apply (simp add:
+                bind_assoc ARM_H.getObjectSize_def
+                mapM_def sequence_def Retype_H.createObject_def
+                ARM_H.toAPIType_def
+                createObjects_def ARM_H.createObject_def
+                Arch_createNewCaps_def comp_def
+                apiGetObjectSize_def shiftl_t2n field_simps
+                shiftL_nat mapM_x_def sequence_x_def append
+                fromIntegral_def integral_inv[unfolded Fun.comp_def])
+             \<comment> \<open>TCB\<close>
+              apply (simp add:
+                bind_assoc ARM_H.getObjectSize_def
+                mapM_def sequence_def Retype_H.createObject_def
+                ARM_H.toAPIType_def objBitsKO_def
+                createObjects_def ARM_H.createObject_def
+                Arch_createNewCaps_def comp_def append
+                apiGetObjectSize_def shiftl_t2n field_simps
+                shiftL_nat fromIntegral_def integral_inv[unfolded Fun.comp_def])
+             apply (subst curDomain_createObjects'_comm)
+             apply (subst curDomain_twice_simp)
+             apply (simp add: monad_eq_simp_state)
+             apply (intro conjI; clarsimp simp: in_monad)
+               apply ((fastforce simp: curDomain_def simpler_gets_def return_def placeNewObject_def2
+                                       field_simps shiftl_t2n bind_assoc objBits_simps in_monad
+                                       createObjects_Cons[where
+                                         val="KOTCB (tcbDomain_update (\<lambda>_. ksCurDomain s) makeObject)"
+                                         and s=s, simplified objBitsKO_def])+)[2]
+              apply ((clarsimp simp: curDomain_def simpler_gets_def return_def split_def bind_def
+                                    field_simps shiftl_t2n bind_assoc objBits_simps placeNewObject_def2
+                                    createObjects_Cons[where
+                                      val="KOTCB (tcbDomain_update (\<lambda>_. ksCurDomain s) makeObject)"
+                                      and s=s, simplified objBitsKO_def])+)[1]
+            \<comment> \<open>EP, NTFN\<close>
+            apply (((simp add:
+                        ARM_H.getObjectSize_def
+                        mapM_def sequence_def Retype_H.createObject_def
+                        ARM_H.toAPIType_def
+                        createObjects_def ARM_H.createObject_def
+                        Arch_createNewCaps_def comp_def
+                        apiGetObjectSize_def shiftl_t2n field_simps
+                        shiftL_nat mapM_x_def sequence_x_def append
+                        fromIntegral_def integral_inv[unfolded Fun.comp_def])+
+                     , subst monad_eq, rule createObjects_Cons
+                     , (simp add: field_simps shiftl_t2n bind_assoc pageBits_def
+                                 objBits_simps' placeNewObject_def2)+)+)[2]
+          \<comment> \<open>CNode\<close>
+          apply (simp add: cteSizeBits_def pageBits_def tcbBlockSizeBits_def
+                        epSizeBits_def ntfnSizeBits_def pdBits_def bind_assoc
+                        ARM_H.getObjectSize_def
+                        mapM_def sequence_def Retype_H.createObject_def
+                        ARM_H.toAPIType_def
+                        createObjects_def ARM_H.createObject_def
+                        Arch_createNewCaps_def comp_def
+                        apiGetObjectSize_def shiftl_t2n field_simps
+                        shiftL_nat mapM_x_def sequence_x_def append
+                        fromIntegral_def integral_inv[unfolded Fun.comp_def])+
+          apply (subst monad_eq, rule createObjects_Cons)
+                apply (simp add: field_simps shiftl_t2n bind_assoc pageBits_def
+                                 objBits_simps' placeNewObject_def2)+
+          apply (subst gsCNodes_update gsCNodes_upd_createObjects'_comm)+
+          apply (simp add: modify_modify_bind)
+          apply (rule fun_cong[where x=s])
+          apply (rule arg_cong_bind[OF refl ext])+
+          apply (rule arg_cong_bind[OF _ refl])
+          apply (rule arg_cong[where f=modify, OF ext], simp)
+          apply (rule arg_cong2[where f=gsCNodes_update, OF ext refl])
+          apply (rule ext)
+          apply simp
+         \<comment> \<open>SC, Reply\<close>
+         apply ((simp add: cteSizeBits_def pageBits_def tcbBlockSizeBits_def scBits_simps
+                           epSizeBits_def ntfnSizeBits_def pdBits_def bind_assoc objBits_simps
+                           mapM_def sequence_def Retype_H.createObject_def ARM_H.toAPIType_def
+                           createObjects_def ARM_H.createObject_def Arch_createNewCaps_def comp_def
+                           apiGetObjectSize_def shiftl_t2n field_simps shiftL_nat mapM_x_def
+                           sequence_x_def append fromIntegral_def ARM_H.getObjectSize_def
+                           integral_inv[unfolded Fun.comp_def],
+                 subst monad_eq, rule createObjects_Cons;
+                 fastforce simp: field_simps shiftl_t2n bind_assoc pageBits_def objBits_simps'
+                                 placeNewObject_def2 scBits_simps)+)[2]
        \<comment> \<open>SmallPageObject\<close>
        apply (simp add: Arch_createNewCaps_def
                         Retype_H.createObject_def createObjects_def bind_assoc
@@ -5008,7 +5184,7 @@ proof -
         apply (subst monad_eq, rule createObjects_Cons)
              apply (simp_all add: field_simps shiftl_t2n pageBits_def
                         getObjectSize_def ARM_H.getObjectSize_def
-                        objBits_simps)[6]
+                        objBits_simps)[7]
         apply (simp add: bind_assoc placeNewObject_def2 objBits_simps
                          getObjectSize_def ARM_H.getObjectSize_def
                          pageBits_def add.commute append)
@@ -5018,7 +5194,7 @@ proof -
         apply (subst monad_eq, rule createObjects_Cons)
              apply (simp_all add: field_simps shiftl_t2n pageBits_def
                         getObjectSize_def ARM_H.getObjectSize_def
-                        objBits_simps)[6]
+                        objBits_simps)[7]
         apply (simp add: bind_assoc placeNewObject_def2 objBits_simps
                          getObjectSize_def ARM_H.getObjectSize_def
                          pageBits_def add.commute append)
@@ -5034,7 +5210,7 @@ proof -
        apply (subst monad_eq, rule createObjects_Cons)
             apply (simp_all add: field_simps shiftl_t2n pageBits_def
                        getObjectSize_def ARM_H.getObjectSize_def
-                       objBits_simps)[6]
+                       objBits_simps)[7]
        apply (simp add: bind_assoc placeNewObject_def2 objBits_simps
                         getObjectSize_def ARM_H.getObjectSize_def
                         pageBits_def add.commute append)
@@ -5043,7 +5219,7 @@ proof -
                   | simp add: modify_modify_bind o_def)+)[1]
       apply (subst monad_eq, rule createObjects_Cons)
             apply (simp_all add: field_simps shiftl_t2n pageBits_def
-                       ARM_H.getObjectSize_def objBits_simps)[6]
+                       ARM_H.getObjectSize_def objBits_simps)[7]
       apply (simp add: bind_assoc placeNewObject_def2 objBits_simps
                         ARM_H.getObjectSize_def
                        pageBits_def add.commute append)
@@ -5059,7 +5235,7 @@ proof -
       apply (subst monad_eq, rule createObjects_Cons)
            apply (simp_all add: field_simps shiftl_t2n pageBits_def
                       getObjectSize_def ARM_H.getObjectSize_def
-                      objBits_simps)[6]
+                      objBits_simps)[7]
       apply (simp add: bind_assoc placeNewObject_def2 objBits_simps
                        getObjectSize_def ARM_H.getObjectSize_def
                        pageBits_def add.commute append)
@@ -5068,7 +5244,7 @@ proof -
               | simp add: modify_modify_bind o_def)+)[1]
      apply (subst monad_eq, rule createObjects_Cons)
            apply (simp_all add: field_simps shiftl_t2n pageBits_def
-                      ARM_H.getObjectSize_def objBits_simps)[6]
+                      ARM_H.getObjectSize_def objBits_simps)[7]
      apply (simp add: bind_assoc placeNewObject_def2 objBits_simps
                        ARM_H.getObjectSize_def
                       pageBits_def add.commute append)
@@ -5084,7 +5260,7 @@ proof -
      apply (subst monad_eq, rule createObjects_Cons)
           apply (simp_all add: field_simps shiftl_t2n pageBits_def
                      getObjectSize_def ARM_H.getObjectSize_def
-                     objBits_simps)[6]
+                     objBits_simps)[7]
      apply (simp add: bind_assoc placeNewObject_def2 objBits_simps
                       getObjectSize_def ARM_H.getObjectSize_def
                       pageBits_def add.commute append)
@@ -5093,7 +5269,7 @@ proof -
                | simp add: modify_modify_bind o_def)+)[1]
     apply (subst monad_eq, rule createObjects_Cons)
           apply (simp_all add: field_simps shiftl_t2n pageBits_def
-                     ARM_H.getObjectSize_def objBits_simps)[6]
+                     ARM_H.getObjectSize_def objBits_simps)[7]
     apply (simp add: bind_assoc placeNewObject_def2 objBits_simps
                       ARM_H.getObjectSize_def
                      pageBits_def add.commute append)
@@ -5107,7 +5283,7 @@ proof -
          apply (subst monad_eq,rule createObjects_Cons)
              apply ((simp add: field_simps shiftl_t2n pageBits_def archObjSize_def
                getObjectSize_def ARM_H.getObjectSize_def
-               objBits_simps ptBits_def)+)[6]
+               objBits_simps ptBits_def)+)[7]
          apply (simp add:bind_assoc placeNewObject_def2)
          apply (simp add: pageBits_def field_simps
                getObjectSize_def  ptBits_def archObjSize_def
@@ -5158,7 +5334,7 @@ proof -
          apply (subst monad_eq,rule createObjects_Cons)
                apply ((simp add: field_simps shiftl_t2n pageBits_def archObjSize_def
                  ARM_H.getObjectSize_def pdBits_def
-                 objBits_simps ptBits_def)+)[6]
+                 objBits_simps ptBits_def)+)[7]
          apply (simp add:objBits_simps archObjSize_def pdBits_def pageBits_def ARM_H.getObjectSize_def)
          apply (simp add:bind_assoc)
          apply (simp add: placeNewObject_def2[where val = "makeObject::ARM_H.pde",simplified,symmetric])
@@ -5228,6 +5404,7 @@ proof -
             apply (wp createObjects_valid_arch[where sz = sz])
            apply (wp createObjects'_page_directory_at'[where sz = sz]
              createObjects'_psp_aligned[where sz = sz]
+             createObjects'_psp_bounded[where sz = sz]
              createObjects'_psp_distinct[where sz = sz] hoare_vcg_imp_lift
              createObjects'_pspace_no_overlap[where sz = sz]
             | simp add:objBits_simps archObjSize_def field_simps pdeBits_def)+
@@ -5275,7 +5452,8 @@ lemma createNewObjects_def2:
     valid_arch_state' s;
     range_cover ptr sz (Types_H.getObjectSize ty us) (length dslots);
     ptr \<noteq> 0;
-    ksCurDomain s \<le> maxDomain\<rbrakk>
+    ksCurDomain s \<le> maxDomain;
+    ty = APIObjectType ArchTypes_H.apiobject_type.SchedContextObject \<longrightarrow> sc_size_bounds us\<rbrakk>
    \<Longrightarrow> createNewObjects ty parent dslots ptr us d s =
        insertNewCaps ty parent dslots ptr us d s"
   apply (clarsimp simp:insertNewCaps_def createNewObjects_def neq_Nil_conv)
@@ -5403,7 +5580,8 @@ assumes check: "distinct dslots"
   \<and> caps_no_overlap'' ptr sz s
   \<and> caps_overlap_reserved'
    {ptr..ptr + of_nat (length dslots) * 2^ (Types_H.getObjectSize ty us) - 1} s
-  \<and> valid_pspace' s \<and> valid_arch_state' s \<and> ksCurDomain s \<le> maxDomain)"
+  \<and> valid_pspace' s \<and> valid_arch_state' s \<and> ksCurDomain s \<le> maxDomain
+  \<and> (ty = APIObjectType ArchTypes_H.apiobject_type.SchedContextObject \<longrightarrow> sc_size_bounds us))"
 shows "corres r P P' f (createNewObjects ty parent dslots ptr us d)"
   using check cover not_0
   apply (clarsimp simp:corres_underlying_def)
@@ -5467,10 +5648,11 @@ lemma ArchCreateObject_pspace_no_overlap':
               copyGlobalMappings_pspace_no_overlap'
               createObjects'_psp_aligned[where sz = sz]
               createObjects'_psp_distinct[where sz = sz]
+              createObjects'_psp_bounded[where sz = sz]
             | simp add: placeNewObject_def2 word_shiftl_add_distrib
             | simp add: placeNewObject_def2 word_shiftl_add_distrib
             | simp add: placeNewDataObject_def placeNewObject_def2 word_shiftl_add_distrib
-                        field_simps  split del: if_splits
+                        field_simps  split del: if_split
             | clarsimp simp add: add.assoc[symmetric],wp createObjects'_pspace_no_overlap2[where n =0 and sz = sz,simplified]
             | clarsimp simp add: APIType_capBits_def objBits_simps pageBits_def)+
 
@@ -5554,29 +5721,30 @@ lemma createObject_pspace_no_overlap':
    apply (simp add:shiftl_t2n field_simps)
   apply (frule range_cover_offset[rotated,where p = n])
    apply simp+
-  apply (auto simp: word_shiftl_add_distrib field_simps shiftl_t2n elim: range_cover_le,
-    auto simp add: APIType_capBits_def fromAPIType_def objBits_def
-        dest!: to_from_apiTypeD)
-  done
+  by (auto simp: word_shiftl_add_distrib field_simps shiftl_t2n elim: range_cover_le)
+     (auto simp add: APIType_capBits_def fromAPIType_def objBits_def scBits_simps objBits_simps
+              dest!: to_from_apiTypeD)
 
 lemma createObject_pspace_aligned_distinct':
-  "\<lbrace>pspace_aligned' and K (is_aligned ptr (APIType_capBits ty us))
+  "\<lbrace>pspace_aligned' and K (is_aligned ptr (APIType_capBits ty us)) and pspace_bounded'
    and pspace_distinct' and pspace_no_overlap' ptr (APIType_capBits ty us)
-   and K (ty = APIObjectType apiobject_type.CapTableObject \<longrightarrow> us < 28)\<rbrace>
+   and K (ty = APIObjectType apiobject_type.CapTableObject \<longrightarrow> us < 28)
+   and K (ty = APIObjectType ArchTypes_H.apiobject_type.SchedContextObject \<longrightarrow>
+            sc_size_bounds us)\<rbrace>
   createObject ty ptr us d
-  \<lbrace>\<lambda>xa s. pspace_aligned' s \<and> pspace_distinct' s\<rbrace>"
+  \<lbrace>\<lambda>xa s. pspace_aligned' s \<and> pspace_distinct' s \<and> pspace_bounded' s\<rbrace>"
   apply (rule hoare_pre)
   apply (wp placeNewObject_pspace_aligned' hoare_unless_wp
-      placeNewObject_pspace_distinct'
+      placeNewObject_pspace_distinct' placeNewObject_pspace_bounded'
     | simp add:ARM_H.createObject_def
       Retype_H.createObject_def objBits_simps
       curDomain_def placeNewDataObject_def
           split del: if_split
     | wpc | intro conjI impI)+
-  apply (auto simp:APIType_capBits_def pdBits_def objBits_simps' pteBits_def pdeBits_def
-    pageBits_def word_bits_def archObjSize_def ptBits_def ARM_H.toAPIType_def
-    split:ARM_H.object_type.splits apiobject_type.splits)
-  done
+  by (auto simp: APIType_capBits_def pdBits_def objBits_simps' pteBits_def pdeBits_def
+                 pageBits_def word_bits_def archObjSize_def ptBits_def ARM_H.toAPIType_def
+                 untypedBits_defs scBits_simps
+          split: ARM_H.object_type.splits apiobject_type.splits)
 
 declare objSize_eq_capBits [simp]
 
@@ -5632,21 +5800,23 @@ lemma insertNewCap_wps[wp]:
       insertNewCap parent slot cap
    \<lbrace>\<lambda>rv s. P (cteCaps_of s)\<rbrace>"
   apply (simp_all add: insertNewCap_def)
-   apply (wp hoare_drop_imps
-            | simp add: o_def)+
+   apply (wpsimp wp: hoare_drop_imps)+
   apply (fastforce elim!: rsubst[where P=P])
   done
 
-crunch typ_at'[wp]: insertNewCap "\<lambda>s. P (typ_at' T p s)"
+crunches insertNewCap
+  for typ_at'[wp]: "\<lambda>s. P (typ_at' T p s)"
+  and pspace_bounded'[wp]: pspace_bounded'
   (wp: crunch_wps)
 
 lemma createNewObjects_pspace_no_overlap':
-  "\<lbrace>pspace_no_overlap' ptr sz and pspace_aligned' and pspace_distinct'
+  "\<lbrace>pspace_no_overlap' ptr sz and pspace_aligned' and pspace_distinct' and pspace_bounded'
   and K (range_cover ptr sz (Types_H.getObjectSize ty us) (Suc (length dests)))
   and K (ptr \<noteq> 0)
-  and K (ty = APIObjectType apiobject_type.CapTableObject \<longrightarrow> us < 28)\<rbrace>
+  and K (ty = APIObjectType apiobject_type.CapTableObject \<longrightarrow> us < 28)
+  and K (ty = APIObjectType apiobject_type.SchedContextObject \<longrightarrow> sc_size_bounds us)\<rbrace>
   createNewObjects ty src dests ptr us d
-  \<lbrace>\<lambda>rv s.  pspace_aligned' s \<and> pspace_distinct' s \<and>
+  \<lbrace>\<lambda>rv s.  pspace_aligned' s \<and> pspace_distinct' s \<and> pspace_bounded' s \<and>
   pspace_no_overlap' ((of_nat (length dests) << APIType_capBits ty us) + ptr) sz s\<rbrace>"
   apply (rule hoare_gen_asm)+
   proof (induct rule:rev_induct )
@@ -5665,41 +5835,39 @@ lemma createNewObjects_pspace_no_overlap':
      apply (subst createNewObjects_Cons)
       apply (drule range_cover.weak)
       apply (simp add: word_bits_def)
-     apply (wp pspace_no_overlap'_lift)
-      apply (simp add: conj_comms)
-      apply (rule hoare_vcg_conj_lift)
-       apply (rule hoare_post_imp[OF _ createObject_pspace_aligned_distinct'])
-       apply simp
-      apply (rule hoare_vcg_conj_lift)
-       apply (rule hoare_post_imp[OF _ createObject_pspace_aligned_distinct'])
-       apply simp
-      apply (simp add:field_simps)
-      apply (wp createObject_pspace_no_overlap')
-     apply (clarsimp simp: conj_comms)
-     apply (rule hoare_pre)
-      apply (rule hoare_vcg_conj_lift)
-       apply (rule hoare_post_imp[OF _ snoc.hyps])
-       apply (simp add:snoc)+
-      apply (rule hoare_vcg_conj_lift)
-       apply (rule hoare_post_imp[OF _ snoc.hyps])
-       apply (simp add:snoc)+
-      apply wp
-     apply (simp add: conj_comms field_simps)
-     apply (rule hoare_post_imp)
-     apply (erule context_conjI)
-      apply (intro conjI)
-        apply (rule aligned_add_aligned[OF range_cover.aligned
-                                           is_aligned_shiftl_self])
+     apply (wpsimp wp: pspace_no_overlap'_lift2)
+       apply (simp add: conj_comms)
+       apply (subst conj_assoc[symmetric])
+       apply (subst conj_assoc[symmetric])
+       apply (rule hoare_vcg_conj_lift)
+        apply (rule hoare_post_imp[OF _ createObject_pspace_aligned_distinct'])
+        apply simp
+       apply (simp add:field_simps)
+       apply (wp createObject_pspace_no_overlap')
+      apply (clarsimp simp: conj_comms)
+      apply (rule hoare_pre)
+       apply (subst conj_assoc[symmetric])
+       apply (subst conj_assoc[symmetric])
+       apply (rule hoare_vcg_conj_lift)
+        apply (rule hoare_post_imp[OF _ snoc.hyps])
+            apply (simp add:snoc)+
+       apply wp
+       apply (simp add: conj_comms field_simps)
+       apply (rule hoare_post_imp)
+        apply (erule context_conjI)
+        apply (intro conjI)
+         apply (rule aligned_add_aligned[OF range_cover.aligned
+                                            is_aligned_shiftl_self])
           apply simp
          apply simp
         apply simp
-       apply (erule pspace_no_overlap'_le)
-       apply (simp add: range_cover.sz[where 'a=32, folded word_bits_def])+
-     apply (rule hoare_post_imp[OF _ snoc.hyps])
-     apply (simp add:field_simps snoc)+
-    using snoc
-    apply simp
-  done
+        apply (erule pspace_no_overlap'_le)
+         apply (simp add: range_cover.sz[where 'a=32, folded word_bits_def])+
+       apply (rule hoare_post_imp[OF _ snoc.hyps])
+           apply (simp add:field_simps snoc)+
+     using snoc
+     apply simp
+     done
 qed
 
 end

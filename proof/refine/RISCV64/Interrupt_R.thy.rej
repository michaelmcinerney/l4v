--- Interrupt_R.thy
+++ Interrupt_R.thy
@@ -287,27 +288,12 @@ lemma decodeIRQControlInvocation_corres:
                simp: not_less unat_le_helper)
   done
 
-crunch inv[wp]: "InterruptDecls_H.decodeIRQControlInvocation"  "P"
+crunches "InterruptDecls_H.decodeIRQControlInvocation"
+  for inv[wp]: "P"
   (simp: crunch_simps)
 
-
-(* Levity: added (20090201 10:50:27) *)
 declare ensureEmptySlot_stronger [wp]
 
-lemma lsfco_real_cte_at'[wp]:
-  "\<lbrace>valid_objs' and valid_cap' croot\<rbrace>
-     lookupSlotForCNodeOp is_src croot ptr depth
-   \<lbrace>\<lambda>rv s. real_cte_at' rv s\<rbrace>,-"
-  apply (simp add: lookupSlotForCNodeOp_def split_def unlessE_def
-                   whenE_def
-               split del: if_split
-             cong: if_cong list.case_cong capability.case_cong)
-  apply (rule hoare_pre)
-   apply (wp resolveAddressBits_real_cte_at'
-            | simp
-            | wpc | wp (once) hoare_drop_imps)+
-  done
-
 lemma arch_decode_irq_control_valid'[wp]:
   "\<lbrace>\<lambda>s. invs' s \<and> (\<forall>cap \<in> set caps. s \<turnstile>' cap)
         \<and> (\<forall>cap \<in> set caps. \<forall>r \<in> cte_refs' cap (irq_node' s). ex_cte_cap_to' r s)
@@ -440,13 +426,15 @@ lemma isnt_irq_handler_strg:
 lemma invoke_arch_irq_handler_invs'[wp]:
   "\<lbrace>invs' and irq_handler_inv_valid' i\<rbrace> ARM_H.invokeIRQHandler i \<lbrace>\<lambda>rv. invs'\<rbrace>"
   apply (cases i; wpsimp wp: dmo_maskInterrupt simp: ARM_H.invokeIRQHandler_def)
-  apply (clarsimp simp: invs'_def valid_state'_def valid_irq_masks'_def
-                        valid_machine_state'_def ct_not_inQ_def)
+  apply (clarsimp simp: invs'_def valid_dom_schedule'_def valid_irq_masks'_def
+                        valid_machine_state'_def ct_not_inQ_def
+                        ct_in_current_domain_ksMachineState)
   done
 
 lemma invoke_irq_handler_invs'[wp]:
-  "\<lbrace>invs' and irq_handler_inv_valid' i\<rbrace>
-    InterruptDecls_H.invokeIRQHandler i \<lbrace>\<lambda>rv. invs'\<rbrace>"
+  "\<lbrace>invs' and sch_act_simple and irq_handler_inv_valid' i\<rbrace>
+   InterruptDecls_H.invokeIRQHandler i
+   \<lbrace>\<lambda>rv. invs'\<rbrace>"
   apply (cases i; simp add: Interrupt_H.invokeIRQHandler_def)
     apply wpsimp
    apply (wp cteInsert_invs)+
@@ -468,8 +456,8 @@ lemma IRQHandler_valid':
   "(s' \<turnstile>' IRQHandlerCap irq) = (irq \<le> maxIRQ)"
   by (simp add: valid_cap'_def capAligned_def word_bits_conv)
 
-crunch valid_mdb'[wp]: setIRQState "valid_mdb'"
-crunch cte_wp_at[wp]: setIRQState "cte_wp_at' P p"
+crunches setIRQState
+  for valid_mdb'[wp]: "valid_mdb'"
 
 lemma no_fail_setIRQTrigger: "no_fail \<top> (setIRQTrigger irq trig)"
   by (simp add: setIRQTrigger_def)
@@ -504,7 +492,7 @@ lemma arch_performIRQControl_corres:
    apply (clarsimp simp: invs_def valid_state_def valid_pspace_def cte_wp_at_caps_of_state
                          is_simple_cap_def is_cap_simps arch_irq_control_inv_valid_def
                          safe_parent_for_def)
-  apply (clarsimp simp: invs'_def valid_state'_def valid_pspace'_def IRQHandler_valid
+  apply (clarsimp simp: invs'_def valid_pspace'_def IRQHandler_valid
                         IRQHandler_valid' is_simple_cap'_def isCap_simps IRQ_def)
   apply (clarsimp simp: safe_parent_for'_def cte_wp_at_ctes_of)
   apply (case_tac ctea)
@@ -615,9 +608,8 @@ lemma getIRQState_prop:
 
 lemma decDomainTime_corres:
   "corres dc \<top> \<top> dec_domain_time decDomainTime"
-  apply (simp add:dec_domain_time_def corres_underlying_def
-    decDomainTime_def simpler_modify_def)
-  apply (clarsimp simp:state_relation_def)
+  apply (simp add:dec_domain_time_def corres_underlying_def decDomainTime_def simpler_modify_def)
+  apply (clarsimp simp:state_relation_def cdt_relation_def)
   done
 
 lemma tcbSchedAppend_valid_objs':
@@ -637,108 +629,27 @@ lemma threadState_case_if:
   (if state = Structures_H.thread_state.Running then f else g)"
   by (case_tac state,auto)
 
-lemma tcbSchedAppend_invs_but_ct_not_inQ':
-  "\<lbrace>invs' and st_tcb_at' runnable' t \<rbrace>
-   tcbSchedAppend t \<lbrace>\<lambda>_. all_invs_but_ct_not_inQ'\<rbrace>"
-  apply (simp add: invs'_def valid_state'_def)
-  apply (rule hoare_pre)
-   apply (wp sch_act_wf_lift valid_irq_node_lift irqs_masked_lift
-             valid_irq_handlers_lift' cur_tcb_lift ct_idle_or_in_cur_domain'_lift2
-             untyped_ranges_zero_lift
-        | simp add: cteCaps_of_def o_def
-        | fastforce elim!: st_tcb_ex_cap'' split: thread_state.split_asm)+
-  done
-
-lemma timerTick_corres:
-  "corres dc (cur_tcb and valid_sched)
-             invs'
-             timer_tick timerTick"
-  supply if_weak_cong[cong]
-  apply (simp add: timerTick_def timer_tick_def)
-  apply (simp add:thread_state_case_if threadState_case_if)
-  apply (rule_tac Q="\<top> and (cur_tcb and valid_sched)" and Q'="\<top> and invs'" in corres_guard_imp)
-  apply (rule corres_guard_imp)
-  apply (rule corres_split_deprecated [OF _ getCurThread_corres])
-      apply simp
-      apply (rule corres_split_deprecated [OF _ getThreadState_corres])
-        apply (rename_tac state state')
-        apply (rule corres_split_deprecated[where r' = dc ])
-           apply simp
-           apply (rule corres_when,simp)
-           apply (rule corres_split_deprecated[OF _ decDomainTime_corres])
-             apply (rule corres_split_deprecated[OF _ getDomainTime_corres])
-               apply (rule corres_when,simp)
-               apply (rule rescheduleRequired_corres)
-              apply (wp hoare_drop_imp)+
-            apply (simp add:dec_domain_time_def)
-            apply wp+
-           apply (simp add:decDomainTime_def)
-          apply wp
-          apply (rule corres_if[where Q = \<top> and Q' = \<top>])
-            apply (case_tac state,simp_all)[1]
-          apply (simp add: Let_def)
-          apply (rule_tac r'="(=)" in corres_split_deprecated [OF _ ethreadget_corres])
-             apply (rename_tac ts ts')
-             apply (rule_tac R="1 < ts" in corres_cases)
-              apply (simp)
-              apply (unfold thread_set_time_slice_def)
-              apply (rule ethread_set_corres, simp+)
-              apply (clarsimp simp: etcb_relation_def)
-             apply simp
-             apply (rule corres_split_deprecated [OF _ ethread_set_corres])
-                      apply (rule corres_split_deprecated [OF _ tcbSchedAppend_corres])
-                        apply (rule rescheduleRequired_corres)
-                       apply (wp)[1]
-                      apply (rule hoare_strengthen_post)
-                       apply (rule tcbSchedAppend_invs_but_ct_not_inQ', clarsimp simp: sch_act_wf_weak)
-                     apply (simp add: sch_act_wf_weak etcb_relation_def pred_conj_def)+
-                 apply (wp threadSet_timeslice_invs threadSet_valid_queues
-                           threadSet_valid_queues' threadSet_pred_tcb_at_state)+
-               apply (simp add:etcb_relation_def)
-              apply (wp threadSet_timeslice_invs threadSet_valid_queues
-                        threadSet_valid_queues' threadSet_pred_tcb_at_state)
-             apply simp
-            apply (wp|wpc|unfold Let_def|simp)+
-            apply (wp static_imp_wp threadSet_timeslice_invs threadSet_valid_queues  threadSet_valid_queues'
-               threadSet_pred_tcb_at_state threadSet_weak_sch_act_wf tcbSchedAppend_valid_objs'
-               rescheduleRequired_weak_sch_act_wf tcbSchedAppend_valid_queues| simp)+
-            apply (strengthen sch_act_wf_weak)
-            apply (clarsimp simp:conj_comms)
-            apply (wp tcbSchedAppend_valid_queues tcbSchedAppend_sch_act_wf)
-           apply simp
-           apply (wp threadSet_valid_queues threadSet_pred_tcb_at_state threadSet_sch_act
-            threadSet_tcbDomain_triv threadSet_valid_queues' threadSet_valid_objs'| simp)+
-         apply (wp threadGet_wp gts_wp gts_wp')+
-       apply (clarsimp simp: cur_tcb_def tcb_at_is_etcb_at valid_sched_def valid_sched_action_def)
-        prefer 2
-       apply clarsimp
-     apply (clarsimp simp add:cur_tcb_def valid_sched_def
-         valid_sched_action_def valid_etcbs_def is_tcb_def
-         is_etcb_at_def st_tcb_at_def obj_at_def
-         dest!:get_tcb_SomeD)
-    apply (clarsimp simp: invs'_def valid_state'_def
-    sch_act_wf_weak
-    cur_tcb'_def inQ_def
-    ct_in_state'_def obj_at'_def)
-    apply (clarsimp simp:st_tcb_at'_def
-       valid_idle'_def ct_idle_or_in_cur_domain'_def
-       obj_at'_def projectKO_eq)
-   apply simp
-  done
-
 lemmas corres_eq_trivial = corres_Id[where f = h and g = h for h, simplified]
 
+lemma doMachineOp_ackDeadlineIRQ_invs'[wp]:
+  "doMachineOp ackDeadlineIRQ \<lbrace>invs'\<rbrace>"
+  apply (wpsimp simp: ackDeadlineIRQ_def wp: dmo_invs' ackInterrupt_irq_masks)
+  apply (drule_tac P4="\<lambda>m'. underlying_memory m' p = underlying_memory m p"
+         in use_valid[where P=P and Q="\<lambda>_. P" for P])
+    apply wpsimp+
+  done
+
 lemma handleInterrupt_corres:
   "corres dc
-     (einvs) (invs' and (\<lambda>s. intStateIRQTable (ksInterruptState s) irq \<noteq> IRQInactive))
+     (einvs and current_time_bounded 0) (invs' and (\<lambda>s. intStateIRQTable (ksInterruptState s) irq \<noteq> IRQInactive))
      (handle_interrupt irq) (handleInterrupt irq)"
-  (is "corres dc (einvs) ?P' ?f ?g")
+  (is "corres dc ?Q ?P' ?f ?g")
   apply (simp add: handle_interrupt_def handleInterrupt_def )
   apply (rule conjI[rotated]; rule impI)
 
    apply (rule corres_guard_imp)
      apply (rule corres_split_deprecated [OF _ getIRQState_corres,
-                               where R="\<lambda>rv. einvs"
+                               where R="\<lambda>rv. ?Q"
                                  and R'="\<lambda>rv. invs' and (\<lambda>s. rv \<noteq> IRQInactive)"])
        defer
        apply (wp getIRQState_prop getIRQState_inv do_machine_op_bind doMachineOp_bind | simp add: do_machine_op_bind doMachineOp_bind )+
@@ -767,92 +678,23 @@ lemma handleInterrupt_corres:
             apply ((wp | simp)+)
     apply clarsimp
    apply fastforce
-  apply (rule corres_guard_imp)
-    apply (rule corres_split_deprecated)
-       apply simp
-      apply (rule corres_split_deprecated [OF corres_machine_op timerTick_corres])
-        apply (rule corres_eq_trivial, simp+)
-         apply (rule corres_machine_op)
-         apply (rule corres_eq_trivial, (simp add: no_fail_ackInterrupt)+)
-        apply wp+
-   apply clarsimp
-  apply clarsimp
-  done
-
-lemma threadSet_ksDomainTime[wp]:
-  "\<lbrace>\<lambda>s. P (ksDomainTime s)\<rbrace> threadSet f ptr \<lbrace>\<lambda>rv s. P (ksDomainTime s)\<rbrace>"
-  apply (simp add: threadSet_def setObject_def split_def)
-  apply (wp crunch_wps | simp add:updateObject_default_def)+
-  done
-
-crunch ksDomainTime[wp]: rescheduleRequired "\<lambda>s. P (ksDomainTime s)"
-(simp:tcbSchedEnqueue_def wp:hoare_unless_wp)
-
-crunch ksDomainTime[wp]: tcbSchedAppend "\<lambda>s. P (ksDomainTime s)"
-(simp:tcbSchedEnqueue_def wp:hoare_unless_wp)
-
-lemma updateTimeSlice_valid_pspace[wp]:
-  "\<lbrace>valid_pspace'\<rbrace> threadSet (tcbTimeSlice_update (\<lambda>_. ts')) thread
-  \<lbrace>\<lambda>r. valid_pspace'\<rbrace>"
-  apply (wp threadSet_valid_pspace'T)
-  apply (auto simp:tcb_cte_cases_def)
-  done
-
-lemma updateTimeSlice_sch_act_wf[wp]:
-  "\<lbrace>\<lambda>s. sch_act_wf (ksSchedulerAction s) s \<rbrace>
-   threadSet (tcbTimeSlice_update (\<lambda>_. ts')) thread
-   \<lbrace>\<lambda>r s. sch_act_wf (ksSchedulerAction s) s\<rbrace>"
-  by (wp threadSet_sch_act,simp)
-
-
-lemma updateTimeSlice_valid_queues[wp]:
-  "\<lbrace>\<lambda>s. Invariants_H.valid_queues s \<rbrace>
-   threadSet (tcbTimeSlice_update (\<lambda>_. ts')) thread
-   \<lbrace>\<lambda>r s. Invariants_H.valid_queues s\<rbrace>"
-  apply (wp threadSet_valid_queues,simp)
-  apply (clarsimp simp:obj_at'_def inQ_def)
+  apply (corressimp corres: corres_machine_op reprogram_timer_corres
+                      simp: ackDeadlineIRQ_def)
   done
 
+crunches rescheduleRequired, tcbSchedAppend
+  for ksDomainTime[wp]: "\<lambda>s. P (ksDomainTime s)"
+  (simp: tcbSchedEnqueue_def wp: hoare_unless_wp crunch_wps)
 
 (* catch up tcbSchedAppend to tcbSchedEnqueue, which has these from crunches on possibleSwitchTo *)
-crunch ifunsafe[wp]: tcbSchedAppend if_unsafe_then_cap'
-crunch irq_handlers'[wp]: tcbSchedAppend valid_irq_handlers'
+crunches tcbSchedAppend
+  for irq_handlers'[wp]: valid_irq_handlers'
+  and irqs_masked'[wp]: irqs_masked'
   (simp: unless_def tcb_cte_cases_def wp: crunch_wps)
-crunch irq_states'[wp]: tcbSchedAppend valid_irq_states'
-crunch pde_mappigns'[wp]: tcbSchedAppend valid_pde_mappings'
-crunch irqs_masked'[wp]: tcbSchedAppend irqs_masked'
-  (simp: unless_def wp: crunch_wps)
-crunch ct[wp]: tcbSchedAppend cur_tcb'
-  (wp: cur_tcb_lift crunch_wps)
 
-crunch cur_tcb'[wp]: tcbSchedAppend cur_tcb'
-  (simp: unless_def wp: crunch_wps)
-
-lemma timerTick_invs'[wp]:
-  "\<lbrace>invs'\<rbrace> timerTick \<lbrace>\<lambda>rv. invs'\<rbrace>"
-  apply (simp add: timerTick_def)
-  apply (wpsimp wp: threadSet_invs_trivial threadSet_pred_tcb_no_state
-                    rescheduleRequired_all_invs_but_ct_not_inQ
-                    tcbSchedAppend_invs_but_ct_not_inQ'
-                simp: tcb_cte_cases_def)
-     apply (rule_tac Q="\<lambda>rv. invs'" in hoare_post_imp)
-     apply (clarsimp simp add:invs'_def valid_state'_def)
-      apply (simp add: decDomainTime_def)
-      apply wp
-     apply simp
-     apply wpc
-          apply (wp add: threadGet_wp threadSet_cur threadSet_timeslice_invs
-                               rescheduleRequired_all_invs_but_ct_not_inQ
-                               hoare_vcg_imp_lift threadSet_ct_idle_or_in_cur_domain'
-                          del: tcbSchedAppend_sch_act_wf)+
-             apply (rule hoare_strengthen_post[OF tcbSchedAppend_invs_but_ct_not_inQ'])
-             apply (wpsimp simp: valid_pspace'_def sch_act_wf_weak)+
-           apply (wpsimp wp: threadSet_pred_tcb_no_state threadSet_tcbDomain_triv
-                             threadSet_valid_objs' threadSet_timeslice_invs)+
-       apply (wp threadGet_wp)
-      apply (wp gts_wp')+
-  apply (clarsimp simp: invs'_def st_tcb_at'_def obj_at'_def valid_state'_def)
-  done
+crunches tcbSchedAppend
+  for ct[wp]: cur_tcb'
+  (wp: cur_tcb_lift crunch_wps)
 
 lemma resetTimer_invs'[wp]:
   "\<lbrace>invs'\<rbrace> doMachineOp resetTimer \<lbrace>\<lambda>_. invs'\<rbrace>"
@@ -877,9 +719,8 @@ lemma dmo_ackInterrupt[wp]:
   done
 
 lemma hint_invs[wp]:
-  "\<lbrace>invs'\<rbrace> InterruptDecls_H.handleInterrupt irq \<lbrace>\<lambda>rv. invs'\<rbrace>"
-  apply (simp add: Interrupt_H.handleInterrupt_def getSlotCap_def
-             cong: irqstate.case_cong)
+  "handleInterrupt irq \<lbrace>invs'\<rbrace>"
+  apply (simp add: handleInterrupt_def getSlotCap_def cong: irqstate.case_cong)
   apply (rule conjI; rule impI)
    apply (wp dmo_maskInterrupt_True getCTE_wp'
           | wpc | simp add: doMachineOp_bind maskIrqSignal_def )+

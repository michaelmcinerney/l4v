--- CSpace_I.thy
+++ CSpace_I.thy
@@ -14,21 +14,8 @@ begin
 
 context begin interpretation Arch . (*FIXME: arch_split*)
 
-lemma capUntypedPtr_simps [simp]:
-  "capUntypedPtr (ThreadCap r) = r"
-  "capUntypedPtr (NotificationCap r badge a b) = r"
-  "capUntypedPtr (EndpointCap r badge a b c d) = r"
-  "capUntypedPtr (Zombie r bits n) = r"
-  "capUntypedPtr (ArchObjectCap x) = Arch.capUntypedPtr x"
-  "capUntypedPtr (UntypedCap d r n f) = r"
-  "capUntypedPtr (CNodeCap r n g n2) = r"
-  "capUntypedPtr (ReplyCap r m a) = r"
-  "Arch.capUntypedPtr (ARM_H.ASIDPoolCap r asid) = r"
-  "Arch.capUntypedPtr (ARM_H.PageCap d r rghts sz mapdata) = r"
-  "Arch.capUntypedPtr (ARM_H.PageTableCap r mapdata2) = r"
-  "Arch.capUntypedPtr (ARM_H.PageDirectoryCap r mapdata3) = r"
-  by (auto simp: capUntypedPtr_def
-                 ARM_H.capUntypedPtr_def)
+lemmas capUntypedPtr_simps[simp] = capUntypedPtr_def[split_simps capability.split, simplified PPtr_def id_def]
+lemmas arch_capUntypedPtr_simps[simp] = ARM_H.capUntypedPtr_def[split_simps arch_capability.split, simplified PPtr_def id_def]
 
 lemma rights_mask_map_UNIV [simp]:
   "rights_mask_map UNIV = allRights"
@@ -519,7 +506,6 @@ lemma isPhysicalCap[simp]:
   by (simp add: isPhysicalCap_def ARM_H.isPhysicalCap_def
          split: capability.split arch_capability.split)
 
-(* FIXME instead of a definition and then a simp rule in the simp set, we should use fun *)
 definition
   capMasterCap :: "capability \<Rightarrow> capability"
 where
@@ -542,29 +528,7 @@ where
     | _ \<Rightarrow> acap)
  | _ \<Rightarrow> cap"
 
-lemma capMasterCap_simps[simp]:
-  "capMasterCap (EndpointCap ref bdg s r g gr) = EndpointCap ref 0 True True True True"
-  "capMasterCap (NotificationCap ref bdg s r) = NotificationCap ref 0 True True"
-  "capMasterCap (CNodeCap ref bits gd gs) = CNodeCap ref bits 0 0"
-  "capMasterCap (ThreadCap ref) = ThreadCap ref"
-  "capMasterCap capability.NullCap = capability.NullCap"
-  "capMasterCap capability.DomainCap = capability.DomainCap"
-  "capMasterCap (capability.IRQHandlerCap irq) = capability.IRQHandlerCap irq"
-  "capMasterCap (capability.Zombie word zombie_type n) = capability.Zombie word zombie_type n"
-  "capMasterCap (capability.ArchObjectCap (arch_capability.ASIDPoolCap word1 word2)) =
-            capability.ArchObjectCap (arch_capability.ASIDPoolCap word1 0)"
-  "capMasterCap (capability.ArchObjectCap arch_capability.ASIDControlCap) =
-         capability.ArchObjectCap arch_capability.ASIDControlCap"
-  "capMasterCap (capability.ArchObjectCap (arch_capability.PageCap d word vmrights vmpage_size pdata)) =
-            capability.ArchObjectCap (arch_capability.PageCap d word VMReadWrite vmpage_size None)"
-  "capMasterCap (capability.ArchObjectCap (arch_capability.PageTableCap word ptdata)) =
-            capability.ArchObjectCap (arch_capability.PageTableCap word None)"
-  "capMasterCap (capability.ArchObjectCap (arch_capability.PageDirectoryCap word pddata)) =
-            capability.ArchObjectCap (arch_capability.PageDirectoryCap word None)"
-  "capMasterCap (capability.UntypedCap d word n f) = capability.UntypedCap d word n 0"
-  "capMasterCap capability.IRQControlCap = capability.IRQControlCap"
-  "capMasterCap (capability.ReplyCap word m g) = capability.ReplyCap word True True"
-  by (simp_all add: capMasterCap_def)
+lemmas capMasterCap_simps[simp] = capMasterCap_def[split_simps capability.split arch_capability.split]
 
 lemma capMasterCap_eqDs1:
   "capMasterCap cap = EndpointCap ref bdg s r g gr
@@ -593,8 +561,8 @@ lemma capMasterCap_eqDs1:
      \<Longrightarrow> cap = Zombie ref tp n"
   "capMasterCap cap = UntypedCap d ref bits 0
      \<Longrightarrow> \<exists>f. cap = UntypedCap d ref bits f"
-  "capMasterCap cap = ReplyCap ref master g
-     \<Longrightarrow> master \<and> g \<and> (\<exists>master g. cap = ReplyCap ref master g)"
+  "capMasterCap cap = ReplyCap ref g
+     \<Longrightarrow> g \<and> (\<exists>g. cap = ReplyCap ref g)"
   "capMasterCap cap = ArchObjectCap (PageCap d ref rghts sz mapdata)
      \<Longrightarrow> rghts = VMReadWrite \<and> mapdata = None
           \<and> (\<exists>rghts mapdata. cap = ArchObjectCap (PageCap d ref rghts sz mapdata))"
@@ -709,7 +681,7 @@ lemma sameRegionAs_def2:
            split del: if_split cong: if_cong)
   apply (clarsimp simp: capRange_def Let_def)
   apply (simp add: range_subset_eq2 cong: conj_cong)
-  by (simp add: conj_comms)
+  by (auto simp add: conj_comms)
 
 lemma sameObjectAs_def2:
  "sameObjectAs cap cap' = (\<lambda>cap cap'.
@@ -865,7 +834,7 @@ lemma cte_wp_at_obj_cases':
   apply (simp add: cte_wp_at_cases' obj_at'_def)
   apply (rule iffI)
    apply (erule disjEI
-           | clarsimp simp: objBits_simps' cte_level_bits_def projectKOs
+           | clarsimp simp: objBits_simps' cte_level_bits_def projectKOs word_bits_def
            | rule rev_bexI, erule domI)+
   apply fastforce
   done
@@ -1969,12 +1942,11 @@ lemma setCTE_valid_objs'[wp]:
   unfolding setCTE_def
   apply (rule setObject_valid_objs')
    apply (clarsimp simp: prod_eq_iff lookupAround2_char1 updateObject_cte objBits_simps)
-   apply (clarsimp simp: prod_eq_iff lookupAround2_char1
+   by (clarsimp simp: prod_eq_iff lookupAround2_char1
                          updateObject_cte in_monad typeError_def
                          valid_obj'_def valid_tcb'_def valid_cte'_def
                          tcb_cte_cases_def
-                  split: kernel_object.split_asm if_split_asm)
-  done
+                  split: kernel_object.split_asm if_split_asm)+
 
 lemma getCTE_cte_wp_at:
   "\<lbrace>\<top>\<rbrace> getCTE p \<lbrace>\<lambda>rv. cte_wp_at' (\<lambda>c. c = rv) p\<rbrace>"
@@ -2022,9 +1994,6 @@ lemma setCTE_no_0_obj' [wp]:
 
 declare mresults_fail[simp]
 
-crunch idle[wp]: get_object "valid_idle"
-  (wp: crunch_wps simp: crunch_simps)
-
 end
 
 

--- PageTableDuplicates.thy
+++ PageTableDuplicates.thy
@@ -19,9 +19,10 @@ lemma set_ep_valid_duplicate' [wp]:
                         objBits_def[symmetric] lookupAround2_char1
                  split: if_split_asm)
   apply (frule pspace_storable_class.updateObject_type[where v = v,simplified])
-  apply (clarsimp simp:updateObject_default_def assert_def bind_def
-    alignCheck_def in_monad when_def alignError_def magnitudeCheck_def
-    assert_opt_def return_def fail_def split:if_splits option.splits)
+  apply (clarsimp simp: updateObject_default_def assert_def bind_def when_def
+                        alignError_def magnitudeCheck_def read_magnitudeCheck_def
+                        assert_opt_def return_def fail_def
+                 split: if_splits option.splits)
    apply (rule_tac ko = ba in valid_duplicates'_non_pd_pt_I)
        apply simp+
   apply (rule_tac ko = ba in valid_duplicates'_non_pd_pt_I)
@@ -37,9 +38,10 @@ lemma set_ntfn_valid_duplicate' [wp]:
                         objBits_def[symmetric] lookupAround2_char1
                  split: if_split_asm)
   apply (frule pspace_storable_class.updateObject_type[where v = v,simplified])
-  apply (clarsimp simp:updateObject_default_def assert_def bind_def
-    alignCheck_def in_monad when_def alignError_def magnitudeCheck_def
-    assert_opt_def return_def fail_def split:if_splits option.splits)
+  apply (clarsimp simp: updateObject_default_def assert_def bind_def when_def
+                        alignError_def magnitudeCheck_def read_magnitudeCheck_def
+                        assert_opt_def return_def fail_def
+                 split: if_splits option.splits)
    apply (rule_tac ko = ba in valid_duplicates'_non_pd_pt_I)
        apply simp+
   apply (rule_tac ko = ba in valid_duplicates'_non_pd_pt_I)
@@ -62,7 +64,7 @@ lemma setCTE_valid_duplicates'[wp]:
      apply (erule valid_duplicates'_non_pd_pt_I[rotated 3],simp+)+
   done
 
-crunches cteInsert, setupReplyMaster
+crunches cteInsert
   for valid_duplicates'[wp]: "(\<lambda>s. vs_valid_duplicates' (ksPSpace s))"
   (wp: crunch_wps simp: crunch_simps)
 
@@ -72,7 +74,7 @@ lemma doMachineOp_ksPSpace_inv[wp]:
 
 crunches threadSet, setBoundNotification, setExtraBadge
   for valid_duplicates'[wp]: "\<lambda>s. vs_valid_duplicates' (ksPSpace s)"
-  (wp: setObject_ksInterrupt updateObject_default_inv)
+  (wp: updateObject_default_inv)
 
 lemma transferCapsToSlots_duplicates'[wp]:
  "\<lbrace>\<lambda>s. vs_valid_duplicates' (ksPSpace s)\<rbrace>
@@ -80,11 +82,39 @@ lemma transferCapsToSlots_duplicates'[wp]:
   \<lbrace>\<lambda>rv s. vs_valid_duplicates' (ksPSpace s)\<rbrace>"
   by (rule transferCapsToSlots_pres1; wp)
 
+lemma setObjectSC_valid_duplicates'[wp]:
+  "setObject a (sc::sched_context) \<lbrace>\<lambda>s. vs_valid_duplicates' (ksPSpace s)\<rbrace>"
+  apply (clarsimp simp: setObject_def split_def valid_def in_monad
+                        projectKOs pspace_aligned'_def ps_clear_upd
+                        objBits_def[symmetric] lookupAround2_char1
+                 split: if_split_asm)
+  apply (frule pspace_storable_class.updateObject_type[where v = sc,simplified])
+  apply (clarsimp simp: updateObject_default_def assert_def bind_def
+                        alignCheck_def in_monad when_def alignError_def magnitudeCheck_def
+                        assert_opt_def return_def fail_def typeError_def
+                  split: if_splits option.splits Structures_H.kernel_object.splits)
+     apply (erule valid_duplicates'_non_pd_pt_I[rotated 3],simp+)+
+  done
+
+lemma setObjectReply_valid_duplicates'[wp]:
+  "setObject a (r::reply) \<lbrace>\<lambda>s. vs_valid_duplicates' (ksPSpace s)\<rbrace>"
+  apply (clarsimp simp: setObject_def split_def valid_def in_monad
+                        projectKOs pspace_aligned'_def ps_clear_upd
+                        objBits_def[symmetric] lookupAround2_char1
+                 split: if_split_asm)
+  apply (frule pspace_storable_class.updateObject_type[where v = r,simplified])
+  apply (clarsimp simp: updateObject_default_def assert_def bind_def
+                        alignCheck_def in_monad when_def alignError_def magnitudeCheck_def
+                        assert_opt_def return_def fail_def typeError_def
+                  split: if_splits option.splits Structures_H.kernel_object.splits)
+     apply (erule valid_duplicates'_non_pd_pt_I[rotated 3],simp+)+
+  done
+
 crunches transferCaps, sendFaultIPC, handleFault, replyFromKernel, insertNewCap
   for valid_duplicates'[wp]: "\<lambda>s. vs_valid_duplicates' (ksPSpace s)"
   (ignore: transferCapsToSlots
-       wp: crunch_wps hoare_vcg_const_Ball_lift get_rs_cte_at'
-     simp: zipWithM_x_mapM ball_conj_distrib)
+       wp: crunch_wps hoare_vcg_const_Ball_lift hoare_vcg_all_lift get_rs_cte_at' whileM_inv
+     simp: zipWithM_x_mapM ball_conj_distrib crunch_simps)
 
 lemma koTypeOf_pte:
   "koTypeOf ko = ArchT PTET \<Longrightarrow> \<exists>pte. ko = KOArch (KOPTE pte)"
@@ -107,15 +137,16 @@ lemma mapM_x_storePTE_updates:
   apply (thin_tac "valid P f Q" for P f Q)
   apply (simp add: storePTE_def setObject_def)
   apply (wp | simp add:split_def updateObject_default_def)+
-  apply clarsimp
+  apply (clarsimp cong: if_cong)
   apply (intro conjI ballI)
    apply (drule(1) bspec)
-   apply (clarsimp simp:typ_at'_def ko_wp_at'_def
-     objBits_simps archObjSize_def dest!:koTypeOf_pte
-     split:  Structures_H.kernel_object.split_asm)
+   apply (clarsimp simp: typ_at'_def ko_wp_at'_def objBits_defs
+                   dest!: koTypeOf_pte
+                   split:  kernel_object.split_asm)
    apply (simp add:ps_clear_def dom_fun_upd2[unfolded fun_upd_def])
+   apply (simp add: lookupAround2_known1)
   apply (erule rsubst[where P=Q])
-  apply fastforce
+  apply (rule ext, clarsimp)
   done
 
 lemma is_aligned_plus_bound:
@@ -345,7 +376,7 @@ lemma mapM_x_storePTE_update_helper:
       apply (drule pspace_alignedD')
        apply simp
       apply (simp add:objBits_simps' archObjSize_def pteBits_def
-        is_aligned_weaken[where y = 2] pageBits_def pdeBits_def
+        is_aligned_weaken[where y = 2] pageBits_def pdeBits_def vs_ptr_align_def
         split:kernel_object.splits arch_kernel_object.splits)
      apply (simp add:mask_lower_twice)
      apply (drule mask_out_first_mask_some[where m = ptBits])
@@ -403,15 +434,15 @@ lemma mapM_x_storePDE_updates:
   apply (thin_tac "valid P f Q" for P f Q)
   apply (simp add: storePDE_def setObject_def)
   apply (wp | simp add:split_def updateObject_default_def)+
-  apply clarsimp
+  apply (clarsimp cong: if_cong)
   apply (intro conjI ballI)
    apply (drule(1) bspec)
    apply (clarsimp simp:typ_at'_def ko_wp_at'_def
      objBits_simps archObjSize_def dest!:koTypeOf_pde
      split:  Structures_H.kernel_object.split_asm  arch_kernel_object.split_asm if_split)
-   apply (simp add:ps_clear_def dom_fun_upd2[unfolded fun_upd_def])
+   apply (simp add:ps_clear_def dom_fun_upd2[unfolded fun_upd_def])+
   apply (erule rsubst[where P=Q])
-  apply fastforce
+  apply (rule ext, clarsimp)
   done
 
 lemma mapM_x_storePDE_update_helper:
@@ -457,7 +488,7 @@ lemma mapM_x_storePDE_update_helper:
       apply (drule pspace_alignedD')
        apply simp
       apply (simp add:objBits_simps' archObjSize_def pteBits_def
-        is_aligned_weaken[where y = 2] pageBits_def pdeBits_def
+        is_aligned_weaken[where y = 2] pageBits_def pdeBits_def vs_ptr_align_def
         split:kernel_object.splits arch_kernel_object.splits)
      apply (simp add:mask_lower_twice)
      apply (drule mask_out_first_mask_some[where m = pdBits])
@@ -578,12 +609,11 @@ lemma copyGlobalMappings_ksPSpace_stable:
       apply (rule ccontr)
       apply clarsimp
       apply (drule(1) pspace_alignedD')
-      apply (drule is_aligned_weaken[where y = 2])
-       apply (case_tac y, simp_all add: objBits_simps' pageBits_def)
-      apply (simp add: archObjSize_def pageBits_def
-                       pteBits_def pdeBits_def
-                  split: arch_kernel_object.splits)
-      done
+      apply (drule is_aligned_weaken[where y = 2]; simp?)
+      apply (clarsimp simp: archObjSize_def pageBits_def pteBits_def pdeBits_def objBits_simps'
+                     split: arch_kernel_object.split kernel_object.splits)
+      using scBits_at_least_6
+      by (metis add_num_simps(2) arith_simps(45) le_add2 le_trans numeral.simps(2))
     have ptr_eqD:
       "\<And>p a b. \<lbrakk>p + a = ptr + b;is_aligned p pdBits;
             a < 2^ pdBits; b < 2^pdBits \<rbrakk>
@@ -697,12 +727,13 @@ lemma copyGlobalMappings_ksPSpace_stable:
         | simp add: storePDE_def setObject_def split_def
         updateObject_default_def
         split: option.splits)+
-     apply (clarsimp simp:objBits_simps archObjSize_def)
-     apply (clarsimp simp:obj_at'_def objBits_simps
-        projectKO_def projectKO_opt_pde fail_def return_def
-        split: Structures_H.kernel_object.splits
-        arch_kernel_object.splits)
-     apply (drule_tac x = xa in bspec)
+     apply (clarsimp simp: objBits_simps archObjSize_def obj_at'_def scBits_simps
+                           projectKO_def projectKO_opt_pde fail_def return_def oassert_opt_def)
+     apply (intro conjI impI)
+       apply (clarsimp simp: obj_at'_def objBits_simps scBits_simps
+                             projectKO_def projectKO_opt_pde fail_def return_def pde.exhaust
+                      split: Structures_H.kernel_object.splits  arch_kernel_object.splits)
+      apply (drule_tac x = xa in bspec)
       apply simp
       apply (rule ccontr)
       apply (simp add: pdeBits_def)
@@ -719,7 +750,11 @@ lemma copyGlobalMappings_ksPSpace_stable:
        apply (drule postfix_listD)
        apply (clarsimp simp:pdBits_def pdeBits_def le_less_trans)
       apply (simp add:pdBits_def pageBits_def pdeBits_def)
-     apply simp
+      apply (clarsimp simp: obj_at'_def objBits_simps scBits_simps
+                            projectKO_def projectKO_opt_pde fail_def return_def
+                     split: Structures_H.kernel_object.splits arch_kernel_object.splits)
+     apply (drule_tac x = xa in bspec)
+      apply (clarsimp simp:pdBits_def pdeBits_def le_less_trans)+
     apply wp
    apply (clarsimp simp:objBits_simps archObjSize_def pdeBits_def)
   apply (rule hoare_name_pre_state)
@@ -761,7 +796,7 @@ lemma copyGlobalMappings_ksPSpace_same:
     updateObject_default_def
     split: option.splits)+
     apply (clarsimp simp:objBits_simps archObjSize_def)
-    apply (clarsimp simp:obj_at'_def objBits_simps
+    apply (clarsimp simp:obj_at'_def objBits_simps oassert_opt_def
       projectKO_def projectKO_opt_pde fail_def return_def
       split: Structures_H.kernel_object.splits
       arch_kernel_object.splits)
@@ -835,7 +870,7 @@ lemma copyGlobalMappings_ksPSpace_concrete:
     apply (frule_tac d1 = "0x3FFF" and p1="ptr" in is_aligned_add_helper[THEN conjunct2])
      apply (simp add: pdeBits_def)
     apply (frule_tac d1 = "pptrBase >> 20 << 2" and p1 = "ptr"
-                     in is_aligned_add_helper[THEN conjunct2])
+      in is_aligned_add_helper[THEN conjunct2])
      apply (simp add: pptrBase_def pdeBits_def)
     apply (simp add: pdeBits_def)
     apply (cut_tac copyGlobalMappings_ksPSpace_sameD)
@@ -1033,12 +1068,13 @@ lemma valid_duplicates'_update:
 
 lemma createObject_valid_duplicates'[wp]:
   "\<lbrace>(\<lambda>s. vs_valid_duplicates' (ksPSpace s)) and pspace_aligned' and pspace_distinct'
-   and pspace_no_overlap' ptr (getObjectSize ty us)
+   and pspace_no_overlap' ptr (getObjectSize ty us) and pspace_bounded'
    and (\<lambda>s. is_aligned (armKSGlobalPD (ksArchState s)) pdBits)
    and K (is_aligned ptr (getObjectSize ty us))
    and K (ty = APIObjectType apiobject_type.CapTableObject \<longrightarrow> us < 28)\<rbrace>
   RetypeDecls_H.createObject ty ptr us d
   \<lbrace>\<lambda>xa s. vs_valid_duplicates' (ksPSpace s)\<rbrace>"
+  supply if_cong[cong]
   apply (rule hoare_gen_asm)
   apply (simp add:createObject_def)
   apply (rule hoare_pre)
@@ -1110,12 +1146,17 @@ lemma createObject_valid_duplicates'[wp]:
      ,simplified objBits_simps])
     apply simp
    apply (clarsimp simp: objBits_simps archObjSize_def pdBits_def pageBits_def)
-   apply (frule(2) retype_aligned_distinct'[where n = 4096 and ko = "KOArch (KOPDE makeObject)"])
+   apply (frule(3) retype_aligned_distinct'[where n = 4096 and ko = "KOArch (KOPDE makeObject)"])
+    apply (simp add:objBits_simps archObjSize_def)
+    apply (rule range_cover_rel[OF range_cover_full])
+       apply simp
+      apply (simp add:APIType_capBits_def word_bits_def pdeBits_def)+
+   apply (frule(3) retype_aligned_distinct'(2)[where n = 4096 and ko = "KOArch (KOPDE makeObject)"])
     apply (simp add:objBits_simps archObjSize_def)
     apply (rule range_cover_rel[OF range_cover_full])
        apply simp
       apply (simp add:APIType_capBits_def word_bits_def pdeBits_def)+
-   apply (frule(2) retype_aligned_distinct'(2)[where n = 4096 and ko = "KOArch (KOPDE makeObject)"])
+   apply (frule(3) retype_aligned_distinct'(3)[where n = 4096 and ko = "KOArch (KOPDE makeObject)"])
     apply (simp add:objBits_simps archObjSize_def)
     apply (rule range_cover_rel[OF range_cover_full])
        apply simp
@@ -1133,49 +1174,42 @@ lemma createObject_valid_duplicates'[wp]:
    apply (rule none_in_new_cap_addrs[where us =12,simplified]
      ,(simp add: objBits_simps pageBits_def word_bits_conv archObjSize_def pdeBits_def)+)[1]
   apply (intro conjI impI allI)
-      apply simp
-     apply clarsimp
-     apply (drule(2) valid_duplicates'_update) prefer 3
-       apply fastforce
-      apply (simp add: vs_entry_align_def)
-     apply simp
-    apply clarsimp
-    apply (drule(2) valid_duplicates'_update) prefer 3
-      apply (fastforce simp: vs_entry_align_def)+
-   apply clarsimp
-   apply (drule(2) valid_duplicates'_update) prefer 3
-     apply (fastforce simp: vs_entry_align_def)+
-  apply (clarsimp simp:ARM_H.toAPIType_def word_bits_def
-                 split:ARM_H.object_type.splits)
-  apply (cut_tac ptr = ptr in new_cap_addrs_fold'[where n = "2^us"
-   and ko = "(KOCTE makeObject)",simplified])
-   apply (rule word_1_le_power)
-  apply (clarsimp simp: word_bits_def)
-  apply (drule_tac ptr = ptr and ko = "KOCTE makeObject" in
-    valid_duplicates'_insert_ko[where us = us,simplified])
-      apply (simp add: APIType_capBits_def is_aligned_mask ARM_H.toAPIType_def
-                split: ARM_H.object_type.splits)
-     apply (simp add: vs_entry_align_def)
-   apply (simp add: objBits_simps')
-   apply (rule none_in_new_cap_addrs
-     ,(simp add: objBits_simps' pageBits_def APIType_capBits_def
-                 ARM_H.toAPIType_def
-                 word_bits_conv archObjSize_def is_aligned_mask
-          split: ARM_H.object_type.splits)+)[1]
-  apply (clarsimp simp: word_bits_def)
- done
-
+        apply simp
+       apply (fastforce elim!: valid_duplicates'_update simp: vs_entry_align_def)+
+    apply (clarsimp simp:ARM_H.toAPIType_def word_bits_def
+                   split:ARM_H.object_type.splits)
+    apply (cut_tac ptr = ptr in new_cap_addrs_fold'[where n = "2^us"
+               and ko = "(KOCTE makeObject)",simplified])
+     apply (rule word_1_le_power)
+     apply (clarsimp simp: word_bits_def)
+    apply (drule_tac ptr = ptr and ko = "KOCTE makeObject" in
+           valid_duplicates'_insert_ko[where us = us,simplified])
+        apply (simp add: APIType_capBits_def is_aligned_mask toAPIType_def
+                  split: ARM_H.object_type.splits)
+       apply (simp add: vs_entry_align_def)
+      apply (simp add: objBits_simps')
+     apply (rule none_in_new_cap_addrs
+            ,(simp add: objBits_simps' pageBits_def APIType_capBits_def
+                        ARM_H.toAPIType_def
+                        word_bits_conv archObjSize_def is_aligned_mask
+                 split: ARM_H.object_type.splits)+)[1]
+    apply (clarsimp simp: word_bits_def)
+   apply (fastforce elim!: valid_duplicates'_update
+                     simp: vs_entry_align_def)+
+  done
 
 crunch arch_inv[wp]: createNewObjects "\<lambda>s. P (armKSGlobalPD (ksArchState s))"
   (simp: crunch_simps zipWithM_x_mapM wp: crunch_wps hoare_unless_wp)
 
 
 lemma createNewObjects_valid_duplicates'[wp]:
- "\<lbrace> (\<lambda>s. vs_valid_duplicates' (ksPSpace s)) and pspace_no_overlap' ptr sz
-  and pspace_aligned' and pspace_distinct' and (\<lambda>s. is_aligned (armKSGlobalPD (ksArchState s)) pdBits)
-  and K (range_cover ptr sz (Types_H.getObjectSize ty us) (length dest) \<and>
-      ptr \<noteq> 0 \<and> (ty = APIObjectType ArchTypes_H.apiobject_type.CapTableObject \<longrightarrow> us < 28) ) \<rbrace>
-       createNewObjects ty src dest ptr us d
+ "\<lbrace>(\<lambda>s. vs_valid_duplicates' (ksPSpace s)) and pspace_no_overlap' ptr sz and pspace_aligned'
+    and pspace_distinct' and pspace_bounded' and (\<lambda>s. is_aligned (armKSGlobalPD (ksArchState s)) pdBits)
+    and K (range_cover ptr sz (Types_H.getObjectSize ty us) (length dest))
+    and K (ptr \<noteq> 0)
+    and K (ty = APIObjectType ArchTypes_H.apiobject_type.CapTableObject \<longrightarrow> us < 28)
+    and K (ty = APIObjectType ArchTypes_H.apiobject_type.SchedContextObject \<longrightarrow> sc_size_bounds us)\<rbrace>
+  createNewObjects ty src dest ptr us d
   \<lbrace>\<lambda>reply s. vs_valid_duplicates' (ksPSpace s)\<rbrace>"
   proof (induct rule:rev_induct )
     case Nil
@@ -1184,24 +1218,24 @@ lemma createNewObjects_valid_duplicates'[wp]:
    next
    case (snoc dest dests)
    show ?case
-     apply (rule hoare_gen_asm)
+     apply (rule hoare_gen_asm)+
      apply clarsimp
      apply (frule range_cover.weak)
      apply (subst createNewObjects_Cons)
       apply (simp add: word_bits_def)
      apply wp
       apply (wp snoc.hyps)
+       (* first bundling up "pspace_xxx" conjuncts together to apply
+          createNewObjects_pspace_no_overlap' in an appropriate way *)
+      apply (subst conj_assoc[symmetric])
+      apply (subst conj_assoc[symmetric])
+      apply (subst conj_assoc[symmetric])
       apply (rule hoare_vcg_conj_lift)
        apply (rule hoare_post_imp[OF _ createNewObjects_pspace_no_overlap'[where sz = sz]])
        apply clarsimp
-      apply (rule hoare_vcg_conj_lift)
-       apply (rule hoare_post_imp[OF _ createNewObjects_pspace_no_overlap'[where sz = sz]])
-       apply clarsimp
-      apply (rule hoare_vcg_conj_lift)
-       apply (rule hoare_post_imp[OF _ createNewObjects_pspace_no_overlap'[where sz = sz]])
        apply (rule pspace_no_overlap'_le)
-        apply fastforce
-       apply (simp add: range_cover.sz[where 'a=32, folded word_bits_def])+
+         apply fastforce
+        apply (simp add: range_cover.sz[where 'a=32, folded word_bits_def])+
       apply wp
      apply clarsimp
      apply (frule range_cover.aligned)
@@ -1256,51 +1290,52 @@ lemma valid_duplicates_deleteObjects_helper:
           atLeastAtMost_iff
   shows "vs_valid_duplicates'  (\<lambda>x. if x \<in> {ptr .. ptr + 2 ^ sz - 1} then None else m x)"
   apply (rule valid_duplicates'_diffI,rule vd)
-  apply (clarsimp simp: vs_valid_duplicates'_def split:option.splits)
+   apply (clarsimp simp: vs_valid_duplicates'_def split:option.splits)
   apply (clarsimp simp: vs_valid_duplicates'_def split:option.splits)
   apply (case_tac "the (m x)",simp_all add:vs_ptr_align_def)
-   apply fastforce+
+           apply fastforce+
   apply (rename_tac arch_kernel_object)
   apply (case_tac arch_kernel_object)
-    apply fastforce+
-   apply (clarsimp split:ARM_H.pte.splits)
-   apply auto[1]
+      apply fastforce+
+     apply (clarsimp split:ARM_H.pte.splits)
+     apply auto[1]
+       apply (drule_tac p' = y in valid_duplicates'_D[OF vd])
+         apply (simp add:vs_ptr_align_def)+
+       apply clarsimp
+       apply (drule(1) inc)
+       apply (drule(1) mask_out_first_mask_some)
+       apply (simp add:mask_lower_twice)
+       apply (simp add: mask_in_range[OF aligned,symmetric])
+      apply (drule_tac p' = y in valid_duplicates'_D[OF vd])
+        apply simp
+       apply (simp add:vs_ptr_align_def)
+      apply simp
      apply (drule_tac p' = y in valid_duplicates'_D[OF vd])
-       apply (simp add:vs_ptr_align_def)+
-     apply clarsimp
-     apply (drule(1) inc)
-     apply (drule(1) mask_out_first_mask_some)
+       apply simp
+      apply (simp add:vs_ptr_align_def)
+     apply simp
+    apply (clarsimp split:ARM_H.pde.splits)
+    apply auto[1]
+      apply (drule_tac p' = y in valid_duplicates'_D[OF vd])
+        apply simp
+       apply (simp add:vs_ptr_align_def)
+      apply (drule(1) inc)
+      apply (drule(1) mask_out_first_mask_some)
       apply (simp add:mask_lower_twice)
-     apply (simp add: mask_in_range[OF aligned,symmetric])
-    apply (drule_tac p' = y in valid_duplicates'_D[OF vd])
-      apply simp
-     apply (simp add:vs_ptr_align_def)
-    apply simp
-   apply (drule_tac p' = y in valid_duplicates'_D[OF vd])
+      apply (simp add: mask_in_range[OF aligned,symmetric])
+     apply (drule_tac p' = y in valid_duplicates'_D[OF vd])
+       apply simp
+      apply (simp add:vs_ptr_align_def)
      apply simp
-    apply (simp add:vs_ptr_align_def)
-   apply simp
-  apply (clarsimp split:ARM_H.pde.splits)
-  apply auto[1]
     apply (drule_tac p' = y in valid_duplicates'_D[OF vd])
       apply simp
      apply (simp add:vs_ptr_align_def)
-    apply (drule(1) inc)
-    apply (drule(1) mask_out_first_mask_some)
-    apply (simp add:mask_lower_twice)
-    apply (simp add: mask_in_range[OF aligned,symmetric])
-   apply (drule_tac p' = y in valid_duplicates'_D[OF vd])
-     apply simp
-    apply (simp add:vs_ptr_align_def)
-   apply simp
-  apply (drule_tac p' = y in valid_duplicates'_D[OF vd])
     apply simp
-   apply (simp add:vs_ptr_align_def)
-  apply simp
+   apply fastforce+
   done
 
 lemma deleteObjects_valid_duplicates'[wp]:
-  notes blah[simp del] =  atLeastatMost_subset_iff atLeastLessThan_iff
+  notes [simp del] =  atLeastatMost_subset_iff atLeastLessThan_iff
           Int_atLeastAtMost atLeastatMost_empty_iff split_paired_Ex
           atLeastAtMost_iff
   shows
@@ -1309,7 +1344,9 @@ lemma deleteObjects_valid_duplicates'[wp]:
    \<rbrace> deleteObjects ptr sz
    \<lbrace>\<lambda>r s. vs_valid_duplicates' (ksPSpace s)\<rbrace>"
   apply (rule hoare_gen_asm)
-  apply (clarsimp simp:deleteObjects_def2)
+  apply (clarsimp simp: deleteObjects_def2)
+  apply (rule hoare_seq_ext_skip, wpsimp)
+  apply (rule hoare_seq_ext_skip, wpsimp)
   apply (wp hoare_drop_imps|simp)+
   apply clarsimp
   apply (simp add:deletionIsSafe_def)
@@ -1326,20 +1363,32 @@ crunch arch_inv[wp]: resetUntypedCap "\<lambda>s. P (ksArchState s)"
 
 crunch valid_duplicates[wp]: updateFreeIndex "\<lambda>s. vs_valid_duplicates' (ksPSpace s)"
 
+lemma untypedCap_is_aligned:
+  "\<lbrakk>valid_objs' s; cte_wp_at' (isUntypedCap \<circ> cteCap) slot s; cte_wp_at' ((=) cap \<circ> cteCap) slot s\<rbrakk>
+   \<Longrightarrow> is_aligned (capPtr cap) (capBlockSize cap)"
+  apply (clarsimp simp: cte_wp_at_ctes_of)
+  apply (frule cte_wp_at_valid_objs_valid_cap'[OF ctes_of_cte_wpD], clarsimp+)
+  apply (clarsimp simp: valid_cap_simps' capAligned_def isCap_simps)
+  done
+
 lemma resetUntypedCap_valid_duplicates'[wp]:
   "\<lbrace>(\<lambda>s. vs_valid_duplicates' (ksPSpace s))
       and valid_objs' and cte_wp_at' (isUntypedCap o cteCap) slot\<rbrace>
-    resetUntypedCap slot
-  \<lbrace>\<lambda>r s. vs_valid_duplicates' (ksPSpace s)\<rbrace>"
+   resetUntypedCap slot
+   \<lbrace>\<lambda>_ s. vs_valid_duplicates' (ksPSpace s)\<rbrace>"
   (is "\<lbrace>?P\<rbrace> ?f \<lbrace>\<lambda>_. ?Q\<rbrace>")
   apply (clarsimp simp: resetUntypedCap_def)
-  apply (rule hoare_pre)
-   apply (wp | simp add: unless_def)+
-   apply (wp mapME_x_inv_wp preemptionPoint_inv | simp | wp (once) hoare_drop_imps)+
-   apply (wp getSlotCap_wp)
-  apply (clarsimp simp: cte_wp_at_ctes_of split del: if_split)
-  apply (frule cte_wp_at_valid_objs_valid_cap'[OF ctes_of_cte_wpD], clarsimp+)
-  apply (clarsimp simp add: isCap_simps valid_cap_simps' capAligned_def)
+  apply (rule validE_valid)
+  apply (rule_tac B="\<lambda>cap. ?P and cte_wp_at' ((=) cap \<circ> cteCap) slot" in hoare_vcg_seqE[rotated])
+   apply wpsimp
+  apply (simp only: unlessE_def)
+  apply (clarsimp; safe; (solves wpsimp)?)
+    apply wpsimp
+    apply (fastforce elim: untypedCap_is_aligned)
+   apply wpsimp
+   apply (fastforce elim: untypedCap_is_aligned)
+  apply (wpsimp wp: mapME_x_inv_wp preemptionPoint_inv)
+  apply (fastforce elim: untypedCap_is_aligned)
   done
 
 lemma is_aligned_armKSGlobalPD:
@@ -1359,8 +1408,8 @@ lemma invokeUntyped_valid_duplicates[wp]:
   notes hoare_whenE_wps[wp_split del] shows
   "\<lbrace>invs' and (\<lambda>s. vs_valid_duplicates' (ksPSpace s))
          and valid_untyped_inv' ui and ct_active'\<rbrace>
-     invokeUntyped ui
-   \<lbrace>\<lambda>rv s. vs_valid_duplicates' (ksPSpace s) \<rbrace>"
+   invokeUntyped ui
+   \<lbrace>\<lambda>_ s. vs_valid_duplicates' (ksPSpace s) \<rbrace>"
   apply (simp only: invokeUntyped_def updateCap_def)
   apply (rule hoare_name_pre_state)
   apply (cases ui)
@@ -1369,7 +1418,8 @@ lemma invokeUntyped_valid_duplicates[wp]:
   apply (frule(2) invokeUntyped_proofs.intro)
   apply (rule hoare_pre)
    apply simp
-   apply (wp add: updateFreeIndex_pspace_no_overlap')
+   apply (wp add: updateFreeIndex_pspace_no_overlap'
+             del: whenE_E_wp whenE_R_wp)
    apply (rule hoare_post_impErr)
      apply (rule combine_validE)
       apply (rule_tac ui=ui in whenE_reset_resetUntypedCap_invs_etc)
@@ -1411,8 +1461,7 @@ crunch valid_duplicates'[wp]:
 lemma get_asid_valid_duplicates'[wp]:
   "\<lbrace>\<lambda>s. vs_valid_duplicates' (ksPSpace s)\<rbrace>
   getObject param_b \<lbrace>\<lambda>(pool::asidpool) s. vs_valid_duplicates' (ksPSpace s)\<rbrace>"
-  apply (simp add:getObject_def split_def| wp)+
-  apply (simp add:loadObject_default_def|wp)+
+  apply (simp add:getObject_def | wp)+
   done
 
 lemma set_asid_pool_valid_duplicates'[wp]:
@@ -1433,7 +1482,7 @@ lemma set_asid_pool_valid_duplicates'[wp]:
 
 crunch valid_duplicates'[wp]:
   suspend "\<lambda>s. vs_valid_duplicates' (ksPSpace s)"
-  (wp: crunch_wps simp: crunch_simps unless_def o_def)
+  (wp: crunch_wps gts_wp' simp: crunch_simps unless_def o_def)
 
 crunch valid_duplicates'[wp]:
 deletingIRQHandler  "\<lambda>s. vs_valid_duplicates' (ksPSpace s)"
@@ -1468,7 +1517,7 @@ lemma storePDE_no_duplicates':
      Structures_H.kernel_object.splits ARM_H.pde.splits
      ARM_H.pte.splits)
   apply (clarsimp split:option.splits)
-  apply (drule_tac p = x and p' = y in valid_duplicates'_D)
+  apply (drule_tac p = x in valid_duplicates'_D)
    apply simp+
   done
 
@@ -1501,7 +1550,7 @@ lemma storePTE_no_duplicates':
      Structures_H.kernel_object.splits ARM_H.pde.splits
      ARM_H.pte.splits)
   apply (clarsimp split:option.splits)
-  apply (drule_tac p = x and p' = y in valid_duplicates'_D)
+  apply (drule_tac p = x in valid_duplicates'_D)
    apply simp+
   done
 
@@ -1516,7 +1565,7 @@ lemma checkMappingPPtr_SmallPage:
    apply (wp unlessE_wp getPTE_wp |wpc|simp add:)+
   apply (clarsimp simp:ko_wp_at'_def obj_at'_def)
   apply (clarsimp simp:projectKO_def projectKO_opt_pte
-    return_def fail_def vs_entry_align_def
+    return_def fail_def vs_entry_align_def oassert_opt_def
     split:kernel_object.splits
     arch_kernel_object.splits option.splits)
   done
@@ -1528,7 +1577,7 @@ lemma checkMappingPPtr_Section:
    apply (wp unlessE_wp getPDE_wp |wpc|simp add:)+
   apply (clarsimp simp:ko_wp_at'_def obj_at'_def)
   apply (clarsimp simp:projectKO_def projectKO_opt_pde
-    return_def fail_def vs_entry_align_def
+    return_def fail_def vs_entry_align_def oassert_opt_def
     split:kernel_object.splits
     arch_kernel_object.splits option.splits)
   done
@@ -1549,14 +1598,14 @@ crunch valid_duplicates'[wp]:
   (wp: crunch_wps simp: crunch_simps unless_def)
 
 lemma lookupPTSlot_aligned:
-  "\<lbrace>\<lambda>s. valid_objs' s \<and> vmsz_aligned' vptr sz \<and> sz \<noteq> ARMSuperSection\<rbrace>
+  "\<lbrace>\<lambda>s. valid_objs' s \<and> vmsz_aligned vptr sz \<and> sz \<noteq> ARMSuperSection\<rbrace>
    lookupPTSlot pd vptr
   \<lbrace>\<lambda>rv s. is_aligned rv ((pageBitsForSize sz) - 10)\<rbrace>,-"
   apply (simp add:lookupPTSlot_def)
   apply (wp|wpc|simp)+
   apply (wp getPDE_wp)
-  apply (clarsimp simp:obj_at'_def vmsz_aligned'_def)
-  apply (clarsimp simp:projectKO_def fail_def
+  apply (clarsimp simp:obj_at'_def vmsz_aligned_def)
+  apply (clarsimp simp:projectKO_def fail_def oassert_opt_def
     projectKO_opt_pde return_def lookup_pt_slot_no_fail_def
     split:option.splits Structures_H.kernel_object.splits
     arch_kernel_object.splits)
@@ -1584,7 +1633,7 @@ crunch valid_arch_state'[wp]:
 lemma unmapPage_valid_duplicates'[wp]:
   notes checkMappingPPtr_inv[wp del] shows
   "\<lbrace>pspace_aligned' and valid_objs' and (\<lambda>s. vs_valid_duplicates' (ksPSpace s))
-   and K (vmsz_aligned' vptr vmpage_size)\<rbrace>
+   and K (vmsz_aligned vptr vmpage_size)\<rbrace>
   unmapPage vmpage_size asiv vptr word \<lbrace>\<lambda>r s. vs_valid_duplicates' (ksPSpace s)\<rbrace>"
   apply (simp add:unmapPage_def)
    (* make sure checkMappingPPtr_SmallPage is first tried before checkMappingPPtr_inv *)
@@ -1616,10 +1665,10 @@ lemma unmapPage_valid_duplicates'[wp]:
    apply (clarsimp simp:conj_comms)
    apply (rule hoare_post_imp_R[where Q'= "\<lambda>r. pspace_aligned' and
      (\<lambda>s. vs_valid_duplicates' (ksPSpace s)) and
-     K(vmsz_aligned' vptr vmpage_size \<and> is_aligned r pdBits)
+     K(vmsz_aligned vptr vmpage_size \<and> is_aligned r pdBits)
      and page_directory_at' (lookup_pd_slot r vptr && ~~ mask pdBits)"])
     apply (wp findPDForASID_page_directory_at' | simp)+
-   apply (clarsimp simp add:pdBits_def pageBits_def vmsz_aligned'_def)
+   apply (clarsimp simp add:pdBits_def pageBits_def vmsz_aligned_def)
    apply (drule is_aligned_lookup_pd_slot)
     apply (erule is_aligned_weaken,simp)
    apply simp
@@ -1658,7 +1707,9 @@ crunch valid_duplicates'[wp]:
  deleteASID "\<lambda>s. vs_valid_duplicates' (ksPSpace s)"
   (wp: crunch_wps simp: crunch_simps unless_def)
 
-crunches deleteASIDPool, unbindNotification, prepareThreadDelete
+crunches deleteASIDPool, unbindNotification, prepareThreadDelete, unbindFromSC,
+         schedContextUnbindAllTCBs, schedContextZeroRefillMax, schedContextUnbindYieldFrom,
+         schedContextUnbindReply
   for valid_duplicates'[wp]: "\<lambda>s. vs_valid_duplicates' (ksPSpace s)"
   (wp: crunch_wps simp: crunch_simps unless_def)
 
@@ -1676,8 +1727,10 @@ lemma finaliseCap_valid_duplicates'[wp]:
   "\<lbrace>valid_objs' and pspace_aligned' and (\<lambda>s. vs_valid_duplicates' (ksPSpace s))
   and (valid_cap' cap)\<rbrace>
   finaliseCap cap call final \<lbrace>\<lambda>r s. vs_valid_duplicates' (ksPSpace s)\<rbrace>"
-  apply (case_tac cap,simp_all add:isCap_simps finaliseCap_def)
-            apply (wp|intro conjI|clarsimp split: option.splits)+
+  apply (cases cap; simp add: isCap_simps finaliseCap_def)
+               apply (wpsimp wp: crunch_wps hoare_vcg_all_lift
+                             simp: crunch_simps split: option.splits
+                      | rule conjI)+
   done
 
 crunch valid_duplicates'[wp]:
@@ -1742,15 +1795,15 @@ lemma cteRevoke_valid_duplicates'[wp]:
        \<and> sch_act_simple s \<rbrace>"
   apply (rule cteRevoke_preservation)
    apply (wp cteDelete_invs' cteDelete_valid_duplicates' cteDelete_sch_act_simple)
-     apply (simp add:cteDelete_def)+
+     apply (fastforce simp: cteDelete_def sch_act_simple_def)+
   done
 
 lemma mapM_x_storePTE_invalid_whole:
   "\<lbrace>\<lambda>s. vs_valid_duplicates' (ksPSpace s) \<and>
-        s \<turnstile>' capability.ArchObjectCap (arch_capability.PageTableCap word option) \<and>
-        pspace_aligned' s\<rbrace>
-   mapM_x (swp storePTE InvalidPTE) [word , word + 2 ^ pteBits .e. word + 2 ^ ptBits - 1]
-   \<lbrace>\<lambda>_ s. vs_valid_duplicates' (ksPSpace s)\<rbrace>"
+  s \<turnstile>' capability.ArchObjectCap (arch_capability.PageTableCap word option) \<and>
+  pspace_aligned' s\<rbrace>
+  mapM_x (swp storePTE InvalidPTE) [word , word + 2 ^ pteBits .e. word + 2 ^ ptBits - 1]
+  \<lbrace>\<lambda>y s. vs_valid_duplicates' (ksPSpace s)\<rbrace>"
   apply (wp mapM_x_storePTE_update_helper[where word = word and sz = ptBits and ptr = word])
   apply (clarsimp simp: valid_cap'_def capAligned_def pageBits_def ptBits_def objBits_simps
                         archObjSize_def pteBits_def)
@@ -1765,24 +1818,18 @@ crunch pspace_aligned'[wp]:
   invalidateTLBByASID pspace_aligned'
   (wp: crunch_wps simp: crunch_simps unless_def)
 
-crunch valid_duplicates'[wp]:
-  isFinalCapability "\<lambda>s. vs_valid_duplicates' (ksPSpace s)"
-  (wp: crunch_wps filterM_preserved simp: crunch_simps unless_def)
-
 crunch valid_cap'[wp]:
   isFinalCapability "\<lambda>s. valid_cap' cap s"
   (wp: crunch_wps filterM_preserved simp: crunch_simps unless_def)
 
 crunch valid_duplicates'[wp]:
   sendSignal "\<lambda>s. vs_valid_duplicates' (ksPSpace s)"
+  (wp: crunch_wps simp: crunch_simps)
 
 lemma invokeIRQControl_valid_duplicates'[wp]:
   "\<lbrace>\<lambda>s. vs_valid_duplicates' (ksPSpace s) \<rbrace> performIRQControl a
-  \<lbrace>\<lambda>_ s. vs_valid_duplicates' (ksPSpace s)\<rbrace>"
-  apply (simp add:performIRQControl_def )
-  apply (rule hoare_pre)
-  apply (wp|wpc | simp add:ARM_H.performIRQControl_def)+
- done
+   \<lbrace>\<lambda>_ s. vs_valid_duplicates' (ksPSpace s)\<rbrace>"
+  unfolding performIRQControl_def by (wpsimp simp: ARM_H.performIRQControl_def)
 
 crunch valid_duplicates'[wp]: InterruptDecls_H.invokeIRQHandler "\<lambda>s. vs_valid_duplicates' (ksPSpace s)"
 
@@ -1800,14 +1847,8 @@ lemma invokeCNode_valid_duplicates'[wp]:
     apply (rule hoare_pre)
     apply (wp hoare_unless_wp | wpc | simp)+
    apply (simp add:invokeCNode_def)
-   apply (wp getSlotCap_inv hoare_drop_imp
-     |simp add:locateSlot_conv getThreadCallerSlot_def
-     |wpc)+
   apply (simp add:cteDelete_def invokeCNode_def)
-  apply (wp getSlotCap_inv hoare_drop_imp
-     |simp add:locateSlot_conv getThreadCallerSlot_def
-    whenE_def split_def
-     |wpc)+
+  apply (wp getSlotCap_inv hoare_drop_imp | simp add:locateSlot_conv whenE_def split_def | wpc)+
   apply (rule valid_validE)
    apply (rule hoare_post_imp[OF _ finaliseSlot_valid_duplicates'])
    apply simp
@@ -1960,7 +2001,7 @@ lemma performArchInvocation_valid_duplicates':
        apply fastforce
       apply (rule hoare_name_pre_state)
       apply (clarsimp simp: valid_arch_inv'_def isCap_simps valid_pti'_def
-                            cte_wp_at_ctes_of is_arch_update'_def isPageTableCap_def
+        cte_wp_at_ctes_of is_arch_update'_def isPageTableCap_def
                       split: arch_capability.splits)
       apply (clarsimp simp: performPageTableInvocation_def)
       apply (wp storePDE_no_duplicates' | simp)+
@@ -1994,7 +2035,7 @@ lemma performArchInvocation_valid_duplicates':
                          descendants_range'_def2 empty_descendants_range_in')
    apply (intro conjI; clarsimp)
    apply (drule(1) cte_cap_in_untyped_range, fastforce simp:cte_wp_at_ctes_of, simp_all)[1]
-    apply (clarsimp simp: invs'_def valid_state'_def if_unsafe_then_cap'_def cte_wp_at_ctes_of)
+    apply (clarsimp simp: invs'_def if_unsafe_then_cap'_def cte_wp_at_ctes_of)
    apply clarsimp
   apply (rename_tac asidpool_invocation)
   apply (case_tac asidpool_invocation)
@@ -2004,59 +2045,56 @@ lemma performArchInvocation_valid_duplicates':
 
 crunches restart
   for valid_duplicates'[wp]: "(\<lambda>s. vs_valid_duplicates' (ksPSpace s))"
-  (wp: crunch_wps)
+  (wp: crunch_wps simp: crunch_simps)
 
 crunches setPriority, setMCPriority
   for valid_duplicates'[wp]: "(\<lambda>s. vs_valid_duplicates' (ksPSpace s))"
   (ignore: threadSet
-       wp: setObject_ksInterrupt updateObject_default_inv
+       wp: setObject_ksInterrupt updateObject_default_inv crunch_wps
      simp: crunch_simps)
 
-lemma tc_valid_duplicates':
-  "\<lbrace>invs' and sch_act_simple and (\<lambda>s. vs_valid_duplicates' (ksPSpace s)) and tcb_at' a and ex_nonz_cap_to' a and
-    case_option \<top> (valid_cap' o fst) e' and
-    K (case_option True (isCNodeCap o fst) e') and
-    case_option \<top> (valid_cap' o fst) f' and
-    K (case_option True (isValidVTableRoot o fst) f') and
-    case_option \<top> (valid_cap') (case_option None (case_option None (Some o fst) o snd) g) and
-    K (valid_option_prio d) and
-    K (valid_option_prio mcp) and
-    K (case_option True isArchObjectCap (case_option None (case_option None (Some o fst) o snd) g))
-    and K (case_option True (swp is_aligned msg_align_bits o fst) g)\<rbrace>
-      invokeTCB (tcbinvocation.ThreadControl a sl b' mcp d e' f' g)
+crunches installTCBCap, installThreadBuffer
+  for valid_duplicates'[wp]: "(\<lambda>s. vs_valid_duplicates' (ksPSpace s))"
+  (wp:  crunch_wps checkCap_inv
+   simp: crunch_simps getThreadVSpaceRoot_def getThreadFaultHandlerSlot_def
+         getThreadTimeoutHandlerSlot_def
+   ignore: checkCapAt)
+
+lemma tc_caps_valid_duplicates':
+  "\<lbrace>invs' and sch_act_simple and (\<lambda>s. vs_valid_duplicates' (ksPSpace s)) and
+    tcb_at' t and ex_nonz_cap_to' t and
+    case_option \<top> (valid_cap' o fst) croot and
+    K (case_option True (isCNodeCap o fst) croot) and
+    case_option \<top> (valid_cap' o fst) vroot and
+    K (case_option True (isValidVTableRoot o fst) vroot) and
+    case_option \<top> (valid_cap' o fst) fault_h and
+    K (case_option True (isValidFaultHandler o fst) fault_h) and
+    case_option \<top> (valid_cap' o fst) timeout_h and
+    K (case_option True (isValidFaultHandler o fst) timeout_h) and
+    case_option \<top> (valid_cap') (case_option None (case_option None (Some o fst) o snd) ipcb) and
+    K (case_option True isArchObjectCap (case_option None (case_option None (Some o fst) o snd) ipcb))
+    and K (case_option True (swp is_aligned msg_align_bits o fst) ipcb)\<rbrace>
+      invokeTCB (ThreadControlCaps t sl fault_h timeout_h croot vroot ipcb)
    \<lbrace>\<lambda>rv s. vs_valid_duplicates' (ksPSpace s)\<rbrace>"
-  apply (rule hoare_gen_asm)
-  apply (simp add: split_def invokeTCB_def getThreadCSpaceRoot getThreadVSpaceRoot
-                   getThreadBufferSlot_def locateSlot_conv
-             cong: option.case_cong)
-  apply (simp only: eq_commute[where a="a"])
-  apply (rule hoare_walk_assmsE)
-    apply (clarsimp simp: pred_conj_def option.splits [where P="\<lambda>x. x s" for s])
-    apply ((wp case_option_wp threadSet_invs_trivial static_imp_wp
-               hoare_vcg_all_lift threadSet_cap_to' | clarsimp simp: inQ_def)+)[2]
-  apply (rule hoare_walk_assmsE)
-    apply (clarsimp simp: pred_conj_def option.splits [where P="\<lambda>x. x s" for s])
-    apply ((wp case_option_wp threadSet_invs_trivial static_imp_wp setMCPriority_invs'
-               typ_at_lifts[OF setMCPriority_typ_at']
-               hoare_vcg_all_lift threadSet_cap_to' | clarsimp simp: inQ_def)+)[2]
-  apply ((simp only: simp_thms cases_simp cong: conj_cong
-          | (wp cteDelete_deletes cteDelete_invs' cteDelete_sch_act_simple
-              threadSet_ipcbuffer_trivial
-              (* setPriority has no effect on vs_duplicates *)
-              case_option_wp[where m'="return ()", OF setPriority_valid_duplicates' return_inv,simplified]
-              checkCap_inv[where P="tcb_at' t" for t]
-              checkCap_inv[where P="valid_cap' c" for c]
-              checkCap_inv[where P="\<lambda>s. P (ksReadyQueues s)" for P]
-              checkCap_inv[where P="\<lambda>s. vs_valid_duplicates' (ksPSpace s)"]
-              checkCap_inv[where P=sch_act_simple] cteDelete_valid_duplicates' hoare_vcg_const_imp_lift_R
-              typ_at_lifts[OF setPriority_typ_at'] assertDerived_wp threadSet_cte_wp_at'
-              hoare_vcg_all_lift_R hoare_vcg_all_lift static_imp_wp)[1]
-          | wpc
-          | simp add: inQ_def
-          | wp hoare_vcg_conj_liftE1 cteDelete_invs' cteDelete_deletes hoare_vcg_const_imp_lift)+)
-  apply (clarsimp simp: tcb_cte_cases_def cte_level_bits_def objBits_defs
-                        tcbIPCBufferSlot_def)
-  by (auto dest!: isCapDs isReplyCapD isValidVTableRootD simp: isCap_simps)
+  apply (simp add: invokeTCB_def)
+  apply (wpsimp wp: hoare_vcg_all_lift hoare_vcg_const_imp_lift
+                    installTCBCap_invs' installTCBCap_sch_act_simple)
+  apply (fastforce simp: isValidFaultHandler_def isCap_simps isValidVTableRoot_def)
+  done
+
+crunches schedContextBindTCB
+  for valid_duplicates'[wp]: "(\<lambda>s. vs_valid_duplicates' (ksPSpace s))"
+  (wp: crunch_wps simp: crunch_simps)
+
+lemma tc_sched_valid_duplicates':
+  "\<lbrace>invs' and sch_act_simple and (\<lambda>s. vs_valid_duplicates' (ksPSpace s)) and
+    tcb_at' t and ex_nonz_cap_to' t and
+    case_option \<top> (valid_cap' o fst) sc_fh and
+    K (valid_option_prio pri) and
+    K (valid_option_prio mcp)\<rbrace>
+      invokeTCB  (ThreadControlSched t sl sc_fh pri mcp sc_opt)
+   \<lbrace>\<lambda>rv s. vs_valid_duplicates' (ksPSpace s)\<rbrace>"
+  by (wpsimp simp: mapTCBPtr_def stateAssertE_def invokeTCB_def wp: hoare_drop_imps)
 
 crunches performTransfer, unbindNotification, bindNotification, setDomain
   for valid_duplicates'[wp]: "(\<lambda>s. vs_valid_duplicates' (ksPSpace s))"
@@ -2068,72 +2106,65 @@ lemma invokeTCB_valid_duplicates'[wp]:
   "\<lbrace>invs' and sch_act_simple and ct_in_state' runnable' and tcb_inv_wf' ti and (\<lambda>s. vs_valid_duplicates' (ksPSpace s))\<rbrace>
      invokeTCB ti
    \<lbrace>\<lambda>rv s. vs_valid_duplicates' (ksPSpace s)\<rbrace>"
-  apply (case_tac ti, simp_all only:)
-       apply (simp add: invokeTCB_def)
-       apply wp
-       apply (clarsimp simp: invs'_def valid_state'_def
-                      dest!: global'_no_ex_cap)
-      apply (simp add: invokeTCB_def)
-      apply wp
-      apply (clarsimp simp: invs'_def valid_state'_def
-                     dest!: global'_no_ex_cap)
-     apply (wp tc_valid_duplicates')
-     apply (clarsimp split:option.splits)
-     apply (rename_tac option)
-     apply (case_tac option, simp_all)
-    apply (simp add:invokeTCB_def | wp mapM_x_wp' | intro impI conjI | wpc)+
+  apply (case_tac ti; simp only:)
+          apply (simp add: invokeTCB_def)
+          apply wp
+          apply (clarsimp simp: invs'_def
+                         dest!: global'_no_ex_cap)
+         apply (simp add: invokeTCB_def)
+         apply wp
+         apply (clarsimp simp: invs'_def
+                        dest!: global'_no_ex_cap)
+        apply (wpsimp wp: tc_caps_valid_duplicates' split: option.splits)
+       apply (wpsimp wp: tc_sched_valid_duplicates')
+      apply (simp add:invokeTCB_def | wp mapM_x_wp' | intro impI conjI | wpc)+
   done
 
+crunches invokeSchedContext, invokeSchedControlConfigureFlags
+  for valid_duplicates'[wp]: "\<lambda>s. vs_valid_duplicates' (ksPSpace s)"
+  (simp: crunch_simps wp: crunch_wps hoare_vcg_all_lift)
+
 lemma performInvocation_valid_duplicates'[wp]:
   "\<lbrace>\<lambda>s. vs_valid_duplicates' (ksPSpace s) \<and> invs' s \<and> sch_act_simple s
     \<and> valid_invocation' i s \<and> ct_active' s\<rbrace>
-  RetypeDecls_H.performInvocation isBlocking isCall i
-  \<lbrace>\<lambda>reply s. vs_valid_duplicates' (ksPSpace s)\<rbrace>"
+  RetypeDecls_H.performInvocation isBlocking isCall canDonate i
+  \<lbrace>\<lambda>_ s. vs_valid_duplicates' (ksPSpace s)\<rbrace>"
   apply (clarsimp simp: performInvocation_def)
-  apply (simp add:ct_in_state'_def)
+  apply (simp add: ct_in_state'_def)
   apply (rule hoare_name_pre_state)
   apply (rule hoare_pre)
-  apply wpc
-   apply (wp performArchInvocation_valid_duplicates' |simp)+
+   apply wpc
+              apply (wpsimp wp: performArchInvocation_valid_duplicates'
+                          simp: stateAssertE_def stateAssert_def)+
   apply (cases i)
-  apply (clarsimp simp: simple_sane_strg sch_act_simple_def
-                    ct_in_state'_def ct_active_runnable'[unfolded ct_in_state'_def]
-                  | wp tcbinv_invs' arch_performInvocation_invs'
-                  | rule conjI | erule active_ex_cap')+
+             apply (clarsimp simp: simple_sane_strg sch_act_simple_def ct_in_state'_def
+                        ct_active_runnable'[unfolded ct_in_state'_def]
+                    | wp tcbinv_invs' arch_performInvocation_invs'
+                    | rule conjI
+                    | erule active_ex_cap')+
   apply simp
   done
 
 lemma hi_valid_duplicates'[wp]:
   "\<lbrace>invs' and sch_act_simple and ct_active'
     and (\<lambda>s. vs_valid_duplicates' (ksPSpace s))\<rbrace>
-      handleInvocation isCall isBlocking
+      handleInvocation isCall isBlocking canDonate firstPhase cptr
    \<lbrace>\<lambda>r s. vs_valid_duplicates' (ksPSpace s) \<rbrace>"
   apply (simp add: handleInvocation_def split_def
-                   ts_Restart_case_helper')
-  apply (wp syscall_valid' setThreadState_nonqueued_state_update
-    rfk_invs' ct_in_state'_set | simp)+
-    apply (fastforce simp add: tcb_at_invs' ct_in_state'_def
-                              simple_sane_strg
-                              sch_act_simple_def
-                       elim!: pred_tcb'_weakenE st_tcb_ex_cap''
-                        dest: st_tcb_at_idle_thread')+
+                   ts_Restart_case_helper' ct_not_inQ_asrt_def)
+  apply (rule validE_valid)
+  apply (intro hoare_vcg_seqE[OF _ stateAssertE_sp])
+  apply (wpsimp wp: syscall_valid' setThreadState_nonqueued_state_update rfk_invs' ct_in_state'_set
+                    hoare_drop_imp)
+  apply (fastforce simp: ct_in_state'_def simple_sane_strg sch_act_simple_def
+                  elim!: pred_tcb'_weakenE st_tcb_ex_cap''
+                   dest: st_tcb_at_idle_thread')
   done
 
-crunch valid_duplicates' [wp]:
-  activateIdleThread "(\<lambda>s. vs_valid_duplicates' (ksPSpace s))"
+crunches activateIdleThread, schedContextCompleteYieldTo
+  for valid_duplicates' [wp]: "\<lambda>s. vs_valid_duplicates' (ksPSpace s)"
   (ignore: setNextPC threadSet simp:crunch_simps)
 
-crunch valid_duplicates' [wp]:
-  tcbSchedAppend "(\<lambda>s. vs_valid_duplicates' (ksPSpace s))"
-  (simp:crunch_simps wp:hoare_unless_wp)
-
-lemma timerTick_valid_duplicates'[wp]:
-  "\<lbrace>\<lambda>s. vs_valid_duplicates' (ksPSpace s)\<rbrace>
-  timerTick \<lbrace>\<lambda>x s. vs_valid_duplicates' (ksPSpace s)\<rbrace>"
-  apply (simp add:timerTick_def decDomainTime_def)
-   apply (wp hoare_drop_imps|wpc|simp)+
-  done
-
 lemma handleInterrupt_valid_duplicates'[wp]:
   "\<lbrace>\<lambda>s. vs_valid_duplicates' (ksPSpace s)\<rbrace>
   handleInterrupt irq \<lbrace>\<lambda>r s. vs_valid_duplicates' (ksPSpace s)\<rbrace>"
@@ -2144,46 +2175,28 @@ lemma handleInterrupt_valid_duplicates'[wp]:
           |wpc|simp add: handleReservedIRQ_def maskIrqSignal_def)+
   done
 
+crunches awaken
+  for valid_duplicates'[wp]: "\<lambda>s. vs_valid_duplicates' (ksPSpace s)"
+  (wp: crunch_wps)
 
 crunch valid_duplicates' [wp]:
-  schedule "(\<lambda>s. vs_valid_duplicates' (ksPSpace s))"
-  (ignore: setNextPC clearExMonitor threadSet simp:crunch_simps wp:findM_inv hoare_drop_imps)
+  schedule "\<lambda>s. vs_valid_duplicates' (ksPSpace s)"
+  (ignore: setNextPC clearExMonitor threadSet simp: crunch_simps
+   wp: hoare_drop_imps)
 
 lemma activate_sch_valid_duplicates'[wp]:
-  "\<lbrace>\<lambda>s. ct_in_state' activatable' s \<and> vs_valid_duplicates' (ksPSpace s)\<rbrace>
+  "\<lbrace>\<lambda>s. vs_valid_duplicates' (ksPSpace s)\<rbrace>
      activateThread \<lbrace>\<lambda>rv s. vs_valid_duplicates' (ksPSpace s)\<rbrace>"
   apply (simp add: activateThread_def getCurThread_def
              cong: if_cong Structures_H.thread_state.case_cong)
   apply (rule hoare_seq_ext [OF _ gets_sp])
-  apply (rule hoare_seq_ext[where B="\<lambda>st s.  (runnable' or idle') st
-    \<and> vs_valid_duplicates' (ksPSpace s)"])
-   apply (rule hoare_pre)
-    apply (wp | wpc | simp add: setThreadState_runnable_simp)+
-  apply (clarsimp simp: ct_in_state'_def cur_tcb'_def pred_tcb_at'
-                 elim!: pred_tcb'_weakenE)
-  done
-
-crunch valid_duplicates'[wp]:
-  receiveSignal "\<lambda>s. vs_valid_duplicates' (ksPSpace s)"
-
-crunch valid_duplicates'[wp]:
-  receiveIPC "\<lambda>s. vs_valid_duplicates' (ksPSpace s)"
-(wp: getNotification_wp gbn_wp')
-
-crunch valid_duplicates'[wp]:
-  deleteCallerCap "\<lambda>s. vs_valid_duplicates' (ksPSpace s)"
-  (wp: crunch_wps)
-
-crunch valid_duplicates'[wp]:
-  handleReply "\<lambda>s. vs_valid_duplicates' (ksPSpace s)"
-
-crunch valid_duplicates'[wp]:
-  handleYield "\<lambda>s. vs_valid_duplicates' (ksPSpace s)"
- (ignore: threadGet simp:crunch_simps wp:hoare_unless_wp)
+  apply (wpsimp wp: threadGet_wp hoare_drop_imps)
+  by (fastforce simp: obj_at'_def)
 
-crunch valid_duplicates'[wp]:
-  "VSpace_H.handleVMFault", handleHypervisorFault "\<lambda>s. vs_valid_duplicates' (ksPSpace s)"
- (ignore: getFAR getDFSR getIFSR simp:crunch_simps)
+crunches receiveSignal, receiveIPC, handleYield, "VSpace_H.handleVMFault", handleHypervisorFault,
+         lookupReply, checkBudgetRestart
+  for valid_duplicates'[wp]: "\<lambda>s. vs_valid_duplicates' (ksPSpace s)"
+  (wp: crunch_wps simp: crunch_simps)
 
 lemma hs_valid_duplicates'[wp]:
   "\<lbrace>invs' and ct_active' and sch_act_simple and (\<lambda>s. vs_valid_duplicates' (ksPSpace s))\<rbrace>
@@ -2195,43 +2208,90 @@ lemma hs_valid_duplicates'[wp]:
 
 lemma hc_valid_duplicates'[wp]:
   "\<lbrace>invs' and ct_active' and sch_act_simple and (\<lambda>s. vs_valid_duplicates' (ksPSpace s))\<rbrace>
-     handleCall
-   \<lbrace>\<lambda>rv s. vs_valid_duplicates' (ksPSpace s)\<rbrace>"
-  by (simp add: handleCall_def |  wp)+
+   handleCall
+   \<lbrace>\<lambda>_ s. vs_valid_duplicates' (ksPSpace s)\<rbrace>"
+  apply (clarsimp simp: handleCall_def)
+  apply (rule validE_valid)
+  apply (rule hoare_vcg_seqE[OF _ stateAssertE_sp])
+  apply wpsimp
+  done
 
 lemma handleRecv_valid_duplicates'[wp]:
   "\<lbrace>(\<lambda>s. vs_valid_duplicates' (ksPSpace s))\<rbrace>
-  handleRecv isBlocking \<lbrace>\<lambda>r s. vs_valid_duplicates' (ksPSpace s)\<rbrace>"
-  apply (simp add: handleRecv_def cong: if_cong)
+  handleRecv isBlocking canDonate \<lbrace>\<lambda>r s. vs_valid_duplicates' (ksPSpace s)\<rbrace>"
+  apply (simp add: handleRecv_def cong: if_cong split del: if_split)
   apply (rule hoare_pre)
    apply wp
-       apply ((wp getNotification_wp | wpc | simp add: whenE_def split del: if_split)+)[1]
-
-      apply (rule_tac Q="\<lambda>rv s. vs_valid_duplicates' (ksPSpace s)"
-
-                   in hoare_post_impErr[rotated])
-
-        apply (clarsimp simp: isCap_simps sch_act_sane_not)
-       apply assumption
-      apply (wp deleteCallerCap_nonz_cap)+
+      apply ((wp getNotification_wp | wpc | simp add: whenE_def split del: if_split)+)[1]
+     apply (rule_tac Q="\<lambda>rv s. vs_valid_duplicates' (ksPSpace s)" in hoare_post_impErr[rotated])
+       apply (clarsimp simp: isCap_simps sch_act_sane_not)
+      apply assumption
+     apply (wp)+
   apply (auto elim: st_tcb_ex_cap'' pred_tcb'_weakenE
              dest!: st_tcb_at_idle_thread'
               simp: ct_in_state'_def sch_act_sane_def)
   done
 
+lemma checkBudget_true:
+  "\<lbrace>P\<rbrace> checkBudget \<lbrace>\<lambda>rv s. rv \<longrightarrow> P s\<rbrace>"
+  unfolding checkBudget_def
+  apply wpsimp
+  apply (wpsimp wp: hoare_drop_imp)
+  apply wpsimp
+  apply (wpsimp wp: hoare_drop_imp)+
+  done
+
+lemma checkBudgetRestart_true:
+  "\<lbrace>P\<rbrace> checkBudgetRestart \<lbrace>\<lambda>rv s. rv \<longrightarrow> P s\<rbrace>"
+  unfolding checkBudgetRestart_def
+  apply wpsimp
+  apply (rule_tac Q="\<lambda>rv s. rv \<longrightarrow> P s" in hoare_strengthen_post[rotated], clarsimp)
+  apply (wpsimp wp: checkBudget_true)+
+  done
+
+lemma checkBudgetRestart_gen:
+  "\<lbrace>R\<rbrace> checkBudgetRestart \<lbrace>\<lambda>_. Q\<rbrace> \<Longrightarrow>
+   \<lbrace>P and R\<rbrace> checkBudgetRestart \<lbrace>\<lambda>rv s. (rv \<longrightarrow> P s) \<and> (\<not>rv \<longrightarrow> Q s)\<rbrace>"
+  apply (wpsimp wp: checkBudgetRestart_true)
+  apply (wpsimp wp: hoare_drop_imp)+
+  done
+
+lemma setCurTime_invs'[wp]:
+  "setCurTime v \<lbrace>invs'\<rbrace>"
+  unfolding setCurTime_def
+  apply wp
+  apply (clarsimp simp: invs'_def valid_machine_state'_def
+                        valid_irq_node'_def valid_release_queue_def valid_release_queue'_def)
+  apply (clarsimp simp: valid_dom_schedule'_def valid_queues'_def valid_queues_def valid_bitmapQ_def
+                        bitmapQ_def valid_queues_no_bitmap_def bitmapQ_no_L2_orphans_def bitmapQ_no_L1_orphans_def)
+  done
+
+lemma updateTimeStamp_invs'[wp]:
+  "updateTimeStamp \<lbrace>invs'\<rbrace>"
+  unfolding updateTimeStamp_def
+  by (wpsimp wp: dmo_invs'_simple simp: getCurrentTime_def no_irq_def)
+
+lemma updateTimeStamp_sch_act_simple[wp]:
+  "updateTimeStamp \<lbrace>sch_act_simple\<rbrace>"
+  unfolding updateTimeStamp_def sch_act_simple_def setDomainTime_def
+  by (wpsimp wp: dmo_invs'_simple simp: setCurTime_def)
+
+crunches updateTimeStamp
+  for ksPSpace[wp]: "\<lambda>s. P (ksPSpace s)"
+  and tcb_at'[wp]: "tcb_at' t"
+
+crunches getCapReg, refillCapacity
+  for inv[wp]: P
 
 lemma handleEvent_valid_duplicates':
   "\<lbrace>invs' and (\<lambda>s. vs_valid_duplicates' (ksPSpace s)) and
     sch_act_simple and (\<lambda>s. e \<noteq> Interrupt \<longrightarrow> ct_running' s)\<rbrace>
    handleEvent e
    \<lbrace>\<lambda>rv s. vs_valid_duplicates' (ksPSpace s)\<rbrace>"
-  apply (case_tac e, simp_all add: handleEvent_def)
-      apply (rename_tac syscall)
-      apply (case_tac syscall)
-            apply (wp handleReply_sane
-              | simp add: active_from_running' simple_sane_strg cong: if_cong
-              | wpc)+
-  done
+  supply if_cong[cong]
+  apply (case_tac e; simp add: handleEvent_def)
+       apply (rename_tac syscall, case_tac syscall; simp)
+  by (wpsimp wp: checkBudgetRestart_gen stateAssertE_inv active_from_running')+
 
 lemma callKernel_valid_duplicates':
   "\<lbrace>invs' and (\<lambda>s. vs_valid_duplicates' (ksPSpace s)) and
@@ -2239,19 +2299,8 @@ lemma callKernel_valid_duplicates':
     (\<lambda>s. e \<noteq> Interrupt \<longrightarrow> ct_running' s)\<rbrace>
    callKernel e
    \<lbrace>\<lambda>rv s. vs_valid_duplicates' (ksPSpace s)\<rbrace>"
-  apply (simp add: callKernel_def)
-  apply (rule hoare_pre)
-   apply (wp activate_invs' activate_sch_act schedule_sch
-             schedule_sch_act_simple he_invs'
-          | simp add: no_irq_getActiveIRQ
-          | wp (once) hoare_drop_imps )+
-   apply (rule hoare_post_impErr)
-     apply (rule valid_validE)
-     prefer 2
-     apply assumption
-    apply (wp handleEvent_valid_duplicates')
-   apply simp
-  apply simp
+  apply (simp add: callKernel_def mcsPreemptionPoint_def)
+  apply (wpsimp wp: hoare_drop_imp hoare_vcg_if_lift2 handleEvent_valid_duplicates')
   done
 
 end

--- TcbAcc_R.thy
+++ TcbAcc_R.thy
@@ -16,10 +16,12 @@ declare hoare_in_monad_post[wp]
 declare trans_state_update'[symmetric,simp]
 declare empty_fail_sequence_x[simp]
 declare storeWordUser_typ_at' [wp]
-declare of_nat_power [simp del]
-declare word_neq_0_conv [simp del]
 declare complement_def[simp]
 
+lemma threadRead_SomeD:
+  "threadRead f t s = Some y \<Longrightarrow> \<exists>tcb. ko_at' tcb t s \<and> y = f tcb"
+  by (fastforce simp: threadRead_def oliftM_def dest!: readObject_misc_ko_at')
+
 (* Auxiliaries and basic properties of priority bitmap functions *)
 
 lemma countLeadingZeros_word_clz[simp]:
@@ -102,40 +103,290 @@ lemma valid_queues_no_bitmap_exceptI[intro]:
   unfolding valid_queues_no_bitmap_except_def valid_queues_no_bitmap_def
   by simp
 
-lemma st_tcb_at_coerce_abstract:
-  assumes t: "st_tcb_at' P t c"
-  assumes sr: "(a, c) \<in> state_relation"
-  shows "st_tcb_at (\<lambda>st. \<exists>st'. thread_state_relation st st' \<and> P st') t a"
+crunches setThreadState, threadSet
+  for replies_of'[wp]: "\<lambda>s. P (replies_of' s)"
+  and reply_at'[wp]: "\<lambda>s. P (reply_at' p s)"
+  and tcb_at'[wp]: "\<lambda>s. P (tcb_at' p s)"
+  and obj_at'_reply[wp]: "\<lambda>s. P (obj_at' (Q :: reply \<Rightarrow> bool) p s)"
+  and obj_at'_ep[wp]: "\<lambda>s. P (obj_at' (Q :: endpoint \<Rightarrow> bool) p s)"
+  and obj_at'_ntfn[wp]: "\<lambda>s. P (obj_at' (Q :: notification \<Rightarrow> bool) p s)"
+  and obj_at'_sc[wp]: "\<lambda>s. Q (obj_at' (P :: sched_context \<Rightarrow> bool) p s)"
+  (wp: crunch_wps set_tcb'.set_preserves_some_obj_at')
+
+crunches tcbSchedDequeue, tcbSchedEnqueue
+  for replies_of'[wp]: "\<lambda>s. P (replies_of' s)"
+
+crunches tcbSchedDequeue, tcbSchedEnqueue, tcbReleaseRemove
+  for obj_at'_reply[wp]: "\<lambda>s. P (obj_at' (Q :: reply \<Rightarrow> bool) p s)"
+  and obj_at'_ep[wp]: "\<lambda>s. P (obj_at' (Q :: endpoint \<Rightarrow> bool) p s)"
+  and obj_at'_sc[wp]: "\<lambda>s. Q (obj_at' (P :: sched_context \<Rightarrow> bool) p s)"
+
+lemma valid_objs_valid_tcbE':
+  assumes "valid_objs' s"
+          "tcb_at' t s"
+          "\<And>tcb. ko_at' tcb t s \<Longrightarrow> valid_tcb' tcb s \<Longrightarrow> R s tcb"
+  shows "obj_at' (R s) t s"
   using assms
-  apply (clarsimp simp: state_relation_def pred_tcb_at'_def obj_at'_def
-                        projectKOs objBits_simps)
-  apply (erule(1) pspace_dom_relatedE)
-  apply (erule(1) obj_relation_cutsE, simp_all)
-  apply (clarsimp simp: st_tcb_at_def obj_at_def other_obj_relation_def
-                        tcb_relation_def
-                 split: Structures_A.kernel_object.split_asm if_split_asm
-                        ARM_A.arch_kernel_obj.split_asm)+
-  apply fastforce
-  done
-
-lemma valid_objs_valid_tcbE: "\<And>s t.\<lbrakk> valid_objs' s; tcb_at' t s; \<And>tcb. valid_tcb' tcb s \<Longrightarrow> R s tcb \<rbrakk> \<Longrightarrow> obj_at' (R s) t s"
   apply (clarsimp simp add: projectKOs valid_objs'_def ran_def typ_at'_def
                             ko_wp_at'_def valid_obj'_def valid_tcb'_def obj_at'_def)
   apply (fastforce simp: projectKO_def projectKO_opt_tcb return_def valid_tcb'_def)
   done
 
-lemma valid_objs'_maxDomain:
-  "\<And>s t. \<lbrakk> valid_objs' s; tcb_at' t s \<rbrakk> \<Longrightarrow> obj_at' (\<lambda>tcb. tcbDomain tcb \<le> maxDomain) t s"
-  apply (erule (1) valid_objs_valid_tcbE)
-  apply (clarsimp simp: valid_tcb'_def)
+(* Consider further unbundling of valid_objs and valid_objs'; see JIRA issue VER-1343 *)
+
+definition valid_tcbs :: "'z::state_ext state \<Rightarrow> bool" where
+  "valid_tcbs s \<equiv> \<forall>ptr. \<forall>tcb. ko_at (TCB tcb) ptr s \<longrightarrow> valid_tcb ptr tcb s"
+
+(* FIXME RT: move? All lemmas for valid_tcbs (and associated lemmas for valid_tcb) are
+             collected here so that they may be more easily moved *)
+
+lemma valid_objs_valid_tcbs[elim!]:
+  "valid_objs s \<Longrightarrow> valid_tcbs s"
+  by (force simp: valid_objs_def valid_tcbs_def obj_at_def valid_obj_def)
+
+lemma invs_valid_tcbs[elim!]:
+  "invs s \<Longrightarrow> valid_tcbs s"
+  by (fastforce intro: valid_objs_valid_tcbs)
+
+lemma valid_tcbs_valid_tcb:
+  "\<lbrakk>valid_tcbs s; get_tcb thread s = Some tcb\<rbrakk> \<Longrightarrow> valid_tcb thread tcb s"
+  by (fastforce simp: valid_tcbs_def get_tcb_def obj_at_def
+               split: Structures_A.kernel_object.splits option.splits)
+
+lemma valid_tcb_valid_obj:
+  "valid_tcb ptr tcb s = valid_obj ptr (TCB tcb) s"
+  by (clarsimp simp: valid_obj_def)
+
+lemma set_object_valid_tcbs[wp]:
+  "\<lbrace>valid_tcbs and valid_tcb ptr tcb\<rbrace>
+   set_object ptr (TCB tcb)
+   \<lbrace>\<lambda>_. valid_tcbs\<rbrace>"
+  apply (wpsimp wp: set_object_wp_strong)
+  apply (fastforce intro: valid_obj_same_type
+                    simp: obj_at_def valid_tcb_valid_obj valid_tcbs_def dom_def)
+  done
+
+lemma set_reply_obj_ref_valid_tcb[wp]:
+  "set_reply_obj_ref f rp opt \<lbrace>valid_tcb ptr tcb\<rbrace>"
+  apply (clarsimp simp: update_sk_obj_ref_def set_simple_ko_def)
+  apply (wpsimp wp: set_object_typ_ats get_object_wp)
+  done
+
+lemma set_simple_ko_not_tcb_at[wp]:
+  "set_reply ptr new \<lbrace>\<lambda>s. \<not> ko_at (TCB tcb) t s\<rbrace>"
+  "set_endpoint ptr new' \<lbrace>\<lambda>s. \<not> ko_at (TCB tcb) t s\<rbrace>"
+  "set_notification ptr new'' \<lbrace>\<lambda>s. \<not> ko_at (TCB tcb) t s\<rbrace>"
+  apply (wpsimp simp: set_simple_ko_def set_object_def obj_at_def pred_neg_def
+                  wp: get_object_wp)+
+  done
+
+lemma set_reply_obj_ref_not_tcb_at[wp]:
+  "set_reply_obj_ref f rp opt \<lbrace>\<lambda>s. P (ko_at (TCB tcb) t s)\<rbrace>"
+  apply (clarsimp simp: update_sk_obj_ref_def)
+  apply (wpsimp wp: set_simple_ko_wp get_simple_ko_wp)
+  apply (clarsimp simp: obj_at_def sk_obj_at_pred_def pred_neg_def split: if_splits)
+  done
+
+lemma set_reply_obj_ref_valid_tcbs[wp]:
+  "set_reply_obj_ref f rp opt \<lbrace>valid_tcbs\<rbrace>"
+  unfolding valid_tcbs_def
+  apply (wpsimp wp: hoare_vcg_all_lift hoare_vcg_imp_lift' simp: pred_neg_def)
+  done
+
+lemma set_simple_ko_valid_tcb[wp]:
+  "set_simple_ko C p obj \<lbrace>valid_tcb ptr tcb\<rbrace>"
+  apply (clarsimp simp: set_simple_ko_def)
+  apply (wpsimp wp: set_object_typ_ats get_object_wp)+
+  done
+
+lemma set_simple_ko_valid_tcbs[wp]:
+  "set_endpoint ep eval \<lbrace>valid_tcbs\<rbrace>"
+  "set_notification ntfnptr nval \<lbrace>valid_tcbs\<rbrace>"
+  "set_reply rptr rval \<lbrace>valid_tcbs\<rbrace>"
+  unfolding valid_tcbs_def
+  apply (wpsimp wp: hoare_vcg_all_lift hoare_vcg_imp_lift')+
+  done
+
+(* FIXME RT: move/cleanup as part of consolidating valid_objs/valid_tcbs *)
+lemma update_valid_tcb[simp]:
+  "\<And>f. valid_tcb ptr tcb (release_queue_update f s) = valid_tcb ptr tcb s"
+  "\<And>f. valid_tcb ptr tcb (reprogram_timer_update f s) = valid_tcb ptr tcb s"
+  "\<And>f. valid_tcb ptr tcb (ready_queues_update f s) = valid_tcb ptr tcb s"
+  "\<And>f. valid_tcb ptr tcb (scheduler_action_update f s) = valid_tcb ptr tcb s"
+  by (auto simp: valid_tcb_def valid_tcb_state_def valid_bound_obj_def valid_arch_tcb_def
+          split: Structures_A.thread_state.splits option.splits)
+
+lemma update_valid_tcbs[simp]:
+  "\<And>f. valid_tcbs (release_queue_update f s) = valid_tcbs s"
+  "\<And>f. valid_tcbs (reprogram_timer_update f s) = valid_tcbs s"
+  "\<And>f. valid_tcbs (ready_queues_update f s) = valid_tcbs s"
+  "\<And>f. valid_tcbs (scheduler_action_update f s) = valid_tcbs s"
+  by (simp_all add: valid_tcbs_def)
+
+lemma valid_tcb_domain_update[simp]:
+  "valid_tcb tptr (tcb_domain_update f tcb) s = valid_tcb tptr tcb s"
+  unfolding valid_tcb_def
+  by (clarsimp simp: tcb_cap_cases_def)
+
+lemma valid_tcb'_tcbDomain_update:
+  "new_dom \<le> maxDomain \<Longrightarrow>
+   \<forall>tcb. valid_tcb' tcb s \<longrightarrow> valid_tcb' (tcbDomain_update (\<lambda>_. new_dom) tcb) s"
+  unfolding valid_tcb'_def
+  by (clarsimp simp: tcb_cte_cases_def)
+
+lemma valid_tcb'_tcbState_update:
+  "\<lbrakk>valid_tcb_state' st s; valid_tcb' tcb s\<rbrakk> \<Longrightarrow>
+   valid_tcb' (tcbState_update (\<lambda>_. st) tcb) s"
+  apply (clarsimp simp: valid_tcb'_def tcb_cte_cases_def valid_tcb_state'_def)
+  done
+
+crunches tcb_release_remove
+  for valid_tcbs[wp]: valid_tcbs
+  (simp: crunch_simps)
+
+crunches tcb_sched_action
+  for valid_tcb[wp]: "\<lambda>s. valid_tcb ptr tcb s"
+  (simp: Let_def wp: update_valid_tcb
+   ignore: set_tcb_obj_ref get_tcb_obj_ref)
+
+lemma tcb_sched_action_valid_tcbs[wp]:
+  "tcb_sched_action action thread \<lbrace>valid_tcbs\<rbrace>"
+  unfolding valid_tcbs_def
+  apply (wpsimp wp: hoare_vcg_ball_lift2 hoare_vcg_all_lift hoare_vcg_imp_lift')
+  done
+
+lemma set_thread_state_valid_tcb[wp]:
+  "\<lbrace>valid_tcb ptr tcb and valid_tcb_state st\<rbrace> set_thread_state thread st \<lbrace>\<lambda>_. valid_tcb ptr tcb\<rbrace>"
+  apply (clarsimp simp: set_thread_state_def set_thread_state_act_def)
+  apply (rule hoare_seq_ext_skip, wpsimp)
+  apply (rule_tac B="\<lambda>_. valid_tcb ptr tcb" in hoare_seq_ext[rotated])
+   apply (wpsimp wp: set_object_valid_tcbs)
+  apply (wpsimp wp: set_object_valid_tcbs update_valid_tcb is_schedulable_inv hoare_vcg_if_lift2
+                    hoare_vcg_conj_lift hoare_drop_imps
+              simp: set_scheduler_action_def )
+  done
+
+lemma set_thread_state_valid_tcbs[wp]:
+  "\<lbrace>valid_tcbs and valid_tcb_state st\<rbrace> set_thread_state thread st \<lbrace>\<lambda>_. valid_tcbs\<rbrace>"
+  apply (clarsimp simp: set_thread_state_def set_thread_state_act_def)
+  apply (rule hoare_seq_ext[OF _ gets_the_get_tcb_sp])
+  apply (rule_tac B="\<lambda>_. valid_tcbs" in hoare_seq_ext[rotated])
+   apply (wpsimp wp: set_object_valid_tcbs)
+   apply (fastforce simp: valid_tcbs_def obj_at_def
+                   intro: valid_tcb_state_update)
+  apply (clarsimp simp: valid_tcbs_def)
+  apply (wpsimp wp: is_schedulable_inv hoare_vcg_if_lift2 hoare_vcg_conj_lift hoare_drop_imps
+              simp: set_scheduler_action_def)
+  done
+
+lemma reply_unlink_tcb_valid_tcbs[wp]:
+  "reply_unlink_tcb tptr reply_ptr \<lbrace>valid_tcbs\<rbrace>"
+  apply (clarsimp simp: reply_unlink_tcb_def get_simple_ko_def)
+  apply (wpsimp wp: gts_wp get_object_wp)
+  done
+
+lemma reschedule_required_valid_tcbs[wp]:
+  "reschedule_required \<lbrace>valid_tcbs\<rbrace>"
+  apply (clarsimp simp: reschedule_required_def)
+  apply (rule hoare_seq_ext_skip, wpsimp)
+  apply (case_tac action; clarsimp?)
+    apply (wpsimp wp: update_valid_tcbs simp: set_scheduler_action_def)
+   apply (clarsimp simp: bind_assoc)
+   apply (rule hoare_seq_ext_skip, wpsimp wp: is_schedulable_inv)
+   apply (rule hoare_seq_ext_skip)
+    apply (clarsimp simp: when_def)
+    apply (rule hoare_seq_ext_skip, wpsimp)+
+    apply (wpsimp wp: update_valid_tcbs simp: set_scheduler_action_def)+
+  done
+
+lemma possible_switch_to_valid_tcbs[wp]:
+  "possible_switch_to thread \<lbrace>valid_tcbs\<rbrace>"
+  apply (clarsimp simp: possible_switch_to_def)
+  apply (wpsimp wp: update_valid_tcbs thread_get_inv hoare_vcg_conj_lift hoare_drop_imps
+              simp: set_scheduler_action_def get_tcb_obj_ref_def)+
+  done
+
+lemma update_sched_context_ko_at_TCB[wp]:
+  "update_sched_context ref f \<lbrace>\<lambda>s. P (ko_at (TCB tcb) t s)\<rbrace>"
+  apply (clarsimp simp: update_sched_context_def)
+  apply (wpsimp wp: set_object_wp get_object_wp)
+  apply (clarsimp simp: obj_at_def sk_obj_at_pred_def pred_neg_def split: if_splits)
+  done
+
+lemma update_sched_context_valid_tcb[wp]:
+  "update_sched_context scp f \<lbrace>valid_tcb ptr tcb\<rbrace>"
+  apply (clarsimp simp: update_sched_context_def)
+  apply (wpsimp wp: set_object_typ_ats get_object_wp)
+  done
+
+lemma update_sched_context_valid_tcbs[wp]:
+  "update_sched_context ref f \<lbrace>valid_tcbs\<rbrace>"
+  unfolding valid_tcbs_def
+  apply (wpsimp wp: hoare_vcg_all_lift hoare_vcg_imp_lift')
+  done
+
+crunches refill_unblock_check, restart_thread_if_no_fault
+  for valid_tcbs[wp]: valid_tcbs
+  (simp: is_round_robin_def crunch_simps wp: whileLoop_wp)
+
+definition valid_tcbs' :: "kernel_state \<Rightarrow> bool" where
+  "valid_tcbs' s' \<equiv> \<forall>ptr tcb. ksPSpace s' ptr = Some (KOTCB tcb) \<longrightarrow> valid_tcb' tcb s'"
+
+lemma valid_objs'_valid_tcbs'[elim!]:
+  "valid_objs' s \<Longrightarrow> valid_tcbs' s"
+  by (auto simp: valid_objs'_def valid_tcbs'_def valid_obj'_def split: kernel_object.splits)
+
+lemma invs'_valid_tcbs'[elim!]:
+  "invs' s \<Longrightarrow> valid_tcbs' s"
+  by (fastforce intro: valid_objs'_valid_tcbs')
+
+lemma valid_tcbs'_maxDomain:
+  "\<And>s t. \<lbrakk> valid_tcbs' s; tcb_at' t s \<rbrakk> \<Longrightarrow> obj_at' (\<lambda>tcb. tcbDomain tcb \<le> maxDomain) t s"
+  apply (clarsimp simp: valid_tcbs'_def obj_at'_def projectKOs valid_tcb'_def)
+  done
+
+lemmas valid_objs'_maxDomain = valid_tcbs'_maxDomain[OF valid_objs'_valid_tcbs']
+
+lemma valid_tcbs'_maxPriority:
+  "\<And>s t. \<lbrakk> valid_tcbs' s; tcb_at' t s \<rbrakk> \<Longrightarrow> obj_at' (\<lambda>tcb. tcbPriority tcb \<le> maxPriority) t s"
+  apply (clarsimp simp: valid_tcbs'_def obj_at'_def projectKOs valid_tcb'_def)
   done
 
-lemma valid_objs'_maxPriority:
-  "\<And>s t. \<lbrakk> valid_objs' s; tcb_at' t s \<rbrakk> \<Longrightarrow> obj_at' (\<lambda>tcb. tcbPriority tcb \<le> maxPriority) t s"
-  apply (erule (1) valid_objs_valid_tcbE)
-  apply (clarsimp simp: valid_tcb'_def)
+lemmas valid_objs'_maxPriority = valid_tcbs'_maxPriority[OF valid_objs'_valid_tcbs']
+
+lemma valid_tcbs'_obj_at':
+  assumes "valid_tcbs' s"
+          "tcb_at' t s"
+          "\<And>tcb. ko_at' tcb t s \<Longrightarrow> valid_tcb' tcb s \<Longrightarrow> R s tcb"
+  shows "obj_at' (R s) t s"
+  using assms
+  apply (clarsimp simp add: projectKOs valid_tcbs'_def ran_def typ_at'_def
+                            ko_wp_at'_def valid_obj'_def valid_tcb'_def obj_at'_def)
   done
 
+lemma update_valid_tcb'[simp]:
+  "\<And>f. valid_tcb' tcb (ksReleaseQueue_update f s) = valid_tcb' tcb s"
+  "\<And>f. valid_tcb' tcb (ksReprogramTimer_update f s) = valid_tcb' tcb s"
+  "\<And>f. valid_tcb' tcb (ksReadyQueuesL1Bitmap_update f s) = valid_tcb' tcb s"
+  "\<And>f. valid_tcb' tcb (ksReadyQueuesL2Bitmap_update f s) = valid_tcb' tcb s"
+  "\<And>f. valid_tcb' tcb (ksReadyQueues_update f s) = valid_tcb' tcb s"
+  "\<And>f. valid_tcb' tcb (ksSchedulerAction_update f s) = valid_tcb' tcb s"
+  by (auto simp: valid_tcb'_def valid_tcb_state'_def valid_bound_obj'_def
+          split: option.splits thread_state.splits)
+
+lemma update_tcbInReleaseQueue_False_valid_tcb'[simp]:
+  "valid_tcb' (tcbInReleaseQueue_update a tcb) s = valid_tcb' tcb s"
+  by (auto simp: valid_tcb'_def tcb_cte_cases_def)
+
+lemma update_valid_tcbs'[simp]:
+  "\<And>f. valid_tcbs' (ksReleaseQueue_update f s) = valid_tcbs' s"
+  "\<And>f. valid_tcbs' (ksReprogramTimer_update f s) = valid_tcbs' s"
+  "\<And>f. valid_tcbs' (ksReadyQueuesL1Bitmap_update f s) = valid_tcbs' s"
+  "\<And>f. valid_tcbs' (ksReadyQueuesL2Bitmap_update f s) = valid_tcbs' s"
+  "\<And>f. valid_tcbs' (ksReadyQueues_update f s) = valid_tcbs' s"
+  "\<And>f. valid_tcbs' (ksSchedulerAction_update f s) = valid_tcbs' s"
+  by (simp_all add: valid_tcbs'_def)
+
 lemma doMachineOp_irq_states':
   assumes masks: "\<And>P. \<lbrace>\<lambda>s. P (irq_masks s)\<rbrace> f \<lbrace>\<lambda>_ s. P (irq_masks s)\<rbrace>"
   shows "\<lbrace>valid_irq_states'\<rbrace> doMachineOp f \<lbrace>\<lambda>rv. valid_irq_states'\<rbrace>"
@@ -197,38 +432,20 @@ lemma doMachineOp_getActiveIRQ_IRQ_active':
   apply simp
   done
 
-lemma preemptionPoint_irq [wp]:
-  "\<lbrace>valid_irq_states'\<rbrace> preemptionPoint -,
-   \<lbrace>\<lambda>irq s. intStateIRQTable (ksInterruptState s) irq \<noteq> IRQInactive\<rbrace>"
-  apply (simp add: preemptionPoint_def setWorkUnits_def modifyWorkUnits_def getWorkUnits_def)
-  apply (wp hoare_whenE_wp|wpc)+
-     apply (rule hoare_post_imp)
-      prefer 2
-     apply (rule doMachineOp_getActiveIRQ_IRQ_active)
-    apply clarsimp
-   apply wp+
-  apply clarsimp
-  done
-
 lemmas doMachineOp_obj_at = doMachineOp_obj_at'
 
-lemma updateObject_tcb_inv:
-  "\<lbrace>P\<rbrace> updateObject (obj::tcb) ko p q n \<lbrace>\<lambda>rv. P\<rbrace>"
-  by simp (rule updateObject_default_inv)
-
 lemma setObject_update_TCB_corres':
   assumes tcbs: "tcb_relation tcb tcb' \<Longrightarrow> tcb_relation tcbu tcbu'"
   assumes tables: "\<forall>(getF, v) \<in> ran tcb_cap_cases. getF tcbu = getF tcb"
   assumes tables': "\<forall>(getF, v) \<in> ran tcb_cte_cases. getF tcbu' = getF tcb'"
   assumes r: "r () ()"
-  assumes exst: "exst_same tcb' tcbu'"
   shows "corres r (ko_at (TCB tcb) add)
                   (ko_at' tcb' add)
                   (set_object add (TCB tcbu)) (setObject add tcbu')"
-  apply (rule_tac F="tcb_relation tcb tcb' \<and> exst_same tcb' tcbu'" in corres_req)
+  apply (rule_tac F="tcb_relation tcb tcb'" in corres_req)
    apply (clarsimp simp: state_relation_def obj_at_def obj_at'_def)
    apply (frule(1) pspace_relation_absD)
-   apply (clarsimp simp: projectKOs other_obj_relation_def exst)
+   apply (clarsimp simp: projectKOs other_obj_relation_def)
   apply (rule corres_guard_imp)
     apply (rule corres_rel_imp)
      apply (rule setObject_other_corres[where P="(=) tcb'"])
@@ -252,16 +469,15 @@ lemma setObject_update_TCB_corres:
   "\<lbrakk> tcb_relation tcb tcb' \<Longrightarrow> tcb_relation tcbu tcbu';
      \<forall>(getF, v) \<in> ran tcb_cap_cases. getF tcbu = getF tcb;
      \<forall>(getF, v) \<in> ran tcb_cte_cases. getF tcbu' = getF tcb';
-     r () (); exst_same tcb' tcbu'\<rbrakk>
+     r () ()\<rbrakk>
    \<Longrightarrow> corres r (\<lambda>s. get_tcb add s = Some tcb)
                (\<lambda>s'. (tcb', s') \<in> fst (getObject add s'))
                (set_object add (TCB tcbu)) (setObject add tcbu')"
   apply (rule corres_guard_imp)
     apply (erule (3) setObject_update_TCB_corres', force)
-   apply fastforce
   apply (clarsimp simp: getObject_def in_monad split_def obj_at'_def
-                        loadObject_default_def projectKOs objBits_simps'
-                        in_magnitude_check)
+                        loadObject_default_def projectKOs objBits_simps' in_magnitude_check
+                 dest!: readObject_misc_ko_at')
   done
 
 lemma getObject_TCB_corres:
@@ -277,28 +493,30 @@ lemma getObject_TCB_corres:
 lemma threadGet_corres:
   assumes x: "\<And>tcb tcb'. tcb_relation tcb tcb' \<Longrightarrow> r (f tcb) (f' tcb')"
   shows      "corres r (tcb_at t) (tcb_at' t) (thread_get f t) (threadGet f' t)"
-  apply (simp add: thread_get_def threadGet_def)
-  apply (fold liftM_def)
-  apply simp
-  apply (rule corres_rel_imp)
+  apply (simp add: thread_get_def threadGet_getObject)
+  apply (rule corres_split_skip)
+     apply wpsimp+
    apply (rule getObject_TCB_corres)
   apply (simp add: x)
   done
 
+lemmas get_tcb_obj_ref_corres
+  = threadGet_corres[where 'a="obj_ref option", folded get_tcb_obj_ref_def]
+
 lemma threadGet_inv [wp]: "\<lbrace>P\<rbrace> threadGet f t \<lbrace>\<lambda>rv. P\<rbrace>"
-  by (simp add: threadGet_def getObject_inv_tcb | wp)+
+  by (simp add: threadGet_def getObject_tcb_inv | wp)+
 
 lemma ball_tcb_cte_casesI:
   "\<lbrakk> P (tcbCTable, tcbCTable_update);
      P (tcbVTable, tcbVTable_update);
-     P (tcbReply, tcbReply_update);
-     P (tcbCaller, tcbCaller_update);
-     P (tcbIPCBufferFrame, tcbIPCBufferFrame_update) \<rbrakk>
+     P (tcbIPCBufferFrame, tcbIPCBufferFrame_update);
+     P (tcbFaultHandler, tcbFaultHandler_update);
+     P (tcbTimeoutHandler, tcbTimeoutHandler_update) \<rbrakk>
     \<Longrightarrow> \<forall>x \<in> ran tcb_cte_cases. P x"
   by (simp add: tcb_cte_cases_def)
 
 lemma all_tcbI:
-  "\<lbrakk> \<And>a b c d e f g h i j k l m n p q. P (Thread a b c d e f g h i j k l m n p q) \<rbrakk> \<Longrightarrow> \<forall>tcb. P tcb"
+  "\<lbrakk> \<And>a b c d e f g h i j k l m n p q r. P (Thread a b c d e f g h i j k l m n p q r) \<rbrakk> \<Longrightarrow> \<forall>tcb. P tcb"
   by (rule allI, case_tac tcb, simp)
 
 lemma threadset_corresT:
@@ -307,7 +525,6 @@ lemma threadset_corresT:
   assumes y: "\<And>tcb. \<forall>(getF, setF) \<in> ran tcb_cap_cases. getF (f tcb) = getF tcb"
   assumes z: "\<forall>tcb. \<forall>(getF, setF) \<in> ran tcb_cte_cases.
                  getF (f' tcb) = getF tcb"
-  assumes e: "\<And>tcb'. exst_same tcb' (f' tcb')"
   shows      "corres dc (tcb_at t)
                         (tcb_at' t)
                     (thread_set f t) (threadSet f' t)"
@@ -330,35 +546,22 @@ lemma threadset_corresT:
 lemmas threadset_corres =
     threadset_corresT [OF _ _ all_tcbI, OF _ ball_tcb_cap_casesI ball_tcb_cte_casesI]
 
-lemma pspace_relation_tcb_at:
-  assumes p: "pspace_relation (kheap a) (ksPSpace c)"
-  assumes t: "tcb_at' t c"
-  shows "tcb_at t a" using assms
-  apply (clarsimp simp: obj_at'_def projectKOs)
-  apply (erule(1) pspace_dom_relatedE)
-  apply (erule(1) obj_relation_cutsE)
-  apply (clarsimp simp: other_obj_relation_def is_tcb obj_at_def
-                 split: Structures_A.kernel_object.split_asm if_split_asm
-                        ARM_A.arch_kernel_obj.split_asm)+
-  done
-
 lemma threadSet_corres_noopT:
   assumes x: "\<And>tcb tcb'. tcb_relation tcb tcb' \<Longrightarrow>
                          tcb_relation tcb (fn tcb')"
   assumes y: "\<forall>tcb. \<forall>(getF, setF) \<in> ran tcb_cte_cases.
                  getF (fn tcb) = getF tcb"
-  assumes e: "\<And>tcb'. exst_same tcb' (fn tcb')"
   shows      "corres dc \<top> (tcb_at' t)
                            (return v) (threadSet fn t)"
 proof -
   have S: "\<And>t s. tcb_at t s \<Longrightarrow> return v s = (thread_set id t >>= (\<lambda>x. return v)) s"
     apply (clarsimp simp: tcb_at_def)
-    apply (simp add: return_def thread_set_def gets_the_def
-                     assert_opt_def simpler_gets_def set_object_def get_object_def
-                     put_def get_def bind_def assert_def a_type_def[split_simps kernel_object.split arch_kernel_obj.split])
+    apply (clarsimp simp: return_def thread_set_def gets_the_def
+                          assert_opt_def simpler_gets_def set_object_def get_object_def
+                          put_def get_def bind_def assert_def a_type_def[split_simps kernel_object.split arch_kernel_obj.split]
+                   dest!: get_tcb_SomeD)
     apply (subgoal_tac "kheap s(t \<mapsto> TCB tcb) = kheap s", simp)
      apply (simp add: map_upd_triv get_tcb_SomeD)
-    apply (simp add: get_tcb_SomeD map_upd_triv)
     done
   show ?thesis
     apply (rule stronger_corres_guard_imp)
@@ -366,15 +569,15 @@ proof -
        defer
        apply (subst bind_return [symmetric],
               rule corres_split' [OF threadset_corresT])
-             apply (simp add: x)
-            apply simp
-           apply (rule y)
-          apply (rule e)
-         apply (rule corres_noop [where P=\<top> and P'=\<top>])
-          apply wpsimp+
-      apply (erule pspace_relation_tcb_at[rotated])
-      apply clarsimp
-     apply simp
+            apply (simp add: x)
+           apply simp
+          apply (rule y)
+        apply (rule corres_noop [where P=\<top> and P'=\<top>])
+         apply wpsimp+
+      apply (fastforce dest: pspace_relation_tcb_at
+                       simp: state_relation_def opt_map_def obj_at'_def projectKOs
+                      split: option.splits)
+     apply clarsimp
     apply simp
     done
 qed
@@ -389,16 +592,14 @@ lemma threadSet_corres_noop_splitT:
                  getF (fn tcb) = getF tcb"
   assumes z: "corres r P Q' m m'"
   assumes w: "\<lbrace>P'\<rbrace> threadSet fn t \<lbrace>\<lambda>x. Q'\<rbrace>"
-  assumes e: "\<And>tcb'. exst_same tcb' (fn tcb')"
   shows      "corres r P (tcb_at' t and P')
                            m (threadSet fn t >>= (\<lambda>rv. m'))"
   apply (rule corres_guard_imp)
     apply (subst return_bind[symmetric])
     apply (rule corres_split_nor [OF _ threadSet_corres_noopT])
-         apply (rule z)
-        apply (simp add: x)
-       apply (rule y)
-      apply (rule e)
+        apply (rule z)
+       apply (simp add: x)
+      apply (rule y)
      apply (wp w)+
    apply simp
   apply simp
@@ -471,24 +641,30 @@ lemma setObject_tcb_iflive':
                          in_magnitude_check objBits_simps' prod_eq_iff
                          obj_at'_def)
    apply fastforce
-  apply (clarsimp simp: updateObject_default_def bind_def projectKOs)
+  apply (clarsimp simp: updateObject_default_def bind_def projectKOs in_monad)
   done
 
 lemma setObject_tcb_idle':
-  "\<lbrace>\<lambda>s. valid_idle' s \<and>
-     (t = ksIdleThread s \<longrightarrow> idle' (tcbState v) \<and> tcbBoundNotification v = None)\<rbrace>
+  "\<lbrace>\<lambda>s. valid_idle' s \<and> (t = ksIdleThread s \<longrightarrow> idle_tcb' v)\<rbrace>
      setObject t (v :: tcb) \<lbrace>\<lambda>rv. valid_idle'\<rbrace>"
   apply (rule hoare_pre)
   apply (rule setObject_idle')
       apply (simp add: objBits_simps')+
    apply (simp add: updateObject_default_inv)
-  apply (simp add: projectKOs idle_tcb_ps_def idle_tcb'_def)
+  apply (simp add: projectKOs idle_tcb_ps_def idle_sc_ps_def)
   done
 
-lemma setObject_tcb_irq_node'[wp]:
-  "\<lbrace>\<lambda>s. P (irq_node' s)\<rbrace> setObject t (v :: tcb) \<lbrace>\<lambda>rv s. P (irq_node' s)\<rbrace>"
-  apply (simp add: setObject_def split_def)
-  apply (wp updateObject_default_inv | simp)+
+lemma setObject_sc_idle':
+  "\<lbrace>\<lambda>s. valid_idle' s  \<and> (t = idle_sc_ptr \<longrightarrow> idle_sc' v)\<rbrace>
+   setSchedContext t v
+   \<lbrace>\<lambda>rv. valid_idle'\<rbrace>"
+  apply (clarsimp simp: setSchedContext_def)
+  apply (rule hoare_pre)
+  apply (rule setObject_idle')
+     apply (simp add: objBits_simps')
+    apply (simp add: objBits_simps' scBits_pos_power2)
+   apply (simp add: updateObject_default_inv)
+  apply (simp add: projectKOs idle_tcb_ps_def idle_sc_ps_def)
   done
 
 lemma setObject_tcb_ifunsafe':
@@ -500,21 +676,10 @@ lemma setObject_tcb_ifunsafe':
                           in_magnitude_check objBits_simps' prod_eq_iff
                           obj_at'_def)
     apply fastforce
-   apply (clarsimp simp: updateObject_default_def bind_def projectKOs)
+   apply (clarsimp simp: updateObject_default_def bind_def projectKOs in_monad)
   apply wp
   done
 
-lemma setObject_tcb_arch' [wp]:
-  "\<lbrace>\<lambda>s. P (ksArchState s)\<rbrace> setObject t (v :: tcb) \<lbrace>\<lambda>rv s. P (ksArchState s)\<rbrace>"
-  apply (simp add: setObject_def split_def updateObject_default_def)
-  apply wp
-  apply simp
-  done
-
-lemma setObject_tcb_valid_arch' [wp]:
-  "\<lbrace>valid_arch_state'\<rbrace> setObject t (v :: tcb) \<lbrace>\<lambda>rv. valid_arch_state'\<rbrace>"
-  by (wp valid_arch_state_lift' setObject_typ_at')
-
 lemma setObject_tcb_refs' [wp]:
   "\<lbrace>\<lambda>s. P (global_refs' s)\<rbrace> setObject t (v::tcb) \<lbrace>\<lambda>rv s. P (global_refs' s)\<rbrace>"
   apply (clarsimp simp: setObject_def split_def updateObject_default_def)
@@ -541,23 +706,6 @@ lemma setObject_tcb_valid_globals' [wp]:
    apply (wp | wp setObject_ksPSpace_only updateObject_default_inv | simp)+
   done
 
-lemma setObject_tcb_irq_states' [wp]:
-  "\<lbrace>valid_irq_states'\<rbrace> setObject t (v :: tcb) \<lbrace>\<lambda>rv. valid_irq_states'\<rbrace>"
-  apply (rule hoare_pre)
-   apply (rule hoare_use_eq [where f=ksInterruptState, OF setObject_ksInterrupt])
-    apply (simp, rule updateObject_default_inv)
-   apply (rule hoare_use_eq [where f=ksMachineState, OF setObject_ksMachine])
-    apply (simp, rule updateObject_default_inv)
-   apply wp
-  apply assumption
-  done
-
-lemma getObject_tcb_wp:
-  "\<lbrace>\<lambda>s. tcb_at' p s \<longrightarrow> (\<exists>t::tcb. ko_at' t p s \<and> Q t s)\<rbrace> getObject p \<lbrace>Q\<rbrace>"
-  by (clarsimp simp: getObject_def valid_def in_monad
-                     split_def objBits_simps' loadObject_default_def
-                     projectKOs obj_at'_def in_magnitude_check)
-
 lemma setObject_tcb_pspace_no_overlap':
   "\<lbrace>pspace_no_overlap' w s and tcb_at' t\<rbrace>
   setObject t (tcb::tcb)
@@ -631,17 +804,20 @@ lemma threadSet_valid_pspace'T_P:
   assumes w: "\<forall>tcb. tcbPriority tcb \<le> maxPriority \<longrightarrow> tcbPriority (F tcb) \<le> maxPriority"
   assumes w': "\<forall>tcb. tcbMCP tcb \<le> maxPriority \<longrightarrow> tcbMCP (F tcb) \<le> maxPriority"
   shows
-  "\<lbrace>valid_pspace' and (\<lambda>s. P \<longrightarrow> st_tcb_at' Q t s \<and> bound_tcb_at' Q' t s)\<rbrace>
-     threadSet F t
+  "\<lbrace>valid_pspace' and (\<lambda>s. P \<longrightarrow> st_tcb_at' Q t s \<and> bound_tcb_at' Q' t s \<and>
+                                 bound_sc_tcb_at' Q'' t s \<and> bound_yt_tcb_at' Q''' t s)\<rbrace>
+   threadSet F t
    \<lbrace>\<lambda>rv. valid_pspace'\<rbrace>"
   apply (simp add: valid_pspace'_def threadSet_def)
   apply (rule hoare_pre,
-         wp setObject_tcb_valid_objs getObject_tcb_wp)
+         wpsimp wp: setObject_tcb_valid_objs setObject_tcb_valid_replies'
+                    getObject_tcb_wp)
   apply (clarsimp simp: obj_at'_def projectKOs pred_tcb_at'_def)
   apply (erule(1) valid_objsE')
   apply (clarsimp simp add: valid_obj'_def valid_tcb'_def
                             bspec_split [OF spec [OF x]] z
-                            split_paired_Ball y u w v w')
+                            split_paired_Ball y u w v1 v2 v3 w')
+  apply (drule sym, fastforce simp: z')
   done
 
 lemmas threadSet_valid_pspace'T =
@@ -662,48 +838,88 @@ lemmas threadSet_ifunsafe' =
     threadSet_ifunsafe'T [OF all_tcbI, OF ball_tcb_cte_casesI]
 
 lemma threadSet_state_refs_of'_helper[simp]:
-  "{r. (r \<in> tcb_st_refs_of' ts \<or>
-       r \<in> tcb_bound_refs' ntfnptr) \<and>
-      snd r = TCBBound} =
-   tcb_bound_refs' ntfnptr"
-  by (auto simp: tcb_st_refs_of'_def tcb_bound_refs'_def
-          split: thread_state.splits)
+  "{r. (r \<in> tcb_st_refs_of' ts \<or> r \<in> tcb_bound_refs' ntfnptr sc_ptr yt_ptr)
+       \<and> (snd r = TCBBound \<or> snd r = TCBSchedContext \<or> snd r = TCBYieldTo)}
+   = tcb_bound_refs' ntfnptr sc_ptr yt_ptr"
+  by (auto simp: tcb_st_refs_of'_def tcb_bound_refs'_def get_refs_def
+          split: thread_state.splits reftype.splits option.splits)
 
 lemma threadSet_state_refs_of'_helper'[simp]:
-  "{r. (r \<in> tcb_st_refs_of' ts \<or>
-        r \<in> tcb_bound_refs' ntfnptr) \<and>
-       snd r \<noteq> TCBBound} =
-   tcb_st_refs_of' ts"
-  by (auto simp: tcb_st_refs_of'_def tcb_bound_refs'_def
-          split: thread_state.splits)
+  "{r. (r \<in> tcb_st_refs_of' ts \<or> r \<in> tcb_bound_refs' ntfnptr sc_ptr yt_ptr)
+       \<and> (snd r \<noteq> TCBBound \<and> snd r \<noteq> TCBSchedContext \<and> snd r \<noteq> TCBYieldTo)}
+   = tcb_st_refs_of' ts"
+  by (auto simp: tcb_st_refs_of'_def tcb_bound_refs'_def get_refs_def
+          split: thread_state.splits reftype.splits option.splits)
+
+lemma threadSet_state_refs_of'_helper_TCBBound[simp]:
+  "{r. (r \<in> tcb_st_refs_of' (tcbState obj)
+        \<or> r \<in> tcb_bound_refs' (tcbBoundNotification obj)(tcbSchedContext obj) (tcbYieldTo obj))
+          \<and> snd r = TCBBound}
+  = get_refs TCBBound (tcbBoundNotification obj)"
+  by (auto simp: tcb_st_refs_of'_def tcb_bound_refs'_def get_refs_def
+          split: thread_state.splits reftype.splits option.splits)
+
+lemma threadSet_state_refs_of'_helper_TCBSchedContext[simp]:
+  "{r. (r \<in> tcb_st_refs_of' (tcbState obj)
+        \<or> r \<in> tcb_bound_refs' (tcbBoundNotification obj)(tcbSchedContext obj) (tcbYieldTo obj))
+          \<and> snd r = TCBSchedContext}
+  = get_refs TCBSchedContext (tcbSchedContext obj)"
+  by (auto simp: tcb_st_refs_of'_def tcb_bound_refs'_def get_refs_def
+          split: thread_state.splits reftype.splits option.splits)
+
+lemma threadSet_state_refs_of'_helper_TCBYieldTo[simp]:
+  "{r. (r \<in> tcb_st_refs_of' (tcbState obj)
+        \<or> r \<in> tcb_bound_refs' (tcbBoundNotification obj)(tcbSchedContext obj) (tcbYieldTo obj))
+          \<and> snd r = TCBYieldTo}
+  = get_refs TCBYieldTo (tcbYieldTo obj)"
+  by (auto simp: tcb_st_refs_of'_def tcb_bound_refs'_def get_refs_def
+          split: thread_state.splits reftype.splits option.splits)
 
 lemma threadSet_state_refs_of'T_P:
   assumes x: "\<forall>tcb. (P' \<longrightarrow> Q (tcbState tcb)) \<longrightarrow>
                      tcb_st_refs_of' (tcbState (F tcb))
                        = f' (tcb_st_refs_of' (tcbState tcb))"
   assumes y: "\<forall>tcb. (P' \<longrightarrow> Q' (tcbBoundNotification tcb)) \<longrightarrow>
-                     tcb_bound_refs' (tcbBoundNotification (F tcb))
-                       = g' (tcb_bound_refs' (tcbBoundNotification tcb))"
+                     (get_refs TCBBound (tcbBoundNotification (F tcb))
+                      = (g' (get_refs TCBBound (tcbBoundNotification tcb))))"
+  assumes z: "\<forall>tcb. (P' \<longrightarrow> Q'' (tcbSchedContext tcb)) \<longrightarrow>
+                     (get_refs TCBSchedContext (tcbSchedContext (F tcb))
+                      = (h' (get_refs TCBSchedContext (tcbSchedContext tcb))))"
+  assumes w: "\<forall>tcb. (P' \<longrightarrow> Q''' (tcbYieldTo tcb)) \<longrightarrow>
+                     (get_refs TCBYieldTo (tcbYieldTo (F tcb))
+                      = (i' (get_refs TCBYieldTo (tcbYieldTo tcb))))"
   shows
-  "\<lbrace>\<lambda>s. P ((state_refs_of' s) (t := f' {r \<in> state_refs_of' s t. snd r \<noteq> TCBBound}
-                                  \<union> g' {r \<in> state_refs_of' s t. snd r = TCBBound}))
-              \<and> (P' \<longrightarrow> st_tcb_at' Q t s \<and> bound_tcb_at' Q' t s)\<rbrace>
-     threadSet F t
+  "\<lbrace>\<lambda>s. P ((state_refs_of' s) (t := f' {r \<in> state_refs_of' s t. snd r \<notin> {TCBBound, TCBSchedContext, TCBYieldTo}}
+                                    \<union> g' {r \<in> state_refs_of' s t. snd r = TCBBound}
+                                    \<union> h' {r \<in> state_refs_of' s t. snd r = TCBSchedContext}
+                                    \<union> i' {r \<in> state_refs_of' s t. snd r = TCBYieldTo}))
+        \<and> (P' \<longrightarrow> st_tcb_at' Q t s \<and> bound_tcb_at' Q' t s \<and> bound_sc_tcb_at' Q'' t s
+                  \<and> bound_yt_tcb_at' Q''' t s)\<rbrace>
+   threadSet F t
    \<lbrace>\<lambda>rv s. P (state_refs_of' s)\<rbrace>"
   apply (simp add: threadSet_def)
   apply (wp getObject_tcb_wp)
-  apply (clarsimp simp: obj_at'_def projectKOs pred_tcb_at'_def
+  apply (clarsimp simp: obj_at'_def projectKOs pred_tcb_at'_def tcb_bound_refs'_def
                  elim!: rsubst[where P=P] intro!: ext)
   apply (cut_tac s=s and p=t and 'a=tcb in ko_at_state_refs_ofD')
    apply (simp add: obj_at'_def projectKOs)
-  apply (clarsimp simp: x y)
+  apply (fastforce simp: x y z w)
   done
 
 lemmas threadSet_state_refs_of'T =
     threadSet_state_refs_of'T_P [where P'=False, simplified]
 
 lemmas threadSet_state_refs_of' =
-    threadSet_state_refs_of'T [OF all_tcbI all_tcbI]
+    threadSet_state_refs_of'T [OF all_tcbI all_tcbI all_tcbI all_tcbI]
+
+lemma state_refs_of'_helper[simp]:
+  "{r \<in> state_refs_of' s t. snd r \<noteq> TCBBound \<and> snd r \<noteq> TCBSchedContext \<and> snd r \<noteq> TCBYieldTo}
+   \<union> {r \<in> state_refs_of' s t. snd r = TCBBound}
+   \<union> {r \<in> state_refs_of' s t. snd r = TCBSchedContext}
+   \<union> {r \<in> state_refs_of' s t. snd r = TCBYieldTo}
+   = state_refs_of' s t"
+  by (auto simp: tcb_st_refs_of'_def tcb_bound_refs'_def get_refs_def
+          split: thread_state.splits reftype.splits option.splits)
 
 lemma threadSet_iflive'T:
   assumes x: "\<forall>tcb. \<forall>(getF, setF) \<in> ran tcb_cte_cases. getF (F tcb) = getF tcb"
@@ -782,62 +1013,59 @@ lemma threadSet_ctes_ofT:
 lemmas threadSet_ctes_of =
     threadSet_ctes_ofT [OF all_tcbI, OF ball_tcb_cte_casesI]
 
-lemmas threadSet_cap_to' = ex_nonz_cap_to_pres' [OF threadSet_cte_wp_at']
+lemmas threadSet_cteCaps_of = ctes_of_cteCaps_of_lift [OF threadSet_ctes_of]
+
+lemmas threadSet_urz = untyped_ranges_zero_lift[where f="cteCaps_of", OF _ threadSet_cteCaps_of]
 
 lemma threadSet_idle'T:
-  assumes x: "\<forall>tcb. \<forall>(getF, setF) \<in> ran tcb_cte_cases. getF (F tcb) = getF tcb"
+  (* RT FIXME: why was this assumption here? It's not necessary for the lemma,
+     and doesn't introduce any unification. *)
+  (* assumes x: "\<forall>tcb. \<forall>(getF, setF) \<in> ran tcb_cte_cases. getF (F tcb) = getF tcb" *)
   shows
   "\<lbrace>\<lambda>s. valid_idle' s
-      \<and> (t = ksIdleThread s \<longrightarrow>
-          (\<forall>tcb. ko_at' tcb t s \<and> idle_tcb' tcb \<longrightarrow> idle_tcb' (F tcb)))\<rbrace>
-     threadSet F t
+        \<and> (t = ksIdleThread s \<longrightarrow> (\<forall>tcb. ko_at' tcb t s \<and> idle_tcb' tcb \<longrightarrow> idle_tcb' (F tcb)))\<rbrace>
+   threadSet F t
    \<lbrace>\<lambda>rv. valid_idle'\<rbrace>"
   apply (simp add: threadSet_def)
-  apply (wp setObject_tcb_idle' getObject_tcb_wp)
-  apply (clarsimp simp: obj_at'_def projectKOs)
-  apply (clarsimp simp: valid_idle'_def pred_tcb_at'_def obj_at'_def projectKOs idle_tcb'_def)
+  apply (wpsimp wp: setObject_tcb_idle' getObject_tcb_wp
+              simp: obj_at'_def projectKOs valid_idle'_def pred_tcb_at'_def threadSet_def)
   done
 
 lemmas threadSet_idle' =
-    threadSet_idle'T [OF all_tcbI, OF ball_tcb_cte_casesI]
-
-lemma set_tcb_valid_bitmapQ[wp]:
-  "\<lbrace> valid_bitmapQ \<rbrace> setObject t (f tcb :: tcb) \<lbrace>\<lambda>_. valid_bitmapQ \<rbrace>"
-  apply (rule setObject_tcb_pre)
-  apply (simp add: bitmapQ_defs setObject_def split_def)
-  apply (wp hoare_Ball_helper hoare_vcg_all_lift updateObject_default_inv | simp add: bitmapQ_def)+
-  done
+    (*threadSet_idle'T [OF all_tcbI, OF ball_tcb_cte_casesI]*)
+    threadSet_idle'T
 
-lemma set_tcb_bitmapQ_no_L1_orphans[wp]:
-  "\<lbrace> bitmapQ_no_L1_orphans \<rbrace> setObject t (f tcb :: tcb) \<lbrace>\<lambda>_. bitmapQ_no_L1_orphans \<rbrace>"
-  apply (rule setObject_tcb_pre)
-  apply (simp add: bitmapQ_defs setObject_def split_def)
-  apply (wp hoare_Ball_helper hoare_vcg_all_lift updateObject_default_inv | simp add: bitmapQ_def)+
-  done
+lemma threadSet_valid_queues_no_bitmap:
+  "\<lbrace>valid_queues_no_bitmap and
+    (\<lambda>s. \<forall>d p. (\<exists>tcb. (inQ d p tcb) \<and> \<not>(inQ d p (f tcb)))
+                \<longrightarrow> obj_at' (\<lambda>tcb. (inQ d p tcb) \<and> \<not>(inQ d p (f tcb))) t s
+                \<longrightarrow> t \<notin> set (ksReadyQueues s (d, p)))\<rbrace>
+   threadSet f t
+   \<lbrace>\<lambda>_. valid_queues_no_bitmap \<rbrace>"
+  apply (simp add: threadSet_def)
+  apply wp
+   apply (simp add: Invariants_H.valid_queues_no_bitmap_def' pred_tcb_at'_def)
 
-lemma set_tcb_bitmapQ_no_L2_orphans[wp]:
-  "\<lbrace> bitmapQ_no_L2_orphans \<rbrace> setObject t (f tcb :: tcb) \<lbrace>\<lambda>_. bitmapQ_no_L2_orphans \<rbrace>"
-  apply (rule setObject_tcb_pre)
-  apply (simp add: bitmapQ_defs setObject_def split_def)
-  apply (wp hoare_Ball_helper hoare_vcg_all_lift updateObject_default_inv | simp add: bitmapQ_def)+
+   apply (wp hoare_Ball_helper
+             hoare_vcg_all_lift
+             setObject_tcb_strongest)[1]
+  apply (wp getObject_tcb_wp)
+  apply (clarsimp simp: valid_queues_no_bitmap_def' pred_tcb_at'_def)
+  apply (clarsimp simp: obj_at'_def projectKOs)
+  apply (fastforce)
   done
 
-lemma threadSet_valid_queues_no_bitmap:
-  "\<lbrace> valid_queues_no_bitmap and
-    (\<lambda>s. \<forall>d p. (\<exists>tcb. (inQ d p tcb \<and> runnable' (tcbState tcb)) \<and>
-                     \<not>(inQ d p (f tcb) \<and> runnable' (tcbState (f tcb))))
-                \<longrightarrow> obj_at' (\<lambda>tcb. (inQ d p tcb \<and> runnable' (tcbState tcb)) \<and>
-                                 \<not>(inQ d p (f tcb) \<and> runnable' (tcbState (f tcb)))) t s
-                \<longrightarrow> t \<notin> set (ksReadyQueues s (d, p))
-    )\<rbrace>
+lemma threadSet_valid_queues_no_bitmap_new:
+  "\<lbrace> valid_queues_no_bitmap
+     and (\<lambda>s. \<forall>d p. obj_at' (\<lambda>tcb. (inQ d p tcb) \<and> \<not>(inQ d p (f tcb))) t s
+                     \<longrightarrow> t \<notin> set (ksReadyQueues s (d, p)))\<rbrace>
      threadSet f t
    \<lbrace>\<lambda>rv. valid_queues_no_bitmap \<rbrace>"
   apply (simp add: threadSet_def)
   apply wp
    apply (simp add: Invariants_H.valid_queues_no_bitmap_def' pred_tcb_at'_def)
 
-   apply (wp setObject_queues_unchanged_tcb
-             hoare_Ball_helper
+   apply (wp hoare_Ball_helper
              hoare_vcg_all_lift
              setObject_tcb_strongest)[1]
   apply (wp getObject_tcb_wp)
@@ -991,23 +1264,19 @@ lemma modifyReadyQueuesL1Bitmap_obj_at[wp]:
 
 crunches setThreadState, setBoundNotification
   for valid_arch' [wp]: valid_arch_state'
-  (simp: unless_def crunch_simps)
-
-crunch ksInterrupt'[wp]: threadSet "\<lambda>s. P (ksInterruptState s)"
-  (wp: setObject_ksInterrupt updateObject_default_inv)
+  (simp: unless_def crunch_simps wp: crunch_wps)
 
 lemma threadSet_typ_at'[wp]:
   "\<lbrace>\<lambda>s. P (typ_at' T p s)\<rbrace> threadSet t F \<lbrace>\<lambda>rv s. P (typ_at' T p s)\<rbrace>"
-  by (simp add: threadSet_def, wp setObject_typ_at')
-
-lemmas threadSet_typ_at_lifts[wp] = typ_at_lifts [OF threadSet_typ_at']
+  by (wpsimp simp: threadSet_def wp: setObject_typ_at')
 
 lemma setObject_tcb_pde_mappings'[wp]:
   "\<lbrace>valid_pde_mappings'\<rbrace> setObject p (tcb :: tcb) \<lbrace>\<lambda>rv. valid_pde_mappings'\<rbrace>"
-  apply (wp valid_pde_mappings_lift' setObject_typ_at')
-  apply (rule obj_at_setObject2)
-  apply (auto dest: updateObject_default_result)
-  done
+  by (wpsimp wp: valid_pde_mappings_lift' setObject_typ_at')
+
+lemma setObject_sc_pde_mappings'[wp]:
+  "\<lbrace>valid_pde_mappings'\<rbrace> setObject p (sc :: sched_context) \<lbrace>\<lambda>rv. valid_pde_mappings'\<rbrace>"
+  by (wpsimp wp: valid_pde_mappings_lift' setObject_typ_at')
 
 crunches threadSet
   for irq_states' [wp]: valid_irq_states'
@@ -1217,55 +1466,43 @@ lemma threadSet_ct_idle_or_in_cur_domain':
       apply (wp hoare_vcg_disj_lift| simp)+
   done
 
-crunch ksDomScheduleIdx[wp]: threadSet "\<lambda>s. P (ksDomScheduleIdx s)"
-  (wp: setObject_ksPSpace_only updateObject_default_inv)
-crunch gsUntypedZeroRanges[wp]: threadSet "\<lambda>s. P (gsUntypedZeroRanges s)"
-  (wp: setObject_ksPSpace_only updateObject_default_inv)
-
-lemma setObject_tcb_ksDomScheduleIdx [wp]:
-  "\<lbrace>\<lambda>s. P (ksDomScheduleIdx s) \<rbrace> setObject t (v::tcb) \<lbrace>\<lambda>_ s. P (ksDomScheduleIdx s)\<rbrace>"
-  apply (simp add:setObject_def)
-  apply (simp add: updateObject_default_def in_monad)
-  apply (wp|wpc)+
-  apply (simp add: projectKOs)
-  done
-
 lemma threadSet_valid_dom_schedule':
   "\<lbrace> valid_dom_schedule'\<rbrace> threadSet F t \<lbrace>\<lambda>_. valid_dom_schedule'\<rbrace>"
-  unfolding threadSet_def
+  unfolding threadSet_def valid_dom_schedule'_def
   by (wp setObject_ksDomSchedule_inv hoare_Ball_helper)
 
 lemma threadSet_invs_trivialT:
   assumes x: "\<forall>tcb. \<forall>(getF,setF) \<in> ran tcb_cte_cases. getF (F tcb) = getF tcb"
-  assumes z: "\<forall>tcb. tcbState (F tcb) = tcbState tcb \<and> tcbDomain (F tcb) = tcbDomain tcb"
+  assumes z: "\<forall>tcb. tcbState (F tcb) = tcbState tcb"
   assumes w: "\<forall>tcb. is_aligned (tcbIPCBuffer tcb) msg_align_bits \<longrightarrow> is_aligned (tcbIPCBuffer (F tcb)) msg_align_bits"
-  assumes a: "\<forall>tcb. tcbBoundNotification (F tcb) = tcbBoundNotification tcb"
+  assumes a1: "\<forall>tcb. tcbBoundNotification (F tcb) = tcbBoundNotification tcb"
+  assumes a2: "\<forall>tcb. tcbSchedContext (F tcb) = tcbSchedContext tcb"
+  assumes a3: "\<forall>tcb. tcbYieldTo (F tcb) = tcbYieldTo tcb"
   assumes w: "\<forall>tcb. is_aligned (tcbIPCBuffer tcb) msg_align_bits \<longrightarrow> is_aligned (tcbIPCBuffer (F tcb)) msg_align_bits"
   assumes v: "\<forall>tcb. tcbDomain tcb \<le> maxDomain \<longrightarrow> tcbDomain (F tcb) \<le> maxDomain"
   assumes u: "\<forall>tcb. tcbPriority tcb \<le> maxPriority \<longrightarrow> tcbPriority (F tcb) \<le> maxPriority"
   assumes b: "\<forall>tcb. tcbMCP tcb \<le> maxPriority \<longrightarrow> tcbMCP (F tcb) \<le> maxPriority"
   shows
   "\<lbrace>\<lambda>s. invs' s \<and>
-       tcb_at' t s \<and>
        (\<forall>d p. (\<exists>tcb. inQ d p tcb \<and> \<not> inQ d p (F tcb)) \<longrightarrow> t \<notin> set (ksReadyQueues s (d, p))) \<and>
        (\<forall>ko d p. ko_at' ko t s \<and> inQ d p (F ko) \<and> \<not> inQ d p ko \<longrightarrow> t \<in> set (ksReadyQueues s (d, p))) \<and>
-       ((\<exists>tcb. \<not> tcbQueued tcb \<and> tcbQueued (F tcb)) \<longrightarrow> ex_nonz_cap_to' t s \<and> t \<noteq> ksCurThread s) \<and>
-       (\<forall>tcb. tcbQueued (F tcb) \<and> ksSchedulerAction s = ResumeCurrentThread \<longrightarrow> tcbQueued tcb \<or> t \<noteq> ksCurThread s)\<rbrace>
+       ((\<exists>tcb. tcbInReleaseQueue tcb \<and> \<not> tcbInReleaseQueue (F tcb)) \<longrightarrow> t \<notin> set (ksReleaseQueue s)) \<and>
+       (\<forall>ko. ko_at' ko t s \<and> tcbInReleaseQueue (F ko) \<longrightarrow> t \<in> set (ksReleaseQueue s)) \<and>
+       ((\<exists>tcb. \<not> tcbQueued tcb \<and> tcbQueued (F tcb)) \<longrightarrow> ex_nonz_cap_to' t s)\<rbrace>
    threadSet F t
    \<lbrace>\<lambda>rv. invs'\<rbrace>"
 proof -
-  from z have domains: "\<And>tcb. tcbDomain (F tcb) = tcbDomain tcb" by blast
   note threadSet_sch_actT_P[where P=False, simplified]
   have y: "\<forall>tcb. tcb_st_refs_of' (tcbState (F tcb)) = tcb_st_refs_of' (tcbState tcb) \<and>
                  valid_tcb_state' (tcbState (F tcb)) = valid_tcb_state' (tcbState tcb)"
     by (auto simp: z)
   show ?thesis
-    apply (simp add: invs'_def valid_state'_def split del: if_split)
+    apply (simp add: invs'_def split del: if_split)
     apply (rule hoare_pre)
      apply (wp x w v u b
               threadSet_valid_pspace'T
               threadSet_sch_actT_P[where P=False, simplified]
-              threadSet_valid_queues
+              threadSet_valid_queues threadSet_valid_release_queue threadSet_valid_release_queue'
               threadSet_state_refs_of'T[where f'=id]
               threadSet_iflive'T
               threadSet_ifunsafe'T
@@ -1281,10 +1518,14 @@ proof -
               threadSet_valid_queues'
               threadSet_cur
               untyped_ranges_zero_lift
-           |clarsimp simp: y z a domains cteCaps_of_def |rule refl)+
-   apply (clarsimp simp: obj_at'_def projectKOs pred_tcb_at'_def)
-   apply (clarsimp simp: cur_tcb'_def valid_irq_node'_def valid_queues'_def o_def)
-   by (fastforce simp: domains ct_idle_or_in_cur_domain'_def tcb_in_cur_domain'_def z a)
+           | clarsimp simp: y z a1 a2 a3 cteCaps_of_def | rule refl)+
+   apply (clarsimp simp: cur_tcb'_def valid_irq_node'_def valid_queues'_def valid_release_queue_def
+                         valid_release_queue'_def o_def)
+  apply (intro conjI impI allI
+         ; clarsimp simp: ct_idle_or_in_cur_domain'_def tcb_in_cur_domain'_def z a1 a2 a3
+                          valid_queues_def valid_queues_no_bitmap_def obj_at'_def
+         ; blast)
+  done
 qed
 
 lemmas threadSet_invs_trivial =
@@ -1432,7 +1750,7 @@ lemma asUser_corres':
                      (set_object add (TCB (tcb \<lparr> tcb_arch := arch_tcb_context_set con (tcb_arch tcb) \<rparr>)))
                      (setObject add (tcb' \<lparr> tcbArch := atcbContextSet con' (tcbArch tcb') \<rparr>))"
     by (rule setObject_update_TCB_corres [OF L2],
-        (simp add: tcb_cte_cases_def tcb_cap_cases_def exst_same_def)+)
+        (simp add: tcb_cte_cases_def tcb_cap_cases_def)+)
   have L4: "\<And>con con'. con = con' \<Longrightarrow>
             corres (\<lambda>(irv, nc) (irv', nc'). r irv irv' \<and> nc = nc')
                    \<top> \<top> (select_f (f con)) (select_f (g con'))"
@@ -1478,12 +1796,14 @@ proof -
   have R: "\<And>x. tcbArch_update (\<lambda>_. tcbArch x) x = x"
     by (case_tac x, simp)
   show ?thesis
-    apply (simp add: asUser_def split_def threadGet_def threadSet_def
+    apply (simp add: asUser_def split_def threadGet_getObject threadSet_def
                      liftM_def bind_assoc)
-    apply (clarsimp simp: valid_def in_monad getObject_def setObject_def
+    apply (clarsimp simp: valid_def in_monad getObject_def readObject_def setObject_def
                           loadObject_default_def projectKOs objBits_simps'
                           modify_def split_def updateObject_default_def
-                          in_magnitude_check select_f_def
+                          in_magnitude_check select_f_def omonad_defs obind_def
+               split del: if_split
+                   split: option.split_asm if_split_asm
                    dest!: P)
     apply (simp add: R map_upd_triv)
     done
@@ -1496,25 +1816,48 @@ lemma asUser_getRegister_corres:
   apply (clarsimp simp: getRegister_def)
   done
 
-crunch inv[wp]: getRegister "P"
-  (ignore_del: getRegister)
-
 lemma user_getreg_inv'[wp]:
   "\<lbrace>P\<rbrace> asUser t (getRegister r) \<lbrace>\<lambda>x. P\<rbrace>"
   by (wp asUser_inv)
 
-lemma asUser_typ_at' [wp]:
-  "\<lbrace>\<lambda>s. P (typ_at' T p s)\<rbrace> asUser t' f \<lbrace>\<lambda>rv s. P (typ_at' T p s)\<rbrace>"
-  by (simp add: asUser_def bind_assoc split_def, wp select_f_inv)
+end
+
+crunches asUser
+  for typ_at'[wp]: "\<lambda>s. P (typ_at' T p s)"
+  and sc_at'_n[wp]: "\<lambda>s. P (sc_at'_n n p s)"
+  (wp: crunch_wps)
 
-lemmas asUser_typ_ats[wp] = typ_at_lifts [OF asUser_typ_at']
+global_interpretation asUser: typ_at_all_props' "asUser tptr f"
+  by typ_at_props'
+
+lemma threadGet_wp:
+  "\<lbrace>\<lambda>s. tcb_at' t s \<longrightarrow> (\<exists>tcb. ko_at' tcb t s \<and> P (f tcb) s)\<rbrace>
+   threadGet f t
+   \<lbrace>P\<rbrace>"
+  apply (simp add: threadGet_getObject)
+  apply (wp getObject_tcb_wp)
+  done
+
+lemma threadGet_sp:
+  "\<lbrace>P\<rbrace> threadGet f ptr \<lbrace>\<lambda>rv s. \<exists>tcb :: tcb. ko_at' tcb ptr s \<and> f tcb = rv \<and> P s\<rbrace>"
+  apply (wpsimp wp: threadGet_wp)
+  apply (clarsimp simp: obj_at'_def)
+  done
+
+lemma inReleaseQueue_wp:
+  "\<lbrace>\<lambda>s. tcb_at' t s \<longrightarrow> (\<exists>tcb. ko_at' tcb t s \<and> P (tcbInReleaseQueue tcb) s)\<rbrace>
+   inReleaseQueue t
+   \<lbrace>P\<rbrace>"
+  apply (simp add: inReleaseQueue_def)
+  apply (wp threadGet_wp)
+  done
 
 lemma asUser_invs[wp]:
   "\<lbrace>invs' and tcb_at' t\<rbrace> asUser t m \<lbrace>\<lambda>rv. invs'\<rbrace>"
   apply (simp add: asUser_def split_def)
-  apply (wp hoare_drop_imps | simp)+
-
-  apply (wp threadSet_invs_trivial hoare_drop_imps | simp)+
+  apply (wpsimp wp: threadSet_invs_trivial threadGet_wp)
+  apply (fastforce dest!: invs_valid_release_queue'
+                    simp: obj_at'_def valid_release_queue'_def)
   done
 
 lemma asUser_nosch[wp]:
@@ -1603,31 +1952,22 @@ lemma asUser_pred_tcb_at' [wp]:
 crunches asUser
   for ct[wp]: "\<lambda>s. P (ksCurThread s)"
   and cur_domain[wp]: "\<lambda>s. P (ksCurDomain s)"
-  (simp: crunch_simps wp: hoare_drop_imps getObject_inv_tcb setObject_ct_inv)
+  (simp: crunch_simps wp: hoare_drop_imps getObject_tcb_inv setObject_ct_inv)
 
 lemma asUser_tcb_in_cur_domain'[wp]:
   "\<lbrace>tcb_in_cur_domain' t'\<rbrace> asUser t m \<lbrace>\<lambda>_. tcb_in_cur_domain' t'\<rbrace>"
-  apply (simp add: asUser_def tcb_in_cur_domain'_def threadGet_def)
-  apply (wp | wpc | simp)+
-     apply (rule_tac f="ksCurDomain" in hoare_lift_Pf)
-      apply (wp threadSet_obj_at'_strongish getObject_tcb_wp | simp)+
-  apply (clarsimp simp: obj_at'_def)
-  done
-
-crunch tcb_in_cur_domain'[wp]: asUser "\<lambda>s. P (tcb_in_cur_domain' t)"
-  (simp: crunch_simps wp: hoare_drop_imps getObject_inv_tcb setObject_ct_inv)
+  unfolding asUser_def tcb_in_cur_domain'_def threadGet_getObject
+  by (wpsimp wp: threadSet_obj_at'_strongish getObject_tcb_wp | wps | clarsimp simp: obj_at'_def)+
 
 lemma asUser_tcbDomain_inv[wp]:
   "\<lbrace>obj_at' (\<lambda>tcb. P (tcbDomain tcb)) t'\<rbrace> asUser t m \<lbrace>\<lambda>_. obj_at' (\<lambda>tcb. P (tcbDomain tcb)) t'\<rbrace>"
-  apply (simp add: asUser_def tcb_in_cur_domain'_def threadGet_def)
-  apply (wp threadSet_obj_at'_strongish getObject_tcb_wp | wpc | simp | clarsimp simp: obj_at'_def)+
-  done
+  unfolding asUser_def tcb_in_cur_domain'_def threadGet_getObject
+  by (wpsimp wp: threadSet_obj_at'_strongish getObject_tcb_wp | wps | clarsimp simp: obj_at'_def)+
 
 lemma asUser_tcbPriority_inv[wp]:
   "\<lbrace>obj_at' (\<lambda>tcb. P (tcbPriority tcb)) t'\<rbrace> asUser t m \<lbrace>\<lambda>_. obj_at' (\<lambda>tcb. P (tcbPriority tcb)) t'\<rbrace>"
-  apply (simp add: asUser_def tcb_in_cur_domain'_def threadGet_def)
-  apply (wp threadSet_obj_at'_strongish getObject_tcb_wp | wpc | simp | clarsimp simp: obj_at'_def)+
-  done
+  unfolding asUser_def tcb_in_cur_domain'_def threadGet_getObject
+  by (wpsimp wp: threadSet_obj_at'_strongish getObject_tcb_wp | wps | clarsimp simp: obj_at'_def)+
 
 lemma asUser_sch_act_wf[wp]:
   "\<lbrace>\<lambda>s. sch_act_wf (ksSchedulerAction s) s\<rbrace>
@@ -1661,16 +2003,21 @@ lemma asUser_setRegister_corres:
   apply (rule corres_modify'; simp)
   done
 
-lemma getThreadState_corres:
-  "corres thread_state_relation (tcb_at t) (tcb_at' t)
-          (get_thread_state t) (getThreadState t)"
+end
+
+lemma getThreadState_corres':
+  "t = t' \<Longrightarrow>
+   corres thread_state_relation (tcb_at t) (tcb_at' t)
+          (get_thread_state t) (getThreadState t')"
   apply (simp add: get_thread_state_def getThreadState_def)
   apply (rule threadGet_corres)
   apply (simp add: tcb_relation_def)
   done
 
+lemmas getThreadState_corres = getThreadState_corres'[OF refl]
+
 lemma gts_wf'[wp]: "\<lbrace>tcb_at' t and invs'\<rbrace> getThreadState t \<lbrace>valid_tcb_state'\<rbrace>"
-  apply (simp add: getThreadState_def threadGet_def liftM_def)
+  apply (simp add: getThreadState_def threadGet_getObject)
   apply (wp getObject_tcb_wp)
   apply clarsimp
   apply (drule obj_at_ko_at', clarsimp)
@@ -1692,16 +2039,17 @@ lemma gts_st_tcb_at'[wp]: "\<lbrace>st_tcb_at' P t\<rbrace> getThreadState t \<l
 lemma gts_inv'[wp]: "\<lbrace>P\<rbrace> getThreadState t \<lbrace>\<lambda>rv. P\<rbrace>"
   by (simp add: getThreadState_def) wp
 
+
 lemma getBoundNotification_corres:
   "corres (=) (tcb_at t) (tcb_at' t)
-          (get_bound_notification t) (getBoundNotification t)"
-  apply (simp add: get_bound_notification_def getBoundNotification_def)
+          (get_tcb_obj_ref tcb_bound_notification t) (getBoundNotification t)"
+  apply (simp add: get_tcb_obj_ref_def getBoundNotification_def)
   apply (rule threadGet_corres)
   apply (simp add: tcb_relation_def)
   done
 
 lemma gbn_bound_tcb_at'[wp]: "\<lbrace>bound_tcb_at' P t\<rbrace> getBoundNotification t \<lbrace>\<lambda>rv s. P rv\<rbrace>"
-  apply (simp add: getBoundNotification_def threadGet_def liftM_def)
+  apply (simp add: getBoundNotification_def threadGet_getObject)
   apply wp
    apply (rule hoare_strengthen_post)
     apply (rule obj_at_getObject)
@@ -1745,14 +2097,14 @@ lemma isRunnable_inv[wp]:
 lemma isRunnable_wp[wp]:
   "\<lbrace>\<lambda>s. Q (st_tcb_at' (runnable') t s) s\<rbrace> isRunnable t \<lbrace>Q\<rbrace>"
   apply (simp add: isRunnable_def2)
-  apply (wpsimp simp: getThreadState_def threadGet_def wp: getObject_tcb_wp)
+  apply (wpsimp simp: getThreadState_def threadGet_getObject wp: getObject_tcb_wp)
   apply (clarsimp simp: getObject_def valid_def in_monad st_tcb_at'_def
                         loadObject_default_def projectKOs obj_at'_def
                         split_def objBits_simps in_magnitude_check)
   done
 
 lemma setQueue_obj_at[wp]:
-  "\<lbrace>obj_at' P t\<rbrace> setQueue d p q \<lbrace>\<lambda>rv. obj_at' P t\<rbrace>"
+  "setQueue d p q \<lbrace>\<lambda>s. Q (obj_at' P t s)\<rbrace>"
   apply (simp add: setQueue_def)
   apply wp
   apply (fastforce intro: obj_at'_pspaceI)
@@ -1801,52 +2153,16 @@ lemma getObject_obj_at_tcb:
 
 lemma threadGet_obj_at':
   "\<lbrace>obj_at' (\<lambda>t. P (f t) t) t\<rbrace> threadGet f t \<lbrace>\<lambda>rv. obj_at' (P rv) t\<rbrace>"
-  by (simp add: threadGet_def o_def | wp getObject_obj_at_tcb)+
-
-lemma corres_get_etcb:
-  "corres (etcb_relation) (is_etcb_at t) (tcb_at' t)
-                    (gets_the (get_etcb t)) (getObject t)"
-  apply (rule corres_no_failI)
-   apply wp
-  apply (clarsimp simp add: get_etcb_def gets_the_def gets_def
-                            get_def assert_opt_def bind_def
-                            return_def fail_def
-                            split: option.splits
-                            )
-  apply (frule in_inv_by_hoareD [OF getObject_inv_tcb])
-  apply (clarsimp simp add: is_etcb_at_def obj_at'_def projectKO_def
-                            projectKO_opt_tcb split_def
-                            getObject_def loadObject_default_def in_monad)
-  apply (case_tac bb)
-        apply (simp_all add: fail_def return_def)
-  apply (clarsimp simp add: state_relation_def ekheap_relation_def)
-  apply (drule bspec)
-   apply clarsimp
-   apply blast
-  apply (clarsimp simp add: other_obj_relation_def lookupAround2_known1)
-  done
-
-
-lemma ethreadget_corres:
-  assumes x: "\<And>etcb tcb'. etcb_relation etcb tcb' \<Longrightarrow> r (f etcb) (f' tcb')"
-  shows      "corres r (is_etcb_at t) (tcb_at' t) (ethread_get f t) (threadGet f' t)"
-  apply (simp add: ethread_get_def threadGet_def)
-  apply (fold liftM_def)
-  apply simp
-  apply (rule corres_rel_imp)
-   apply (rule corres_get_etcb)
-  apply (simp add: x)
-  done
+  by (simp add: threadGet_getObject | wp getObject_obj_at_tcb)+
 
 lemma setQueue_corres:
   "corres dc \<top> \<top> (set_tcb_queue d p q) (setQueue d p q)"
   apply (rule corres_no_failI)
    apply wp
   apply (clarsimp simp: setQueue_def in_monad set_tcb_queue_def return_def simpler_modify_def)
-  apply (fastforce simp: state_relation_def ready_queues_relation_def)
+  apply (fastforce simp: state_relation_def ready_queues_relation_def swp_def)
   done
 
-
 lemma getQueue_corres: "corres (=) \<top> \<top> (get_tcb_queue qdom prio) (getQueue qdom prio)"
   apply (clarsimp simp add: getQueue_def state_relation_def ready_queues_relation_def get_tcb_queue_def gets_def)
   apply (fold gets_def)
@@ -1874,56 +2190,80 @@ lemma removeFromBitmap_corres_noop:
   by (rule corres_noop)
      (wp | simp add: bitmap_fun_defs state_relation_def | rule no_fail_pre)+
 
-crunch typ_at'[wp]: addToBitmap "\<lambda>s. P (typ_at' T p s)"
-  (wp: hoare_drop_imps setCTE_typ_at')
+crunches addToBitmap, removeFromBitmap
+  for typ_at'[wp]: "\<lambda>s. P (typ_at' T p s)"
+  and sc_at'_n[wp]: "\<lambda>s. P (sc_at'_n n p s)"
 
-crunch typ_at'[wp]: removeFromBitmap "\<lambda>s. P (typ_at' T p s)"
-  (wp: hoare_drop_imps setCTE_typ_at')
+global_interpretation addToBitmap: typ_at_all_props' "addToBitmap tdom prio"
+  by typ_at_props'
 
-lemmas addToBitmap_typ_ats [wp] = typ_at_lifts [OF addToBitmap_typ_at']
-lemmas removeFromBitmap_typ_ats [wp] = typ_at_lifts [OF removeFromBitmap_typ_at']
+global_interpretation removeFromBitmap: typ_at_all_props' "removeFromBitmap tdom prio"
+  by typ_at_props'
+
+lemma pspace_relation_tcb_domain_priority:
+  "\<lbrakk>pspace_relation (kheap s) (ksPSpace s'); kheap s t = Some (TCB tcb);
+    ksPSpace s' t = Some (KOTCB tcb')\<rbrakk>
+   \<Longrightarrow> tcb_domain tcb = tcbDomain tcb' \<and> tcb_priority tcb = tcbPriority tcb'"
+  apply (clarsimp simp: pspace_relation_def)
+  apply (drule_tac x=t in bspec, blast)
+  apply (drule_tac x="(t, other_obj_relation)" in bspec, simp)
+  apply (clarsimp simp: other_obj_relation_def tcb_relation_def)
+  done
 
 lemma tcbSchedEnqueue_corres:
-  "corres dc (is_etcb_at t) (tcb_at' t and Invariants_H.valid_queues and valid_queues')
-             (tcb_sched_action (tcb_sched_enqueue) t) (tcbSchedEnqueue t)"
+  "corres dc (tcb_at t and pspace_aligned and pspace_distinct)
+             (Invariants_H.valid_queues and valid_queues')
+          (tcb_sched_action (tcb_sched_enqueue) t) (tcbSchedEnqueue t)"
+    (is "corres _ _ ?conc_guard _ _")
 proof -
+
   have ready_queues_helper:
-    "\<And>t tcb a b. \<lbrakk> ekheap a t = Some tcb;  obj_at' tcbQueued t b  ;  valid_queues' b  ;
-                   ekheap_relation (ekheap a) (ksPSpace b) \<rbrakk>
-                 \<Longrightarrow> t \<in> set (ksReadyQueues b (tcb_domain tcb, tcb_priority tcb))"
+    "\<And>t tcb s s'. \<lbrakk> obj_at' tcbQueued t s';  valid_queues' s'; kheap s t = Some (TCB tcb);
+                   pspace_relation (kheap s) (ksPSpace s') \<rbrakk>
+                   \<Longrightarrow> t \<in> set (ksReadyQueues s' (tcb_domain tcb, tcb_priority tcb))"
   unfolding valid_queues'_def
-  by (fastforce dest: ekheap_relation_absD simp: obj_at'_def inQ_def etcb_relation_def projectKO_eq projectKO_tcb)
+  apply  (clarsimp dest:  simp: obj_at'_def inQ_def tcb_relation_def projectKO_eq projectKO_tcb)
+  using pspace_relation_tcb_domain_priority by fastforce
 
-  show ?thesis unfolding tcbSchedEnqueue_def tcb_sched_action_def
-    apply (rule corres_symb_exec_r [OF _ _ threadGet_inv,
-             where Q'="\<lambda>rv. tcb_at' t and Invariants_H.valid_queues and valid_queues' and obj_at' (\<lambda>obj. tcbQueued obj = rv) t"])
-      defer
-      apply (wp threadGet_obj_at'; simp_all)
+  show ?thesis
+    apply (rule corres_cross_over_guard[where Q="?conc_guard and tcb_at' t"])
+     apply (fastforce intro: tcb_at_cross)
+    unfolding tcbSchedEnqueue_def tcb_sched_action_def
+    apply (rule corres_symb_exec_r[where Q'="\<lambda>rv. tcb_at' t and Invariants_H.valid_queues
+                                                  and valid_queues'
+                                                  and obj_at' (\<lambda>obj. tcbQueued obj = rv) t"])
+       defer
+       apply (wp threadGet_obj_at'; simp_all)
+      apply (wpsimp wp: threadGet_inv)
      apply (rule no_fail_pre, wp, blast)
     apply (case_tac queued; simp_all)
-     apply (rule corres_no_failI; simp add: no_fail_return)
-     apply (clarsimp simp: in_monad ethread_get_def gets_the_def bind_assoc
-                           assert_opt_def exec_gets is_etcb_at_def get_etcb_def get_tcb_queue_def
+     apply (rule corres_no_failI)
+      apply (simp add: no_fail_return)
+     apply (clarsimp simp: in_monad gets_the_def bind_assoc
+                           assert_opt_def exec_gets get_tcb_queue_def
                            set_tcb_queue_def simpler_modify_def ready_queues_relation_def
-                           state_relation_def tcb_sched_enqueue_def)
-     apply (rule ready_queues_helper; auto)
+                           state_relation_def tcb_sched_enqueue_def thread_get_def get_tcb_def
+                           gets_def get_def return_def fail_def bind_def tcb_at_def cdt_relation_def
+                    split: option.splits Structures_A.kernel_object.splits)
+      using ready_queues_helper apply blast
+
     apply (clarsimp simp: when_def)
     apply (rule stronger_corres_guard_imp)
-      apply (rule corres_split_deprecated[where r'="(=)", OF _ ethreadget_corres])
-         apply (rule corres_split_deprecated[where r'="(=)", OF _ ethreadget_corres])
+      apply (rule corres_split_deprecated[where r'="(=)", OF _ threadGet_corres])
+         apply (rule corres_split_deprecated[where r'="(=)", OF _ threadGet_corres])
             apply (rule corres_split_deprecated[where r'="(=)"])
                apply (rule corres_split_noop_rhs2)
                    apply (rule corres_split_noop_rhs2)
-                     apply (fastforce intro: threadSet_corres_noop simp: tcb_relation_def exst_same_def)
+                     apply (fastforce intro: threadSet_corres_noop simp: tcb_relation_def)
                     apply (fastforce intro: addToBitmap_noop_corres)
                    apply wp+
                  apply (simp add: tcb_sched_enqueue_def split del: if_split)
                  apply (rule_tac P=\<top> and Q="K (t \<notin> set queuea)" in corres_assume_pre)
                  apply (wp setQueue_corres[unfolded dc_def] | simp)+
-              apply (wp getQueue_corres getObject_tcb_wp  | simp add: etcb_relation_def threadGet_def)+
+              apply (wp getQueue_corres getObject_tcb_wp  | simp add: tcb_relation_def threadGet_def)+
       apply (fastforce simp: valid_queues_def valid_queues_no_bitmap_def obj_at'_def inQ_def
                              projectKO_eq project_inject)
-     done
+  done
 qed
 
 definition
@@ -1952,28 +2294,307 @@ lemma getSchedulerAction_corres:
   apply (clarsimp simp: state_relation_def)
   done
 
-lemma rescheduleRequired_corres:
-  "corres dc (weak_valid_sched_action and valid_etcbs) (Invariants_H.valid_queues and valid_queues' and (\<lambda>s. weak_sch_act_wf (ksSchedulerAction s) s))
-     (reschedule_required) rescheduleRequired"
-  apply (simp add: rescheduleRequired_def reschedule_required_def)
+\<comment>\<open>
+  State-preservation lemmas: lemmas of the form @{term "m \<lbrace>P\<rbrace>"}.
+\<close>
+lemmas tcb_inv_collection =
+  getObject_tcb_inv
+  threadGet_inv
+
+\<comment>\<open>
+  State preservation lowered through @{thm use_valid}. Results are of
+  the form @{term "(rv, s') \<in> fst (m s) \<Longrightarrow> P s \<Longrightarrow> P s'"}.
+\<close>
+lemmas tcb_inv_use_valid =
+  tcb_inv_collection[THEN use_valid[rotated], rotated]
+
+\<comment>\<open>
+  Low-level monadic state preservation. Results are of the form
+  @{term "(rv, s') \<in> fst (m s) \<Longrightarrow> s = s'"}.
+\<close>
+lemmas tcb_inv_state_eq =
+  tcb_inv_use_valid[where s=s and P="(=) s" for s, OF _ refl]
+
+\<comment>\<open>
+  For when you want an obj_at' goal instead of the ko_at' that @{thm threadGet_wp}
+  gives you.
+\<close>
+lemma threadGet_obj_at'_field:
+  "\<lbrace>\<lambda>s. tcb_at' ptr s \<longrightarrow> obj_at' (\<lambda>tcb. P (field tcb) s) ptr s\<rbrace>
+   threadGet field ptr
+   \<lbrace>P\<rbrace>"
+  by (wpsimp wp: threadGet_wp
+           simp: obj_at_ko_at')
+
+\<comment>\<open>
+  Getting a boolean field of a thread is the same as the thread
+  "satisfying" the "predicate" which the field represents.
+\<close>
+lemma threadGet_obj_at'_bool_field:
+  "\<lbrace>tcb_at' ptr\<rbrace>
+   threadGet field ptr
+   \<lbrace>\<lambda>rv s. obj_at' field ptr s = rv\<rbrace>"
+   by (wpsimp wp: threadGet_wp
+            simp: obj_at'_def)
+
+lemma inReleaseQueue_corres:
+  shows "corres (=)
+          (tcb_at ptr)
+          (tcb_at' ptr and valid_release_queue_iff)
+          (gets (in_release_queue ptr))
+          (inReleaseQueue ptr)"
+  apply (simp add: gets_def)
+  apply (rule corres_bind_return_l)
+  apply (clarsimp simp: corres_underlying_def inReleaseQueue_def
+                        valid_release_queue_def valid_release_queue'_def
+                        no_fail_threadGet[unfolded no_fail_def])
+  apply (rename_tac s s' rv t')
+  apply (prop_tac "ksReleaseQueue s' = release_queue s")
+   subgoal by (clarsimp simp: state_relation_def release_queue_relation_def)
+  apply (frule tcb_inv_state_eq)
+  apply (clarsimp simp: split_paired_Bex in_get)
+  apply (frule tcb_inv_state_eq)
+  apply (erule allE[where x=ptr])+
+  apply (frule use_valid[OF _ threadGet_obj_at'_bool_field], assumption)
+  apply (fastforce simp: in_release_q_def)
+  done
+
+lemma isRunnable_corres:
+  "tcb_relation tcb_abs tcb_conc \<Longrightarrow>
+   corres (=)
+          (tcb_at t)
+          (ko_at' tcb_conc t)
+          (return (runnable (tcb_state tcb_abs)))
+          (isRunnable t)"
+  unfolding isRunnable_def getThreadState_def
+  apply (rule corres_symb_exec_r[where Q'="\<lambda>rv s. tcbState tcb_conc = rv"])
+     apply (case_tac "tcb_state tcb_abs"; clarsimp simp: tcb_relation_def)
+    apply (wpsimp wp: threadGet_wp)
+    apply (rule exI, fastforce)
+   apply (rule tcb_inv_collection)
+  apply (rule no_fail_pre[OF no_fail_threadGet])
+  apply (clarsimp simp: obj_at'_weaken)
+  done
+
+
+lemma isSchedulable_corres:
+  "corres (=)
+          (valid_tcbs and pspace_aligned and pspace_distinct and tcb_at t)
+          (valid_tcbs' and valid_release_queue_iff)
+          (is_schedulable t)
+          (isSchedulable t)"
+    (is "corres _ _ ?conc_guard _ _")
+  apply (rule corres_cross_over_guard[where Q="?conc_guard and tcb_at' t"])
+   apply (fastforce intro: tcb_at_cross)
+  unfolding is_schedulable_def isSchedulable_def fun_app_def
   apply (rule corres_guard_imp)
-    apply (rule corres_split_deprecated[OF _ getSchedulerAction_corres])
-      apply (rule_tac P="case action of switch_thread t \<Rightarrow> P t | _ \<Rightarrow> \<top>"
-              and P'="case actiona of SwitchToThread t \<Rightarrow> P' t | _ \<Rightarrow> \<top>" for P P' in corres_split_deprecated[where r'=dc])
-         apply (rule setSchedulerAction_corres)
-         apply simp
-        apply (case_tac action)
-          apply simp
-         apply simp
-         apply (rule tcbSchedEnqueue_corres)
-        apply simp
-       apply (wp | wpc | simp)+
-   apply (force dest: st_tcb_weakenE simp: in_monad weak_valid_sched_action_def valid_etcbs_def
-               split: Deterministic_A.scheduler_action.split)
-  apply simp
-  apply (clarsimp simp: weak_sch_act_wf_def pred_tcb_at' split: scheduler_action.splits)
+    apply (rule corres_split_deprecated[OF _ getObject_TCB_corres])
+      apply (rename_tac tcb_abs tcb_conc)
+      apply (rule corres_if[OF _ corres_return_eq_same])
+        apply (clarsimp simp: tcb_relation_def Option.is_none_def)
+       apply simp
+      apply (rule corres_split_deprecated[OF _ get_sc_corres[THEN equify]])
+         apply (rename_tac sc_abs sc_conc)
+         apply (rule corres_split_deprecated[OF _ isRunnable_corres])
+            apply (rule corres_split_deprecated[OF _ inReleaseQueue_corres])
+              apply (clarsimp simp: sc_relation_def active_sc_def)
+             apply blast
+            apply wp
+           apply assumption
+          apply wp
+         apply wp
+        apply (clarsimp simp: tcb_relation_def)
+       apply wp
+      apply wp
+     apply wp
+    apply (wpsimp simp: pred_conj_def
+                    wp: hoare_vcg_if_lift2 getObject_tcb_wp)
+   apply (clarsimp simp: pred_conj_def)
+   apply (frule (1) valid_tcbs_valid_tcb)
+   apply (fastforce simp: valid_tcb_def valid_bound_obj_def obj_at_def split: option.splits)
+  apply (fastforce simp: valid_tcbs'_def valid_tcb'_def obj_at'_def projectKOs)
+  done
+
+
+lemma get_simple_ko_exs_valid:
+  "\<lbrakk>inj C; \<exists>ko. ko_at (C ko) p s \<and> is_simple_type (C ko)\<rbrakk> \<Longrightarrow> \<lbrace>(=) s\<rbrace> get_simple_ko C p \<exists>\<lbrace>\<lambda>_. (=) s\<rbrace>"
+  by (fastforce simp: get_simple_ko_def get_object_def gets_def return_def get_def
+                      partial_inv_def exs_valid_def bind_def obj_at_def is_reply fail_def inj_def
+                      gets_the_def assert_def)
+
+lemmas get_notification_exs_valid[wp] =
+  get_simple_ko_exs_valid[where C=kernel_object.Notification, simplified]
+lemmas get_reply_exs_valid[wp] =
+  get_simple_ko_exs_valid[where C=kernel_object.Reply, simplified]
+lemmas get_endpoint_exs_valid[wp] =
+  get_simple_ko_exs_valid[where C=kernel_object.Endpoint, simplified]
+
+lemma thread_get_exs_valid:
+  "tcb_at tcb_ptr s \<Longrightarrow> \<lbrace>(=) s\<rbrace> thread_get f tcb_ptr \<exists>\<lbrace>\<lambda>_. (=) s\<rbrace>"
+  by (clarsimp simp: thread_get_def get_tcb_def gets_the_def gets_def return_def get_def
+                     exs_valid_def tcb_at_def bind_def)
+
+lemma isRunnable_sp:
+  "\<lbrace>P\<rbrace>
+   isRunnable tcb_ptr
+   \<lbrace>\<lambda>rv s. \<exists>tcb'. ko_at' tcb' tcb_ptr s
+                  \<and> (rv = (tcbState tcb' = Running \<or> tcbState tcb' = Restart))
+           \<and> P s\<rbrace>"
+  unfolding isRunnable_def getThreadState_def
+  apply (wpsimp wp: hoare_case_option_wp getObject_tcb_wp simp: threadGet_getObject)
+  apply (fastforce simp: obj_at'_def split: Structures_H.thread_state.splits)
+  done
+
+lemma isRunnable_sp':
+  "\<lbrace>P\<rbrace>
+   isRunnable tcb_ptr
+   \<lbrace>\<lambda>rv s. (rv = st_tcb_at' active' tcb_ptr s) \<and> P s\<rbrace>"
+  apply (clarsimp simp: isRunnable_def getThreadState_def)
+  apply (wpsimp wp: hoare_case_option_wp getObject_tcb_wp
+              simp: threadGet_getObject)
+  apply (fastforce simp: obj_at'_def st_tcb_at'_def
+                  split: Structures_H.thread_state.splits)
+  done
+
+lemma inReleaseQueue_sp:
+  "\<lbrace>P\<rbrace>
+   inReleaseQueue tcb_ptr
+   \<lbrace>\<lambda>rv s. \<exists>tcb'. ko_at' tcb' tcb_ptr s \<and> (rv = (tcbInReleaseQueue tcb')) \<and> P s\<rbrace>"
+  unfolding inReleaseQueue_def
+  apply (wpsimp wp: hoare_case_option_wp getObject_tcb_wp simp: threadGet_getObject)
+  apply (clarsimp simp: obj_at'_def)
   done
 
+lemma inReleaseQueue_inv[wp]:
+  "inReleaseQueue t \<lbrace>P\<rbrace>"
+  by (simp add: inReleaseQueue_def | wp gts_inv')+
+
+lemma conjunct_rewrite:
+  "P = P' \<and> Q = Q' \<and> R = R' \<Longrightarrow> (P \<and> Q \<and> R) = (P' \<and> Q' \<and> R')"
+  by simp
+
+lemma isSchedulable_inv[wp]:
+  "isSchedulable tcbPtr \<lbrace>P\<rbrace>"
+  apply (clarsimp simp: isSchedulable_def inReleaseQueue_def)
+  apply (rule hoare_seq_ext[OF _ getObject_tcb_inv])
+  by (wpsimp wp: inReleaseQueue_inv)
+
+lemma get_sc_refill_sufficient_sp:
+  "\<lbrace>P\<rbrace>
+   get_sc_refill_sufficient sc_ptr usage
+   \<lbrace>\<lambda>rv s. (\<exists>sc n. ko_at (kernel_object.SchedContext sc n) sc_ptr s
+                   \<and> (rv = sc_refill_sufficient usage sc))
+           \<and> P s\<rbrace>"
+  by (wpsimp simp: get_sc_refill_sufficient_def obj_at_def)
+
+lemma get_sc_refill_ready_sp:
+  "\<lbrace>P\<rbrace>
+   get_sc_refill_ready sc_ptr
+   \<lbrace>\<lambda>rv s. (\<exists>sc n. ko_at (kernel_object.SchedContext sc n) sc_ptr s
+                   \<and> (rv = sc_refill_ready (cur_time s) sc))
+           \<and> P s\<rbrace>"
+  by (wpsimp simp: obj_at_def)
+
+\<comment> \<open>In sched_context_donate, weak_valid_sched_action does not propagate backwards over the statement
+    where from_tptr's sched context is set to None because it requires the thread associated with a
+    switch_thread action to have a sched context. For this instance, we introduce a weaker version
+    of weak_valid_sched_action that is sufficient to prove refinement for reschedule_required\<close>
+definition weaker_valid_sched_action where
+  "weaker_valid_sched_action s \<equiv>
+   \<forall>t. scheduler_action s = switch_thread t \<longrightarrow>
+       tcb_at t s \<and> (bound_sc_tcb_at ((\<noteq>) None) t s \<longrightarrow> released_sc_tcb_at t s)"
+
+lemma weak_valid_sched_action_strg:
+  "weak_valid_sched_action s \<longrightarrow> weaker_valid_sched_action s"
+  by (fastforce simp: weak_valid_sched_action_def weaker_valid_sched_action_def
+                      obj_at_kh_kheap_simps vs_all_heap_simps is_tcb_def
+               split: Structures_A.kernel_object.splits)
+
+lemma no_ofail_get_tcb[wp]:
+  "no_ofail (tcb_at tp) (get_tcb tp)"
+  unfolding get_tcb_def no_ofail_def
+  by (clarsimp simp: obj_at_def is_tcb split: option.splits)
+
+lemma no_ofail_read_sched_context[wp]:
+  "no_ofail (\<lambda>s. \<exists>sc n. kheap s scp = Some (Structures_A.SchedContext sc n)) (read_sched_context scp)"
+  unfolding read_sched_context_def no_ofail_def
+  by (clarsimp simp: obj_at_def is_sc_obj obind_def)
+
+lemma no_ofail_read_sc_refill_ready:
+  "no_ofail (\<lambda>s. \<exists>sc n. kheap s scp = Some (Structures_A.SchedContext sc n)) (read_sc_refill_ready scp)"
+  unfolding read_sc_refill_ready_def no_ofail_def
+  by (clarsimp simp: omonad_defs obind_def dest!: no_ofailD[OF no_ofail_read_sched_context])
+
+lemma rescheduleRequired_corres_weak:
+  "corres dc (valid_tcbs and weaker_valid_sched_action and pspace_aligned and pspace_distinct
+              and active_sc_valid_refills)
+             (valid_tcbs' and Invariants_H.valid_queues and valid_queues' and valid_release_queue_iff)
+             reschedule_required rescheduleRequired"
+  apply (simp add: rescheduleRequired_def reschedule_required_def)
+  apply (rule corres_split'[OF _ _ gets_sp, rotated 2])
+    apply (clarsimp simp: getSchedulerAction_def)
+    apply (rule gets_sp)
+   apply (corressimp corres: getSchedulerAction_corres)
+  apply (rule corres_split'[where r'=dc, rotated]; (solves \<open>wpsimp\<close>)?)
+   apply (corressimp corres: setSchedulerAction_corres)
+  apply (case_tac action; clarsimp?)
+  apply (rename_tac tp)
+  apply (rule corres_split'[OF _ _ is_schedulable_sp isSchedulable_inv, rotated 2])
+   apply (corressimp corres: isSchedulable_corres)
+   apply (clarsimp simp: weaker_valid_sched_action_def obj_at_def vs_all_heap_simps is_tcb_def)
+  apply (clarsimp simp: when_def)
+
+  apply (rule corres_symb_exec_l[OF _ thread_get_exs_valid thread_get_sp , rotated])
+    apply (clarsimp simp: weaker_valid_sched_action_def vs_all_heap_simps obj_at_def is_tcb_def)
+   apply (wpsimp simp: thread_get_def get_tcb_def weaker_valid_sched_action_def vs_all_heap_simps)
+   apply (clarsimp simp: obj_at_def is_tcb_def)
+   apply (clarsimp split: Structures_A.kernel_object.splits)
+  apply (rule corres_symb_exec_l[OF _ _ assert_opt_sp, rotated])
+    apply (clarsimp simp: exs_valid_def obj_at_def return_def is_schedulable_opt_def get_tcb_def
+                   split: option.splits)
+   apply (clarsimp simp: no_fail_def obj_at_def return_def is_schedulable_opt_def get_tcb_def
+                  split: Structures_A.kernel_object.splits option.splits)
+
+  apply (rule corres_symb_exec_l[OF _ _ get_sc_refill_sufficient_sp, rotated])
+    apply (wpsimp wp: get_sched_context_exs_valid exs_valid_bind
+                simp: get_sc_refill_sufficient_def is_schedulable_opt_def get_tcb_def obj_at_def
+                      is_sc_active_def
+               split: Structures_A.kernel_object.splits option.splits)
+   apply (wpsimp wp: get_sched_context_no_fail simp: get_sc_refill_sufficient_def)
+   apply (fastforce simp: valid_tcbs_def valid_tcb_def obj_at_def is_schedulable_opt_def get_tcb_def
+                          is_sc_active_def is_sc_obj_def
+                   split: option.splits Structures_A.kernel_object.splits)
+
+  apply (rule corres_symb_exec_l[OF _ _ get_sc_refill_ready_sp, rotated])
+    apply (wpsimp wp: get_sched_context_exs_valid gets_the_exs_valid
+                simp: get_sc_refill_ready_def)
+     apply (clarsimp intro!: no_ofailD[OF no_ofail_read_sc_refill_ready] simp: obj_at_def is_sc_obj)
+    apply simp
+   apply (wpsimp wp: get_sched_context_no_fail simp: get_sc_refill_ready_def)
+   apply (clarsimp intro!: no_ofailD[OF no_ofail_read_sc_refill_ready] simp: obj_at_def is_sc_obj)
+  apply (rule_tac F=sufficient in corres_req)
+   apply (clarsimp simp: obj_at_def is_schedulable_opt_def get_tcb_def)
+   apply (drule_tac tp=tp in active_valid_budget_sufficient)
+    apply (clarsimp simp: vs_all_heap_simps is_sc_active_def)
+   apply (clarsimp simp: return_def vs_all_heap_simps
+                         obj_at_def pred_tcb_at_def weaker_valid_sched_action_def)
+  apply (rule corres_symb_exec_l[OF _ _ assert_sp, rotated])
+    apply (clarsimp simp: exs_valid_def return_def vs_all_heap_simps
+                          obj_at_def pred_tcb_at_def weaker_valid_sched_action_def)
+   apply (clarsimp simp: no_fail_def return_def vs_all_heap_simps
+                         obj_at_def pred_tcb_at_def weaker_valid_sched_action_def)
+  apply (corressimp corres: tcbSchedEnqueue_corres
+                      simp: obj_at_def is_tcb_def weak_sch_act_wf_def)
+  done
+
+lemma rescheduleRequired_corres:
+  "corres dc (valid_tcbs and weak_valid_sched_action and pspace_aligned and pspace_distinct
+              and active_sc_valid_refills)
+             (valid_tcbs' and valid_queues and valid_queues' and valid_release_queue_iff)
+             reschedule_required rescheduleRequired"
+  by (rule corres_guard_imp[OF rescheduleRequired_corres_weak])
+     (auto simp: weak_valid_sched_action_strg)
+
 lemma rescheduleRequired_corres_simple:
   "corres dc \<top> sch_act_simple
      (set_scheduler_action choose_new_thread) rescheduleRequired"
@@ -2077,7 +2687,7 @@ lemma gets_the_exec: "f s \<noteq> None \<Longrightarrow>  (do x \<leftarrow> ge
   done
 
 lemma tcbSchedDequeue_corres:
-  "corres dc (is_etcb_at t) (tcb_at' t and Invariants_H.valid_queues)
+  "corres dc (tcb_at t) (tcb_at' t and Invariants_H.valid_queues)
              (tcb_sched_action tcb_sched_dequeue t) (tcbSchedDequeue t)"
   apply (simp only: tcbSchedDequeue_def tcb_sched_action_def)
   apply (rule corres_symb_exec_r[OF _ _ threadGet_inv, where Q'="\<lambda>rv. tcb_at' t and Invariants_H.valid_queues and obj_at' (\<lambda>obj. tcbQueued obj = rv) t"])
@@ -2089,27 +2699,36 @@ lemma tcbSchedDequeue_corres:
    apply (simp add: when_def)
    apply (rule corres_no_failI)
     apply (wp)
-   apply (clarsimp simp: in_monad ethread_get_def set_tcb_queue_def is_etcb_at_def state_relation_def)
-   apply (subgoal_tac "t \<notin> set (ready_queues a (tcb_domain y) (tcb_priority y))")
-    prefer 2
-    subgoal by (force simp: tcb_sched_dequeue_def Invariants_H.valid_queues_def valid_queues_no_bitmap_def
-                            ready_queues_relation_def obj_at'_def inQ_def projectKO_eq project_inject)
+   apply (clarsimp simp: in_monad thread_get_def set_tcb_queue_def state_relation_def tcb_at_def
+                         get_tcb_def
+                  split: Structures_A.kernel_object.split option.splits)
+   apply (rename_tac tcb s')
+   apply (prop_tac "t \<notin> set (ready_queues a (tcb_domain tcb) (tcb_priority tcb))")
+    apply (clarsimp simp: tcb_sched_dequeue_def Invariants_H.valid_queues_def
+                          valid_queues_no_bitmap_def ready_queues_relation_def obj_at'_def inQ_def
+                          projectKO_eq project_inject)
+    apply (drule spec, clarsimp)+
+    apply (drule(1) bspec)
+    subgoal by force
    apply (subst gets_the_exec)
-    apply (simp add: get_etcb_def)
+    apply (simp add: get_tcb_def)
    apply (subst gets_the_exec)
-    apply (simp add: get_etcb_def)
-   apply (simp add: exec_gets simpler_modify_def get_etcb_def ready_queues_relation_def cong: if_cong get_tcb_queue_def)
+    apply (simp add: get_tcb_def)
+   apply (simp add: exec_gets simpler_modify_def get_tcb_def ready_queues_relation_def
+                    cdt_relation_def
+              cong: if_cong get_tcb_queue_def)
   apply (simp add: when_def)
   apply (rule corres_guard_imp)
-    apply (rule corres_split_deprecated[where r'="(=)", OF _ ethreadget_corres])
-       apply (rule corres_split_deprecated[where r'="(=)", OF _ ethreadget_corres])
+    apply (rule corres_split_deprecated[where r'="(=)", OF _ threadGet_corres])
+       apply (rule corres_split_deprecated[where r'="(=)", OF _ threadGet_corres])
           apply (rule corres_split_deprecated[where r'="(=)"])
              apply (rule corres_split_noop_rhs2)
                 apply (rule corres_split_noop_rhs)
-                  apply (rule threadSet_corres_noop; simp_all add: tcb_relation_def exst_same_def)
+                  apply (rule threadSet_corres_noop; simp_all add: tcb_relation_def)
                  apply (clarsimp, rule removeFromBitmap_corres_noop)
                 apply (rule setQueue_corres | rule getQueue_corres |
-                        wp | simp add: tcb_sched_dequeue_def etcb_relation_def)+
+                        wp | simp add: tcb_sched_dequeue_def tcb_relation_def
+                                       [[@\<open>prove_prop \<open>(\<lambda>x. x \<noteq> t) = (\<noteq>) t\<close>\<close>]])+
   done
 
 lemma thread_get_test: "do cur_ts \<leftarrow> get_thread_state cur; g (test cur_ts) od =
@@ -2118,7 +2737,7 @@ lemma thread_get_test: "do cur_ts \<leftarrow> get_thread_state cur; g (test cur
   done
 
 lemma thread_get_isRunnable_corres: "corres (=) (tcb_at t) (tcb_at' t) (thread_get (\<lambda>tcb. runnable (tcb_state tcb)) t) (isRunnable t)"
-  apply (simp add:  isRunnable_def getThreadState_def threadGet_def
+  apply (simp add:  isRunnable_def getThreadState_def threadGet_getObject
                    thread_get_def)
   apply (fold liftM_def)
   apply simp
@@ -2128,49 +2747,152 @@ lemma thread_get_isRunnable_corres: "corres (=) (tcb_at t) (tcb_at' t) (thread_g
   apply (case_tac "tcb_state x",simp_all)
   done
 
-lemma setThreadState_corres:
-  "thread_state_relation ts ts' \<Longrightarrow>
+lemma setObject_tcbState_update_corres:
+  "\<lbrakk>thread_state_relation ts ts'; tcb_relation tcb tcb'\<rbrakk> \<Longrightarrow>
    corres dc
-          (tcb_at t)
-          (tcb_at' t)
+          (ko_at (TCB tcb) t)
+          (ko_at' tcb' t)
+          (set_object t (TCB (tcb\<lparr>tcb_state := ts\<rparr>)))
+          (setObject t (tcbState_update (\<lambda>_. ts') tcb'))"
+  apply (rule setObject_update_TCB_corres')
+     apply (simp add: tcb_relation_def)
+    apply (rule ball_tcb_cap_casesI; clarsimp)
+   apply (rule ball_tcb_cte_casesI; clarsimp)
+  apply simp
+  done
+
+lemma threadSet_wp:
+  "\<lbrace>\<lambda>s. \<forall>tcb :: tcb. ko_at' tcb t s \<longrightarrow> P (set_obj' t (f tcb) s)\<rbrace>
+   threadSet f t
+   \<lbrace>\<lambda>_. P\<rbrace>"
+  unfolding threadSet_def
+  apply (wpsimp wp: setObject_tcb_wp set_tcb'.getObject_wp)
+  done
+
+\<comment>\<open>
+  If we don't change the @{term tcbInReleaseQueue} flag of a TCB,
+  then the release queues stay valid.
+\<close>
+lemma setObject_valid_release_queue:
+  "\<lbrace>valid_release_queue
+      and obj_at' (\<lambda>old_tcb. tcbInReleaseQueue old_tcb \<longrightarrow> tcbInReleaseQueue tcb) ptr\<rbrace>
+   setObject ptr tcb
+   \<lbrace>\<lambda>rv. valid_release_queue\<rbrace>"
+  unfolding valid_release_queue_def
+  apply (rule hoare_allI)
+  apply (wpsimp wp: setObject_tcb_obj_at'_strongest hoare_vcg_imp_lift)
+  apply (clarsimp simp: obj_at'_imp obj_at'_def)
+  done
+
+lemma setObject_valid_release_queue':
+  "\<lbrace>valid_release_queue'
+      and obj_at' (\<lambda>old_tcb. tcbInReleaseQueue tcb \<longrightarrow> tcbInReleaseQueue old_tcb) ptr\<rbrace>
+   setObject ptr tcb
+   \<lbrace>\<lambda>rv. valid_release_queue'\<rbrace>"
+  unfolding valid_release_queue'_def
+  apply (rule hoare_allI)
+  apply (wpsimp wp: setObject_tcb_obj_at'_strongest hoare_vcg_imp_lift)
+  apply (rename_tac t s)
+  apply (case_tac "ptr = t"; clarsimp)
+  done
+
+lemma setThreadState_corres:
+  assumes "thread_state_relation ts ts'"
+  shows "corres dc
+          (valid_tcbs and pspace_aligned and pspace_distinct and tcb_at t and valid_tcb_state ts)
+          (valid_tcbs' and valid_release_queue_iff)
           (set_thread_state t ts) (setThreadState ts' t)"
-  (is "?tsr \<Longrightarrow> corres dc ?Pre ?Pre' ?sts ?sts'")
-  apply (simp add: set_thread_state_def setThreadState_def)
-  apply (simp add: set_thread_state_ext_def[abs_def])
-  apply (subst bind_assoc[symmetric], subst thread_set_def[simplified, symmetric])
+    (is "corres _ _ ?conc_guard _ _")
+  using assms
+  apply -
+  apply (rule corres_cross_over_guard
+                  [where Q="?conc_guard and tcb_at' t and valid_tcb_state' ts'"])
+   apply (solves \<open>auto simp: state_relation_def intro: valid_tcb_state_cross tcb_at_cross\<close>)[1]
+  apply (simp add: set_thread_state_def setThreadState_def threadSet_def)
   apply (rule corres_guard_imp)
-    apply (rule corres_split_deprecated[where r'=dc])
-       apply simp
-       apply (subst thread_get_test[where test="runnable"])
-       apply (rule corres_split_deprecated[OF _ thread_get_isRunnable_corres])
-         apply (rule corres_split_deprecated[OF _ getCurThread_corres])
-           apply (rule corres_split_deprecated[OF _ getSchedulerAction_corres])
-             apply (simp only: when_def)
-             apply (rule corres_if[where Q=\<top> and Q'=\<top>])
-               apply (rule iffI)
-                apply clarsimp+
-               apply (case_tac rva,simp_all)[1]
-              apply (wp rescheduleRequired_corres_simple corres_return_trivial | simp)+
-      apply (rule threadset_corres, (simp add: tcb_relation_def exst_same_def)+)
-     apply (wp hoare_vcg_conj_lift[where Q'="\<top>\<top>"] | simp add: sch_act_simple_def)+
-   done
+    apply (subst bind_assoc)
+    apply (rule corres_split_deprecated[OF _ getObject_TCB_corres])
+      apply (rule corres_split_deprecated[OF _ setObject_tcbState_update_corres])
+          apply (simp add: set_thread_state_act_def scheduleTCB_def)
+          apply (rule corres_split_deprecated[OF _ getCurThread_corres])
+            apply (rule corres_split_deprecated[OF _ getSchedulerAction_corres])
+              apply (rule corres_split_deprecated[OF _ isSchedulable_corres])
+                apply (rule corres_split_deprecated corres_when)+
+                 apply (rename_tac sched_act sched_act' dont_care dont_care')
+                 apply (case_tac sched_act; clarsimp)
+                apply (rule rescheduleRequired_corres_simple)
+               apply wpsimp
+              apply (wpsimp simp: isSchedulable_def inReleaseQueue_def
+                              wp: threadGet_obj_at'_field getObject_tcb_wp)
+             apply wp
+            apply wp
+           apply wp
+          apply wp
+         apply assumption
+        apply assumption
+       apply wpsimp
+      apply (wpsimp simp: pred_conj_def sch_act_simple_def obj_at_ko_at'_eq
+                      wp: setObject_tcb_valid_tcbs' setObject_tcb_obj_at'_strongest
+                          setObject_valid_release_queue setObject_valid_release_queue')
+     apply wp
+    apply (wpsimp wp: getObject_tcb_wp)
+    apply (fastforce intro: valid_tcb_state_update valid_tcbs_valid_tcb
+                      simp: obj_at_def is_tcb_def)
+   apply (fastforce intro: valid_tcb'_tcbState_update
+                     simp: projectKOs valid_tcbs'_def obj_at'_def)+
+  done
+
+lemma set_tcb_obj_ref_corresT:
+  assumes x: "\<And>tcb tcb'. tcb_relation tcb tcb' \<Longrightarrow>
+                         tcb_relation (f (\<lambda>_. new) tcb) (f' tcb')"
+  assumes y: "\<And>tcb. \<forall>(getF, setF) \<in> ran tcb_cap_cases. getF (f (\<lambda>_. new) tcb) = getF tcb"
+  assumes z: "\<forall>tcb. \<forall>(getF, setF) \<in> ran tcb_cte_cases.
+                 getF (f' tcb) = getF tcb"
+  shows      "corres dc (tcb_at t) (tcb_at' t)
+                     (set_tcb_obj_ref f t new) (threadSet f' t)"
+  by (clarsimp simp: set_tcb_obj_ref_thread_set threadset_corresT x y z)
+
+lemmas set_tcb_obj_ref_corres =
+    set_tcb_obj_ref_corresT [OF _ _ all_tcbI, OF _ ball_tcb_cap_casesI ball_tcb_cte_casesI]
 
 lemma setBoundNotification_corres:
-  "corres dc
-          (tcb_at t)
-          (tcb_at' t)
-          (set_bound_notification t ntfn) (setBoundNotification ntfn t)"
-  apply (simp add: set_bound_notification_def setBoundNotification_def)
-  apply (subst thread_set_def[simplified, symmetric])
-  apply (rule threadset_corres, simp_all add:tcb_relation_def exst_same_def)
+  "corres dc (tcb_at t) (tcb_at' t)
+          (set_tcb_obj_ref tcb_bound_notification_update t ntfn) (setBoundNotification ntfn t)"
+  apply (simp add: setBoundNotification_def)
+  apply (rule set_tcb_obj_ref_corres; simp add: tcb_relation_def)
   done
 
 crunches rescheduleRequired, tcbSchedDequeue, setThreadState, setBoundNotification
-  for tcb'[wp]: "tcb_at' addr"
+  for typ_at'[wp]: "\<lambda>s. P (typ_at' T p s)"
+  and sc_at'_n[wp]: "\<lambda>s. P (sc_at'_n n p s)"
+  and ctes_of[wp]: "\<lambda>s. P (ctes_of s)"
+  (wp: crunch_wps)
+
+global_interpretation rescheduleRequired: typ_at_all_props' "rescheduleRequired"
+  by typ_at_props'
+
+global_interpretation tcbSchedDequeue: typ_at_all_props' "tcbSchedDequeue thread"
+  by typ_at_props'
+
+global_interpretation threadSet: typ_at_all_props' "threadSet f p"
+  by typ_at_props'
+
+global_interpretation setThreadState: typ_at_all_props' "setThreadState st p"
+  by typ_at_props'
 
-crunches rescheduleRequired, removeFromBitmap
+global_interpretation setBoundNotification: typ_at_all_props' "setBoundNotification v p"
+  by typ_at_props'
+
+global_interpretation scheduleTCB: typ_at_all_props' "scheduleTCB tcbPtr"
+  by typ_at_props'
+
+lemma sts'_valid_mdb'[wp]:
+  "setThreadState st t \<lbrace>valid_mdb'\<rbrace>"
+  by (wpsimp simp: valid_mdb'_def)
+
+crunches rescheduleRequired, removeFromBitmap, scheduleTCB
   for valid_objs'[wp]: valid_objs'
-  (simp: crunch_simps)
+  (simp: unless_def crunch_simps wp: crunch_wps)
 
 lemma tcbSchedDequeue_valid_objs' [wp]: "\<lbrace> valid_objs' \<rbrace> tcbSchedDequeue t \<lbrace>\<lambda>_. valid_objs' \<rbrace>"
   unfolding tcbSchedDequeue_def
@@ -2186,50 +2908,108 @@ lemma sts_valid_objs':
   "\<lbrace>valid_objs' and valid_tcb_state' st\<rbrace>
   setThreadState st t
   \<lbrace>\<lambda>rv. valid_objs'\<rbrace>"
-  apply (simp add: setThreadState_def setQueue_def isRunnable_def isStopped_def)
-  apply (wp threadSet_valid_objs')
-     apply (simp add: valid_tcb'_def tcb_cte_cases_def)
-     apply (wp threadSet_valid_objs' | simp)+
-  apply (clarsimp simp: valid_tcb'_def tcb_cte_cases_def)
-  done
+  apply (wpsimp simp: setThreadState_def wp: threadSet_valid_objs')
+  by (simp add: valid_tcb'_def tcb_cte_cases_def)
 
 lemma sbn_valid_objs':
   "\<lbrace>valid_objs' and valid_bound_ntfn' ntfn\<rbrace>
   setBoundNotification ntfn t
   \<lbrace>\<lambda>rv. valid_objs'\<rbrace>"
-  apply (simp add: setBoundNotification_def)
-  apply (wp threadSet_valid_objs')
-     apply (simp add: valid_tcb'_def tcb_cte_cases_def)
-  done
+  apply (wpsimp simp: setBoundNotification_def wp: threadSet_valid_objs')
+  by (simp add: valid_tcb'_def tcb_cte_cases_def)
+
+crunches setBoundNotification
+  for reply_projs[wp]: "\<lambda>s. P (replyNexts_of s) (replyPrevs_of s) (replyTCBs_of s) (replySCs_of s)"
+  and st_tcb_at'[wp]: "st_tcb_at' P p"
+  and valid_replies' [wp]: valid_replies'
+  (wp: valid_replies'_lift threadSet_pred_tcb_no_state)
 
 lemma ssa_wp[wp]:
   "\<lbrace>\<lambda>s. P (s \<lparr>ksSchedulerAction := sa\<rparr>)\<rbrace> setSchedulerAction sa \<lbrace>\<lambda>_. P\<rbrace>"
   by (wpsimp simp: setSchedulerAction_def)
 
-crunches rescheduleRequired, tcbSchedDequeue
+crunches rescheduleRequired, tcbSchedDequeue, scheduleTCB
+  for st_tcb_at'[wp]: "st_tcb_at' P p"
+  and valid_replies' [wp]: valid_replies'
+  (wp: crunch_wps threadSet_pred_tcb_no_state valid_replies'_lift)
+
+crunches rescheduleRequired, tcbSchedDequeue, setThreadState
   for aligned'[wp]: "pspace_aligned'"
   and distinct'[wp]: "pspace_distinct'"
-  and ctes_of[wp]: "\<lambda>s. P (ctes_of s)"
-
-crunches rescheduleRequired, tcbSchedDequeue
-  for no_0_obj'[wp]: "no_0_obj'"
+  and bounded'[wp]: "pspace_bounded'"
+  and no_0_obj'[wp]: "no_0_obj'"
+  (wp: crunch_wps)
+
+lemma threadSet_valid_replies':
+  "\<lbrace>\<lambda>s. valid_replies' s  \<and>
+        (\<forall>tcb. ko_at' tcb t s
+           \<longrightarrow> (\<forall>rptr. tcbState tcb = BlockedOnReply (Some rptr)
+                       \<longrightarrow> is_reply_linked rptr s \<longrightarrow> tcbState (f tcb) = BlockedOnReply (Some rptr)))\<rbrace>
+   threadSet f t
+   \<lbrace>\<lambda>_. valid_replies'\<rbrace>"
+  apply (clarsimp simp: threadSet_def)
+  apply (wpsimp wp: setObject_tcb_valid_replies' getObject_tcb_wp)
+  by (force simp: pred_tcb_at'_def obj_at'_def projectKOs)
+
+lemma sts'_valid_replies':
+  "\<lbrace>\<lambda>s. valid_replies' s \<and>
+        (\<forall>rptr. st_tcb_at' ((=) (BlockedOnReply (Some rptr))) t s
+                  \<longrightarrow> is_reply_linked rptr s \<longrightarrow> st = BlockedOnReply (Some rptr))\<rbrace>
+   setThreadState st t
+   \<lbrace>\<lambda>_. valid_replies'\<rbrace>"
+  apply (clarsimp simp: setThreadState_def)
+  apply (wpsimp wp: threadSet_valid_replies')
+  by (auto simp: pred_tcb_at'_def obj_at'_def projectKOs opt_map_def)
 
 lemma sts'_valid_pspace'_inv[wp]:
-  "\<lbrace> valid_pspace' and tcb_at' t and valid_tcb_state' st \<rbrace>
-  setThreadState st t
-  \<lbrace> \<lambda>rv. valid_pspace' \<rbrace>"
+  "\<lbrace> valid_pspace' and tcb_at' t and valid_tcb_state' st
+     and (\<lambda>s. \<forall>rptr. st_tcb_at' ((=) (BlockedOnReply (Some rptr))) t s
+                      \<longrightarrow> st = BlockedOnReply (Some rptr) \<or> \<not> is_reply_linked rptr s)\<rbrace>
+   setThreadState st t
+   \<lbrace> \<lambda>rv. valid_pspace' \<rbrace>"
   apply (simp add: valid_pspace'_def)
-  apply (rule hoare_pre)
-   apply (wp sts_valid_objs')
-   apply (simp add: setThreadState_def threadSet_def
-                    setQueue_def bind_assoc valid_mdb'_def)
-   apply (wp getObject_obj_at_tcb | simp)+
-  apply (clarsimp simp: valid_mdb'_def)
-  apply (drule obj_at_ko_at')
-  apply clarsimp
-  apply (erule obj_at'_weakenE)
-  apply (simp add: tcb_cte_cases_def)
-  done
+  apply (wpsimp wp: sts_valid_objs' sts'_valid_replies')
+  by (auto simp: opt_map_def)
+
+abbreviation
+  "is_replyState st \<equiv> is_BlockedOnReply st \<or> is_BlockedOnReceive st"
+
+lemma setObject_tcb_valid_replies'_except_Blocked:
+  "\<lbrace>\<lambda>s. valid_replies'_except {rptr} s \<and> replyTCBs_of s rptr = Some t
+        \<and> st_tcb_at' (\<lambda>st. is_replyState st \<longrightarrow> replyObject st = None) t s
+        \<and> (tcbState v = BlockedOnReply (Some rptr))\<rbrace>
+   setObject t (v :: tcb)
+   \<lbrace>\<lambda>rv. valid_replies'\<rbrace>"
+  unfolding valid_replies'_def valid_replies'_except_def
+  apply (subst pred_tcb_at'_eq_commute)+
+  apply (wpsimp wp: hoare_vcg_all_lift hoare_vcg_imp_lift' hoare_vcg_ex_lift
+                    set_tcb'.setObject_obj_at'_strongest
+                simp: pred_tcb_at'_def simp_del: imp_disjL)
+  apply (rename_tac rptr' rp obj)
+  apply (case_tac "rptr' = rptr")
+   apply (fastforce simp: opt_map_def)
+  apply (drule_tac x=rptr' in spec, drule mp, clarsimp)
+  apply (auto simp: opt_map_def obj_at'_def)
+  done
+
+lemma threadSet_valid_replies'_except_Blocked:
+  "\<lbrace>\<lambda>s. valid_replies'_except {rptr} s \<and> replyTCBs_of s rptr = Some t
+        \<and> st_tcb_at' (\<lambda>st. is_replyState st \<longrightarrow> replyObject st = None) t s
+        \<and> (\<forall>tcb. tcbState (f tcb) = BlockedOnReply (Some rptr))\<rbrace>
+   threadSet f t
+   \<lbrace>\<lambda>_. valid_replies'\<rbrace>"
+  apply (clarsimp simp: threadSet_def)
+  apply (wpsimp wp: setObject_tcb_valid_replies'_except_Blocked[where rptr=rptr] getObject_tcb_wp)
+  by (auto simp: pred_tcb_at'_def obj_at'_def projectKOs)
+
+lemma sts'_valid_replies'_except_Blocked:
+  "\<lbrace>\<lambda>s. valid_replies'_except {rptr} s \<and> replyTCBs_of s rptr = Some t
+        \<and> st_tcb_at' (\<lambda>st. is_replyState st \<longrightarrow> replyObject st = None) t s\<rbrace>
+   setThreadState (BlockedOnReply (Some rptr)) t
+   \<lbrace>\<lambda>_. valid_replies'\<rbrace>"
+  apply (clarsimp simp: setThreadState_def)
+  apply (wpsimp wp: threadSet_valid_replies'_except_Blocked)
+  by (auto simp: pred_tcb_at'_def obj_at'_def projectKOs opt_map_def)
 
 crunch ct[wp]: setQueue "\<lambda>s. P (ksCurThread s)"
 
@@ -2240,10 +3020,10 @@ crunch ct'[wp]: removeFromBitmap "\<lambda>s. P (ksCurThread s)"
 
 lemma setQueue_tcb_in_cur_domain'[wp]:
   "\<lbrace>tcb_in_cur_domain' t\<rbrace> setQueue d p xs \<lbrace>\<lambda>_. tcb_in_cur_domain' t\<rbrace>"
-apply (simp add: setQueue_def tcb_in_cur_domain'_def)
-apply wp
-apply (simp add: ps_clear_def projectKOs obj_at'_def)
-done
+  apply (simp add: setQueue_def tcb_in_cur_domain'_def)
+  apply wp
+  apply (simp add: ps_clear_def projectKOs obj_at'_def)
+  done
 
 lemma sbn'_valid_pspace'_inv[wp]:
   "\<lbrace> valid_pspace' and tcb_at' t and valid_bound_ntfn' ntfn \<rbrace>
@@ -2335,25 +3115,28 @@ lemma threadSet_runnable_sch_act:
   done
 
 lemma threadSet_pred_tcb_at_state:
-  "\<lbrace>\<lambda>s. tcb_at' t s \<longrightarrow> (if p = t
-        then obj_at' (\<lambda>tcb. P (proj (tcb_to_itcb' (f tcb)))) t s
-        else pred_tcb_at' proj P p s)\<rbrace>
-  threadSet f t \<lbrace>\<lambda>_. pred_tcb_at' proj P p\<rbrace>"
-  apply (rule hoare_chain)
-    apply (rule threadSet_obj_at'_really_strongest)
-   prefer 2
-   apply (simp add: pred_tcb_at'_def)
-  apply (clarsimp split: if_splits simp: pred_tcb_at'_def o_def)
+  "\<lbrace>\<lambda>s. tcb_at' t s \<longrightarrow>
+         (p = t \<longrightarrow> obj_at' (\<lambda>tcb. P (Q (proj (tcb_to_itcb' (f tcb))))) t s) \<and>
+         (p \<noteq> t \<longrightarrow>  P (pred_tcb_at' proj Q p s))\<rbrace>
+   threadSet f t
+   \<lbrace>\<lambda>_ s. P (pred_tcb_at' proj Q p s)\<rbrace>"
+  unfolding threadSet_def
+  apply (wpsimp wp: set_tcb'.setObject_wp set_tcb'.getObject_wp)
+  apply (case_tac "p = t"; clarsimp)
+   apply (subst pred_tcb_at'_set_obj'_iff, assumption)
+   apply (clarsimp simp: obj_at'_def)
+  apply (subst pred_tcb_at'_set_obj'_distinct, assumption, assumption)
+  apply (clarsimp simp: obj_at'_def)
   done
 
 lemma threadSet_tcbDomain_triv':
   "\<lbrace>tcb_in_cur_domain' t' and K (t \<noteq> t')\<rbrace> threadSet f t \<lbrace>\<lambda>_. tcb_in_cur_domain' t'\<rbrace>"
-apply (simp add: tcb_in_cur_domain'_def)
-apply (rule hoare_assume_pre)
-apply simp
-apply (rule_tac f="ksCurDomain" in hoare_lift_Pf)
-apply (wp threadSet_obj_at'_strongish getObject_tcb_wp | simp)+
-done
+  apply (simp add: tcb_in_cur_domain'_def)
+  apply (rule hoare_assume_pre)
+  apply simp
+  apply (rule_tac f="ksCurDomain" in hoare_lift_Pf)
+   apply (wp threadSet_obj_at'_strongish getObject_tcb_wp | simp)+
+  done
 
 lemma threadSet_sch_act_wf:
   "\<lbrace>\<lambda>s. sch_act_wf (ksSchedulerAction s) s \<and> sch_act_not t s \<and>
@@ -2516,50 +3377,51 @@ lemma tcbSchedDequeue_sch_act_wf[wp]:
   unfolding tcbSchedDequeue_def
   by (wp setQueue_sch_act | wp sch_act_wf_lift | simp add: if_apply_def2)+
 
-crunch nosch: tcbSchedDequeue "\<lambda>s. P (ksSchedulerAction s)"
+lemma scheduleTCB_sch_act_wf:
+  "\<lbrace>\<lambda>s. \<not>(t = ksCurThread s \<and> ksSchedulerAction s = ResumeCurrentThread
+        \<and> \<not> pred_map (\<lambda>tcb. runnable' (tcbState tcb)) (tcbs_of' s) t)
+        \<longrightarrow> (sch_act_wf (ksSchedulerAction s) s)\<rbrace>
+   scheduleTCB t \<lbrace>\<lambda>_ s. sch_act_wf (ksSchedulerAction s) s\<rbrace>"
+  apply (simp add: scheduleTCB_def)
+  by (wpsimp wp: isSchedulable_wp  simp: isSchedulable_bool_def pred_map_def opt_map_Some)
 
 lemma sts_sch_act':
   "\<lbrace>\<lambda>s. (\<not> runnable' st \<longrightarrow> sch_act_not t s) \<and> sch_act_wf (ksSchedulerAction s) s\<rbrace>
   setThreadState st t  \<lbrace>\<lambda>rv s. sch_act_wf (ksSchedulerAction s) s\<rbrace>"
   apply (simp add: setThreadState_def)
-  apply (wp | simp)+
+  apply (wp scheduleTCB_sch_act_wf)
    prefer 2
    apply assumption
   apply (case_tac "runnable' st")
-   apply ((wp threadSet_runnable_sch_act hoare_drop_imps | simp)+)[1]
+   apply (wpsimp wp: hoare_drop_imps threadSet_runnable_sch_act)
   apply (rule_tac Q="\<lambda>rv s. st_tcb_at' (Not \<circ> runnable') t s \<and>
-                     (ksCurThread s \<noteq> t \<or> ksSchedulerAction s \<noteq> ResumeCurrentThread \<longrightarrow>
-                            sch_act_wf (ksSchedulerAction s) s)"
-               in hoare_post_imp)
-   apply (clarsimp simp: pred_tcb_at'_def obj_at'_def projectKOs)
+                            (ksCurThread s \<noteq> t \<or> ksSchedulerAction s \<noteq> ResumeCurrentThread \<longrightarrow>
+                               sch_act_wf (ksSchedulerAction s) s)"
+           in hoare_post_imp)
+   apply (clarsimp simp: pred_tcb_at'_def obj_at'_def projectKOs pred_map_def)
   apply (simp only: imp_conv_disj)
-  apply (wp threadSet_pred_tcb_at_state threadSet_sch_act_wf
-            hoare_vcg_disj_lift|simp)+
+  apply (wpsimp wp: threadSet_pred_tcb_at_state threadSet_sch_act_wf hoare_vcg_disj_lift)
   done
 
+(* FIXME: sts_sch_act' (above) is stronger, and should be the wp rule. VER-1366 *)
 lemma sts_sch_act[wp]:
   "\<lbrace>\<lambda>s. (\<not> runnable' st \<longrightarrow> sch_act_simple s) \<and> sch_act_wf (ksSchedulerAction s) s\<rbrace>
      setThreadState st t
    \<lbrace>\<lambda>rv s. sch_act_wf (ksSchedulerAction s) s\<rbrace>"
   apply (simp add: setThreadState_def)
-  apply wp
-   apply simp
+  apply (wp scheduleTCB_sch_act_wf)
    prefer 2
    apply assumption
   apply (case_tac "runnable' st")
-   apply (rule_tac Q="\<lambda>s. sch_act_wf (ksSchedulerAction s) s"
-                in hoare_pre_imp, simp)
-   apply ((wp hoare_drop_imps threadSet_runnable_sch_act | simp)+)[1]
+   apply (wpsimp wp: hoare_drop_imps threadSet_runnable_sch_act)
   apply (rule_tac Q="\<lambda>rv s. st_tcb_at' (Not \<circ> runnable') t s \<and>
-                     (ksCurThread s \<noteq> t \<or> ksSchedulerAction s \<noteq> ResumeCurrentThread \<longrightarrow>
-                            sch_act_wf (ksSchedulerAction s) s)"
-               in hoare_post_imp)
-   apply (clarsimp simp: pred_tcb_at'_def obj_at'_def projectKOs)
+                            (ksCurThread s \<noteq> t \<or> ksSchedulerAction s \<noteq> ResumeCurrentThread \<longrightarrow>
+                               sch_act_wf (ksSchedulerAction s) s)"
+           in hoare_post_imp)
+   apply (clarsimp simp: pred_tcb_at'_def obj_at'_def projectKOs pred_map_def)
   apply (simp only: imp_conv_disj)
-  apply (rule hoare_pre)
-   apply (wp threadSet_pred_tcb_at_state threadSet_sch_act_wf
-             hoare_vcg_disj_lift|simp)+
-  apply (auto simp: sch_act_simple_def)
+  apply (wpsimp wp: threadSet_pred_tcb_at_state threadSet_sch_act_wf hoare_vcg_disj_lift)
+  apply (fastforce simp: sch_act_simple_def)
   done
 
 lemma sbn_sch_act':
@@ -2834,11 +3694,9 @@ proof -
     by - (erule hoare_strengthen_post; fastforce elim: valid_bitmap_valid_bitmapQ_exceptE)
 qed
 
-crunch valid_queues[wp]: threadGet "Invariants_H.valid_queues"
-
 lemma threadGet_const_tcb_at:
   "\<lbrace>\<lambda>s. tcb_at' t s \<and> obj_at' (P s \<circ> f) t s\<rbrace> threadGet f t \<lbrace>\<lambda>rv s. P s rv \<rbrace>"
-  apply (simp add: threadGet_def liftM_def)
+  apply (simp add: threadGet_getObject)
   apply (wp getObject_tcb_wp)
   apply (clarsimp simp: obj_at'_def)
   done
@@ -3173,37 +4083,80 @@ lemma tcbSchedEnqueue_valid_queues'[wp]:
                    in hoare_post_imp)
         apply (clarsimp simp: valid_queues'_def obj_at'_def projectKOs inQ_def)
        apply (wp setQueue_valid_queues' | simp | simp add: setQueue_def)+
-     apply (wp getObject_tcb_wp | simp add: threadGet_def)+
+     apply (wp getObject_tcb_wp | simp add: threadGet_getObject)+
      apply (clarsimp simp: obj_at'_def inQ_def projectKOs valid_queues'_def)
-    apply (wp getObject_tcb_wp | simp add: threadGet_def)+
+    apply (wp getObject_tcb_wp | simp add: threadGet_getObject)+
   apply (clarsimp simp: obj_at'_def)
   done
 
-lemma rescheduleRequired_valid_queues'_weak[wp]:
-  "\<lbrace>\<lambda>s. valid_queues' s \<and> weak_sch_act_wf (ksSchedulerAction s) s\<rbrace>
-    rescheduleRequired
-   \<lbrace>\<lambda>_. valid_queues'\<rbrace>"
+lemma rescheduleRequired_valid_queues'[wp]:
+  "rescheduleRequired \<lbrace>valid_queues'\<rbrace>"
   apply (simp add: rescheduleRequired_def)
-  apply wpsimp
-  apply (clarsimp simp: weak_sch_act_wf_def)
+  apply (wpsimp wp: isSchedulable_inv hoare_vcg_if_lift2)
   done
 
-lemma rescheduleRequired_valid_queues'_sch_act_simple:
-  "\<lbrace>valid_queues' and sch_act_simple\<rbrace>
-    rescheduleRequired
-   \<lbrace>\<lambda>_. valid_queues'\<rbrace>"
-  apply (simp add: rescheduleRequired_def)
-  apply (wp | wpc | simp | fastforce simp: valid_queues'_def sch_act_simple_def)+
+lemma tcbSchedEnqueue_sch_act_sane[wp]:
+  "tcbSchedEnqueue t \<lbrace>sch_act_sane\<rbrace>"
+  apply (clarsimp simp: tcbSchedEnqueue_def sch_act_sane_def)
+  by (wpsimp wp: hoare_vcg_all_lift hoare_vcg_imp_lift')
+
+lemma rescheduleRequired_valid_release_queue[wp]:
+  "rescheduleRequired \<lbrace>valid_release_queue\<rbrace>"
+  apply (simp add: rescheduleRequired_def getSchedulerAction_def)
+  apply (rule hoare_seq_ext[OF _ gets_sp])
+  apply (rule_tac B="\<lambda>_. valid_release_queue" in hoare_seq_ext[rotated]
+         ; (solves \<open>wpsimp simp: valid_release_queue_def\<close>)?)
+  done
+
+lemma rescheduleRequired_valid_release_queue'[wp]:
+  "rescheduleRequired \<lbrace>valid_release_queue'\<rbrace>"
+  apply (simp add: rescheduleRequired_def getSchedulerAction_def)
+  apply (rule hoare_seq_ext[OF _ gets_sp])
+  apply (rule_tac B="\<lambda>_. valid_release_queue'" in hoare_seq_ext[rotated]
+         ; (solves \<open>wpsimp simp: valid_release_queue'_def\<close>)?)
   done
 
 lemma setThreadState_valid_queues'[wp]:
   "\<lbrace>\<lambda>s. valid_queues' s\<rbrace> setThreadState st t \<lbrace>\<lambda>rv. valid_queues'\<rbrace>"
-  apply (simp add: setThreadState_def)
-  apply (wp rescheduleRequired_valid_queues'_sch_act_simple)
-  apply (rule_tac Q="\<lambda>_. valid_queues'" in hoare_post_imp)
-   apply (clarsimp simp: sch_act_simple_def)
-  apply (wp threadSet_valid_queues')
-  apply (fastforce simp: inQ_def obj_at'_def pred_tcb_at'_def)
+  apply (simp add: setThreadState_def scheduleTCB_def)
+  apply (rule hoare_seq_ext_skip)
+   apply (wp threadSet_valid_queues')
+   apply (clarsimp simp: inQ_def)
+  apply (rule hoare_seq_ext_skip, wpsimp)
+  apply (clarsimp simp: getSchedulerAction_def)
+  apply (rule hoare_seq_ext[OF _ gets_sp])
+  apply (rule hoare_seq_ext_skip, wpsimp wp: isSchedulable_inv)
+  apply (rule hoare_when_cases; wpsimp simp: weak_sch_act_wf_def)
+  done
+
+lemma setThreadState_valid_release_queue[wp]:
+  "setThreadState st t \<lbrace>valid_release_queue\<rbrace>"
+  apply (simp add: setThreadState_def scheduleTCB_def)
+  apply (rule hoare_seq_ext_skip)
+   apply (wp threadSet_valid_release_queue)
+   using valid_release_queue_def apply simp
+  apply (rule hoare_seq_ext_skip, wpsimp)
+  apply (clarsimp simp: getSchedulerAction_def)
+  apply (rule hoare_seq_ext[OF _ gets_sp])
+  apply (rule hoare_seq_ext_skip, wpsimp wp: isSchedulable_inv)
+  apply (rule hoare_when_cases)
+   apply clarsimp
+  apply wpsimp
+  done
+
+lemma setThreadState_valid_release_queue'[wp]:
+  "setThreadState st t \<lbrace>valid_release_queue'\<rbrace>"
+  apply (simp add: setThreadState_def scheduleTCB_def)
+  apply (rule hoare_seq_ext_skip)
+   apply (wp threadSet_valid_release_queue')
+   apply (fastforce simp: obj_at'_def valid_release_queue'_def)
+  apply (rule hoare_seq_ext_skip, wpsimp)
+  apply (clarsimp simp: getSchedulerAction_def)
+  apply (rule hoare_seq_ext[OF _ gets_sp])
+  apply (rule hoare_seq_ext_skip, wpsimp wp: isSchedulable_inv)
+  apply (rule hoare_when_cases)
+   apply clarsimp
+  apply wpsimp
   done
 
 lemma setBoundNotification_valid_queues'[wp]:
@@ -3213,30 +4166,115 @@ lemma setBoundNotification_valid_queues'[wp]:
   apply (fastforce simp: inQ_def obj_at'_def pred_tcb_at'_def)
   done
 
-lemma valid_tcb'_tcbState_update:
-  "\<lbrakk> valid_tcb_state' st s; valid_tcb' tcb s \<rbrakk> \<Longrightarrow> valid_tcb' (tcbState_update (\<lambda>_. st) tcb) s"
-  apply (clarsimp simp: valid_tcb'_def tcb_cte_cases_def valid_tcb_state'_def)
+lemma setBoundNotification_valid_release_queue[wp]:
+  "setBoundNotification ntfn t \<lbrace>valid_release_queue\<rbrace>"
+  apply (simp add: setBoundNotification_def)
+  apply (wp threadSet_valid_release_queue)
+  apply (fastforce simp: inQ_def obj_at'_def pred_tcb_at'_def)
+  done
+
+lemma setBoundNotification_valid_release_queues[wp]:
+  "setBoundNotification ntfn t \<lbrace>valid_release_queue'\<rbrace>"
+  apply (simp add: setBoundNotification_def)
+  apply (wp threadSet_valid_release_queue')
+  apply (fastforce simp: inQ_def obj_at'_def pred_tcb_at'_def valid_release_queue'_def)
   done
 
 lemma setThreadState_valid_objs'[wp]:
   "\<lbrace> valid_tcb_state' st and valid_objs' \<rbrace> setThreadState st t \<lbrace> \<lambda>_. valid_objs' \<rbrace>"
-  apply (simp add: setThreadState_def)
-  apply (wp threadSet_valid_objs' | clarsimp simp: valid_tcb'_tcbState_update)+
+  apply (simp add: setThreadState_def pred_conj_def)
+  apply (wpsimp wp: threadSet_valid_objs')
+  apply (clarsimp simp: valid_tcb'_tcbState_update)
+  done
+
+crunches addToBitmap
+  for ksPSpace[wp]: "\<lambda>s. P (ksPSpace s ptr = opt)"
+
+lemma addToBitmap_valid_tcb'[wp]:
+  "addToBitmap tdom prio \<lbrace>valid_tcb' tcb\<rbrace>"
+  by (wpsimp simp: addToBitmap_def getReadyQueuesL2Bitmap_def getReadyQueuesL1Bitmap_def
+                   modifyReadyQueuesL2Bitmap_def modifyReadyQueuesL1Bitmap_def
+                   update_valid_tcb')
+
+lemma addToBitmap_valid_tcbs'[wp]:
+  "addToBitmap tdom prio \<lbrace>valid_tcbs'\<rbrace>"
+  unfolding valid_tcbs'_def
+  apply (wpsimp wp: hoare_vcg_all_lift hoare_vcg_imp_lift')
+  done
+
+crunches setQueue
+  for valid_tcb'[wp]: "\<lambda>s. valid_tcb' tcb s"
+  and ksPSpace[wp]: "\<lambda>s. P (ksPSpace s ptr = opt)"
+
+lemma tcbSchedEnqueue_valid_tcb'[wp]:
+  "tcbSchedEnqueue thread \<lbrace>valid_tcb' tcb\<rbrace>"
+  apply (clarsimp simp: tcbSchedEnqueue_def)
+  apply (rule hoare_seq_ext_skip, wpsimp)
+  apply (clarsimp simp: unless_def when_def)
+  apply (rule hoare_seq_ext_skip, wpsimp)+
+  apply (wpsimp wp: threadSet_valid_tcb')
+  done
+
+lemma tcbSchedEnqueue_valid_tcbs'[wp]:
+  "tcbSchedEnqueue thread \<lbrace>valid_tcbs'\<rbrace>"
+  apply (clarsimp simp: tcbSchedEnqueue_def setQueue_def)
+  apply (rule hoare_seq_ext_skip, wpsimp)
+  apply (clarsimp simp: unless_def when_def)
+  apply (rule hoare_seq_ext_skip, wpsimp simp: valid_tcbs'_def wp: update_valid_tcb')+
+  apply (wpsimp wp: threadSet_valid_tcbs')
+  done
+
+lemma setSchedulerAction_valid_tcbs'[wp]:
+  "setSchedulerAction sa \<lbrace>valid_tcbs'\<rbrace>"
+  unfolding valid_tcbs'_def
+  apply (wpsimp wp: hoare_vcg_all_lift update_valid_tcb')
+  done
+
+lemma rescheduleRequired_valid_tcb'[wp]:
+  "rescheduleRequired \<lbrace>valid_tcb' tcb\<rbrace>"
+  apply (clarsimp simp: rescheduleRequired_def)
+  apply (rule hoare_seq_ext_skip, wpsimp wp: update_valid_tcb' isSchedulable_wp)+
+  apply (wpsimp wp: update_valid_tcb')
+  done
+
+lemma rescheduleRequired_valid_tcbs'[wp]:
+  "rescheduleRequired \<lbrace>valid_tcbs'\<rbrace>"
+  apply (clarsimp simp: rescheduleRequired_def)
+  apply (rule hoare_seq_ext_skip, wpsimp wp: update_valid_tcb' isSchedulable_wp)+
+  apply (wpsimp wp: update_valid_tcb')
+  done
+
+crunches scheduleTCB
+  for valid_tcbs'[wp]: valid_tcbs'
+  (wp: crunch_wps simp: crunch_simps)
+
+lemma setThreadState_valid_tcbs'[wp]:
+  "\<lbrace> valid_tcb_state' st and valid_tcbs' \<rbrace> setThreadState st t \<lbrace> \<lambda>_. valid_tcbs' \<rbrace>"
+  apply (simp add: setThreadState_def pred_conj_def)
+  apply (wpsimp wp: threadSet_valid_tcbs')
+  apply (clarsimp simp: valid_tcb'_tcbState_update)
   done
 
 lemma rescheduleRequired_ksQ:
-  "\<lbrace>\<lambda>s. sch_act_simple s \<and> P (ksReadyQueues s p)\<rbrace>
+  "\<lbrace>\<lambda>s. sch_act_simple s \<and> P (ksReadyQueues s)\<rbrace>
     rescheduleRequired
-   \<lbrace>\<lambda>_ s. P (ksReadyQueues s p)\<rbrace>"
+   \<lbrace>\<lambda>_ s. P (ksReadyQueues s)\<rbrace>"
   including no_pre
   apply (simp add: rescheduleRequired_def sch_act_simple_def)
   apply (rule_tac B="\<lambda>rv s. (rv = ResumeCurrentThread \<or> rv = ChooseNewThread)
-                            \<and> P (ksReadyQueues s p)" in hoare_seq_ext)
+                            \<and> P (ksReadyQueues s)" in hoare_seq_ext)
    apply wpsimp
    apply (case_tac x; simp)
   apply wp
   done
 
+lemma scheduleTCB_ksQ:
+  "\<lbrace>\<lambda>s. P (ksReadyQueues s)\<rbrace>
+   scheduleTCB tcbPtr
+   \<lbrace>\<lambda>_ s. P (ksReadyQueues s)\<rbrace>"
+  by (wpsimp simp: scheduleTCB_def sch_act_simple_def
+               wp: isSchedulable_inv rescheduleRequired_ksQ hoare_vcg_if_lift2 isSchedulable_wp)
+
 lemma setSchedulerAction_ksQ[wp]:
   "\<lbrace>\<lambda>s. P (ksReadyQueues s)\<rbrace> setSchedulerAction act \<lbrace>\<lambda>_ s. P (ksReadyQueues s)\<rbrace>"
   by (wp, simp)
@@ -3277,10 +4312,7 @@ lemma rescheduleRequired_ksQ':
   "\<lbrace>\<lambda>s. t \<notin> set (ksReadyQueues s p) \<and> sch_act_not t s \<rbrace>
    rescheduleRequired \<lbrace>\<lambda>_ s. t \<notin> set (ksReadyQueues s p)\<rbrace>"
   apply (simp add: rescheduleRequired_def)
-  apply (wpsimp wp: tcbSchedEnqueue_ksQ)
-  done
-
-crunch ksQ[wp]: getCurThread "\<lambda>s. P (ksReadyQueues s p)"
+  by (wpsimp wp: tcbSchedEnqueue_ksQ isSchedulable_inv hoare_vcg_if_lift2 hoare_drop_imps)
 
 lemma threadSet_tcbState_st_tcb_at':
   "\<lbrace>\<lambda>s. P st \<rbrace> threadSet (tcbState_update (\<lambda>_. st)) t \<lbrace>\<lambda>_. st_tcb_at' P t\<rbrace>"
@@ -3426,15 +4446,17 @@ lemmas msgRegisters_unfold
          unfolded toEnum_def enum_register, simplified]
 
 lemma getMRs_corres:
+  assumes mirel: "mi' = message_info_map mi" shows
   "corres (=) (tcb_at t)
               (tcb_at' t and case_option \<top> valid_ipc_buffer_ptr' buf)
-              (get_mrs t buf mi) (getMRs t buf (message_info_map mi))"
+              (get_mrs t buf mi) (getMRs t buf mi')"
   proof -
   have S: "get = gets id"
     by (simp add: gets_def)
   have T: "corres (\<lambda>con regs. regs = map con msg_registers) (tcb_at t) (tcb_at' t)
      (thread_get (arch_tcb_get_registers o tcb_arch) t) (asUser t (mapM getRegister ARM_H.msgRegisters))"
     unfolding arch_tcb_get_registers_def
+
     apply (subst thread_get_as_user)
     apply (rule asUser_corres')
     apply (subst mapM_gets)
@@ -3784,18 +4806,21 @@ lemma lookupIPCBuffer_corres:
                (tcb_at' t and invs')
                (lookup_ipc_buffer w t) (lookupIPCBuffer w t)"
   using lookupIPCBuffer_corres'
-  by (rule corres_guard_imp, auto simp: invs'_def valid_state'_def)
-
+  by (rule corres_guard_imp, auto simp: invs'_def)
 
 crunch inv[wp]: lookupIPCBuffer P
+  (wp: crunch_wps)
+
+end
 
-crunch pred_tcb_at'[wp]: rescheduleRequired "pred_tcb_at' proj P t"
+crunches scheduleTCB, possibleSwitchTo
+  for pred_tcb_at'[wp]: "\<lambda>s. P' (pred_tcb_at' proj P t s)"
+  (wp: crunch_wps simp: crunch_simps)
 
 lemma setThreadState_st_tcb':
   "\<lbrace>\<top>\<rbrace> setThreadState st t \<lbrace>\<lambda>rv. st_tcb_at' (\<lambda>s. s = st) t\<rbrace>"
   apply (simp add: setThreadState_def)
-  apply (wp threadSet_pred_tcb_at_state | simp add: if_apply_def2)+
-  done
+  by (wpsimp wp: threadSet_pred_tcb_at_state)
 
 lemma setThreadState_st_tcb:
   "\<lbrace>\<lambda>s. P st\<rbrace> setThreadState st t \<lbrace>\<lambda>rv. st_tcb_at' P t\<rbrace>"
@@ -3845,22 +4871,19 @@ lemma ct_in_state'_set:
   apply clarsimp
   done
 
-crunches setQueue, rescheduleRequired, tcbSchedDequeue
+crunches setQueue, scheduleTCB, tcbSchedDequeue
   for idle'[wp]: "valid_idle'"
-  (simp: crunch_simps )
+  (simp: crunch_simps wp: crunch_wps)
 
 lemma sts_valid_idle'[wp]:
-  "\<lbrace>valid_idle' and valid_pspace' and
-    (\<lambda>s. t = ksIdleThread s \<longrightarrow> idle' ts)\<rbrace>
+  "\<lbrace>valid_idle' and (\<lambda>s. t = ksIdleThread s \<longrightarrow> idle' ts)\<rbrace>
    setThreadState ts t
    \<lbrace>\<lambda>rv. valid_idle'\<rbrace>"
   apply (simp add: setThreadState_def)
-  apply (wpsimp wp: threadSet_idle' simp: idle_tcb'_def)
-  done
+  by (wpsimp wp: threadSet_idle' simp: idle_tcb'_def)
 
 lemma sbn_valid_idle'[wp]:
-  "\<lbrace>valid_idle' and valid_pspace' and
-    (\<lambda>s. t = ksIdleThread s \<longrightarrow> \<not>bound ntfn)\<rbrace>
+  "\<lbrace>valid_idle' and (\<lambda>s. t = ksIdleThread s \<longrightarrow> \<not>bound ntfn)\<rbrace>
    setBoundNotification ntfn t
    \<lbrace>\<lambda>rv. valid_idle'\<rbrace>"
   apply (simp add: setBoundNotification_def)
@@ -3913,72 +4936,138 @@ lemma tcbSchedDequeue_pred_tcb_at'[wp]:
   apply (wp threadSet_pred_tcb_no_state | clarsimp simp: tcb_to_itcb'_def)+
   done
 
-lemma sts_st_tcb':
-  "\<lbrace>if t = t' then K (P st) else st_tcb_at' P t\<rbrace>
-  setThreadState st t'
-  \<lbrace>\<lambda>_. st_tcb_at' P t\<rbrace>"
-  apply (cases "t = t'",
-         simp_all add: setThreadState_def
-                  split del: if_split)
-   apply ((wp threadSet_pred_tcb_at_state | simp)+)[1]
-  apply (wp threadSet_obj_at'_really_strongest
-              | simp add: pred_tcb_at'_def)+
+lemma tcbReleaseRemove_pred_tcb_at'[wp]:
+  "tcbReleaseRemove t \<lbrace>\<lambda>s. P' (pred_tcb_at' proj P t' s)\<rbrace>"
+  apply (rule_tac P=P' in P_bool_lift)
+  unfolding tcbReleaseRemove_def
+   apply (wp threadSet_pred_tcb_no_state
+          | clarsimp simp: tcb_to_itcb'_def setReleaseQueue_def
+                           setReprogramTimer_def getReleaseQueue_def)+
   done
 
-lemma sts_bound_tcb_at':
-  "\<lbrace>bound_tcb_at' P t\<rbrace>
-  setThreadState st t'
-  \<lbrace>\<lambda>_. bound_tcb_at' P t\<rbrace>"
-  apply (cases "t = t'",
-         simp_all add: setThreadState_def
-                  split del: if_split)
-   apply ((wp threadSet_pred_tcb_at_state | simp)+)[1]
-   apply (wp threadSet_obj_at'_really_strongest
-               | simp add: pred_tcb_at'_def)+
+crunches tcbReleaseRemove
+  for weak_sch_act_wf[wp]: "\<lambda>s. weak_sch_act_wf (ksSchedulerAction s) s"
+
+lemma ksReleaseQueue_runnable_thread_state:
+  "\<lbrakk>(s,s') \<in> state_relation; valid_release_q s; pspace_aligned s; pspace_distinct s\<rbrakk>
+   \<Longrightarrow>  \<forall>p. p \<in> set (ksReleaseQueue s') \<longrightarrow> obj_at' (runnable' \<circ> tcbState) p s'"
+  apply (frule state_relation_release_queue_relation)
+  apply (clarsimp simp: valid_release_q_def obj_at'_def release_queue_relation_def)
+  apply (drule_tac x=p in bspec, blast)
+  apply (clarsimp simp: vs_all_heap_simps)
+  apply (frule_tac t=p in st_tcb_at_coerce_concrete[rotated, where P=runnable], simp, simp)
+   apply (clarsimp simp: pred_tcb_at_def obj_at_def)
+  apply (clarsimp simp: pred_tcb_at'_def obj_at'_def sts_rel_runnable)
   done
 
-lemma sbn_st_tcb':
-  "\<lbrace>st_tcb_at' P t\<rbrace>
-  setBoundNotification ntfn t'
+lemma sts_st_tcb':
+  "\<lbrace>if t = t' then K (P st) else st_tcb_at' P t\<rbrace>
+  setThreadState st t'
   \<lbrace>\<lambda>_. st_tcb_at' P t\<rbrace>"
+  by (cases "t = t'"
+      ; wpsimp wp: threadSet_pred_tcb_at_state simp: setThreadState_def)
+
+lemma sts_bound_tcb_at'[wp]:
+  "setThreadState st t' \<lbrace>bound_tcb_at' P t\<rbrace>"
+  apply (clarsimp simp: setThreadState_def)
+  by (cases "t = t'"
+      ; wpsimp wp: threadSet_pred_tcb_at_state
+             simp: pred_tcb_at'_def)+
+
+lemma sts_bound_sc_tcb_at'[wp]:
+  "setThreadState st t' \<lbrace>bound_sc_tcb_at' P t\<rbrace>"
+  apply (clarsimp simp: setThreadState_def)
+  by (cases "t = t'"
+      ; wpsimp wp: threadSet_pred_tcb_at_state
+             simp: pred_tcb_at'_def)+
+
+lemma sts_bound_yt_tcb_at'[wp]:
+  "setThreadState st t' \<lbrace>bound_yt_tcb_at' P t\<rbrace>"
+  apply (clarsimp simp: setThreadState_def)
+  by (cases "t = t'";
+      wpsimp wp: threadSet_pred_tcb_at_state
+           simp: pred_tcb_at'_def)
+
+lemma sbn_st_tcb'[wp]:
+  "setBoundNotification ntfn t' \<lbrace>st_tcb_at' P t\<rbrace>"
   apply (cases "t = t'",
          simp_all add: setBoundNotification_def
                   split del: if_split)
    apply ((wp threadSet_pred_tcb_at_state | simp)+)[1]
-  apply (wp threadSet_obj_at'_really_strongest
-              | simp add: pred_tcb_at'_def)+
+  apply (wp threadSet_obj_at'_really_strongest | simp add: pred_tcb_at'_def)+
   done
 
-crunches rescheduleRequired, tcbSchedDequeue, setThreadState, setBoundNotification
-  for typ_at'[wp]: "\<lambda>s. P (typ_at' T p s)"
+context begin interpretation Arch .
 
-lemmas setThreadState_typ_ats[wp] = typ_at_lifts [OF setThreadState_typ_at']
-lemmas setBoundNotification_typ_ats[wp] = typ_at_lifts [OF setBoundNotification_typ_at']
+crunches scheduleTCB
+  for cte_wp_at'[wp]: "\<lambda>s. Q (cte_wp_at' P p s)"
+  (wp: hoare_when_weak_wp crunch_wps)
+
+lemma sts_ctes_wp_at[wp]:
+  "setThreadState st p \<lbrace>\<lambda>s. P (cte_wp_at' Q p' s)\<rbrace>"
+  apply (clarsimp simp: setThreadState_def)
+  by (wpsimp wp: threadSet_cte_wp_at')
 
 crunches setThreadState, setBoundNotification
   for aligned'[wp]: pspace_aligned'
   and distinct'[wp]: pspace_distinct'
-  and cte_wp_at'[wp]: "cte_wp_at' P p"
-  (wp: hoare_when_weak_wp)
+  and cte_wp_at'[wp]: "\<lambda>s. Q (cte_wp_at' P p s)"
+  (wp: hoare_when_weak_wp crunch_wps)
 
 crunch refs_of'[wp]: rescheduleRequired "\<lambda>s. P (state_refs_of' s)"
-  (wp: threadSet_state_refs_of')
+  (wp: threadSet_state_refs_of' crunch_wps)
+
+crunches scheduleTCB
+  for state_refs_of'[wp]: "\<lambda>s. P (state_refs_of' s)"
+
+abbreviation tcb_non_st_state_refs_of' ::
+  "kernel_state \<Rightarrow> obj_ref \<Rightarrow> (obj_ref \<times> reftype) set"
+  where
+  "tcb_non_st_state_refs_of' s t \<equiv>
+    {r \<in> state_refs_of' s t. snd r = TCBBound \<or> snd r = TCBSchedContext \<or> snd r = TCBYieldTo}"
+
+lemma state_refs_of'_helper2[simp]:
+  "tcb_non_st_state_refs_of' s t
+   = {r \<in> state_refs_of' s t. snd r = TCBBound}
+     \<union> {r \<in> state_refs_of' s t. snd r = TCBSchedContext}
+     \<union> {r \<in> state_refs_of' s t. snd r = TCBYieldTo}"
+  by fastforce
 
 lemma setThreadState_state_refs_of'[wp]:
   "\<lbrace>\<lambda>s. P ((state_refs_of' s) (t := tcb_st_refs_of' st
-                                 \<union> {r \<in> state_refs_of' s t. snd r = TCBBound}))\<rbrace>
-     setThreadState st t
+                                    \<union> tcb_non_st_state_refs_of' s t))\<rbrace>
+   setThreadState st t
    \<lbrace>\<lambda>rv s. P (state_refs_of' s)\<rbrace>"
-  by (simp add: setThreadState_def fun_upd_def
-        | wp threadSet_state_refs_of')+
+  apply (clarsimp simp: setThreadState_def)
+  apply (wpsimp wp: threadSet_state_refs_of')
+      apply simp
+     apply force+
+  by (metis Un_assoc)
 
 lemma setBoundNotification_state_refs_of'[wp]:
-  "\<lbrace>\<lambda>s. P ((state_refs_of' s) (t := tcb_bound_refs' ntfn
-                                 \<union> {r \<in> state_refs_of' s t. snd r \<noteq> TCBBound}))\<rbrace>
-     setBoundNotification ntfn t
+  "\<lbrace>\<lambda>s. P ((state_refs_of' s) (t := (case ntfn of None \<Rightarrow> {} | Some new \<Rightarrow> {(new, TCBBound)})
+                                    \<union> {r \<in> state_refs_of' s t. snd r \<noteq> TCBBound}))\<rbrace>
+   setBoundNotification ntfn t
    \<lbrace>\<lambda>rv s. P (state_refs_of' s)\<rbrace>"
-  by (simp add: setBoundNotification_def Un_commute fun_upd_def
-        | wp threadSet_state_refs_of' )+
+  apply (clarsimp simp: setBoundNotification_def)
+  apply (wpsimp wp: threadSet_state_refs_of'
+                     [where f'=id and h'=id and i'=id and F="tcbBoundNotification_update (\<lambda>_. ntfn)"]
+              simp: get_refs_def)
+     apply simp
+    apply simp
+   apply simp
+  apply (prop_tac "{r \<in> state_refs_of' s t. snd r \<noteq> TCBBound}
+                    = {r \<in> state_refs_of' s t. snd r \<noteq> TCBBound \<and> snd r \<noteq> TCBSchedContext
+                                               \<and> snd r \<noteq> TCBYieldTo}
+                      \<union> {r \<in> state_refs_of' s t. snd r = TCBSchedContext}
+                      \<union> {r \<in> state_refs_of' s t. snd r = TCBYieldTo}")
+   apply fastforce
+  by (metis id_def Un_ac(1) Un_ac(4))
+
+lemma setBoundNotification_list_refs_of_replies'[wp]:
+  "setBoundNotification ntfn t \<lbrace>\<lambda>s. P (list_refs_of_replies' s)\<rbrace>"
+  unfolding setBoundNotification_def
+  by wpsimp
 
 lemma sts_cur_tcb'[wp]:
   "\<lbrace>cur_tcb'\<rbrace> setThreadState st t \<lbrace>\<lambda>rv. cur_tcb'\<rbrace>"
@@ -4007,31 +5100,33 @@ lemma tcbSchedEnqueue_iflive'[wp]:
   done
 
 lemma rescheduleRequired_iflive'[wp]:
-  "\<lbrace>if_live_then_nonz_cap'
-        and (\<lambda>s. \<forall>t. ksSchedulerAction s = SwitchToThread t
-                \<longrightarrow> st_tcb_at' runnable' t s)\<rbrace>
-      rescheduleRequired
-   \<lbrace>\<lambda>rv. if_live_then_nonz_cap'\<rbrace>"
+  "rescheduleRequired \<lbrace>if_live_then_nonz_cap'\<rbrace>"
   apply (simp add: rescheduleRequired_def)
-  apply (wp | wpc | simp)+
-  apply (clarsimp simp: pred_tcb_at'_def obj_at'_real_def)
-  apply (erule(1) if_live_then_nonz_capD')
-  apply (fastforce simp: projectKOs)
+  apply (wpsimp wp: isSchedulable_wp)
+  apply (erule if_live_then_nonz_capE')
+  apply (fastforce simp: isSchedulable_bool_def pred_map_def
+                         ko_wp_at'_def obj_at'_def projectKO_eq projectKO_tcb)
   done
 
+crunches scheduleTCB
+  for if_live_then_nonz_cap'[wp]: if_live_then_nonz_cap'
+  (wp: crunch_wps isSchedulable_inv hoare_vcg_if_lift2)
+
 lemma sts_iflive'[wp]:
   "\<lbrace>\<lambda>s. if_live_then_nonz_cap' s
       \<and> (st \<noteq> Inactive \<and> \<not> idle' st \<longrightarrow> ex_nonz_cap_to' t s)\<rbrace>
      setThreadState st t
    \<lbrace>\<lambda>rv. if_live_then_nonz_cap'\<rbrace>"
-  apply (simp add: setThreadState_def setQueue_def)
-  apply (rule hoare_pre)
-   apply (wp | simp)+
-      apply (rule_tac Q="\<lambda>rv. if_live_then_nonz_cap'" in hoare_post_imp)
-       apply clarsimp
-      apply (wp threadSet_iflive' | simp)+
-   apply auto
- done
+  apply (simp add: setThreadState_def scheduleTCB_def rescheduleRequired_def
+                   getCurThread_def getSchedulerAction_def)
+  apply (rule_tac B="\<lambda>rv. if_live_then_nonz_cap'" in hoare_seq_ext[rotated])
+   apply (wpsimp wp: threadSet_iflive')
+        apply fastforce+
+  apply (intro hoare_seq_ext[OF _ gets_sp]
+               hoare_seq_ext[OF _ isSchedulable_sp])
+  apply (rule hoare_when_cases; (solves \<open>wpsimp\<close>)?)
+  apply (wpsimp wp: isSchedulable_inv hoare_vcg_if_lift2 hoare_drop_imps)
+  done
 
 lemma sbn_iflive'[wp]:
   "\<lbrace>\<lambda>s. if_live_then_nonz_cap' s
@@ -4077,21 +5188,18 @@ lemma bound_tcb_ex_cap'':
               elim!: ko_wp_at'_weakenE
                      if_live_then_nonz_capE')
 
-crunches setThreadState, setBoundNotification
+crunches setThreadState, setBoundNotification (* FIXME RT: instantiate pspace_only' instead *)
   for arch'[wp]:  "\<lambda>s. P (ksArchState s)"
   and it'[wp]: "\<lambda>s. P (ksIdleThread s)"
-  (wp: getObject_inv_tcb
+  (wp: getObject_tcb_inv crunch_wps
    simp: updateObject_default_def unless_def crunch_simps)
 
 crunch it' [wp]: removeFromBitmap "\<lambda>s. P (ksIdleThread s)"
 
-crunch ctes_of [wp]: setQueue "\<lambda>s. P (ctes_of s)"
 
 lemma sts_ctes_of [wp]:
   "\<lbrace>\<lambda>s. P (ctes_of s)\<rbrace> setThreadState st t \<lbrace>\<lambda>rv s. P (ctes_of s)\<rbrace>"
-  apply (simp add: setThreadState_def)
-  apply (wp threadSet_ctes_ofT | simp add: tcb_cte_cases_def)+
-  done
+  by wpsimp
 
 lemma sbn_ctes_of [wp]:
   "\<lbrace>\<lambda>s. P (ctes_of s)\<rbrace> setBoundNotification ntfn t \<lbrace>\<lambda>rv s. P (ctes_of s)\<rbrace>"
@@ -4102,7 +5210,7 @@ lemma sbn_ctes_of [wp]:
 crunches setThreadState, setBoundNotification
   for ksInterruptState[wp]: "\<lambda>s. P (ksInterruptState s)"
   and gsMaxObjectSize[wp]: "\<lambda>s. P (gsMaxObjectSize s)"
-  (simp: unless_def crunch_simps wp: setObject_ksPSpace_only updateObject_default_inv)
+  (simp: unless_def crunch_simps wp: setObject_ksPSpace_only updateObject_default_inv crunch_wps)
 
 lemmas setThreadState_irq_handlers[wp]
     = valid_irq_handlers_lift'' [OF sts_ctes_of setThreadState_ksInterruptState]
@@ -4121,6 +5229,7 @@ lemma sbn_global_reds' [wp]:
 crunches setThreadState, setBoundNotification
   for irq_states' [wp]: valid_irq_states'
   and pde_mappings' [wp]: valid_pde_mappings'
+  (wp: crunch_wps)
 
 lemma addToBitmap_ksMachine[wp]:
   "\<lbrace>\<lambda>s. P (ksMachineState s)\<rbrace> addToBitmap d p \<lbrace>\<lambda>rv s. P (ksMachineState s)\<rbrace>"
@@ -4660,132 +5788,560 @@ lemma asUser_irq_handlers':
   apply (wpsimp wp: threadSet_irq_handlers' [OF all_tcbI, OF ball_tcb_cte_casesI] select_f_inv)
   done
 
-(* the brave can try to move this up to near setObject_update_TCB_corres' *)
+lemma archTcbUpdate_aux2: "(\<lambda>tcb. tcb\<lparr> tcbArch := f (tcbArch tcb)\<rparr>) = tcbArch_update f"
+  by (rule ext, case_tac tcb, simp)
 
-definition non_exst_same :: "Structures_H.tcb \<Rightarrow> Structures_H.tcb \<Rightarrow> bool"
-where
-  "non_exst_same tcb tcb' \<equiv> \<exists>d p ts. tcb' = tcb\<lparr>tcbDomain := d, tcbPriority := p, tcbTimeSlice := ts\<rparr>"
+(* FIXME: rename. VER-1331 *)
+lemma threadSet_obj_at'_simple_strongest:
+  "\<lbrace>\<lambda>s. tcb_at' t s \<longrightarrow>
+          (t = t' \<longrightarrow> P (obj_at' (\<lambda>tcb. Q (f tcb)) t s)) \<and>
+          (t \<noteq> t' \<longrightarrow> P (obj_at' Q t' s))\<rbrace>
+   threadSet f t
+   \<lbrace>\<lambda>_ s. P (obj_at' (Q :: tcb \<Rightarrow> bool) t' s)\<rbrace>"
+  unfolding threadSet_def
+  apply (wpsimp wp: set_tcb'.setObject_obj_at'_strongest set_tcb'.getObject_wp)
+  apply (case_tac "t = t'"; clarsimp simp: obj_at'_def)
+  done
+
+(* Used as the "side condition template" for the `*_obj_at'_only_st_qd_ft` family of
+   `crunch`-able lemmas. Needs to keep the assumption about `f` separate from the hoare
+   triple so as to not pollute the side conditions that `crunch` will add to the final
+   lemma. *)
+lemma threadSet_obj_at'_only_st_qd_ft:
+  assumes "(\<forall>upd tcb. Q (tcbState_update upd tcb) = Q tcb) \<and>
+           (\<forall>upd tcb. Q (tcbQueued_update upd tcb) = Q tcb) \<and>
+           (\<forall>upd tcb. Q (tcbFault_update upd tcb) = Q tcb) \<longrightarrow>
+             (\<forall>tcb. Q (f tcb) = Q tcb)"
+  shows
+  "\<lbrace>\<lambda>s. P (obj_at' Q t' s) \<and>
+        (\<forall>upd tcb. Q (tcbState_update upd tcb) = Q tcb) \<and>
+        (\<forall>upd tcb. Q (tcbQueued_update upd tcb) = Q tcb) \<and>
+        (\<forall>upd tcb. Q (tcbFault_update upd tcb) = Q tcb)\<rbrace>
+   threadSet f t
+   \<lbrace>\<lambda>_ s. P (obj_at' Q t' s)\<rbrace>"
+  apply (wpsimp wp: threadSet_obj_at'_simple_strongest simp: assms)
+  done
 
-fun non_exst_same' :: "Structures_H.kernel_object \<Rightarrow> Structures_H.kernel_object \<Rightarrow> bool"
-where
-  "non_exst_same' (KOTCB tcb) (KOTCB tcb') = non_exst_same tcb tcb'" |
-  "non_exst_same' _ _ = True"
-
-lemma non_exst_same_prio_upd[simp]:
-  "non_exst_same tcb (tcbPriority_update f tcb)"
-  by (cases tcb, simp add: non_exst_same_def)
-
-lemma non_exst_same_timeSlice_upd[simp]:
-  "non_exst_same tcb (tcbTimeSlice_update f tcb)"
-  by (cases tcb, simp add: non_exst_same_def)
-
-lemma non_exst_same_domain_upd[simp]:
-  "non_exst_same tcb (tcbDomain_update f tcb)"
-  by (cases tcb, simp add: non_exst_same_def)
-
-lemma set_eobject_corres':
-  assumes e: "etcb_relation etcb tcb'"
-  assumes z: "\<And>s. obj_at' P ptr s
-               \<Longrightarrow> map_to_ctes ((ksPSpace s) (ptr \<mapsto> KOTCB tcb')) = map_to_ctes (ksPSpace s)"
-  shows "corres dc (tcb_at ptr and is_etcb_at ptr)
-            (obj_at' (\<lambda>ko. non_exst_same ko tcb') ptr
-            and obj_at' P ptr)
-            (set_eobject ptr etcb) (setObject ptr tcb')"
-  apply (rule corres_no_failI)
-   apply (rule no_fail_pre)
-    apply wp
-   apply (clarsimp simp: obj_at'_def)
-  apply (unfold set_eobject_def setObject_def)
-  apply (clarsimp simp: in_monad split_def bind_def gets_def get_def Bex_def
-                        put_def return_def modify_def get_object_def projectKOs
-                        updateObject_default_def in_magnitude_check objBits_simps')
-  apply (clarsimp simp add: state_relation_def z)
-  apply (clarsimp simp add: obj_at_def is_etcb_at_def)
-  apply (simp only: pspace_relation_def dom_fun_upd2 simp_thms)
-  apply (elim conjE)
-  apply (frule bspec, erule domI)
-  apply (rule conjI)
-   apply (rule ballI, drule(1) bspec)
-   apply (drule domD)
-   apply (clarsimp simp: is_other_obj_relation_type)
-   apply (drule(1) bspec)
-   apply (clarsimp simp: non_exst_same_def)
-   apply (case_tac bb; simp)
-     apply (clarsimp simp: obj_at'_def other_obj_relation_def cte_relation_def tcb_relation_def projectKOs split: if_split_asm)+
-   apply (clarsimp simp: aobj_relation_cuts_def split: ARM_A.arch_kernel_obj.splits)
-   apply (rename_tac arch_kernel_obj obj d p ts)
-   apply (case_tac arch_kernel_obj; simp)
-     apply (clarsimp simp: pte_relation_def pde_relation_def is_tcb_def
-                    split: if_split_asm)+
-  apply (simp only: ekheap_relation_def dom_fun_upd2 simp_thms)
-  apply (frule bspec, erule domI)
-  apply (rule ballI, drule(1) bspec)
-  apply (drule domD)
+crunches scheduleTCB
+  for obj_at'_only_st_qd_ft: "\<lambda>s. P (obj_at' (Q :: tcb \<Rightarrow> bool) t s)"
+  (simp: crunch_simps wp: crunch_wps)
+
+(* FIXME: Proved outside of `crunch` because without the `[where P=P]` constraint, the
+   postcondition unifies with the precondition in a wonderfully exponential way. VER-1337 *)
+lemma setThreadState_obj_at'_only_st_qd_ft:
+  "\<lbrace>\<lambda>s. P (obj_at' Q t' s) \<and>
+        (\<forall>upd tcb. Q (tcbState_update upd tcb) = Q tcb) \<and>
+        (\<forall>upd tcb. Q (tcbQueued_update upd tcb) = Q tcb) \<and>
+        (\<forall>upd tcb. Q (tcbFault_update upd tcb) = Q tcb)\<rbrace>
+   setThreadState st t
+   \<lbrace>\<lambda>_ s. P (obj_at' Q t' s)\<rbrace>"
+  unfolding setThreadState_def
+  apply (wpsimp wp: scheduleTCB_obj_at'_only_st_qd_ft threadSet_obj_at'_only_st_qd_ft[where P=P])
+  done
+
+(* FIXME RT: move to ...? *)
+crunches addToBitmap, setQueue
+  for ko_wp_at'[wp]: "\<lambda>s. P (ko_wp_at' Q p s)"
+
+lemma tcbSchedEnqueue_tcb_obj_at'_no_change:
+  assumes [simp]: "\<And>tcb. Q (tcbQueued_update (\<lambda>_. True) tcb) = Q tcb"
+  shows "tcbSchedEnqueue t \<lbrace>\<lambda>s. P (obj_at' Q t' s)\<rbrace>"
+  unfolding tcbSchedEnqueue_def
+  apply (wpsimp wp: threadSet_obj_at'_simple_strongest hoare_vcg_imp_lift threadGet_wp)
   apply (clarsimp simp: obj_at'_def)
-  apply (clarsimp simp: projectKOs)
-  apply (insert e)
-  apply (clarsimp simp: other_obj_relation_def etcb_relation_def is_other_obj_relation_type split: Structures_A.kernel_object.splits Structures_H.kernel_object.splits ARM_A.arch_kernel_obj.splits)
   done
 
-lemma set_eobject_corres:
-  assumes tcbs: "non_exst_same tcb' tcbu'"
-  assumes e: "etcb_relation etcb tcb' \<Longrightarrow> etcb_relation etcbu tcbu'"
-  assumes tables': "\<forall>(getF, v) \<in> ran tcb_cte_cases. getF tcbu' = getF tcb'"
-  assumes r: "r () ()"
-  shows "corres r (tcb_at add and (\<lambda>s. ekheap s add = Some etcb))
-                  (ko_at' tcb' add)
-                  (set_eobject add etcbu) (setObject add tcbu')"
-  apply (rule_tac F="non_exst_same tcb' tcbu' \<and> etcb_relation etcbu tcbu'" in corres_req)
-   apply (clarsimp simp: state_relation_def obj_at_def obj_at'_def)
-   apply (frule(1) pspace_relation_absD)
-   apply (clarsimp simp: projectKOs other_obj_relation_def ekheap_relation_def e tcbs)
-   apply (drule bspec, erule domI)
-   apply (clarsimp simp: e)
-  apply (erule conjE)
-  apply (rule corres_guard_imp)
-    apply (rule corres_rel_imp)
-     apply (rule set_eobject_corres'[where P="(=) tcb'"])
-      apply simp
-     defer
-    apply (simp add: r)
-   apply (fastforce simp: is_etcb_at_def elim!: obj_at_weakenE)
-   apply (subst(asm) eq_commute)
-   apply (clarsimp simp: obj_at'_def)
-  apply (clarsimp simp: projectKOs obj_at'_def objBits_simps)
-  apply (subst map_to_ctes_upd_tcb, assumption+)
-   apply (simp add: ps_clear_def3 field_simps objBits_defs mask_def)
-  apply (subst if_not_P)
-   apply (fastforce dest: bspec [OF tables', OF ranI])
-  apply simp
+lemma setThreadState_tcb_obj_at'_no_change:
+  assumes [simp]: "\<And>tcb. Q (tcbState_update (\<lambda>_. st) tcb) = Q tcb"
+                  "\<And>tcb. Q (tcbQueued_update (\<lambda>_. True) tcb) = Q tcb"
+  shows "setThreadState st t \<lbrace>\<lambda>s. P (obj_at' Q t' s)\<rbrace>"
+  unfolding setThreadState_def scheduleTCB_def rescheduleRequired_def
+  apply (wpsimp wp: tcbSchedEnqueue_tcb_obj_at'_no_change hoare_vcg_if_lift2 isSchedulable_inv
+                    hoare_vcg_imp_lift threadSet_obj_at'_simple_strongest
+                    hoare_pre_cont[where a="isSchedulable x" and P="\<lambda>rv _. rv" for x]
+                    hoare_pre_cont[where a="isSchedulable x" and P="\<lambda>rv _. \<not>rv" for x])
+  done
+
+lemma setThreadState_oa:
+  "setThreadState st t
+   \<lbrace>\<lambda>s. P (obj_at' (\<lambda>tcb. Q (tcbCTable tcb) (tcbVTable tcb) (tcbIPCBufferFrame tcb)
+                            (tcbFaultHandler tcb) (tcbTimeoutHandler tcb) (tcbDomain tcb)
+                            (tcbMCP tcb) (tcbPriority tcb) (tcbQueued tcb) (tcbInReleaseQueue tcb)
+                            (tcbFault tcb))
+                   t' s) \<rbrace>"
+  unfolding setThreadState_def scheduleTCB_def rescheduleRequired_def tcbSchedEnqueue_def
+  apply (wpsimp wp: threadSet_obj_at'_simple_strongest hoare_vcg_imp_lift hoare_vcg_if_lift2
+                    threadGet_obj_at'_field isSchedulable_inv
+                    hoare_pre_cont[where a="isSchedulable x" and P="\<lambda>rv _. rv" for x]
+                    hoare_pre_cont[where a="isSchedulable x" and P="\<lambda>rv _. \<not>rv" for x])
+  done
+
+lemma getThreadState_only_rv_wp[wp]:
+  "\<lbrace>\<lambda>s. tcb_at' t s \<longrightarrow> st_tcb_at' P t s\<rbrace>
+   getThreadState t
+   \<lbrace>\<lambda>rv _. P rv\<rbrace>"
+  apply (wpsimp wp: gts_wp')
+  apply (clarsimp simp: pred_tcb_at'_def obj_at'_def)
   done
 
-lemma ethread_set_corresT:
-  assumes x: "\<And>tcb'. non_exst_same tcb' (f' tcb')"
-  assumes z: "\<forall>tcb. \<forall>(getF, setF) \<in> ran tcb_cte_cases.
-                 getF (f' tcb) = getF tcb"
-  assumes e: "\<And>etcb tcb'. etcb_relation etcb tcb' \<Longrightarrow>
-                         etcb_relation (f etcb) (f' tcb')"
-  shows      "corres dc (tcb_at t and valid_etcbs)
-                        (tcb_at' t)
-                    (ethread_set f t) (threadSet f' t)"
-  apply (simp add: ethread_set_def threadSet_def bind_assoc)
-  apply (rule corres_guard_imp)
-    apply (rule corres_split_deprecated [OF set_eobject_corres corres_get_etcb])
-         apply (rule x)
-        apply (erule e)
-       apply (simp add: z)+
-     apply wp+
-   apply clarsimp
-   apply (simp add: valid_etcbs_def tcb_at_st_tcb_at[symmetric])
-   apply (force simp: tcb_at_def get_etcb_def obj_at_def)
-  apply simp
+lemma getThreadState_only_state_wp[wp]:
+  "\<lbrace>\<lambda>s. tcb_at' t s \<longrightarrow> P s\<rbrace>
+   getThreadState t
+   \<lbrace>\<lambda>_. P\<rbrace>"
+  apply (wpsimp wp: gts_wp')
+  apply (clarsimp simp: pred_tcb_at'_def obj_at'_def)
   done
 
-lemmas ethread_set_corres =
-    ethread_set_corresT [OF _ all_tcbI, OF _ ball_tcb_cte_casesI]
+(* FIXME: replace tcbSchedEnqueue_not_st. VER-1333 *)
+lemma tcbSchedEnqueue_obj_at':
+  "\<lbrace>\<lambda>s. tcb_at' t s \<longrightarrow>
+          (t = t' \<longrightarrow> P (obj_at' (\<lambda>tcb. Q (tcb\<lparr>tcbQueued := True\<rparr>)) t' s)) \<and>
+          (t \<noteq> t' \<longrightarrow> P (obj_at' Q t' s))\<rbrace>
+   tcbSchedEnqueue t
+   \<lbrace>\<lambda>_ s. P (obj_at' Q t' s)\<rbrace>"
+  unfolding tcbSchedEnqueue_def
+  apply (wpsimp wp: threadSet_obj_at'_simple_strongest hoare_vcg_imp_lift hoare_vcg_if_lift2
+                    threadGet_obj_at'_field)
+  apply (case_tac "t = t'"; clarsimp)
+  apply normalise_obj_at'
+  apply (case_tac "tcbQueued ko"; clarsimp)
+  apply (prop_tac "tcbQueued_update (\<lambda>_. True) ko = ko")
+   apply (case_tac ko; clarsimp)
+  apply simp
+  done
 
-lemma archTcbUpdate_aux2: "(\<lambda>tcb. tcb\<lparr> tcbArch := f (tcbArch tcb)\<rparr>) = tcbArch_update f"
-  by (rule ext, case_tac tcb, simp)
+lemma getCurSc_corres:
+  "corres (=) \<top> \<top> (gets cur_sc) (getCurSc)"
+  unfolding getCurSc_def
+  apply (rule corres_gets_trivial)
+  by (clarsimp simp: state_relation_def)
+
+crunches getScTime, scActive
+  for inv[wp]: P
+  (wp: crunch_wps)
+
+lemma threadSet_empty_tcbSchedContext_valid_tcbs'[wp]:
+  "threadSet (tcbSchedContext_update Map.empty) t \<lbrace>valid_tcbs'\<rbrace>"
+  by (wp threadSet_valid_tcbs') (simp add: valid_tcb'_def valid_tcbs'_def tcb_cte_cases_def)
+
+lemma threadSet_vrq_wp:
+  "\<lbrace>valid_release_queue and
+    (\<lambda>s. tptr \<in> set (ksReleaseQueue s) \<longrightarrow> obj_at' (\<lambda>obj. tcbInReleaseQueue (f obj)) tptr s)\<rbrace>
+   threadSet f tptr
+   \<lbrace>\<lambda>_. valid_release_queue\<rbrace>"
+  apply (clarsimp simp: valid_release_queue_def)
+  apply (wpsimp wp: hoare_vcg_imp_lift' hoare_vcg_all_lift)
+  by (case_tac "x=tptr"; simp)
+
+lemma threadSet_vrq_inv:
+  "\<lbrace>valid_release_queue and
+    (\<lambda>s. (\<forall>obj. tcbInReleaseQueue (f obj) = tcbInReleaseQueue obj))\<rbrace>
+   threadSet f tptr
+   \<lbrace>\<lambda>_. valid_release_queue\<rbrace>"
+  apply (clarsimp simp: valid_release_queue_def)
+  by (wpsimp wp: hoare_vcg_imp_lift' hoare_vcg_all_lift)
+
+lemma threadSet_vrq'_inv:
+  "\<lbrace>valid_release_queue' and
+    (\<lambda>s. (\<forall>obj. tcbInReleaseQueue (f obj) = tcbInReleaseQueue obj))\<rbrace>
+   threadSet f tptr
+   \<lbrace>\<lambda>_. valid_release_queue'\<rbrace>"
+  apply (clarsimp simp: valid_release_queue'_def)
+  by (wpsimp wp: threadSet_obj_at'_simple_strongest hoare_vcg_imp_lift' hoare_vcg_all_lift)
+
+lemma threadSet_enqueue_vrq:
+  "\<lbrace>(\<lambda>s. \<forall>a. a \<in> set (ksReleaseQueue s) \<longrightarrow> a\<noteq>t \<longrightarrow> obj_at' tcbInReleaseQueue a s)
+    and tcb_at' t\<rbrace>
+   threadSet (tcbInReleaseQueue_update (\<lambda>_. True)) t
+   \<lbrace>\<lambda>_. valid_release_queue\<rbrace>"
+  apply (clarsimp simp: valid_release_queue_def)
+  apply (wpsimp wp: hoare_vcg_imp_lift' hoare_vcg_all_lift)
+  by (case_tac "x=t"; simp)
+
+lemma threadSet_enqueue_vrq':
+  "\<lbrace>(\<lambda>s. \<forall>a. obj_at' tcbInReleaseQueue a s \<longrightarrow> a\<noteq>t \<longrightarrow> a \<in> set (ksReleaseQueue s))
+    and tcb_at' t
+    and (\<lambda>s. t \<in> set (ksReleaseQueue s))\<rbrace>
+   threadSet (tcbInReleaseQueue_update (\<lambda>_. True)) t
+   \<lbrace>\<lambda>_. valid_release_queue'\<rbrace>"
+  apply (clarsimp simp: valid_release_queue'_def)
+  apply (wpsimp wp: hoare_vcg_imp_lift hoare_vcg_all_lift threadSet_obj_at'_simple_strongest)
+  by (case_tac "x=t"; fastforce)
+
+(* FIXME RT: remove, or move to AInvs
+   (these three thread_set lemmas)       *)
+lemma thread_set_valid_tcbs[wp]:
+  "\<lbrace>valid_tcbs and
+    (\<lambda>s. \<forall>tcb. valid_tcb tptr tcb s \<longrightarrow> valid_tcb tptr (f tcb) s)\<rbrace>
+   thread_set f tptr
+   \<lbrace>\<lambda>_. valid_tcbs\<rbrace>"
+  unfolding valid_tcbs_def
+  apply (rule_tac E="tcb_at tptr" in hoare_strengthen_pre_via_assert_backward)
+   apply (wpsimp wp: thread_set_wp simp: tcb_at_def)
+  apply (wpsimp wp: hoare_vcg_all_lift hoare_vcg_imp_lift' simp: obj_at_def is_tcb get_tcb_def)
+  done
+
+lemma thread_set_empty_tcb_sched_context_valid_tcbs[wp]:
+  "thread_set (tcb_sched_context_update Map.empty) t \<lbrace>valid_tcbs\<rbrace>"
+  by (wp thread_set_valid_tcbs) (simp add: valid_tcbs_def valid_tcb_def tcb_cap_cases_def)
+
+lemma thread_set_empty_tcb_sched_context_weaker_valid_sched_action[wp]:
+  "thread_set (tcb_sched_context_update Map.empty) tcbPtr \<lbrace>weaker_valid_sched_action\<rbrace>"
+  apply (simp only: thread_set_def)
+  apply (wpsimp wp: set_object_wp)
+  apply (clarsimp simp: weaker_valid_sched_action_def pred_tcb_at_def)
+  apply (auto simp: is_tcb_def get_tcb_def obj_at_def  map_project_def tcbs_of_kh_def opt_map_def
+                    pred_map_def map_join_def tcb_scps_of_tcbs_def sc_refill_cfgs_of_scs_def
+             split: option.splits Structures_A.kernel_object.splits)
+  done
 
 end
+
+lemma setReleaseQueue_ksReleaseQueue[wp]:
+  "\<lbrace>\<lambda>_. P qs\<rbrace> setReleaseQueue qs \<lbrace>\<lambda>_ s. P (ksReleaseQueue s)\<rbrace>"
+  by (wpsimp simp: setReleaseQueue_def)
+
+lemma setReleaseQueue_pred_tcb_at'[wp]:
+ "setReleaseQueue qs \<lbrace>\<lambda>s. P (pred_tcb_at' proj P' t' s)\<rbrace>"
+  by (wpsimp simp: setReleaseQueue_def)
+
+crunches tcbReleaseDequeue
+  for valid_pspace'[wp]: valid_pspace'
+  and state_refs_of'[wp]: "\<lambda>s. P (state_refs_of' s)"
+  and list_refs_of_replies'[wp]: "\<lambda>s. P (list_refs_of_replies' s)"
+  and valid_global_refs'[wp]: valid_global_refs'
+  and valid_arch_state'[wp]: valid_arch_state'
+  and irq_node'[wp]: "\<lambda>s. P (irq_node' s)"
+  and typ_at'[wp]: "\<lambda>s. P (typ_at' T p s)"
+  and valid_irq_states'[wp]: valid_irq_states'
+  and ksInterruptState[wp]: "\<lambda>s. P (ksInterruptState s)"
+  and pspace_domain_valid[wp]: pspace_domain_valid
+  and ksCurDomain[wp]: "\<lambda>s. P (ksCurDomain s)"
+  and ksDomSchedule[wp]: "\<lambda>s. P (ksDomSchedule s)"
+  and ksDomScheduleIdx[wp]: "\<lambda>s. P (ksDomScheduleIdx s)"
+  and gsUntypedZeroRanges[wp]: "\<lambda>s. P (gsUntypedZeroRanges s)"
+  and valid_machine_state'[wp]: valid_machine_state'
+  (simp: crunch_simps wp: crunch_wps)
+
+crunches tcbReleaseDequeue
+  for cur_tcb'[wp]: cur_tcb'
+  (simp: crunch_simps cur_tcb'_def wp: crunch_wps threadSet_cur ignore: threadSet)
+
+crunches tcbReleaseRemove
+  for pspace_aligned'[wp]: pspace_aligned'
+  and pspace_distinct'[wp]: pspace_distinct'
+  and pspace_bounded'[wp]: pspace_bounded'
+  and no_0_obj'[wp]: no_0_obj'
+  and ksSchedulerAction[wp]: "\<lambda>s. P (ksSchedulerAction s)"
+  and list_refs_of_replies[wp]: "\<lambda>s. sym_refs (list_refs_of_replies' s)"
+  and state_refs_of'[wp]: "\<lambda>s. sym_refs (state_refs_of' s)"
+  and valid_global_refs'[wp]: valid_global_refs'
+  and valid_arch_state'[wp]: valid_arch_state'
+  and irq_node[wp]: "\<lambda>s. P (irq_node' s)"
+  and typ_at[wp]: "\<lambda>s. P (typ_at' T p s)"
+  and sc_at'_n[wp]: "\<lambda>s. P (sc_at'_n n p s)"
+  and interrupt_state[wp]: "\<lambda>s. P (ksInterruptState s)"
+  and valid_irq_state'[wp]: valid_irq_states'
+  and pspace_domain_valid[wp]: pspace_domain_valid
+  and ksCurDomain[wp]: "\<lambda>s. P (ksCurDomain s)"
+  and ksDomSchedule[wp]: "\<lambda>s. P (ksDomSchedule s)"
+  and ksDomScheduleIdx[wp]: "\<lambda>s. P (ksDomScheduleIdx s)"
+  and gsUntypedZeroRanges[wp]: "\<lambda>s. P (gsUntypedZeroRanges s)"
+  and ctes_of[wp]: "\<lambda>s. P (ctes_of s)"
+  and ksCurThread[wp]: "\<lambda>s. P (ksCurThread s)"
+  and ksMachineState[wp]: "\<lambda>s. P (ksMachineState s)"
+  and valid_pde_mappings'[wp]: valid_pde_mappings'
+  and reply_projs[wp]: "\<lambda>s. P (replyNexts_of s) (replyPrevs_of s) (replyTCBs_of s) (replySCs_of s)"
+  (wp: crunch_wps simp: crunch_simps tcb_cte_cases_def)
+
+global_interpretation tcbReleaseRemove: typ_at_all_props' "tcbReleaseRemove tptr"
+  by typ_at_props'
+
+lemma tcbInReleaseQueue_update_tcb_cte_cases:
+  "(a, b) \<in> ran tcb_cte_cases \<Longrightarrow> a (tcbInReleaseQueue_update f tcb) = a tcb"
+  unfolding tcb_cte_cases_def
+  by (case_tac tcb; fastforce simp: tcbInReleaseQueue_update_def)
+
+lemma tcbInReleaseQueue_update_ctes_of[wp]:
+  "threadSet (tcbInReleaseQueue_update f) x \<lbrace>\<lambda>s. P (ctes_of s)\<rbrace>"
+  by (wpsimp wp: threadSet_ctes_ofT simp: tcbInReleaseQueue_update_tcb_cte_cases)
+
+crunches tcbReleaseDequeue
+  for ctes_of[wp]: "\<lambda>s. P (ctes_of s)"
+  and valid_idle'[wp]: valid_idle'
+  and valid_irq_handlers'[wp]: valid_irq_handlers'
+  and valid_pde_mappings'[wp]: valid_pde_mappings'
+  and ct_idle_or_in_cur_domain'[wp]: ct_idle_or_in_cur_domain'
+  and if_unsafe_then_cap'[wp]: if_unsafe_then_cap'
+  (ignore: threadSet
+     simp: crunch_simps tcbInReleaseQueue_update_tcb_cte_cases
+       wp: crunch_wps threadSet_idle' threadSet_irq_handlers' threadSet_ct_idle_or_in_cur_domain'
+           threadSet_ifunsafe'T)
+
+lemma tcbReleaseDequeue_valid_objs'[wp]:
+  "tcbReleaseDequeue \<lbrace>valid_objs'\<rbrace>"
+  unfolding tcbReleaseDequeue_def
+  by (wpsimp simp: setReprogramTimer_def setReleaseQueue_def wp: threadSet_valid_objs')
+
+lemma tcbReleaseDequeue_sch_act_wf[wp]:
+  "tcbReleaseDequeue \<lbrace>\<lambda>s. sch_act_wf (ksSchedulerAction s) s\<rbrace>"
+  unfolding tcbReleaseDequeue_def
+  by (wpsimp simp: setReprogramTimer_def setReleaseQueue_def wp: threadSet_sch_act)
+
+lemma tcbReleaseDequeue_if_live_then_nonz_cap'[wp]:
+  "tcbReleaseDequeue \<lbrace>if_live_then_nonz_cap'\<rbrace>"
+  unfolding tcbReleaseDequeue_def
+  apply (wpsimp simp: setReprogramTimer_def setReleaseQueue_def tcbInReleaseQueue_update_tcb_cte_cases
+                  wp: threadSet_iflive'T)
+  by auto
+
+lemma tcbReleaseDequeue_ct_not_inQ[wp]:
+  "tcbReleaseDequeue \<lbrace>ct_not_inQ\<rbrace>"
+  unfolding tcbReleaseDequeue_def
+  by (wpsimp simp: setReprogramTimer_def setReleaseQueue_def wp: threadSet_not_inQ)
+
+lemma tcbReleaseDequeue_valid_queues[wp]:
+  "tcbReleaseDequeue \<lbrace>valid_queues\<rbrace>"
+  unfolding tcbReleaseDequeue_def
+  apply (wpsimp simp: setReprogramTimer_def setReleaseQueue_def wp: threadSet_valid_queues)
+  by (auto simp: valid_queues_def valid_queues_no_bitmap_def valid_bitmapQ_def bitmapQ_def
+                 bitmapQ_no_L2_orphans_def bitmapQ_no_L1_orphans_def inQ_def)
+
+lemma tcbReleaseDequeue_valid_queues'[wp]:
+  "tcbReleaseDequeue \<lbrace>valid_queues'\<rbrace>"
+  unfolding tcbReleaseDequeue_def
+  apply (wpsimp simp: setReprogramTimer_def setReleaseQueue_def wp: threadSet_valid_queues')
+  by (auto simp: valid_queues'_def valid_queues_no_bitmap_def valid_bitmapQ_def bitmapQ_def
+                 bitmapQ_no_L2_orphans_def bitmapQ_no_L1_orphans_def inQ_def)
+
+lemma tcbReleaseDequeue_valid_release_queue[wp]:
+  "\<lbrace>valid_release_queue and (\<lambda>s. distinct (ksReleaseQueue s))\<rbrace>
+   tcbReleaseDequeue
+   \<lbrace>\<lambda>_. valid_release_queue\<rbrace>"
+  unfolding tcbReleaseDequeue_def
+  apply (wpsimp simp: setReprogramTimer_def setReleaseQueue_def wp: threadSet_valid_release_queue)
+  apply (clarsimp simp: valid_release_queue_def)
+  by (case_tac "ksReleaseQueue s"; simp)
+
+lemma tcbReleaseDequeue_valid_release_queue'[wp]:
+  "\<lbrace>valid_release_queue' and (\<lambda>s. ksReleaseQueue s \<noteq> [])\<rbrace>
+   tcbReleaseDequeue
+   \<lbrace>\<lambda>_. valid_release_queue'\<rbrace>"
+  unfolding tcbReleaseDequeue_def
+  apply (wpsimp simp: setReprogramTimer_def setReleaseQueue_def wp: threadSet_valid_release_queue')
+  apply (clarsimp simp: valid_release_queue'_def split: list.splits)
+  by (metis list.exhaust_sel set_ConsD)
+
+lemma tcbReleaseDequeue_invs'[wp]:
+  "\<lbrace>invs'
+    and (\<lambda>s. ksReleaseQueue s \<noteq> [])
+    and distinct_release_queue\<rbrace>
+   tcbReleaseDequeue
+   \<lbrace>\<lambda>_. invs'\<rbrace>"
+  by (wpsimp simp: invs'_def valid_dom_schedule'_def
+               wp: valid_irq_node_lift irqs_masked_lift untyped_ranges_zero_lift
+                   cteCaps_of_ctes_of_lift)
+
+lemma tcbReleaseDequeue_ksCurThread[wp]:
+  "\<lbrace>\<lambda>s. P (hd (ksReleaseQueue s)) (ksCurThread s)\<rbrace>
+   tcbReleaseDequeue
+   \<lbrace>\<lambda>r s. P r (ksCurThread s)\<rbrace>"
+  unfolding tcbReleaseDequeue_def
+  by (wpsimp simp: setReprogramTimer_def setReleaseQueue_def)
+
+lemma tcbReleaseDequeue_runnable'[wp]:
+  "\<lbrace>\<lambda>s. st_tcb_at' runnable' (hd (ksReleaseQueue s)) s\<rbrace>
+   tcbReleaseDequeue
+   \<lbrace>\<lambda>r s. st_tcb_at' runnable' r s\<rbrace>"
+  unfolding tcbReleaseDequeue_def
+  by (wpsimp simp: setReprogramTimer_def wp: threadSet_pred_tcb_no_state)
+
+lemma tcbReleaseRemove_if_unsafe_then_cap'[wp]:
+  "tcbReleaseRemove tcbPtr \<lbrace>if_unsafe_then_cap'\<rbrace>"
+  apply (clarsimp simp: tcbReleaseRemove_def getReleaseQueue_def)
+  apply (wpsimp wp: threadSet_ifunsafe')
+  done
+
+lemma tcbReleaseRemove_valid_machine_state'[wp]:
+  "tcbReleaseRemove tcbPtr \<lbrace>valid_machine_state'\<rbrace>"
+  apply (clarsimp simp: tcbReleaseRemove_def getReleaseQueue_def)
+  apply (wpsimp wp: hoare_vcg_all_lift hoare_vcg_disj_lift)
+  done
+
+lemma tcbReleaseRemove_ct_idle_or_in_cur_domain'[wp]:
+  "tcbReleaseRemove tcbPtr \<lbrace>ct_idle_or_in_cur_domain'\<rbrace>"
+  apply (clarsimp simp: tcbReleaseRemove_def getReleaseQueue_def)
+  apply (wpsimp wp: threadSet_ct_idle_or_in_cur_domain' hoare_vcg_imp_lift' hoare_vcg_disj_lift)
+  done
+
+crunches setReprogramTimer
+  for valid_queues[wp]: valid_queues
+  and ksReleaseQueue[wp]: "\<lambda>s. P (ksReleaseQueue s)"
+
+lemma tcbReleaseRemove_valid_queues_no_bitmap:
+  "\<lbrace>valid_queues\<rbrace>
+   tcbReleaseRemove tcbPtr
+   \<lbrace>\<lambda>_. valid_queues_no_bitmap\<rbrace>"
+  apply (clarsimp simp: tcbReleaseRemove_def getReleaseQueue_def setReleaseQueue_def)
+  apply (rule hoare_seq_ext[OF _ gets_sp])
+  apply (rule hoare_seq_ext_skip, wpsimp)
+  apply (wpsimp wp: threadSet_valid_queues_no_bitmap_new)
+  apply (clarsimp simp: valid_queues_no_bitmap_def valid_queues_def)
+  apply (fastforce simp: obj_at'_def inQ_def)
+  done
+
+crunches setReleaseQueue, setReprogramTimer
+  for valid_bitmapQ[wp]: valid_bitmapQ
+  and bitmapQ_no_L2_orphans[wp]: bitmapQ_no_L2_orphans
+  and bitmapQ_no_L1_orphans[wp]: bitmapQ_no_L1_orphans
+  (simp: crunch_simps valid_bitmapQ_def bitmapQ_def bitmapQ_no_L2_orphans_def
+         bitmapQ_no_L1_orphans_def)
+
+crunches tcbReleaseRemove
+  for valid_bitmapQ[wp]: valid_bitmapQ
+  and bitmapQ_no_L2_orphans[wp]: bitmapQ_no_L2_orphans
+  and bitmapQ_no_L1_orphans[wp]: bitmapQ_no_L1_orphans
+
+lemma setReleaseQueue_obj_at'[wp]:
+  "setReleaseQueue Q \<lbrace>\<lambda>s. R (obj_at' P t s)\<rbrace>"
+  unfolding setReleaseQueue_def by wpsimp
+
+crunches setReleaseQueue
+  for ksReadyQueues[wp]: "\<lambda>s. P (ksReadyQueues s)"
+
+lemma setReleaseQueue_valid_queues_no_bitmap[wp]:
+  "setReleaseQueue Q \<lbrace>valid_queues_no_bitmap\<rbrace>"
+  unfolding valid_queues_no_bitmap_def
+  by (wpsimp wp: hoare_vcg_imp_lift' hoare_vcg_all_lift hoare_vcg_ball_lift2)
+
+crunches tcbReleaseRemove
+  for ex_nonz_cap_to'[wp]: "ex_nonz_cap_to' p"
+  (wp: threadSet_cap_to simp: tcb_cte_cases_def)
+
+lemma tcbReleaseRemove_valid_queues:
+  "tcbReleaseRemove tcbPtr \<lbrace>valid_queues\<rbrace>"
+  apply (wpsimp wp: tcbReleaseRemove_valid_queues_no_bitmap tcbReleaseRemove_valid_bitmapQ
+              simp: valid_queues_def)
+  done
+
+crunches setReleaseQueue, setReprogramTimer
+  for valid_queues'[wp]: valid_queues'
+  (simp: valid_queues'_def)
+
+lemma tcbReleaseRemove_valid_queues'[wp]:
+  "tcbReleaseRemove tcbPtr \<lbrace>valid_queues'\<rbrace>"
+  apply (clarsimp simp: tcbReleaseRemove_def getReleaseQueue_def setReleaseQueue_def)
+  apply (rule hoare_seq_ext[OF _ gets_sp])
+  apply (rule hoare_seq_ext_skip, wpsimp)
+  apply (wpsimp wp: threadSet_valid_queues')
+  apply (clarsimp simp: valid_queues'_def inQ_def)
+  done
+
+crunches setReprogramTimer
+  for valid_release_queue[wp]: valid_release_queue
+  and valid_release_queue'[wp]: valid_release_queue'
+
+lemma tcbReleaseRemove_valid_release_queue[wp]:
+  "tcbReleaseRemove tcbPtr \<lbrace>valid_release_queue\<rbrace>"
+  apply (clarsimp simp: tcbReleaseRemove_def getReleaseQueue_def setReleaseQueue_def)
+  apply (rule hoare_seq_ext[OF _ gets_sp])
+  apply (rule hoare_seq_ext_skip, wpsimp)
+  apply (wpsimp wp: threadSet_valid_release_queue)
+  apply (clarsimp simp: valid_release_queue_def)
+  done
+
+lemma tcbReleaseRemove_valid_release_queue'[wp]:
+  "tcbReleaseRemove tcbPtr \<lbrace>valid_release_queue'\<rbrace>"
+  apply (clarsimp simp: tcbReleaseRemove_def getReleaseQueue_def setReleaseQueue_def)
+  apply (rule hoare_seq_ext[OF _ gets_sp])
+  apply (rule hoare_seq_ext_skip, wpsimp)
+  apply (wpsimp wp: threadSet_valid_release_queue')
+  apply (clarsimp simp: valid_release_queue'_def obj_at'_def)
+  done
+
+crunches setReprogramTimer
+  for valid_objs'[wp]: valid_objs'
+  and sch_act_wf[wp]: "\<lambda>s. sch_act_wf (ksSchedulerAction s) s"
+  and if_live_then_nonz_cap'[wp]: if_live_then_nonz_cap'
+  and valid_mdb'[wp]: valid_mdb'
+  and ct_not_inQ[wp]: ct_not_inQ
+  (simp: valid_mdb'_def)
+
+lemma tcbReleaseRemove_valid_objs'[wp]:
+  "tcbReleaseRemove tcbPtr \<lbrace>valid_objs'\<rbrace>"
+  apply (clarsimp simp: tcbReleaseRemove_def getReleaseQueue_def setReleaseQueue_def)
+  apply (rule hoare_seq_ext[OF _ gets_sp])
+  apply (rule hoare_seq_ext_skip, wpsimp)
+  apply (wpsimp wp: threadSet_valid_objs')
+  done
+
+lemma tcbReleaseRemove_valid_mdb'[wp]:
+  "tcbReleaseRemove tcbPtr \<lbrace>valid_mdb'\<rbrace>"
+  apply (clarsimp simp: tcbReleaseRemove_def getReleaseQueue_def setReleaseQueue_def)
+  apply (rule hoare_seq_ext[OF _ gets_sp])
+  apply (rule hoare_seq_ext_skip, wpsimp)
+  apply (rule_tac B="\<lambda>_. valid_mdb'" in hoare_seq_ext[rotated])
+   apply wpsimp
+   apply (clarsimp simp: valid_mdb'_def)
+  apply (wpsimp wp: setObject_tcb_mdb' getObject_tcb_wp simp: threadSet_def)
+  apply (fastforce simp: obj_at'_def projectKOs tcb_cte_cases_def)
+  done
+
+lemma tcbReleaseRemove_sch_act_wf[wp]:
+  "tcbReleaseRemove tcbPtr \<lbrace>\<lambda>s. sch_act_wf (ksSchedulerAction s) s\<rbrace>"
+  apply (clarsimp simp: tcbReleaseRemove_def getReleaseQueue_def setReleaseQueue_def)
+  apply (wpsimp wp: threadSet_sch_act)
+  done
+
+lemma tcbReleaseRemove_if_live_then_nonz_cap'[wp]:
+  "\<lbrace>\<lambda>s. if_live_then_nonz_cap' s\<rbrace>
+   tcbReleaseRemove tptr
+   \<lbrace>\<lambda>_. if_live_then_nonz_cap'\<rbrace>"
+  apply (clarsimp simp: tcbReleaseRemove_def getReleaseQueue_def setReleaseQueue_def)
+  apply (rule hoare_seq_ext[OF _ gets_sp])
+  apply (rule hoare_seq_ext_skip, wpsimp)
+  apply (wpsimp wp: threadSet_iflive' setSchedContext_iflive' threadGet_wp)
+  apply (fastforce simp: obj_at'_def projectKOs)
+  done
+
+lemma tcbReleaseRemove_valid_idle'[wp]:
+  "tcbReleaseRemove tcbPtr \<lbrace>valid_idle'\<rbrace>"
+  apply (clarsimp simp: tcbReleaseRemove_def getReleaseQueue_def setReleaseQueue_def)
+  apply (wpsimp wp: threadSet_idle')
+  done
+
+lemma tcbReleaseRemove_ct_not_inQ[wp]:
+  "tcbReleaseRemove tcbPtr \<lbrace>ct_not_inQ\<rbrace>"
+  apply (clarsimp simp: tcbReleaseRemove_def getReleaseQueue_def setReleaseQueue_def)
+  apply (rule hoare_seq_ext[OF _ gets_sp])
+  apply (rule hoare_seq_ext_skip, wpsimp)
+  apply (wpsimp wp: threadSet_not_inQ)
+  done
+
+lemma tcbReleaseRemove_invs':
+  "tcbReleaseRemove tcbPtr \<lbrace>invs'\<rbrace>"
+  apply (simp add: invs'_def valid_pspace'_def valid_dom_schedule'_def)
+  apply (wpsimp wp: valid_irq_node_lift valid_irq_handlers_lift'' irqs_masked_lift cur_tcb_lift
+                    untyped_ranges_zero_lift tcbReleaseRemove_valid_queues valid_replies'_lift
+              simp: cteCaps_of_def o_def)
+  done
+
+crunches tcbReleaseRemove, tcbSchedDequeue
+  for sch_act_simple[wp]: sch_act_simple
+  and ksIdleThread[wp]: "\<lambda>s. P (ksIdleThread s)"
+  (wp: crunch_wps simp: crunch_simps sch_act_simple_def)
+
+lemma tcbInReleaseQueue_update_st_tcb_at'[wp]:
+  "threadSet (tcbInReleaseQueue_update b) t \<lbrace>\<lambda>s. Q (st_tcb_at' P t' s)\<rbrace>"
+  apply (wpsimp wp: threadSet_wp)
+  apply (cases "t=t'")
+   apply (fastforce simp: obj_at_simps st_tcb_at'_def ps_clear_def)
+  apply (erule back_subst[where P=Q])
+  apply (fastforce simp: obj_at_simps st_tcb_at'_def ps_clear_def)
+  done
+
+crunches tcbReleaseEnqueue
+  for st_tcb_at'[wp]: "\<lambda>s. Q (st_tcb_at' P tptr s)"
+  (wp: mapM_wp_inv ignore: threadSet)
+
 end

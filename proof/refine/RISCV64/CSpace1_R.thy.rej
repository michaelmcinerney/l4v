--- CSpace1_R.thy
+++ CSpace1_R.thy
@@ -11,7 +11,6 @@
 theory CSpace1_R
 imports
   CSpace_I
-  "AInvs.ArchDetSchedSchedule_AI"
 begin
 
 context Arch begin global_naming ARM_A (*FIXME: arch_split*)
@@ -137,7 +136,7 @@ lemma obj_size_relation:
   "\<lbrakk> cap_relation c c'; capClass c' = PhysicalClass \<rbrakk> \<Longrightarrow>
   obj_size c = capUntypedSize c'"
   apply (cases c, simp_all add: objBits_simps' zbits_map_def
-                                cte_level_bits_def
+                                cte_level_bits_def min_sched_context_bits_def
                          split: option.splits sum.splits)
   apply (rename_tac arch_cap)
   apply (case_tac arch_cap,
@@ -145,26 +144,18 @@ lemma obj_size_relation:
                   pageBits_def ptBits_def pteBits_def pdBits_def pdeBits_def)
   done
 
+(* FIXME RT: move up *)
+lemmas bits_of_simps[simp] = bits_of_def[split_simps cap.split]
+
 lemma same_region_as_relation:
-    "\<lbrakk> cap_relation c d; cap_relation c' d' \<rbrakk> \<Longrightarrow>
-  same_region_as c c' = sameRegionAs d d'"
+  "\<lbrakk> cap_relation c d; cap_relation c' d' \<rbrakk> \<Longrightarrow> same_region_as c c' = sameRegionAs d d'"
   apply (cases c)
-            apply clarsimp
-           apply (clarsimp simp: sameRegionAs_def isCap_simps Let_def is_phyiscal_relation)
-           apply (auto simp: obj_ref_of_relation obj_size_relation cong: conj_cong)[1]
-          apply (cases c', auto simp: sameRegionAs_def isCap_simps Let_def)[1]
-         apply (cases c', auto simp: sameRegionAs_def isCap_simps Let_def)[1]
-        apply (cases c', auto simp: sameRegionAs_def isCap_simps Let_def)[1]
-       apply (cases c', auto simp: sameRegionAs_def isCap_simps Let_def bits_of_def)[1]
-      apply (cases c', auto simp: sameRegionAs_def isCap_simps Let_def)[1]
-     apply (cases c', auto simp: sameRegionAs_def isCap_simps Let_def)[1]
-    apply (cases c', auto simp: sameRegionAs_def isCap_simps Let_def)[1]
-   apply (cases c', auto simp: sameRegionAs_def isCap_simps Let_def)[1]
-   apply (cases c', auto simp: sameRegionAs_def isCap_simps Let_def)[1]
-  apply simp
-  apply (cases c')
-  apply (clarsimp simp: same_arch_region_as_relation|
-         clarsimp simp: sameRegionAs_def isCap_simps Let_def)+
+               apply clarsimp
+              apply (clarsimp simp: sameRegionAs_def isCap_simps Let_def is_phyiscal_relation)
+              apply (auto simp: obj_ref_of_relation obj_size_relation cong: conj_cong)[1]
+             apply ((cases c', auto simp: sameRegionAs_def isCap_simps Let_def)+)[11]
+  apply (cases c'; (clarsimp simp: same_arch_region_as_relation|
+                      clarsimp simp: sameRegionAs_def isCap_simps Let_def)+)
   done
 
 lemma can_be_is:
@@ -192,23 +183,20 @@ lemma can_be_is:
   apply (auto simp: Let_def)[1]
   done
 
+lemma no_ofail_cte_wp_at'_readObject[simp]:
+  "no_ofail (cte_wp_at' (P::cte \<Rightarrow> bool) p) (readObject p::cte kernel_r)"
+  by (clarsimp simp: cte_wp_at'_def getObject_def readObject_def obind_def omonad_defs split_def
+                     no_ofail_def gets_the_def gets_def get_def bind_def
+                     return_def assert_opt_def fail_def
+              split: option.splits)
+
+lemma no_fail_getObject [wp]:
+  "no_fail (cte_at' p) (getObject p::cte kernel)"
+  by (clarsimp simp: getCTE_def getObject_def no_ofail_gets_the)
+
 lemma no_fail_getCTE [wp]:
   "no_fail (cte_at' p) (getCTE p)"
-  apply (simp add: getCTE_def getObject_def split_def
-                   loadObject_cte alignCheck_def unless_def
-                   alignError_def is_aligned_mask[symmetric]
-             cong: kernel_object.case_cong)
-  apply (rule no_fail_pre, (wp | wpc)+)
-  apply (clarsimp simp: cte_wp_at'_def getObject_def
-                        loadObject_cte split_def in_monad
-                 dest!: in_singleton
-             split del: if_split)
-  apply (clarsimp simp: in_monad typeError_def objBits_simps
-                        magnitudeCheck_def
-                 split: kernel_object.split_asm if_split_asm option.split_asm
-             split del: if_split)
-       apply simp+
-  done
+  by (wpsimp simp: getCTE_def)
 
 lemma tcb_cases_related:
   "tcb_cap_cases ref = Some (getF, setF, restr) \<Longrightarrow>
@@ -230,7 +218,7 @@ lemma pspace_relation_cte_wp_at:
    apply (simp add: unpleasant_helper)
    apply (drule spec, drule mp, erule domI)
    apply (clarsimp simp: cte_relation_def)
-   apply (drule(2) aligned_distinct_obj_atI'[where 'a=cte])
+   apply (drule(2) aligned'_distinct'_ko_at'I[where 'a=cte], simp)
     apply simp
    apply (drule ko_at_imp_cte_wp_at')
    apply (clarsimp elim!: cte_wp_at_weakenE')
@@ -238,7 +226,7 @@ lemma pspace_relation_cte_wp_at:
   apply (drule(1) pspace_relation_absD)
   apply (clarsimp simp: other_obj_relation_def)
   apply (simp split: kernel_object.split_asm)
-  apply (drule(2) aligned_distinct_obj_atI'[where 'a=tcb])
+  apply (drule(2) aligned'_distinct'_ko_at'I[where 'a=tcb], simp)
    apply simp
   apply (drule tcb_cases_related)
   apply (clarsimp simp: obj_at'_def projectKOs objBits_simps)
@@ -365,8 +353,7 @@ proof (induct rule: resolveAddressBits.induct)
     apply (elim exE conjE)
     apply (simp only: split: if_split_asm)
      apply (clarsimp simp: in_monad locateSlot_conv stateAssert_def)
-     apply (cases cap)
-       apply (simp_all add: isCap_defs)[12]
+     apply (cases cap; simp add: isCap_defs)
      apply (clarsimp simp add: valid_cap'_def objBits_simps' cte_level_bits_def
                         split: option.split_asm)
     apply (simp only: in_bindE_R K_bind_def)
@@ -376,8 +363,7 @@ proof (induct rule: resolveAddressBits.induct)
      apply (simp only: in_bindE_R K_bind_def)
      apply (frule (12) 1 [OF refl], (assumption | rule refl)+)
      apply (clarsimp simp: in_monad locateSlot_conv objBits_simps stateAssert_def)
-     apply (cases cap)
-       apply (simp_all add: isCap_defs)[12]
+     apply (cases cap; simp add: isCap_defs)
      apply (frule in_inv_by_hoareD [OF getSlotCap_inv])
      apply simp
      apply (frule (1) post_by_hoare [OF getSlotCap_valid_cap])
@@ -386,8 +372,7 @@ proof (induct rule: resolveAddressBits.induct)
      apply (drule (1) bspec)
      apply simp
     apply (clarsimp simp: in_monad locateSlot_conv objBits_simps stateAssert_def)
-    apply (cases cap)
-     apply (simp_all add: isCap_defs)[12]
+    apply (cases cap; simp add: isCap_defs)
     apply (frule in_inv_by_hoareD [OF getSlotCap_inv])
     apply (clarsimp simp: valid_cap'_def cte_level_bits_def objBits_defs)
     done
@@ -428,17 +413,15 @@ proof -
   } note x = this
   from assms
   show ?thesis
-  apply (cases c)
-            apply (simp_all add: simps)[5]
-       defer
-       apply (simp_all add: simps)[4]
+  apply (cases c; simp add: simps)
+   defer
    apply (clarsimp simp: simps the_arch_cap_def)
    apply (rename_tac arch_cap)
    apply (case_tac arch_cap)
-        apply (simp_all add: simps arch_update_cap_data_def
+        apply (simp_all add: arch_update_cap_data_def
                              ARM_H.updateCapData_def)[5]
   \<comment> \<open>CNodeCap\<close>
-  apply (simp add: simps word_bits_def the_cnode_cap_def andCapRights_def
+  apply (simp add: word_bits_def the_cnode_cap_def andCapRights_def
                    rightsFromWord_def data_to_rights_def nth_ucast cteRightsBits_def
                    cteGuardBits_def)
   apply (insert x)
@@ -451,6 +434,7 @@ proof -
   done
 qed
 
+end
 
 lemma cte_map_shift:
   assumes bl: "to_bl cref' = zs @ cref"
@@ -605,47 +589,47 @@ proof (induct a arbitrary: c' cref' bits rule: resolve_address_bits'.induct)
         apply (simp add: caps isCap_defs Let_def whenE_bindE_throwError_to_if)
         apply (subst cnode_cap_case_if)
         apply (corressimp search: getSlotCap_corres IH
-                              wp: get_cap_wp getSlotCap_valid no_fail_stateAssert
-                            simp: locateSlot_conv)
+                              wp: get_cap_wp getSlotCap_valid hoare_drop_imps
+                            simp: locateSlot_conv stateAssert_def)
         apply (simp add: drop_postfix_eq)
         apply clarsimp
         apply (prove "is_aligned ptr (cte_level_bits + cbits) \<and> cbits \<le> word_bits - cte_level_bits")
-        apply (erule valid_CNodeCapE; fastforce simp: cte_level_bits_def)
+         apply (erule valid_CNodeCapE; fastforce simp: cte_level_bits_def)
         subgoal premises prems for s s' x
           apply (insert prems)
           apply (rule context_conjI)
-            apply (simp add: guard_mask_shift[OF \<open>to_bl _ = _\<close>, where guard=guard,symmetric])
-            apply (simp add: caps lookup_failure_map_def)
-            apply (rule conjI)
-            apply (clarsimp split: if_splits)
-            apply (intro conjI impI allI;clarsimp?)
-            apply (subst \<open>to_bl _ = _\<close>[symmetric])
-            apply (drule postfix_dropD)
-            apply clarsimp
-            apply (prove "32 + (cbits + length guard) - length cref =
-                         (cbits + length guard) + (32 - length cref)")
-             apply (drule len_drop_lemma, simp, arith)
-            apply simp
-            apply (subst drop_drop [symmetric])
-           subgoal by simp
-              apply (erule (2) valid_CNodeCapE)
-              apply (rule cap_table_at_cte_at[OF _ refl])
-              apply (simp add: obj_at_def is_cap_table_def well_formed_cnode_n_def)
-             apply (frule (2) cte_wp_valid_cap)
+           apply (simp add: guard_mask_shift[OF \<open>to_bl _ = _\<close>, where guard=guard,symmetric])
+          apply (simp add: caps lookup_failure_map_def)
+          apply (rule conjI)
+           apply (clarsimp split: if_splits)
+           apply (intro conjI impI allI;clarsimp?)
+             apply (subst \<open>to_bl _ = _\<close>[symmetric])
+             apply (drule postfix_dropD)
+             apply clarsimp
+             apply (prove "32 + (cbits + length guard) - length cref =
+                          (cbits + length guard) + (32 - length cref)")
+              apply (drule len_drop_lemma, simp, arith)
+             apply simp
+             apply (subst drop_drop [symmetric])
+             subgoal by simp
+            apply (erule (2) valid_CNodeCapE)
+            apply (rule cap_table_at_cte_at[OF _ refl])
+            apply (simp add: obj_at_def is_cap_table_def well_formed_cnode_n_def)
+           apply (frule (2) cte_wp_valid_cap)
            apply (rule context_conjI)
            apply (intro conjI impI allI;clarsimp?)
             apply (erule (2) valid_CNodeCapE)
             apply (erule (3) cte_map_shift')
             apply simp
-              apply (erule (1) cte_map_shift; assumption?)
-              subgoal by simp
-              apply (clarsimp simp: cte_level_bits_def)
-           apply (rule conjI)
-             apply (clarsimp simp: valid_cap_def cap_table_at_gsCNodes isCap_simps)
-             apply (rule and_mask_less_size, simp add: word_bits_def word_size cte_level_bits_def)
-           apply (clarsimp split: if_splits)
-           done
-         done
+           apply (erule (1) cte_map_shift; assumption?)
+           subgoal by simp
+          apply (clarsimp simp: cte_level_bits_def)
+          apply (rule conjI)
+           apply (clarsimp simp: valid_cap_def cap_table_at_gsCNodes isCap_simps)
+          apply (rule and_mask_less_size, simp add: word_bits_def word_size cte_level_bits_def)
+          apply (clarsimp split: if_splits)
+          done
+        done
     }
     ultimately
     show ?thesis by fast
@@ -726,7 +710,7 @@ lemma lookupSlotForThread_corres:
    prefer 2
    apply (rule hoare_vcg_precond_impE)
     apply (rule resolveAddressBits_cte_at')
-   apply (simp add: invs'_def valid_state'_def valid_pspace'_def)
+   apply (simp add: invs'_def valid_pspace'_def)
   apply (simp add: returnOk_def split_def)
   done
 
@@ -763,9 +747,9 @@ lemma lookupCap_corres:
 lemma setObject_cte_obj_at_tcb':
   assumes x: "\<And>tcb f. P (tcbCTable_update f tcb) = P tcb"
              "\<And>tcb f. P (tcbVTable_update f tcb) = P tcb"
-             "\<And>tcb f. P (tcbReply_update f tcb) = P tcb"
-             "\<And>tcb f. P (tcbCaller_update f tcb) = P tcb"
              "\<And>tcb f. P (tcbIPCBufferFrame_update f tcb) = P tcb"
+             "\<And>tcb f. P (tcbFaultHandler_update f tcb) = P tcb"
+             "\<And>tcb f. P (tcbTimeoutHandler_update f tcb) = P tcb"
   shows
   "\<lbrace>\<lambda>s. P' (obj_at' (P :: tcb \<Rightarrow> bool) p s)\<rbrace>
   setObject c (cte::cte)
@@ -782,17 +766,12 @@ lemma setObject_cte_obj_at_tcb':
                         Structures_H.kernel_object.split_asm)
   done
 
-lemma setCTE_typ_at':
-  "\<lbrace>\<lambda>s. P (typ_at' T p s)\<rbrace> setCTE c cte \<lbrace>\<lambda>_ s. P (typ_at' T p s)\<rbrace>"
-  by (clarsimp simp add: setCTE_def) (wp setObject_typ_at')
+crunches setCTE
+  for typ_at'[wp]: "\<lambda>s. P (typ_at' T p s)"
+  and sc_at'_n[wp]: "\<lambda>s. P (sc_at'_n n p s)"
 
-lemmas setObject_typ_at [wp] = setObject_typ_at' [where P=id, simplified]
-
-lemma setCTE_typ_at [wp]:
-  "\<lbrace>typ_at' T p\<rbrace> setCTE c cte \<lbrace>\<lambda>_. typ_at' T p\<rbrace>"
-  by (clarsimp simp add: setCTE_def) wp
-
-lemmas setCTE_typ_ats [wp] = typ_at_lifts [OF setCTE_typ_at']
+global_interpretation setCTE: typ_at_all_props' "setCTE p v"
+  by typ_at_props'
 
 lemma setObject_cte_ksCurDomain[wp]:
   "\<lbrace>\<lambda>s. P (ksCurDomain s)\<rbrace> setObject ptr (cte::cte) \<lbrace>\<lambda>_ s. P (ksCurDomain s)\<rbrace>"
@@ -892,13 +871,7 @@ lemma cap_insert_objs' [wp]:
    cteInsert cap src dest \<lbrace>\<lambda>rv. valid_objs'\<rbrace>"
   including no_pre
   apply (simp add: cteInsert_def updateCap_def setUntypedCapAsFull_def bind_assoc split del: if_split)
-  apply (wp setCTE_valid_objs)
-      apply simp
-      apply wp+
-      apply (clarsimp simp: updateCap_def)
-      apply (wp|simp)+
-    apply (rule hoare_drop_imp)+
-    apply wp+
+  apply (wpsimp wp: setCTE_valid_objs | rule hoare_drop_imp)+
   apply (rule hoare_strengthen_post[OF getCTE_sp])
   apply (clarsimp simp: cte_wp_at_ctes_of isCap_simps
                  dest!: ctes_of_valid_cap'')
@@ -914,11 +887,7 @@ lemma cteInsert_weak_cte_wp_at:
   apply (wp setCTE_weak_cte_wp_at updateMDB_weak_cte_wp_at static_imp_wp | simp)+
    apply (wp getCTE_ctes_wp)+
    apply (clarsimp simp: isCap_simps split:if_split_asm| rule conjI)+
-done
-
-lemma setCTE_valid_cap:
-  "\<lbrace>valid_cap' c\<rbrace> setCTE ptr cte \<lbrace>\<lambda>r. valid_cap' c\<rbrace>"
-  by (rule typ_at_lifts, rule setCTE_typ_at')
+  done
 
 lemma set_is_modify:
   "m p = Some cte \<Longrightarrow>
@@ -960,6 +929,8 @@ abbreviation
 abbreviation
   "revokable' a b \<equiv> global.isCapRevocable b a"
 
+context begin interpretation Arch . (*FIXME: arch_split*)
+
 declare arch_is_cap_revocable_def[simp] ARM_H.isCapRevocable_def[simp]
 
 lemmas revokable_def = is_cap_revocable_def is_cap_revocable_def[split_simps cap.split]
@@ -1239,10 +1210,7 @@ definition
   capBadge cap = capBadge cap' \<and>
   capASID cap = capASID cap' \<and>
   cap_asid_base' cap = cap_asid_base' cap' \<and>
-  cap_vptr' cap = cap_vptr' cap' \<and>
-  \<comment> \<open>check all fields of ReplyCap except capReplyCanGrant\<close>
-  (isReplyCap cap \<longrightarrow> capTCBPtr cap = capTCBPtr cap' \<and>
-                     capReplyMaster cap = capReplyMaster cap')"
+  cap_vptr' cap = cap_vptr' cap'"
 
 lemma capASID_update [simp]:
   "capASID (RetypeDecls_H.updateCapData P x c) = capASID c"
@@ -1297,14 +1265,10 @@ lemma updateCapData_Reply:
   done
 
 lemma weak_derived_updateCapData:
-  "\<lbrakk> (updateCapData P x c) \<noteq> NullCap; weak_derived' c c';
-      capBadge (updateCapData P x c) = capBadge c' \<rbrakk>
+  "\<lbrakk> updateCapData P x c \<noteq> NullCap; weak_derived' c c';
+     capBadge (updateCapData P x c) = capBadge c' \<rbrakk>
   \<Longrightarrow> weak_derived' (updateCapData P x c) c'"
-  apply (clarsimp simp add: weak_derived'_def updateCapData_Master)
-  apply (clarsimp elim: impE dest!: iffD1[OF updateCapData_Reply])
-  apply (clarsimp simp: isCap_simps)
-  apply (clarsimp simp: Let_def isCap_simps updateCapData_def)
-  done
+  by (clarsimp simp add: weak_derived'_def updateCapData_Master)
 
 lemma maskCapRights_Reply[simp]:
   "isReplyCap (maskCapRights r c) = isReplyCap c"
@@ -1699,41 +1663,35 @@ proof -
     done
 qed
 
-definition pspace_relations where
-  "pspace_relations ekh kh kh' \<equiv> pspace_relation kh kh' \<and> ekheap_relation ekh kh'"
-
 lemma set_cap_not_quite_corres_prequel:
   assumes cr:
-  "pspace_relations (ekheap s) (kheap s) (ksPSpace s')"
+  "pspace_relation (kheap s) (ksPSpace s')"
   "(x,t') \<in> fst (setCTE p' c' s')"
   "valid_objs s" "pspace_aligned s" "pspace_distinct s" "cte_at p s"
   "pspace_aligned' s'" "pspace_distinct' s'"
   assumes c: "cap_relation c (cteCap c')"
   assumes p: "p' = cte_map p"
   shows "\<exists>t. ((),t) \<in> fst (set_cap c p s) \<and>
-             pspace_relations (ekheap t) (kheap t) (ksPSpace t')"
+             pspace_relation (kheap t) (ksPSpace t')"
   using cr
   apply (clarsimp simp: setCTE_def setObject_def in_monad split_def)
   apply (drule(1) updateObject_cte_is_tcb_or_cte[OF _ refl, rotated])
   apply (elim disjE exE conjE)
-   apply (clarsimp simp: lookupAround2_char1 pspace_relations_def)
+   apply (clarsimp simp: lookupAround2_char1)
    apply (frule(5) cte_map_pulls_tcb_to_abstract[OF p])
     apply (simp add: domI)
    apply (frule tcb_cases_related2)
    apply (clarsimp simp: set_cap_def2 split_def bind_def get_object_def
                          simpler_gets_def assert_def fail_def return_def
-                         set_object_def get_def put_def)
-   apply (rule conjI)
-    apply (erule(2) pspace_relation_update_tcbs)
-    apply (simp add: c)
-   apply (clarsimp simp: ekheap_relation_def pspace_relation_def)
-   apply (drule bspec, erule domI)
-   apply (clarsimp simp: etcb_relation_def tcb_cte_cases_def split: if_split_asm)
-  apply (clarsimp simp: pspace_relations_def)
+                         set_object_def get_def put_def gets_the_def)
+   apply (erule(2) pspace_relation_update_tcbs)
+   apply (simp add: c)
+  apply clarsimp
   apply (frule(5) cte_map_pulls_cte_to_abstract[OF p])
   apply (clarsimp simp: set_cap_def split_def bind_def get_object_def
                         simpler_gets_def assert_def fail_def return_def
-                        set_object_def get_def put_def domI a_type_def[split_simps kernel_object.split arch_kernel_obj.split])
+                        set_object_def get_def put_def domI gets_the_def
+                        a_type_def[split_simps kernel_object.split arch_kernel_obj.split])
   apply (erule(1) valid_objsE)
   apply (clarsimp simp: valid_obj_def valid_cs_def valid_cs_size_def exI)
   apply (intro conjI impI)
@@ -1751,9 +1709,6 @@ lemma set_cap_not_quite_corres_prequel:
      apply (simp add: cte_at_cases domI well_formed_cnode_invsI[OF cr(3)])
     apply clarsimp
    apply (simp add: c)
-  apply (clarsimp simp: ekheap_relation_def pspace_relation_def)
-  apply (drule bspec, erule domI)
-  apply (clarsimp simp: etcb_relation_def tcb_cte_cases_def split: if_split_asm)
   apply (simp add: wf_cs_insert)
   done
 
@@ -1766,15 +1721,20 @@ lemma setCTE_pspace_only:
 
 lemma set_cap_not_quite_corres:
   assumes cr:
-  "pspace_relations (ekheap s) (kheap s) (ksPSpace s')"
+  "pspace_relation (kheap s) (ksPSpace s')"
   "cur_thread s = ksCurThread s'"
   "idle_thread s = ksIdleThread s'"
+  "idle_sc_ptr = ksIdleSC s'"
   "machine_state s = ksMachineState s'"
   "work_units_completed s = ksWorkUnitsCompleted s'"
   "domain_index s = ksDomScheduleIdx s'"
   "domain_list s = ksDomSchedule s'"
   "cur_domain s = ksCurDomain s'"
   "domain_time s = ksDomainTime s'"
+  "consumed_time s = ksConsumedTime s'"
+  "cur_time s = ksCurTime s'"
+  "cur_sc s = ksCurSc s'"
+  "reprogram_timer s = ksReprogramTimer s'"
   "(x,t') \<in> fst (updateCap p' c' s')"
   "valid_objs s" "pspace_aligned s" "pspace_distinct s" "cte_at p s"
   "pspace_aligned' s'" "pspace_distinct' s'"
@@ -1783,24 +1743,30 @@ lemma set_cap_not_quite_corres:
   assumes c: "cap_relation c c'"
   assumes p: "p' = cte_map p"
   shows "\<exists>t. ((),t) \<in> fst (set_cap c p s) \<and>
-             pspace_relations (ekheap t) (kheap t) (ksPSpace t') \<and>
+             pspace_relation (kheap t) (ksPSpace t') \<and>
              cdt t = cdt s \<and>
              cdt_list t = cdt_list s \<and>
-             ekheap t = ekheap s \<and>
              scheduler_action t = scheduler_action s \<and>
              ready_queues t = ready_queues s \<and>
+             release_queue t = release_queue s \<and>
              is_original_cap t = is_original_cap s \<and>
              interrupt_state_relation (interrupt_irq_node t) (interrupt_states t)
                               (ksInterruptState t') \<and>
              (arch_state t, ksArchState t') \<in> arch_state_relation \<and>
              cur_thread t = ksCurThread t' \<and>
              idle_thread t = ksIdleThread t' \<and>
+             idle_sc_ptr = ksIdleSC t' \<and>
              machine_state t = ksMachineState t' \<and>
              work_units_completed t = ksWorkUnitsCompleted t' \<and>
              domain_index t = ksDomScheduleIdx t' \<and>
              domain_list t = ksDomSchedule t' \<and>
              cur_domain t = ksCurDomain t' \<and>
-             domain_time t = ksDomainTime t'"
+             domain_time t = ksDomainTime t' \<and>
+             consumed_time t = ksConsumedTime t' \<and>
+             cur_time t = ksCurTime t' \<and>
+             cur_sc t = ksCurSc t' \<and>
+             reprogram_timer t = ksReprogramTimer t' \<and>
+             sc_replies_of t = sc_replies_of s"
   using cr
   apply (clarsimp simp: updateCap_def in_monad)
   apply (drule use_valid [OF _ getCTE_sp[where P="\<lambda>s. s2 = s" for s2], OF _ refl])
@@ -1812,9 +1778,12 @@ lemma set_cap_not_quite_corres:
   apply (erule exEI)
   apply clarsimp
   apply (frule setCTE_pspace_only)
+  apply (prop_tac "sc_replies_of x = sc_replies_of s")
+   apply (erule use_valid[OF _ set_cap.valid_sched_pred], simp)
   apply (clarsimp simp: set_cap_def split_def in_monad set_object_def
-                        get_object_def
-                 split: Structures_A.kernel_object.split_asm if_split_asm)
+                        get_object_def)
+  apply (rename_tac obj ps' x' obj' kobj)
+  apply (case_tac obj; clarsimp simp: fail_def return_def split: if_split_asm)
   done
 
 lemma descendants_of_eq':
@@ -1838,20 +1807,54 @@ lemma descendants_of_eq':
   apply simp
   done
 
+\<comment>\<open>
+  This turned out to be the least-annoying way to deal with
+  the subgoal @{term
+    "ps' |> reply_of' |> replyNext_of = replyNexts_of s'"
+  } which shows up in the proof of `updateCap_corres`.
+
+  `ps'` here comes from `ksPSpace s''`, where `s''` is the new state
+  after `setObject`. Unforutnately, @{thm setObject_cte_replies_of'} is
+  specified in terms of `replies_of'`, which uses `ksPSpace` as an
+  accessor and so can't be used for a goal that refers to the PSpace
+  directly.
+\<close>
+lemma setObject_cte_replies_of'_use_valid_ksPSpace:
+  assumes step: "(x, s\<lparr>ksPSpace := ps\<rparr>) \<in> fst (setObject p (cte :: cte) s)"
+      and pre: "P (replies_of' s)"
+  shows "P (ps |> reply_of')"
+  using use_valid[OF step setObject_cte_replies_of'] pre
+  by auto
+
+lemma setObject_cte_scs_of'_use_valid_ksPSpace:
+  assumes step: "(x, s\<lparr>ksPSpace := ps\<rparr>) \<in> fst (setObject p (cte :: cte) s)"
+      and pre: "P (scs_of' s)"
+  shows "P (ps |> sc_of')"
+  using use_valid[OF step setObject_scs_of'(1)] pre
+  by auto
+
 lemma updateCap_stuff:
   assumes "(x, s'') \<in> fst (updateCap p cap s')"
-  shows "(ctes_of s'' = modify_map (ctes_of s') p (cteCap_update (K cap))) \<and>
+  shows "ctes_of s'' = modify_map (ctes_of s') p (cteCap_update (K cap)) \<and>
          gsUserPages s'' = gsUserPages s' \<and>
          gsCNodes s'' = gsCNodes s' \<and>
          ksMachineState s'' = ksMachineState s' \<and>
          ksWorkUnitsCompleted s'' = ksWorkUnitsCompleted s' \<and>
          ksCurThread s'' = ksCurThread s' \<and>
          ksIdleThread s'' = ksIdleThread s' \<and>
+         ksIdleSC s'' = ksIdleSC s' \<and>
          ksReadyQueues s'' = ksReadyQueues s' \<and>
+         ksReleaseQueue s'' = ksReleaseQueue s' \<and>
          ksSchedulerAction s'' = ksSchedulerAction s' \<and>
          (ksArchState s'' = ksArchState s') \<and>
          (pspace_aligned' s' \<longrightarrow> pspace_aligned' s'') \<and>
-         (pspace_distinct' s' \<longrightarrow> pspace_distinct' s'')" using assms
+         (pspace_distinct' s' \<longrightarrow> pspace_distinct' s'') \<and>
+         replyPrevs_of s'' = replyPrevs_of s' \<and>
+         scReplies_of s'' = scReplies_of s' \<and>
+         ksConsumedTime s'' = ksConsumedTime s' \<and>
+         ksCurTime s'' = ksCurTime s' \<and>
+         ksCurSc s'' = ksCurSc s' \<and>
+         ksReprogramTimer s'' = ksReprogramTimer s'" using assms
   apply (clarsimp simp: updateCap_def in_monad)
   apply (drule use_valid [where P="\<lambda>s. s2 = s" for s2, OF _ getCTE_sp refl])
   apply (rule conjI)
@@ -1860,8 +1863,16 @@ lemma updateCap_stuff:
   apply (frule setCTE_pspace_only)
   apply (clarsimp simp: setCTE_def)
   apply (intro conjI impI)
-   apply (erule(1) use_valid [OF _ setObject_aligned])
-  apply (erule(1) use_valid [OF _ setObject_distinct])
+     apply (erule use_valid [OF _ setObject_aligned])
+      apply (clarsimp simp: updateObject_cte in_monad typeError_def
+                            in_magnitude_check objBits_simps
+                     split: kernel_object.split_asm if_split_asm)
+    apply (erule use_valid [OF _ setObject_distinct])
+     apply (clarsimp simp: updateObject_cte in_monad typeError_def
+                           in_magnitude_check objBits_simps
+                    split: kernel_object.split_asm if_split_asm)
+   apply (erule setObject_cte_replies_of'_use_valid_ksPSpace; simp)
+  apply (erule setObject_cte_scs_of'_use_valid_ksPSpace; simp)
   done
 
 (* FIXME: move *)
@@ -2178,24 +2189,33 @@ lemma ctes_of_valid:
   apply (fastforce)
   done
 
-lemma no_fail_setCTE [wp]:
-  "no_fail (cte_at' p) (setCTE p c)"
-  apply (clarsimp simp: setCTE_def setObject_def split_def unless_def
-                        updateObject_cte alignCheck_def alignError_def
-                        typeError_def is_aligned_mask[symmetric]
-                  cong: kernel_object.case_cong)
+lemma readObject_cte_at'[simplified]:
+  "bound (readObject p s :: cte option) \<Longrightarrow> cte_at' p s"
+  unfolding cte_wp_at'_def getObject_def
+  by (clarsimp simp: omonad_defs split_def gets_the_def exec_gets return_def)
+
+lemma readObject_cte_ko_at':
+  "readObject p s = Some (cte :: cte) \<Longrightarrow> cte_wp_at' ((=) cte) p s"
+  unfolding cte_wp_at'_def getObject_def
+  by (clarsimp simp: omonad_defs split_def gets_the_def exec_gets return_def)
+
+lemma no_fail_setObject_cte [wp]:
+  "no_fail (cte_at' t) (setObject t (t'::cte))"
+  unfolding setObject_def
+  apply (clarsimp simp: updateObject_cte gets_the_def alignCheck_def is_aligned_mask[symmetric]
+             split del: if_split cong: kernel_object.case_cong)
   apply (wp|wpc)+
   apply (clarsimp simp: cte_wp_at'_def getObject_def split_def
-                        in_monad loadObject_cte
-                 dest!: in_singleton
-             split del: if_split)
-  apply (clarsimp simp: typeError_def alignCheck_def alignError_def
-                        in_monad is_aligned_mask[symmetric] objBits_simps
-                        magnitudeCheck_def
-                 split: kernel_object.split_asm if_split_asm option.splits
-             split del: if_split)
-    apply simp_all
-  done
+                        in_monad loadObject_cte readObject_def omonad_defs
+                 dest!: in_singleton split: option.splits split del: if_split)
+  by (fastforce simp: read_typeError_def objBits_simps
+                      read_magnitudeCheck_def ohaskell_assert_def
+               split: kernel_object.split_asm if_split_asm
+           split del: if_split)
+
+lemma no_fail_setCTE [wp]:
+  "no_fail (cte_at' p) (setCTE p c)"
+  unfolding setCTE_def by wp
 
 lemma no_fail_updateCap [wp]:
   "no_fail (cte_at' p) (updateCap p cap')"
@@ -2248,23 +2268,20 @@ lemma is_final_untyped_ptrs:
   done
 
 lemma capClass_ztc_relation:
-  "\<lbrakk> is_zombie c \<or> is_cnode_cap c \<or> is_thread_cap c;
-       cap_relation c c' \<rbrakk> \<Longrightarrow> capClass c' = PhysicalClass"
+  "\<lbrakk> is_zombie c \<or> is_cnode_cap c \<or> is_thread_cap c; cap_relation c c' \<rbrakk>
+   \<Longrightarrow> capClass c' = PhysicalClass"
   by (auto simp: is_cap_simps)
 
-lemma pspace_relationsD:
-  "\<lbrakk>pspace_relation kh kh'; ekheap_relation ekh kh'\<rbrakk> \<Longrightarrow> pspace_relations ekh kh kh'"
-  by (simp add: pspace_relations_def)
-
 lemma updateCap_corres:
   "\<lbrakk>cap_relation cap cap';
     is_zombie cap \<or> is_cnode_cap cap \<or> is_thread_cap cap \<rbrakk>
-   \<Longrightarrow> corres dc (\<lambda>s. invs s \<and>
-                      cte_wp_at (\<lambda>c. (is_zombie c \<or> is_cnode_cap c \<or>
-                                      is_thread_cap c) \<and>
-                                     is_final_cap' c s \<and>
-                                     obj_ref_of c = obj_ref_of cap \<and>
-                                     obj_size c = obj_size cap) slot s)
+   \<Longrightarrow> corres dc (\<lambda>s. invs s
+                      \<and> cte_wp_at
+                          (\<lambda>c. (is_zombie c \<or> is_cnode_cap c \<or> is_thread_cap c)
+                            \<and> is_final_cap' c s
+                            \<and> obj_ref_of c = obj_ref_of cap
+                            \<and> obj_size c = obj_size cap)
+                          slot s)
                  invs'
                  (set_cap cap slot) (updateCap (cte_map slot) cap')"
   apply (rule corres_stronger_no_failI)
@@ -2277,39 +2294,30 @@ lemma updateCap_corres:
     apply fastforce
    apply (clarsimp simp: cte_wp_at_ctes_of)
   apply (clarsimp simp add: state_relation_def)
-  apply (drule(1) pspace_relationsD)
   apply (frule (3) set_cap_not_quite_corres; fastforce?)
    apply (erule cte_wp_at_weakenE, rule TrueI)
   apply clarsimp
   apply (rule bexI)
    prefer 2
    apply simp
-  apply (clarsimp simp: in_set_cap_cte_at_swp pspace_relations_def)
+  apply (clarsimp simp: in_set_cap_cte_at_swp)
   apply (drule updateCap_stuff)
-  apply simp
-  apply (rule conjI)
+  apply (rename_tac abs conc conc' abs')
+
+  (* FIXME RT: replace this with whatever comes out of VER-1248. *)
+  apply (extract_conjunct \<open>match conclusion in "ghost_relation _ _ _" \<Rightarrow> -\<close>)
    apply (clarsimp simp: ghost_relation_typ_at set_cap_a_type_inv data_at_def)
-  apply (rule conjI)
-   prefer 2
-   apply (rule conjI)
-    apply (unfold cdt_list_relation_def)[1]
-    apply (intro allI impI)
-    apply (erule_tac x=c in allE)
-    apply (auto elim!: modify_map_casesE)[1]
-   apply (unfold revokable_relation_def)[1]
-   apply (drule set_cap_caps_of_state_monad)
-   apply (simp add: cte_wp_at_caps_of_state del: split_paired_All)
+
+  apply (extract_conjunct \<open>match conclusion in "sched_act_relation _ _" \<Rightarrow> -\<close>)
+   apply clarsimp
+
+  apply (extract_conjunct \<open>match conclusion in "cdt_relation _ _ _" \<Rightarrow> -\<close>)
+   apply (case_tac "ctes_of conc (cte_map slot)")
+    apply (simp add: modify_map_None)
+   apply (simp add: modify_map_apply)
+   apply (simp add: cdt_relation_def del: split_paired_All)
    apply (intro allI impI)
-   apply (erule_tac x=c in allE)
-   apply (erule impE[where P="\<exists>y. v = Some y" for v])
-    apply (clarsimp simp: null_filter_def is_zombie_def split: if_split_asm)
-   apply (auto elim!: modify_map_casesE del: disjE)[1]
-  apply (case_tac "ctes_of b (cte_map slot)")
-   apply (simp add: modify_map_None)
-  apply (simp add: modify_map_apply)
-  apply (simp add: cdt_relation_def del: split_paired_All)
-  apply (intro allI impI)
-  apply (rule use_update_ztc_one [OF descendants_of_update_ztc])
+   apply (rule use_update_ztc_one [OF descendants_of_update_ztc])
          apply simp
         apply assumption
        apply (auto simp: is_cap_simps isCap_simps)[1]
@@ -2327,13 +2335,35 @@ lemma updateCap_corres:
    apply (drule cte_wp_at_norm, clarsimp)
    apply (drule(1) pspace_relation_ctes_ofI, clarsimp+)
    apply (simp add: is_cap_simps, elim disjE exE, simp_all add: isCap_simps)[1]
-  apply clarsimp
-  done
+   apply clarsimp
+
+  apply (extract_conjunct \<open>match conclusion in "ready_queues_relation _ _" \<Rightarrow> -\<close>)
+   apply (case_tac "ctes_of conc (cte_map slot)")
+    apply (simp add: modify_map_None)
+   apply (simp add: modify_map_apply)
 
-lemma exst_set_cap:
-  "(x,s') \<in> fst (set_cap p c s) \<Longrightarrow> exst s' = exst s"
-  by (clarsimp simp: set_cap_def in_monad split_def get_object_def set_object_def
-               split: if_split_asm Structures_A.kernel_object.splits)
+  apply (extract_conjunct \<open>match conclusion in "cdt_list_relation _ _ _" \<Rightarrow> -\<close>)
+   apply (unfold cdt_list_relation_def)[1]
+   apply (intro allI impI)
+   apply (erule_tac x=c in allE)
+   apply (auto elim!: modify_map_casesE)[1]
+
+  apply (extract_conjunct \<open>match conclusion in "revokable_relation _ _ _" \<Rightarrow> -\<close>)
+   apply (unfold revokable_relation_def)[1]
+   apply (drule set_cap_caps_of_state_monad)
+   apply (simp add: cte_wp_at_caps_of_state del: split_paired_All)
+   apply (intro allI impI)
+   apply (erule_tac x=c in allE)
+   apply (erule impE[where P="\<exists>y. v = Some y" for v])
+    apply (clarsimp simp: null_filter_def is_zombie_def split: if_split_asm)
+   apply (auto elim!: modify_map_casesE del: disjE)[1]
+
+  apply (extract_conjunct \<open>match conclusion in "release_queue_relation _ _" \<Rightarrow> -\<close>)
+   apply (clarsimp simp: release_queue_relation_def
+                  elim!: use_valid[OF _ set_cap.valid_sched_pred])
+
+  apply (clarsimp simp: sc_replies_relation_def)
+  done
 
 lemma updateMDB_eqs:
   assumes "(x, s'') \<in> fst (updateMDB p f s')"
@@ -2341,7 +2371,9 @@ lemma updateMDB_eqs:
          ksWorkUnitsCompleted s'' = ksWorkUnitsCompleted s' \<and>
          ksCurThread s'' = ksCurThread s' \<and>
          ksIdleThread s'' = ksIdleThread s' \<and>
+         ksIdleSC s'' = ksIdleSC s' \<and>
          ksReadyQueues s'' = ksReadyQueues s' \<and>
+         ksReleaseQueue s'' = ksReleaseQueue s' \<and>
          ksInterruptState s'' = ksInterruptState s' \<and>
          ksArchState s'' = ksArchState s' \<and>
          ksSchedulerAction s'' = ksSchedulerAction s' \<and>
@@ -2406,24 +2438,6 @@ lemma updateMDB_pspace_relation:
   apply fastforce
   done
 
-lemma updateMDB_ekheap_relation:
-  assumes "(x, s'') \<in> fst (updateMDB p f s')"
-  assumes "ekheap_relation (ekheap s) (ksPSpace s')"
-  shows "ekheap_relation (ekheap s) (ksPSpace s'')" using assms
-  apply (clarsimp simp: updateMDB_def Let_def setCTE_def setObject_def in_monad ekheap_relation_def etcb_relation_def split_def split: if_split_asm)
-  apply (drule(1) updateObject_cte_is_tcb_or_cte[OF _ refl, rotated])
-  apply (drule_tac P="(=) s'" in use_valid [OF _ getCTE_sp], rule refl)
-  apply (drule bspec, erule domI)
-  apply (clarsimp simp: tcb_cte_cases_def lookupAround2_char1 split: if_split_asm)
-  done
-
-lemma updateMDB_pspace_relations:
-  assumes "(x, s'') \<in> fst (updateMDB p f s')"
-  assumes "pspace_relations (ekheap s) (kheap s) (ksPSpace s')"
-  assumes "pspace_aligned' s'" "pspace_distinct' s'"
-  shows "pspace_relations (ekheap s) (kheap s) (ksPSpace s'')" using assms
-  by (simp add: pspace_relations_def updateMDB_pspace_relation updateMDB_ekheap_relation)
-
 lemma updateMDB_ctes_of:
   assumes "(x, s') \<in> fst (updateMDB p f s)"
   assumes "no_0 (ctes_of s)"
@@ -2437,41 +2451,52 @@ lemma updateMDB_ctes_of:
   apply simp
   done
 
-crunch aligned[wp]: updateMDB "pspace_aligned'"
-crunch pdistinct[wp]: updateMDB "pspace_distinct'"
+crunches updateMDB
+  for replies_of'[wp]: "\<lambda>s. P (replies_of' s)"
+  and scs_of'[wp]: "\<lambda>s. P (scs_of' s)"
+  and ksConsumedTime[wp]: "\<lambda>s. P (ksConsumedTime s)"
+  and ksCurTime[wp]: "\<lambda>s. P (ksCurTime s)"
+  and ksCurSc[wp]: "\<lambda>s. P (ksCurSc s)"
+  and ksReprogramTimer[wp]: "\<lambda>s. P (ksReprogramTimer s)"
+  and aligned[wp]: pspace_aligned'
+  and pdistinct[wp]: pspace_distinct'
+  (wp: crunch_wps simp: crunch_simps setObject_def updateObject_cte)
 
 lemma updateMDB_the_lot:
   assumes "(x, s'') \<in> fst (updateMDB p f s')"
-  assumes "pspace_relations (ekheap s) (kheap s) (ksPSpace s')"
+  assumes "pspace_relation (kheap s) (ksPSpace s')"
   assumes "pspace_aligned' s'" "pspace_distinct' s'" "no_0 (ctes_of s')"
   shows "ctes_of s'' = modify_map (ctes_of s') p (cteMDBNode_update f) \<and>
          ksMachineState s'' = ksMachineState s' \<and>
          ksWorkUnitsCompleted s'' = ksWorkUnitsCompleted s' \<and>
          ksCurThread s'' = ksCurThread s' \<and>
          ksIdleThread s'' = ksIdleThread s' \<and>
+         ksIdleSC s'' = ksIdleSC s' \<and>
          ksReadyQueues s'' = ksReadyQueues s' \<and>
+         ksReleaseQueue s'' = ksReleaseQueue s' \<and>
          ksSchedulerAction s'' = ksSchedulerAction s' \<and>
          ksInterruptState s'' = ksInterruptState s' \<and>
          ksArchState s'' = ksArchState s' \<and>
          gsUserPages s'' = gsUserPages s' \<and>
          gsCNodes s'' = gsCNodes s' \<and>
-         pspace_relations (ekheap s) (kheap s) (ksPSpace s'') \<and>
+         pspace_relation (kheap s) (ksPSpace s'') \<and>
          pspace_aligned' s'' \<and> pspace_distinct' s'' \<and>
          no_0 (ctes_of s'') \<and>
          ksDomScheduleIdx s'' = ksDomScheduleIdx s' \<and>
          ksDomSchedule s''    = ksDomSchedule s' \<and>
          ksCurDomain s''      = ksCurDomain s' \<and>
-         ksDomainTime s''     = ksDomainTime s'"
-using assms
-  apply (simp add: updateMDB_eqs updateMDB_pspace_relations split del: if_split)
+         ksDomainTime s''     = ksDomainTime s' \<and>
+         ksConsumedTime s''   = ksConsumedTime s' \<and>
+         ksCurTime s''        = ksCurTime s' \<and>
+         ksCurSc s''          = ksCurSc s' \<and>
+         ksReprogramTimer s'' = ksReprogramTimer s' \<and>
+         replyPrevs_of s'' = replyPrevs_of s' \<and>
+         scReplies_of s'' = scReplies_of s'"
+  using assms
+  apply (simp add: updateMDB_eqs updateMDB_pspace_relation split del: if_split)
   apply (frule (1) updateMDB_ctes_of)
   apply clarsimp
-  apply (rule conjI)
-   apply (erule use_valid)
-    apply wp
-   apply simp
-  apply (erule use_valid)
-   apply wp
+  apply (erule use_valid, wp)
   apply simp
   done
 
@@ -2609,20 +2634,7 @@ lemma subtree_next_0:
 definition
   "isArchCap P cap \<equiv> case cap of ArchObjectCap acap \<Rightarrow> P acap | _ \<Rightarrow> False"
 
-lemma isArchCap_simps[simp]:
-  "isArchCap P (capability.ThreadCap xc) = False"
-  "isArchCap P capability.NullCap = False"
-  "isArchCap P capability.DomainCap = False"
-  "isArchCap P (capability.NotificationCap xca xba xaa xd) = False"
-  "isArchCap P (capability.EndpointCap xda xcb xbb xab xe xi) = False"
-  "isArchCap P (capability.IRQHandlerCap xf) = False"
-  "isArchCap P (capability.Zombie xbc xac xg) = False"
-  "isArchCap P (capability.ArchObjectCap xh) = P xh"
-  "isArchCap P (capability.ReplyCap xad xi xia) = False"
-  "isArchCap P (capability.UntypedCap d xae xj f) = False"
-  "isArchCap P (capability.CNodeCap xfa xea xdb xcc) = False"
-  "isArchCap P capability.IRQControlCap = False"
-  by (simp add: isArchCap_def)+
+lemmas isArchCap_simps[simp] = isArchCap_def[split_simps capability.split]
 
 definition
   vsCapRef :: "capability \<Rightarrow> vs_ref list option"
@@ -2670,8 +2682,6 @@ definition
   badge_derived' cap' cap \<and>
   (isUntypedCap cap \<longrightarrow> descendants_of' p m = {}) \<and>
   (isReplyCap cap = isReplyCap cap') \<and>
-  (isReplyCap cap \<longrightarrow> capReplyMaster cap) \<and>
-  (isReplyCap cap' \<longrightarrow> \<not> capReplyMaster cap') \<and>
   (vsCapRef cap = vsCapRef cap' \<or> isArchCap isPageCap cap') \<and>
   ((isArchCap isPageTableCap cap \<or> isArchCap isPageDirectoryCap cap)
         \<longrightarrow> capASID cap = capASID cap' \<and> capASID cap \<noteq> None)"
@@ -2697,19 +2707,12 @@ lemma capBadge_ordering_relation:
   "\<lbrakk> cap_relation c c'; cap_relation d d' \<rbrakk> \<Longrightarrow>
   ((capBadge c', capBadge d') \<in> capBadge_ordering f) =
   ((cap_badge c, cap_badge d) \<in> capBadge_ordering f)"
-  apply (cases c)
-   apply (auto simp add: cap_badge_def capBadge_ordering_def split: cap.splits)
-  done
+  by (cases c, auto simp add: cap_badge_def capBadge_ordering_def split: cap.splits)
 
 lemma is_reply_cap_relation:
-  "cap_relation c c' \<Longrightarrow> is_reply_cap c = (isReplyCap c' \<and> \<not> capReplyMaster c')"
+  "cap_relation c c' \<Longrightarrow> is_reply_cap c = (isReplyCap c')"
   by (cases c, auto simp: is_cap_simps isCap_simps)
 
-lemma is_reply_master_relation:
-  "cap_relation c c' \<Longrightarrow>
-   is_master_reply_cap c = (isReplyCap c' \<and> capReplyMaster c')"
-  by (cases c, auto simp add: is_cap_simps isCap_simps)
-
 lemma cap_asid_cap_relation:
   "cap_relation c c' \<Longrightarrow> capASID c' = cap_asid c"
   by (auto simp: capASID_def cap_asid_def split: cap.splits arch_cap.splits)
@@ -2728,30 +2731,28 @@ lemma is_derived_eq:
   apply (rule conjI)
    apply (clarsimp simp: is_cap_simps isCap_simps)
    apply (cases c, auto simp: isCap_simps cap_master_cap_def capMasterCap_def)[1]
-  apply (simp add:vsCapRef_def)
-  apply (simp add:vs_cap_ref_def)
-  apply (case_tac "isIRQControlCap d'")
+    apply (simp add:vsCapRef_def)
+   apply (simp add:vs_cap_ref_def)
+  apply (cases "isIRQControlCap d'")
    apply (frule(1) master_cap_relation)
    apply (clarsimp simp: isCap_simps cap_master_cap_def
-                         is_zombie_def is_reply_cap_def is_master_reply_cap_def
+                         is_zombie_def is_reply_cap_def
                   split: cap_relation_split_asm arch_cap.split_asm)[1]
   apply (frule(1) master_cap_relation)
   apply (frule(1) cap_badge_relation)
   apply (frule cap_asid_cap_relation)
   apply (frule(1) capBadge_ordering_relation)
-  apply (case_tac d)
-   apply (simp_all add: isCap_simps is_cap_simps cap_master_cap_def
-     vs_cap_ref_def vsCapRef_def capMasterCap_def
-     split: cap_relation_split_asm arch_cap.split_asm)
-   apply fastforce
-  apply ((auto split:arch_cap.splits arch_capability.splits)[3])
-  apply (clarsimp split:option.splits arch_cap.splits arch_capability.splits)
-  apply (intro conjI|clarsimp)+
-    apply fastforce
-   apply clarsimp+
+  apply (case_tac d; simp add: isCap_simps is_cap_simps cap_master_cap_def
+                               vs_cap_ref_def vsCapRef_def capMasterCap_def
+                          split: cap_relation_split_asm arch_cap.split_asm)
+      apply ((auto split:arch_cap.splits arch_capability.splits)[3])
+   apply (clarsimp split:option.splits arch_cap.splits arch_capability.splits)
+   apply (intro conjI|clarsimp)+
+     apply fastforce
+    apply clarsimp+
   apply (clarsimp split:option.splits arch_cap.splits arch_capability.splits)
   apply (intro conjI|clarsimp)+
-   apply fastforce
+  apply fastforce
   done
 end
 
@@ -3681,7 +3682,6 @@ lemma setCTE_UntypedCap_corres:
    apply (clarsimp simp: cte_wp_at_ctes_of)
   apply clarsimp
   apply (clarsimp simp add: state_relation_def split_def)
-  apply (drule (1) pspace_relationsD)
   apply (frule_tac c = "cap.UntypedCap dev r bits idx"
                 in set_cap_not_quite_corres_prequel)
          apply assumption+
@@ -3692,32 +3692,26 @@ lemma setCTE_UntypedCap_corres:
   apply (rule bexI)
    prefer 2
    apply assumption
-  apply (clarsimp simp: pspace_relations_def)
-  apply (subst conj_assoc[symmetric])
-  apply (rule conjI)
-   apply (frule setCTE_pspace_only)
-   apply (clarsimp simp: set_cap_def in_monad split_def get_object_def set_object_def
-                    split: if_split_asm Structures_A.kernel_object.splits)
-  apply (rule conjI)
+  apply clarsimp
+  apply (rename_tac abs conc conc' abs')
+
+  (* FIXME RT: replace this with whatever comes out of VER-1248. *)
+  apply (extract_conjunct \<open>match conclusion in "ghost_relation _ _ _" \<Rightarrow> -\<close>)
    apply (frule setCTE_pspace_only)
    apply (clarsimp simp: ghost_relation_typ_at set_cap_a_type_inv data_at_def)
-  apply (rule conjI)
-   prefer 2
-   apply (rule conjI)
-    apply (frule mdb_set_cap, frule exst_set_cap)
-    apply (erule use_valid [OF _ setCTE_ctes_of_wp])
-    apply (clarsimp simp: cdt_list_relation_def cte_wp_at_ctes_of split: if_split_asm)
-   apply (rule conjI)
-    prefer 2
-    apply (frule setCTE_pspace_only)
-    apply clarsimp
-    apply (clarsimp simp: set_cap_def in_monad split_def get_object_def set_object_def
-                    split: if_split_asm Structures_A.kernel_object.splits)
+
+  apply (extract_conjunct \<open>match conclusion in "cdt_list_relation _ _ _" \<Rightarrow> -\<close>)
+   apply (frule mdb_set_cap, frule exst_set_cap)
+   apply (erule use_valid [OF _ setCTE_ctes_of_wp])
+   apply (clarsimp simp: cdt_list_relation_def cte_wp_at_ctes_of split: if_split_asm)
+
+  apply (extract_conjunct \<open>match conclusion in "revokable_relation _ _ _" \<Rightarrow> -\<close>)
    apply (frule set_cap_caps_of_state_monad)
    apply (drule is_original_cap_set_cap)
    apply clarsimp
    apply (erule use_valid [OF _ setCTE_ctes_of_wp])
    apply (clarsimp simp: revokable_relation_def simp del: fun_upd_apply)
+   apply (rename_tac oref cidx cap' cap'' node)
    apply (clarsimp split: if_split_asm)
     apply (frule cte_map_inj_eq)
          prefer 2
@@ -3730,26 +3724,41 @@ lemma setCTE_UntypedCap_corres:
      apply fastforce
     apply clarsimp
     apply (simp add: null_filter_def split: if_split_asm)
-    apply (erule_tac x=aa in allE, erule_tac x=bb in allE)
+    apply (erule_tac x=oref in allE, erule_tac x=cidx in allE)
     apply (case_tac cte)
     apply (clarsimp simp: cte_wp_at_caps_of_state is_cap_simps isCap_simps cte_wp_at_ctes_of)
    apply (simp add: null_filter_def cte_wp_at_caps_of_state split: if_split_asm)
-   apply (erule_tac x=aa in allE, erule_tac x=bb in allE)
+   apply (erule_tac x=oref in allE, erule_tac x=cidx in allE)
    apply (clarsimp)
-  apply (clarsimp simp: cdt_relation_def)
-  apply (frule set_cap_caps_of_state_monad)
-  apply (frule mdb_set_cap)
-  apply clarsimp
-  apply (erule use_valid [OF _ setCTE_ctes_of_wp])
-  apply (frule cte_wp_at_norm)
-  apply (clarsimp simp:cte_wp_at_ctes_of simp del: fun_upd_apply)
-  apply (drule_tac slot = "cte_map (aa,bb)" in updateUntypedCap_descendants_of)
-   apply (clarsimp simp:isCap_simps)
-  apply (drule_tac x = aa in spec)
-  apply (drule_tac x = bb in spec)
-  apply (erule impE)
-   apply (clarsimp simp: cte_wp_at_caps_of_state split:if_splits)
-  apply auto
+
+  apply (extract_conjunct \<open>match conclusion in "cdt_relation _ _ _" \<Rightarrow> -\<close>)
+   apply (clarsimp simp: cdt_relation_def)
+   apply (rename_tac oref cidx)
+   apply (frule set_cap_caps_of_state_monad)
+   apply (frule mdb_set_cap)
+   apply clarsimp
+   apply (erule use_valid [OF _ setCTE_ctes_of_wp])
+   apply (frule cte_wp_at_norm)
+   apply (clarsimp simp:cte_wp_at_ctes_of simp del: fun_upd_apply)
+   apply (drule_tac slot = "cte_map (oref, cidx)" in updateUntypedCap_descendants_of)
+    apply (clarsimp simp:isCap_simps)
+   apply (drule_tac x = oref in spec)
+   apply (drule_tac x = cidx in spec)
+   apply (erule impE)
+    apply (clarsimp simp: cte_wp_at_caps_of_state split:if_splits)
+   apply auto[1]
+
+  apply (extract_conjunct \<open>match conclusion in "sc_replies_relation _ _" \<Rightarrow> -\<close>)
+   apply (clarsimp simp: sc_replies_relation_def
+                  elim!: use_valid[OF _ set_cap.valid_sched_pred])
+   apply (rule use_valid[OF _ setCTE_replies_of'], assumption)
+   apply (rule use_valid[OF _ setCTE_scs_of'], assumption)
+   apply clarsimp
+
+  apply (frule setCTE_pspace_only)
+  apply (clarsimp simp: set_cap_def in_monad split_def get_object_def set_object_def)
+  apply (rename_tac obj ps' s'' obj' kobj; case_tac obj;
+         simp add: fail_def return_def split: if_split_asm)
   done
 
 lemma getCTE_get:
@@ -3789,20 +3798,7 @@ lemma setUntypedCapAsFull_corres:
   done
 
 (* FIXME: SELFOUR-421 move *)
-lemma isUntypedCap_simps[simp]:
-  "isUntypedCap (capability.UntypedCap uu uv uw ux) = True"
-  "isUntypedCap (capability.NullCap) = False"
-  "isUntypedCap (capability.EndpointCap v va vb vc vd ve) = False"
-  "isUntypedCap (capability.NotificationCap v va vb vc) = False"
-  "isUntypedCap (capability.ReplyCap v1 v2 v3) = False"
-  "isUntypedCap (capability.CNodeCap x1 x2 x3 x4) = False"
-  "isUntypedCap (capability.ThreadCap v) = False"
-  "isUntypedCap (capability.DomainCap) = False"
-  "isUntypedCap (capability.IRQControlCap) = False"
-  "isUntypedCap (capability.IRQHandlerCap y1) = False"
-  "isUntypedCap (capability.Zombie v va1 vb1) = False"
-  "isUntypedCap (capability.ArchObjectCap z) = False"
-  by (simp_all add: isUntypedCap_def split: capability.splits)
+lemmas isUntypedCap_simps[simp] = isUntypedCap_def[split_simps capability.split]
 
 lemma cap_relation_masked_as_full:
   "\<lbrakk>cap_relation src_cap src_cap';cap_relation c c'\<rbrakk> \<Longrightarrow>
@@ -4312,6 +4308,7 @@ lemma irq_control_preserve:
   apply (simp add:dom misc)+
   done
 end
+
 locale mdb_inv_preserve =
   fixes m m'
   assumes dom: "\<And>x. (x\<in> dom m)  = (x\<in> dom m')"
@@ -4319,7 +4316,6 @@ locale mdb_inv_preserve =
   isUntypedCap (cteCap cte) = isUntypedCap (cteCap cte')
   \<and> isNullCap (cteCap cte) = isNullCap (cteCap cte')
   \<and> isReplyCap (cteCap cte) = isReplyCap (cteCap cte')
-  \<and> (isReplyCap (cteCap cte) \<longrightarrow> capReplyMaster (cteCap cte) = capReplyMaster (cteCap cte'))
   \<and> isNotificationCap (cteCap cte)  = isNotificationCap (cteCap cte')
   \<and> (isNotificationCap (cteCap cte) \<longrightarrow> (capNtfnBadge (cteCap cte) = capNtfnBadge (cteCap cte')))
   \<and> (isEndpointCap (cteCap cte) = isEndpointCap (cteCap cte'))
@@ -4426,59 +4422,44 @@ lemma descendants_of:
   done
 
 lemma by_products:
-  "reply_masters_rvk_fb m = reply_masters_rvk_fb m'
- \<and> no_0 m = no_0 m' \<and> mdb_chain_0 m = mdb_chain_0 m'
- \<and> valid_nullcaps m = valid_nullcaps m'"
-apply (intro conjI)
-  apply (simp add:ran_dom reply_masters_rvk_fb_def mdb_inv_preserve_def dom misc sameRegion mdb_next)
-    apply (rule iffI)
-    apply clarsimp
-    apply (drule_tac x = y in bspec)
-     apply (rule iffD2[OF dom])
-     apply clarsimp
-    apply (frule iffD2[OF dom,OF domI],rotate_tac)
-    apply (clarsimp simp:misc)+
-    apply (drule_tac x = y in bspec)
-     apply (rule iffD1[OF dom])
-     apply clarsimp
-    apply (frule iffD1[OF dom,OF domI],rotate_tac)
-   apply (clarsimp simp:misc)+
-   apply (clarsimp simp:no_0_def)
-   apply (rule ccontr)
-   apply (simp add:dom_in)
-   apply (subst (asm) dom[symmetric])
-   apply fastforce
+  "no_0 m = no_0 m' \<and> mdb_chain_0 m = mdb_chain_0 m'\<and> valid_nullcaps m = valid_nullcaps m'"
+  apply (intro conjI)
+    apply (clarsimp simp:no_0_def)
+    apply (rule ccontr)
+    apply (simp add:dom_in)
+    apply (subst (asm) dom[symmetric])
+    apply fastforce
    apply (rule iffI)
-   apply (clarsimp simp:mdb_chain_0_def)
-      apply (drule_tac x =x in bspec)
-      apply (rule iffD2[OF dom],clarsimp)
-      apply (erule_tac iffD1[OF connect_eqv_singleE,rotated])
-      apply (cut_tac p = p in mdb_next)
-      apply (clarsimp simp: mdb_next_rel_def)
     apply (clarsimp simp:mdb_chain_0_def)
-      apply (drule_tac x =x in bspec)
-      apply (rule iffD1[OF dom],clarsimp)
-      apply (erule_tac iffD1[OF connect_eqv_singleE,rotated])
-      apply (cut_tac p = p in mdb_next)
-      apply (clarsimp simp: mdb_next_rel_def)
-   apply (simp add:valid_nullcaps_def)
-   apply (rule forall_eq,clarsimp)+
-     apply (rule iffI)
-      apply clarsimp
-      apply (frule iffD2[OF dom,OF domI])
-      apply (clarsimp)
-      apply (case_tac y)
-      apply (drule misc)
-        apply assumption
-        apply (clarsimp simp:isCap_simps)
-     apply clarsimp
-     apply (frule iffD1[OF dom,OF domI])
-     apply (clarsimp)
-     apply (case_tac y)
-     apply (drule misc)
-       apply assumption
-       apply (clarsimp simp:isCap_simps)
-done
+    apply (drule_tac x =x in bspec)
+     apply (rule iffD2[OF dom],clarsimp)
+    apply (erule_tac iffD1[OF connect_eqv_singleE,rotated])
+    apply (cut_tac p = p in mdb_next)
+    apply (clarsimp simp: mdb_next_rel_def)
+   apply (clarsimp simp:mdb_chain_0_def)
+   apply (drule_tac x =x in bspec)
+    apply (rule iffD1[OF dom],clarsimp)
+   apply (erule_tac iffD1[OF connect_eqv_singleE,rotated])
+   apply (cut_tac p = p in mdb_next)
+   apply (clarsimp simp: mdb_next_rel_def)
+  apply (simp add:valid_nullcaps_def)
+  apply (rule forall_eq,clarsimp)+
+  apply (rule iffI)
+   apply clarsimp
+   apply (frule iffD2[OF dom,OF domI])
+   apply (clarsimp)
+   apply (case_tac y)
+   apply (drule misc)
+    apply assumption
+   apply (clarsimp simp:isCap_simps)
+  apply clarsimp
+  apply (frule iffD1[OF dom,OF domI])
+  apply (clarsimp)
+  apply (case_tac y)
+  apply (drule misc)
+   apply assumption
+  apply (clarsimp simp:isCap_simps)
+  done
 
 end
 
@@ -4523,7 +4504,7 @@ lemma updateCap_cte_wp_at':
         updateCap ptr cap \<lbrace>\<lambda>rv s. Q (cte_wp_at' P' p s)\<rbrace>"
   apply (simp add:updateCap_def cte_wp_at_ctes_of)
   apply (wp setCTE_ctes_of_wp getCTE_wp)
-  apply (clarsimp simp: cte_wp_at_ctes_of split del: if_split)
+  apply (clarsimp simp: cte_wp_at_ctes_of)
   apply (case_tac cte, auto split: if_split)
   done
 
@@ -4623,22 +4604,6 @@ lemma updateCapFreeIndex_class_links:
     apply (clarsimp simp:cte_wp_at_ctes_of)+
 done
 
-lemma updateCapFreeIndex_reply_masters_rvk_fb:
-  assumes preserve:"\<And>m m'. mdb_inv_preserve m m' \<Longrightarrow> mdb_inv_preserve (Q m) (Q m')"
-  shows
- "\<lbrace>\<lambda>s. P (reply_masters_rvk_fb (Q (ctes_of s))) \<and> cte_wp_at' (\<lambda>c. c = srcCTE \<and> isUntypedCap (cteCap c)) src s\<rbrace>
-  updateCap src (capFreeIndex_update (\<lambda>_. index) (cteCap srcCTE))
- \<lbrace>\<lambda>r s. P (reply_masters_rvk_fb (Q (ctes_of s)))\<rbrace>"
-  apply (wp updateCap_ctes_of_wp)
-  apply (subgoal_tac "mdb_inv_preserve (Q (ctes_of s)) (Q (modify_map (ctes_of s) src
-              (cteCap_update (\<lambda>_. capFreeIndex_update (\<lambda>_. index) (cteCap srcCTE)))))")
-    apply (drule mdb_inv_preserve.by_products)
-    apply simp
-  apply (rule preserve)
-  apply (rule mdb_inv_preserve_updateCap)
-    apply (clarsimp simp:cte_wp_at_ctes_of)+
-done
-
 lemma updateCapFreeIndex_distinct_zombies:
   assumes preserve:"\<And>m m'. mdb_inv_preserve m m' \<Longrightarrow> mdb_inv_preserve (Q m) (Q m')"
   shows
@@ -4833,19 +4798,6 @@ setUntypedCapAsFull (cteCap srcCTE) cap src
   apply clarsimp
 done
 
-lemma setUntypedCapAsFull_reply_masters_rvk_fb:
-  assumes preserve:"\<And>m m'. mdb_inv_preserve m m' \<Longrightarrow> mdb_inv_preserve (Q m) (Q m')"
-  shows
- "\<lbrace>\<lambda>s. P (reply_masters_rvk_fb (Q (ctes_of s))) \<and> cte_wp_at' (\<lambda>c. c = srcCTE) src s\<rbrace>
-setUntypedCapAsFull (cteCap srcCTE) cap src
- \<lbrace>\<lambda>r s. P (reply_masters_rvk_fb (Q (ctes_of s)))\<rbrace>"
-  apply (clarsimp simp:setUntypedCapAsFull_def split:if_splits,intro conjI impI)
-    apply (wp updateCapFreeIndex_reply_masters_rvk_fb)
-    apply (clarsimp simp:cte_wp_at_ctes_of preserve)+
-  apply wp
-  apply clarsimp
-done
-
 lemma modify_map_eq[simp]:
   "\<lbrakk>m slot = Some srcCTE; cap = cteCap srcCTE\<rbrakk>
    \<Longrightarrow>(modify_map m slot (cteCap_update (\<lambda>_. cap))) = m"
@@ -4872,11 +4824,10 @@ lemma setUntypedCapAsFull_valid_cap:
   "\<lbrace>valid_cap' cap and cte_wp_at' ((=) srcCTE) slot\<rbrace>
    setUntypedCapAsFull (cteCap srcCTE) c slot
    \<lbrace>\<lambda>r. valid_cap' cap\<rbrace>"
-  apply (clarsimp simp:setUntypedCapAsFull_def split:if_splits)
+  apply (clarsimp simp:setUntypedCapAsFull_def updateCap_def split:if_splits)
   apply (intro conjI impI)
-    apply (clarsimp simp:updateCap_def)
-  apply (wp|clarsimp)+
-done
+   apply wpsimp+
+  done
 
 lemma cteCap_update_simps:
   "cteCap_update f srcCTE = CTE (f (cteCap srcCTE)) (cteMDBNode srcCTE)"
@@ -4959,38 +4910,41 @@ crunch valid_list[wp]: set_untyped_cap_as_full valid_list
 
 lemma updateMDB_the_lot':
   assumes "(x, s'') \<in> fst (updateMDB p f s')"
-  assumes "pspace_relations (ekheap sa) (kheap s) (ksPSpace s')"
-  assumes "pspace_aligned' s'" "pspace_distinct' s'" "no_0 (ctes_of s')" "ekheap s = ekheap sa"
+  assumes "pspace_relation (kheap s) (ksPSpace s')"
+  assumes "pspace_aligned' s'" "pspace_distinct' s'" "no_0 (ctes_of s')"
   shows "ctes_of s'' = modify_map (ctes_of s') p (cteMDBNode_update f) \<and>
          ksMachineState s'' = ksMachineState s' \<and>
          ksWorkUnitsCompleted s'' = ksWorkUnitsCompleted s' \<and>
          ksCurThread s'' = ksCurThread s' \<and>
          ksIdleThread s'' = ksIdleThread s' \<and>
+         ksIdleSC s'' = ksIdleSC s' \<and>
          ksReadyQueues s'' = ksReadyQueues s' \<and>
+         ksReleaseQueue s'' = ksReleaseQueue s' \<and>
          ksSchedulerAction s'' = ksSchedulerAction s' \<and>
          ksInterruptState s'' = ksInterruptState s' \<and>
          ksArchState s'' = ksArchState s' \<and>
          gsUserPages s'' = gsUserPages s' \<and>
          gsCNodes s'' = gsCNodes s' \<and>
-         pspace_relations (ekheap s) (kheap s) (ksPSpace s'') \<and>
+         pspace_relation (kheap s) (ksPSpace s'') \<and>
          pspace_aligned' s'' \<and> pspace_distinct' s'' \<and>
          no_0 (ctes_of s'') \<and>
          ksDomScheduleIdx s'' = ksDomScheduleIdx s' \<and>
          ksDomSchedule s''    = ksDomSchedule s' \<and>
          ksCurDomain s''      = ksCurDomain s' \<and>
-         ksDomainTime s''     = ksDomainTime s'"
-  apply (rule updateMDB_the_lot)
-      using assms
-      apply (fastforce simp: pspace_relations_def)+
-      done
+         ksDomainTime s''     = ksDomainTime s' \<and>
+         ksConsumedTime s''   = ksConsumedTime s' \<and>
+         ksCurTime s''        = ksCurTime s' \<and>
+         ksCurSc s''          = ksCurSc s' \<and>
+         ksReprogramTimer s'' = ksReprogramTimer s' \<and>
+         replyPrevs_of s'' = replyPrevs_of s' \<and>
+         scReplies_of s'' = scReplies_of s'"
+  by (rule updateMDB_the_lot; fastforce intro: assms)
 
 lemma cte_map_inj_eq':
-  "\<lbrakk>(cte_map p = cte_map p');
-   cte_at p s \<and> cte_at p' s \<and>
-   valid_objs s \<and> pspace_aligned s \<and> pspace_distinct s\<rbrakk>
+  "\<lbrakk> cte_map p = cte_map p';
+     cte_at p s \<and> cte_at p' s \<and> valid_objs s \<and> pspace_aligned s \<and> pspace_distinct s\<rbrakk>
   \<Longrightarrow> p = p'"
-  apply (rule cte_map_inj_eq; fastforce)
-  done
+  by (rule cte_map_inj_eq; fastforce)
 
 context begin interpretation Arch . (*FIXME: arch_split*)
 lemma cteInsert_corres:
@@ -5045,13 +4999,12 @@ lemma cteInsert_corres:
                 apply (simp+)[3]
              apply (clarsimp simp: corres_underlying_def state_relation_def
                                    in_monad valid_mdb'_def valid_mdb_ctes_def)
-             apply (drule (1) pspace_relationsD)
-             apply (drule (18) set_cap_not_quite_corres)
+             apply (drule (22) set_cap_not_quite_corres)
+               apply fastforce
               apply (rule refl)
              apply (elim conjE exE)
              apply (rule bind_execI, assumption)
-             apply (subgoal_tac "mdb_insert_abs (cdt a) src dest")
-              prefer 2
+             apply (prop_tac "mdb_insert_abs (cdt a) src dest")
               apply (erule mdb_insert_abs.intro)
               apply (rule mdb_Null_None)
               apply (simp add: op_equal)
@@ -5059,27 +5012,28 @@ lemma cteInsert_corres:
               apply (rule mdb_Null_descendants)
               apply (simp add: op_equal)
               apply simp
-             apply (subgoal_tac "no_mloop (cdt a)")
-              prefer 2
+             apply (prop_tac "no_mloop (cdt a)")
               apply (simp add: valid_mdb_def)
              apply (clarsimp simp: exec_gets update_cdt_def bind_assoc
-                              set_cdt_def
-                              exec_get exec_put set_original_def modify_def simp del: fun_upd_apply
-                                | (rule bind_execI[where f="cap_insert_ext x y z i p" for x y z i p], clarsimp simp: exec_gets exec_get put_def mdb_insert_abs.cap_insert_ext_det_def2 update_cdt_list_def set_cdt_list_def, rule refl))+
+                                   set_cdt_def exec_get exec_put set_original_def modify_def
+                         simp del: fun_upd_apply
+                   | (rule bind_execI[where f="cap_insert_ext x y z i p" for x y z i p],
+                      clarsimp simp: exec_gets exec_get put_def
+                                     mdb_insert_abs.cap_insert_ext_det_def2 update_cdt_list_def
+                                     set_cdt_list_def,
+                      rule refl))+
              apply (clarsimp simp: put_def state_relation_def)
              apply (drule updateCap_stuff)
              apply clarsimp
              apply (drule (3) updateMDB_the_lot', simp, simp, elim conjE)
              apply (drule (3) updateMDB_the_lot', simp, simp, elim conjE)
-             apply (drule (3) updateMDB_the_lot', simp, simp,  elim conjE)
+             apply (drule (3) updateMDB_the_lot', simp, simp, elim conjE)
              apply (clarsimp simp: cte_wp_at_ctes_of nullPointer_def
                               prev_update_modify_mdb_relation)
-             apply (subgoal_tac "cte_map dest \<noteq> 0")
-              prefer 2
+             apply (prop_tac "cte_map dest \<noteq> 0")
               apply (clarsimp simp: valid_mdb'_def
                                valid_mdb_ctes_def no_0_def)
-             apply (subgoal_tac "cte_map src \<noteq> 0")
-              prefer 2
+             apply (prop_tac "cte_map src \<noteq> 0")
               apply (clarsimp simp: valid_mdb'_def
                                valid_mdb_ctes_def no_0_def)
              apply (thin_tac "ksMachineState t = p" for p t)+
@@ -5087,7 +5041,6 @@ lemma cteInsert_corres:
              apply (thin_tac "ksIdleThread t = p" for p t)+
              apply (thin_tac "ksReadyQueues t = p" for p t)+
              apply (thin_tac "ksSchedulerAction t = p" for p t)+
-             apply (clarsimp simp: pspace_relations_def)
 
              apply (rule conjI)
               apply (clarsimp simp: ghost_relation_typ_at set_cap_a_type_inv data_at_def)
@@ -5102,13 +5055,11 @@ lemma cteInsert_corres:
                apply (case_tac "rv'")
                apply (rename_tac dest_node)
                apply (clarsimp simp: in_set_cap_cte_at_swp)
-               apply (subgoal_tac "cte_at src a \<and> is_derived (cdt a) src c src_cap")
-                prefer 2
+               apply (prop_tac "cte_at src a \<and> is_derived (cdt a) src c src_cap")
                 apply (fastforce simp: cte_wp_at_def)
                apply (erule conjE)
-               apply (subgoal_tac "mdb_insert (ctes_of b) (cte_map src) (maskedAsFull src_cap' c') src_node
+               apply (prop_tac "mdb_insert (ctes_of b) (cte_map src) (maskedAsFull src_cap' c') src_node
                                   (cte_map dest) NullCap dest_node")
-                prefer 2
                 apply (rule mdb_insert.intro)
                   apply (rule mdb_ptr.intro)
                    apply (rule vmdb.intro, simp add: valid_mdb_ctes_def)
@@ -5220,8 +5171,7 @@ lemma cteInsert_corres:
                  subgoal by(fastforce)
                 apply(simp)
                 apply(rule impI)
-                apply(subgoal_tac "cte_at ca a")
-                 prefer 2
+                apply(prop_tac "cte_at ca a")
                  apply(rule cte_at_next_slot)
                     apply(simp_all)[4]
                 apply(clarsimp simp: modify_map_def const_def)
@@ -5373,12 +5323,9 @@ lemma cteInsert_corres:
                    apply(case_tac z)
                    apply(erule_tac x="(aa, bb)" in allE)+
                    subgoal by(fastforce)
-                  apply(drule cte_map_inj_eq')
-                       apply(simp_all)[2]
-                 apply(drule cte_map_inj_eq')
-                      apply(simp_all)[2]
-                apply(drule cte_map_inj_eq')
-                     apply(simp_all)[2]
+                  apply(drule cte_map_inj_eq'; simp)
+                 apply(drule cte_map_inj_eq'; simp)
+                apply(drule cte_map_inj_eq'; simp)
                apply(erule_tac x="(aa, bb)" in allE)+
                subgoal by(fastforce)
               apply (thin_tac "ctes_of t = t'" for t t')+
@@ -5386,8 +5333,7 @@ lemma cteInsert_corres:
               apply (clarsimp simp: revokable_relation_def  split: if_split)
               apply (rule conjI)
               apply clarsimp
-               apply (subgoal_tac "mdbRevocable node = revokable' (cteCap srcCTE) c'")
-                prefer 2
+               apply (prop_tac "mdbRevocable node = revokable' (cteCap srcCTE) c'")
                 apply (case_tac rv')
                 subgoal by (clarsimp simp add: const_def modify_map_def split: if_split_asm)
                apply simp
@@ -5403,8 +5349,7 @@ lemma cteInsert_corres:
               apply (case_tac srcCTE)
               apply (case_tac rv')
               apply clarsimp
-              apply (subgoal_tac "\<exists>cap' node'. ctes_of b (cte_map (aa,bb)) = Some (CTE cap' node')")
-               prefer 2
+              apply (prop_tac "\<exists>cap' node'. ctes_of b (cte_map (aa,bb)) = Some (CTE cap' node')")
                apply (clarsimp simp: modify_map_def split: if_split_asm)
                apply (case_tac z)
                subgoal by clarsimp
@@ -5415,8 +5360,7 @@ lemma cteInsert_corres:
                subgoal by (clarsimp simp: cte_wp_at_caps_of_state null_filter_def split: if_splits)
 
               apply clarsimp
-              apply (subgoal_tac "cte_at (aa,bb) a")
-               prefer 2
+              apply (prop_tac "cte_at (aa,bb) a")
                apply (drule null_filter_caps_of_stateD)
                apply (erule cte_wp_at_weakenE, rule TrueI)
               apply (subgoal_tac "mdbRevocable node = mdbRevocable node'")
@@ -5424,7 +5368,6 @@ lemma cteInsert_corres:
               apply (subgoal_tac "cte_map (aa,bb) \<noteq> cte_map dest")
                subgoal by (clarsimp simp: modify_map_def split: if_split_asm)
               apply (erule (5) cte_map_inj)
-(* FIXME *)
 
              apply (rule setUntypedCapAsFull_corres)
                    apply simp+
@@ -5444,13 +5387,11 @@ lemma cteInsert_corres:
   apply (case_tac "rv'")
   apply (rename_tac dest_node)
   apply (clarsimp simp: in_set_cap_cte_at_swp)
-  apply (subgoal_tac "cte_at src a \<and> is_derived (cdt a) src c src_cap")
-   prefer 2
+  apply (prop_tac "cte_at src a \<and> is_derived (cdt a) src c src_cap")
    subgoal by (fastforce simp: cte_wp_at_def)
   apply (erule conjE)
-  apply (subgoal_tac "mdb_insert (ctes_of b) (cte_map src) (maskedAsFull src_cap' c') src_node
+  apply (prop_tac "mdb_insert (ctes_of b) (cte_map src) (maskedAsFull src_cap' c') src_node
                                  (cte_map dest) NullCap dest_node")
-   prefer 2
    apply (rule mdb_insert.intro)
      apply (rule mdb_ptr.intro)
       subgoal by (rule vmdb.intro, simp add: valid_mdb_ctes_def)
@@ -5469,12 +5410,10 @@ lemma cteInsert_corres:
    apply (rule mdb_insert_der_axioms.intro)
    apply (simp add: is_derived_eq)
   apply (simp (no_asm_simp) add: cdt_relation_def split: if_split)
-  apply (subgoal_tac "descendants_of dest (cdt a) = {}")
-   prefer 2
+  apply (prop_tac "descendants_of dest (cdt a) = {}")
    apply (drule mdb_insert.dest_no_descendants)
    subgoal by (fastforce simp add: cdt_relation_def simp del: split_paired_All)
-  apply (subgoal_tac "mdb_insert_abs (cdt a) src dest")
-   prefer 2
+  apply (prop_tac "mdb_insert_abs (cdt a) src dest")
    apply (erule mdb_insert_abs.intro)
     apply (rule mdb_None)
       apply (erule(1) mdb_insert.descendants_not_dest)
@@ -5564,7 +5503,8 @@ lemma cteInsert_corres:
   subgoal by (simp add: cdt_relation_def del: split_paired_All)
   done
 
-
+(* FIXME RT: This is the sort of crap we should get rid of when possible, or
+   at least make it more localised. VER-1250 *)
 declare if_split [split]
 
 lemma updateCap_no_0:
@@ -6530,10 +6470,10 @@ lemma cteSwap_corres:
   apply (clarsimp simp: corres_underlying_def in_monad
                         state_relation_def)
   apply (clarsimp simp: valid_mdb'_def)
-  apply (drule(1) pspace_relationsD)
-  apply (drule (12) set_cap_not_quite_corres)
-      apply (erule cte_wp_at_weakenE, rule TrueI)
-     apply assumption+
+  apply (drule (16) set_cap_not_quite_corres)
+          apply fastforce
+         apply (erule cte_wp_at_weakenE, rule TrueI)
+        apply assumption+
    apply (rule refl)
   apply (elim exE conjE)
   apply (rule bind_execI, assumption)
@@ -6551,8 +6491,9 @@ lemma cteSwap_corres:
                          use_valid [OF _ set_cap_distinct]
                          cte_wp_at_weakenE)
   apply (elim conjE)
-  apply (drule (14) set_cap_not_quite_corres)
-       apply simp
+  apply (drule (18) set_cap_not_quite_corres)
+        apply simp
+       apply fastforce
       apply assumption+
    apply (rule refl)
   apply (elim exE conjE)
@@ -6565,13 +6506,19 @@ lemma cteSwap_corres:
         | rule refl | clarsimp simp: put_def simp del: fun_upd_apply )+
   apply (simp cong: option.case_cong)
   apply (drule updateCap_stuff, elim conjE, erule(1) impE)
-  apply (drule (2) updateMDB_the_lot', fastforce, fastforce, simp, clarsimp)
-  apply (drule (2) updateMDB_the_lot', fastforce, fastforce, simp, clarsimp)
+  apply (drule (2) updateMDB_the_lot', solves \<open>simp (no_asm_simp)\<close>,
+         erule valid_mdb_ctesE, solves \<open>simp (no_asm_simp)\<close>, clarsimp)
+  apply (drule (2) updateMDB_the_lot', solves \<open>simp (no_asm_simp)\<close>,
+         erule valid_mdb_ctesE, solves \<open>simp (no_asm_simp)\<close>, clarsimp)
   apply (drule in_getCTE, clarsimp)
-  apply (drule (2) updateMDB_the_lot', fastforce, fastforce, simp, clarsimp)
-  apply (drule (2) updateMDB_the_lot', fastforce, fastforce, simp, clarsimp)
-  apply (drule (2) updateMDB_the_lot', fastforce, fastforce, simp, clarsimp)
-  apply (drule (2) updateMDB_the_lot', fastforce, fastforce, simp, clarsimp)
+  apply (drule (2) updateMDB_the_lot', solves \<open>simp (no_asm_simp)\<close>,
+         erule valid_mdb_ctesE, solves \<open>simp (no_asm_simp)\<close>, clarsimp)
+  apply (drule (2) updateMDB_the_lot', solves \<open>simp (no_asm_simp)\<close>,
+         erule valid_mdb_ctesE, solves \<open>simp (no_asm_simp)\<close>, clarsimp)
+  apply (drule (2) updateMDB_the_lot', solves \<open>simp (no_asm_simp)\<close>,
+         erule valid_mdb_ctesE, solves \<open>simp (no_asm_simp)\<close>, clarsimp)
+  apply (drule (2) updateMDB_the_lot', solves \<open>simp (no_asm_simp)\<close>,
+         erule valid_mdb_ctesE, solves \<open>simp (no_asm_simp)\<close>, clarsimp)
   apply (thin_tac "ksMachineState t = p" for t p)+
   apply (thin_tac "ksCurThread t = p" for t p)+
   apply (thin_tac "ksReadyQueues t = p" for t p)+
@@ -6603,7 +6550,7 @@ lemma cteSwap_corres:
      apply (erule weak_derived_sym')
     apply (erule weak_derived_sym')
    apply assumption
-  apply (clarsimp simp: pspace_relations_def)
+
   apply (rule conjI)
    apply (clarsimp simp: ghost_relation_typ_at set_cap_a_type_inv ARM.data_at_def)
   apply(subst conj_assoc[symmetric])
@@ -6746,54 +6693,35 @@ lemma cteSwap_corres:
     apply(fastforce split: option.split)
    apply(simp)
   apply(frule finite_depth)
-  apply(frule mdb_swap.n_next)
-   apply(simp)
+  apply(frule mdb_swap.n_next; (simp (no_asm_simp))?)
   apply(case_tac "(aa, bb)=src")
    apply(case_tac "next_slot dest (cdt_list (a)) (cdt a) = Some src")
     apply(simp)
     apply(erule_tac x="fst dest" in allE, erule_tac x="snd dest" in allE)
     apply(simp)
    apply(simp)
-   apply(case_tac "next_slot dest (cdt_list (a)) (cdt a)")
-    apply(simp)
-   apply(simp)
+   apply(case_tac "next_slot dest (cdt_list (a)) (cdt a)"; (simp (no_asm_simp))?)
    apply(erule_tac x="fst dest" in allE, erule_tac x="snd dest" in allE)
    apply(simp)
    apply(subgoal_tac "mdbNext dest_node \<noteq> cte_map src")
     apply(simp)
    apply(simp)
-   apply(rule_tac s=a in cte_map_inj)
-        apply(simp)
-       apply(rule cte_at_next_slot')
-          apply(simp)
-         apply(simp)
-        apply(simp)
-       apply(simp)
-      apply(erule cte_wp_at_weakenE, rule TrueI)
-     apply(simp_all)[3]
+   apply(rule_tac s=a in cte_map_inj; (simp (no_asm_simp))?)
+    apply(rule cte_at_next_slot'; (simp (no_asm_simp))?)
+   apply(erule cte_wp_at_weakenE, rule TrueI)
   apply(case_tac "(aa, bb)=dest")
    apply(case_tac "next_slot src (cdt_list (a)) (cdt a) = Some dest")
     apply(simp)
     apply(erule_tac x="fst src" in allE, erule_tac x="snd src" in allE)
     apply(simp)
    apply(simp)
-   apply(case_tac "next_slot src (cdt_list (a)) (cdt a)")
-    apply(simp)
-   apply(simp)
+   apply(case_tac "next_slot src (cdt_list (a)) (cdt a)"; (simp (no_asm_simp))?)
    apply(erule_tac x="fst src" in allE, erule_tac x="snd src" in allE)
    apply(simp)
-   apply(subgoal_tac "mdbNext src_node \<noteq> cte_map dest")
-    apply(simp)
-   apply(simp)
-   apply(rule_tac s=a in cte_map_inj)
-        apply(simp)
-       apply(rule cte_at_next_slot')
-          apply(simp)
-         apply(simp)
-        apply(simp)
-       apply(simp)
-      apply(erule cte_wp_at_weakenE, rule TrueI)
-     apply(simp_all)[3]
+   apply(subgoal_tac "mdbNext src_node \<noteq> cte_map dest"; (simp (no_asm_simp))?)
+   apply(rule_tac s=a in cte_map_inj; (simp (no_asm_simp))?)
+    apply(rule cte_at_next_slot'; (simp (no_asm_simp))?)
+   apply(erule cte_wp_at_weakenE, rule TrueI)
   apply(case_tac "next_slot (aa, bb) (cdt_list (a)) (cdt a) = Some src")
    apply(simp)
    apply(erule_tac x=aa in allE, erule_tac x=bb in allE)
@@ -6804,24 +6732,20 @@ lemma cteSwap_corres:
                         cte_map (aa, bb) = mdbPrev src_node")
      apply(clarsimp)
     apply(rule conjI)
-     apply(rule cte_map_inj)
-          apply(simp_all)[6]
+     apply(rule cte_map_inj; (simp (no_asm_simp))?)
      apply(erule cte_wp_at_weakenE, simp)
     apply(rule conjI)
-     apply(rule cte_map_inj)
-          apply(simp_all)[6]
-     apply(erule cte_wp_at_weakenE, simp)
-    apply(frule mdb_swap.m_exists)
-     apply(simp)
+     apply(rule cte_map_inj; (simp (no_asm_simp))?)
+     apply(erule cte_wp_at_weakenE, simp (no_asm_simp))
+    apply(frule mdb_swap.m_exists, simp (no_asm_simp))
     apply(clarsimp)
     apply(frule_tac cte="CTE cap' node'" in valid_mdbD1')
       apply(clarsimp)
-     apply(simp add: valid_mdb'_def)
+     apply(simp (no_asm_simp) add: valid_mdb'_def)
     apply(clarsimp)
-   apply(rule cte_at_next_slot)
-      apply(simp_all)[4]
+   apply(rule cte_at_next_slot; simp (no_asm_simp))
   apply(case_tac "next_slot (aa, bb) (cdt_list (a)) (cdt a) = Some dest")
-   apply(simp)
+   apply(simp (no_asm_simp))
    apply(erule_tac x=aa in allE, erule_tac x=bb in allE)
    apply(simp)
    apply(subgoal_tac "cte_at (aa, bb) a")
@@ -6832,25 +6756,22 @@ lemma cteSwap_corres:
       apply(clarsimp)
      apply(clarsimp simp: mdb_swap.prev_dest_src)
     apply(rule conjI)
-     apply(rule cte_map_inj)
-          apply(simp_all)[6]
-     apply(erule cte_wp_at_weakenE, simp)
+     apply(rule cte_map_inj; (simp (no_asm_simp))?)
+     apply(erule cte_wp_at_weakenE, simp (no_asm_simp))
     apply(rule conjI)
-     apply(rule cte_map_inj)
-          apply(simp_all)[6]
-     apply(erule cte_wp_at_weakenE, simp)
+     apply(rule cte_map_inj; (simp (no_asm_simp))?)
+     apply(erule cte_wp_at_weakenE, simp (no_asm_simp))
     apply(frule mdb_swap.m_exists)
-     apply(simp)
+     apply(simp (no_asm_simp))
     apply(clarsimp)
     apply(frule_tac cte="CTE cap' node'" in valid_mdbD1')
       apply(clarsimp)
-     apply(simp add: valid_mdb'_def)
+     apply(simp (no_asm_simp) add: valid_mdb'_def)
     apply(clarsimp)
-   apply(rule cte_at_next_slot)
-      apply(simp_all)[4]
-  apply(simp)
+   apply(rule cte_at_next_slot; (simp (no_asm_simp))?)
+  apply(simp (no_asm_simp))
   apply(case_tac "next_slot (aa, bb) (cdt_list (a)) (cdt a)")
-   apply(simp)
+   apply(simp (no_asm_simp))
   apply(clarsimp)
   apply(erule_tac x=aa in allE, erule_tac x=bb in allE)
   apply(simp)
@@ -6861,39 +6782,37 @@ lemma cteSwap_corres:
                       cte_map (aa, bb) \<noteq> mdbPrev dest_node")
     apply(clarsimp)
    apply(rule conjI)
-    apply(rule cte_map_inj)
-         apply(simp_all)[6]
-    apply(erule cte_wp_at_weakenE, simp)
+    apply(rule cte_map_inj; (simp (no_asm_simp))?)
+    apply(erule cte_wp_at_weakenE, simp (no_asm_simp))
    apply(rule conjI)
-    apply(rule cte_map_inj)
-         apply simp_all[6]
-    apply(erule cte_wp_at_weakenE, simp)
+    apply(rule cte_map_inj; (simp (no_asm_simp))?)
+    apply(erule cte_wp_at_weakenE, simp (no_asm_simp))
    apply(rule conjI)
     apply(frule mdb_swap.m_exists)
-     apply(simp)
+     apply(simp (no_asm_simp))
     apply(clarsimp)
      apply(frule_tac cte="CTE src_cap src_node" in valid_mdbD2')
-      subgoal by (clarsimp)
-     apply(simp add: valid_mdb'_def)
+     subgoal by (clarsimp)
+     apply(simp (no_asm_simp) add: valid_mdb'_def)
     apply(clarsimp)
-    apply(drule cte_map_inj_eq)
-         apply(rule cte_at_next_slot')
-            apply(simp_all)[9]
-    apply(erule cte_wp_at_weakenE, simp)
+    apply(drule cte_map_inj_eq; (simp (no_asm_simp))?)
+      apply(rule cte_at_next_slot'; simp (no_asm_simp))
+     apply(erule cte_wp_at_weakenE, simp (no_asm_simp))
+    apply simp
    apply(frule mdb_swap.m_exists)
-    apply(simp)
+    apply(simp (no_asm_simp))
    apply(clarsimp)
    apply(frule_tac cte="CTE dest_cap dest_node" in valid_mdbD2')
      apply(clarsimp)
-    apply(simp add: valid_mdb'_def)
+    apply(simp (no_asm_simp) add: valid_mdb'_def)
    apply(clarsimp)
-   apply(drule cte_map_inj_eq)
-         apply(rule cte_at_next_slot')
-           apply(simp_all)[9]
-    apply(erule cte_wp_at_weakenE, simp)
-  apply(rule cte_at_next_slot)
-     apply(simp_all)
-     done
+   apply(drule cte_map_inj_eq; (simp (no_asm_simp))?)
+     apply(rule cte_at_next_slot'; simp (no_asm_simp))
+    apply(erule cte_wp_at_weakenE)
+    apply (simp (no_asm_simp))
+   apply simp
+  apply(rule cte_at_next_slot; simp (no_asm_simp))
+  done
 
 
 lemma capSwapForDelete_corres:

--- CSpace_R.thy
+++ CSpace_R.thy
@@ -728,28 +729,33 @@ lemma set_cap_not_quite_corres':
   assumes c: "cap_relation c c'"
   assumes p: "p' = cte_map p"
   shows "\<exists>t. ((),t) \<in> fst (set_cap c p s) \<and>
-             pspace_relations (ekheap t) (kheap t) (ksPSpace t') \<and>
+             pspace_relation (kheap t) (ksPSpace t') \<and>
              cdt t              = cdt s \<and>
              cdt_list t         = cdt_list (s) \<and>
-             ekheap t           = ekheap (s) \<and>
              scheduler_action t = scheduler_action (s) \<and>
              ready_queues t     = ready_queues (s) \<and>
+             release_queue t = release_queue s \<and>
              is_original_cap t  = is_original_cap s \<and>
              interrupt_state_relation (interrupt_irq_node t) (interrupt_states t)
                               (ksInterruptState t') \<and>
              (arch_state t, ksArchState t') \<in> arch_state_relation \<and>
              cur_thread t    = ksCurThread t' \<and>
              idle_thread t   = ksIdleThread t' \<and>
+             idle_sc_ptr     = ksIdleSC t' \<and>
              machine_state t = ksMachineState t' \<and>
              work_units_completed t = ksWorkUnitsCompleted t' \<and>
              domain_index t  = ksDomScheduleIdx t' \<and>
              domain_list t   = ksDomSchedule t' \<and>
              cur_domain t    = ksCurDomain t' \<and>
-             domain_time t   = ksDomainTime t'"
-  apply (rule set_cap_not_quite_corres)
-                using cr
-                apply (fastforce simp: c p pspace_relations_def)+
-                done
+             domain_time t   = ksDomainTime t' \<and>
+             consumed_time t = ksConsumedTime t' \<and>
+             cur_time t = ksCurTime t' \<and>
+             cur_sc t = ksCurSc t' \<and>
+             reprogram_timer t = ksReprogramTimer t' \<and>
+             sc_replies_of t = sc_replies_of s"
+  using cr
+  by (rule set_cap_not_quite_corres; fastforce simp: c p)
+
 context begin interpretation Arch . (*FIXME: arch_split*)
 lemma cteMove_corres:
   assumes cr: "cap_relation cap cap'"
@@ -945,8 +947,7 @@ lemma cteMove_corres:
      apply fastforce
     apply clarsimp
    subgoal by (simp add: null_filter_def split: if_splits)
-  apply (subgoal_tac "mdb_move (ctes_of b) (cte_map ptr) src_cap src_node (cte_map ptr') cap' old_dest_node")
-   prefer 2
+  apply (prop_tac "mdb_move (ctes_of b) (cte_map ptr) src_cap src_node (cte_map ptr') cap' old_dest_node")
    apply (rule mdb_move.intro)
     apply (rule mdb_ptr.intro)
      apply (rule vmdb.intro)
@@ -2342,175 +2351,160 @@ proof -
 
 
   show "valid_badges ?C"
-  using srcdest badge cofs badges cofd
-  unfolding valid_badges_def
-  apply (intro impI allI)
-  apply (drule mdb_next_disj)
-  apply (elim disjE)
-    defer
-    apply (clarsimp simp:modify_map_cases dest0 src0)
-    apply (clarsimp simp:revokable'_def badge_derived'_def)
-    subgoal by (case_tac src_cap,auto simp:isCap_simps sameRegionAs_def)
-  apply (clarsimp simp:modify_map_cases valid_badges_def)
-    apply (frule_tac x=src in spec, erule_tac x=word1 in allE, erule allE, erule impE)
-    apply fastforce
-    apply simp
-    apply (clarsimp simp:mdb_next_unfold badge_derived'_def split: if_split_asm)
-    apply (thin_tac "All P" for P)
-    subgoal by (cases src_cap,
-       auto simp:mdb_next_unfold isCap_simps sameRegionAs_def Let_def split: if_splits)
-  apply (case_tac "word1 = p'")
+    using srcdest badge cofs badges cofd
+    unfolding valid_badges_def
+    apply (intro impI allI)
+    apply (drule mdb_next_disj)
+    apply (elim disjE)
+      defer
+      apply (clarsimp simp:modify_map_cases dest0 src0)
+      apply (clarsimp simp:revokable'_def badge_derived'_def)
+      subgoal by (case_tac src_cap,auto simp:isCap_simps sameRegionAs_def)
+     apply (clarsimp simp:modify_map_cases valid_badges_def)
+     apply (frule_tac x=src in spec, erule_tac x=word1 in allE, erule allE, erule impE)
+      apply fastforce
+     apply simp
+     apply (clarsimp simp:mdb_next_unfold badge_derived'_def split: if_split_asm)
+     apply (thin_tac "All P" for P)
+     subgoal by (cases src_cap,
+                 auto simp:mdb_next_unfold isCap_simps sameRegionAs_def Let_def split: if_splits)
+    apply (case_tac "word1 = p'")
      apply (clarsimp simp:modify_map_cases valid_badges_def mdb_next_unfold src0 dest0 no0)+
-  apply (case_tac "p = dest")
-   apply (clarsimp simp:dest0 src0 no0)+
-  apply (case_tac z)
-  apply (rename_tac capability mdbnode)
-  apply clarsimp
-  apply (drule_tac x = p in spec,drule_tac x = "mdbNext mdbnode" in spec)
-  by (auto simp:isCap_simps sameRegionAs_def)
+    apply (case_tac "p = dest")
+     apply (clarsimp simp:dest0 src0 no0)+
+    apply (case_tac z)
+    apply (rename_tac capability mdbnode)
+    apply clarsimp
+    apply (drule_tac x = p in spec,drule_tac x = "mdbNext mdbnode" in spec)
+    by (auto simp:isCap_simps sameRegionAs_def)
 
   from badge
   have isUntyped_eq: "isUntypedCap cap = isUntypedCap src_cap"
-   apply (clarsimp simp:badge_derived'_def)
-   apply (case_tac cap,auto simp:isCap_simps)
-   done
+    apply (clarsimp simp:badge_derived'_def)
+    apply (case_tac cap,auto simp:isCap_simps)
+    done
 
   from badge
   have [simp]: "capRange cap = capRange src_cap"
-   apply (clarsimp simp:badge_derived'_def)
-   apply (case_tac cap)
-     apply (clarsimp simp:isCap_simps capRange_def)+
-    (* 5 subgoals *)
+    apply (clarsimp simp:badge_derived'_def)
+    apply (case_tac cap; clarsimp simp:isCap_simps capRange_def)
     apply (rename_tac arch_capability)
-    apply (case_tac arch_capability)
-     (* 9 subgoals *)
-     apply (clarsimp simp:isCap_simps capRange_def)+
-   done
+    apply (case_tac arch_capability; clarsimp simp:isCap_simps capRange_def)
+    done
 
   have [simp]: "untypedRange cap = untypedRange src_cap"
-     using badge
-     apply (clarsimp simp:badge_derived'_def dest!:capMaster_untypedRange)
-     done
+    using badge
+    apply (clarsimp simp:badge_derived'_def dest!:capMaster_untypedRange)
+    done
 
   from contained badge srcdest cofs cofd is_der no0
   show "caps_contained' ?C"
-  apply (clarsimp simp add: caps_contained'_def)
-  apply (case_tac "p = dest")
-   apply (case_tac "p' = dest")
-    apply (clarsimp simp:modify_map_def split:if_splits)
-    apply (case_tac src_cap,auto)[1]
-   apply (case_tac "p' = src")
-    apply (clarsimp simp:modify_map_def split:if_splits)
-    apply (clarsimp simp:badge_derived'_def)
-    apply (case_tac src_cap,auto)[1]
-   apply (drule(2) ctes_ofD)
-   apply (clarsimp simp:modify_map_def split:if_splits)
-   apply (frule capRange_untyped)
-   apply (erule_tac x=src in allE, erule_tac x=p' in allE, simp)
-    apply (case_tac cteb)
-    apply (clarsimp)
-    apply blast
-   apply (case_tac "p' = dest")
-    apply (case_tac "p = src")
+    apply (clarsimp simp add: caps_contained'_def)
+    apply (case_tac "p = dest")
+     apply (case_tac "p' = dest")
+      apply (clarsimp simp:modify_map_def split:if_splits)
+      apply (case_tac src_cap,auto)[1]
+     apply (case_tac "p' = src")
+      apply (clarsimp simp:modify_map_def split:if_splits)
+      apply (clarsimp simp:badge_derived'_def)
+      apply (case_tac src_cap,auto)[1]
+     apply (drule(2) ctes_ofD)
      apply (clarsimp simp:modify_map_def split:if_splits)
-     apply (drule capRange_untyped)
-     subgoal by (case_tac cap,auto simp:isCap_simps badge_derived'_def)
-    apply (clarsimp simp:modify_map_def split:if_splits)
-    apply (drule_tac x = word1 in spec)
-    apply (drule_tac x = src in spec)
-    apply (case_tac z)
-    apply (clarsimp simp:isUntyped_eq)
-    apply blast
+     apply (frule capRange_untyped)
+     apply (erule_tac x=src in allE, erule_tac x=p' in allE, simp)
+     apply (case_tac cteb)
+     apply (clarsimp)
+     apply blast
+    apply (case_tac "p' = dest")
+     apply (case_tac "p = src")
+      apply (clarsimp simp:modify_map_def split:if_splits)
+      apply (drule capRange_untyped)
+    subgoal by (case_tac cap,auto simp:isCap_simps badge_derived'_def)
+     apply (clarsimp simp:modify_map_def split:if_splits)
+      apply (drule_tac x = word1 in spec)
+      apply (drule_tac x = src in spec)
+      apply (case_tac z)
+      apply (clarsimp simp:isUntyped_eq)
+      apply blast
+     apply (drule_tac x = p in spec)
+     apply (drule_tac x = src in spec)
+     apply (frule capRange_untyped)
+     apply (clarsimp simp:isUntyped_eq)
+     apply blast
     apply (drule_tac x = p in spec)
-    apply (drule_tac x = src in spec)
-    apply (frule capRange_untyped)
-    apply (clarsimp simp:isUntyped_eq)
-    apply blast
-   apply (drule_tac x = p in spec)
-   apply (drule_tac x = p' in spec)
-   apply (clarsimp simp:modify_map_def split:if_splits)
-    apply ((case_tac z,fastforce)+)[5]
-   by fastforce+
+    apply (drule_tac x = p' in spec)
+    apply (clarsimp simp:modify_map_def split:if_splits)
+            apply ((case_tac z,fastforce)+)[5]
+    by fastforce+
 
   show "valid_nullcaps ?C"
-  using is_der vn cofs vd no0
-  apply (simp add: valid_nullcaps_def srcdest [symmetric])
-  apply (clarsimp simp:modify_map_def is_derived'_def)
-  apply (rule conjI)
-    apply (clarsimp simp: is_derived'_def badge_derived'_def)+
-  apply (drule_tac x = word1 in spec)
-  apply (case_tac z)
-  apply (clarsimp simp:nullMDBNode_def)
-  apply (drule(1) valid_dlist_nextD)
-    apply simp
-   apply clarsimp
-  apply (simp add:nullPointer_def src0)
-  done
+    using is_der vn cofs vd no0
+    apply (simp add: valid_nullcaps_def)
+    apply (clarsimp simp:modify_map_def is_derived'_def)
+    apply (rule conjI)
+     apply (clarsimp simp: is_derived'_def badge_derived'_def)+
+    apply (drule_tac x = word1 in spec)
+    apply (case_tac z)
+    apply (clarsimp simp:nullMDBNode_def)
+    apply (drule(1) valid_dlist_nextD)
+     apply simp
+     apply clarsimp
+    apply (simp add:nullPointer_def src0)
+    done
 
   from vmdb srcdest cofs ut_rev
   show "ut_revocable' ?C"
-  apply (clarsimp simp: valid_mdb_ctes_def ut_revocable'_def modify_map_def)
-  apply (rule conjI)
-   apply clarsimp
-   apply (clarsimp simp: revokable'_def isCap_simps)+
-   apply auto
-  apply (drule_tac x= src in spec)
-   apply clarsimp
-  apply (case_tac z)
-   apply clarsimp
-  done
+    apply (clarsimp simp: valid_mdb_ctes_def ut_revocable'_def modify_map_def)
+    apply (rule conjI)
+     apply clarsimp
+     apply (clarsimp simp: revokable'_def isCap_simps)+
+    apply auto
+     apply (drule_tac x= src in spec)
+     apply clarsimp
+    apply (case_tac z)
+    apply clarsimp
+    done
 
   from class_links srcdest badge cofs cofd no0 vd
   show "class_links ?C"
-  unfolding class_links_def
-  apply (intro allI impI)
-  apply (drule mdb_next_disj)
-  apply (elim disjE)
-    apply (clarsimp simp:modify_map_def mdb_next_unfold split:if_split_asm)
-   apply (clarsimp simp: badge_derived'_def modify_map_def
-    split: if_split_asm)
-   apply (erule capMaster_capClass)
-  apply (clarsimp simp:modify_map_def split:if_splits)
-  apply (drule_tac x = src in spec)
-  apply (drule_tac x = word1 in spec)
-  apply (clarsimp simp:mdb_next_unfold)
-  apply (case_tac z)
-   apply (clarsimp simp:badge_derived'_def)
-  apply (drule capMaster_capClass)
-  apply simp
-  done
-
- from distinct_zombies badge
- show "distinct_zombies ?C"
- apply (simp add:distinct_zombies_nonCTE_modify_map)
- apply (erule_tac distinct_zombies_copyMasterE[where x=src])
-   apply (rule cofs)
-  apply (simp add: masters)
- apply (simp add: notZomb1 notZomb2)
- done
+    unfolding class_links_def
+    apply (intro allI impI)
+    apply (drule mdb_next_disj)
+    apply (elim disjE)
+      apply (clarsimp simp:modify_map_def mdb_next_unfold split:if_split_asm)
+     apply (clarsimp simp: badge_derived'_def modify_map_def
+                     split: if_split_asm)
+     apply (erule capMaster_capClass)
+    apply (clarsimp simp:modify_map_def split:if_splits)
+    apply (drule_tac x = src in spec)
+    apply (drule_tac x = word1 in spec)
+    apply (clarsimp simp:mdb_next_unfold)
+    apply (case_tac z)
+    apply (clarsimp simp:badge_derived'_def)
+    apply (drule capMaster_capClass)
+    apply simp
+    done
 
- from reply_masters_rvk_fb is_der
- show "reply_masters_rvk_fb ?C"
-   apply (clarsimp simp:reply_masters_rvk_fb_def)
-   apply (erule ranE)
-   apply (clarsimp simp:modify_map_def split:if_split_asm)
-    apply fastforce+
-   apply (clarsimp simp:is_derived'_def isCap_simps)
-   apply fastforce
- done
+  from distinct_zombies badge
+  show "distinct_zombies ?C"
+    apply (simp add:distinct_zombies_nonCTE_modify_map)
+    apply (erule_tac distinct_zombies_copyMasterE[where x=src])
+      apply (rule cofs)
+     apply (simp add: masters)
+    apply (simp add: notZomb1 notZomb2)
+    done
 qed
 
-crunch state_refs_of'[wp]: cteInsert "\<lambda>s. P (state_refs_of' s)"
-  (wp: crunch_wps)
-
-crunch aligned'[wp]: cteInsert pspace_aligned'
-  (wp: crunch_wps)
-
-crunch distinct'[wp]: cteInsert pspace_distinct'
-  (wp: crunch_wps)
-
-crunch no_0_obj' [wp]: cteInsert no_0_obj'
-  (wp: crunch_wps)
+crunches cteInsert
+  for state_refs_of'[wp]: "\<lambda>s. P (state_refs_of' s)"
+  and aligned'[wp]: pspace_aligned'
+  and distinct'[wp]: pspace_distinct'
+  and bounded'[wp]: pspace_bounded'
+  and no_0_obj'[wp]: no_0_obj'
+  and reply_projs[wp]: "\<lambda>s. P (replyNexts_of s) (replyPrevs_of s) (replyTCBs_of s) (replySCs_of s)"
+  and pred_tcb_at'[wp]: "pred_tcb_at' proj P p"
+  and valid_replies' [wp]: valid_replies'
+  (wp: crunch_wps valid_replies'_lift)
 
 lemma cteInsert_valid_pspace:
   "\<lbrace>valid_pspace' and valid_cap' cap and (\<lambda>s. src \<noteq> dest) and valid_objs' and
@@ -2936,11 +2959,6 @@ done
 lemma setCTE_valid_mappings'[wp]:
   "\<lbrace>valid_pde_mappings'\<rbrace> setCTE x y \<lbrace>\<lambda>rv. valid_pde_mappings'\<rbrace>"
   apply (wp valid_pde_mappings_lift' setCTE_typ_at')
-   apply (simp add: setCTE_def)
-   apply (rule obj_at_setObject2)
-   apply (clarsimp simp: updateObject_cte typeError_def in_monad
-                  split: Structures_H.kernel_object.split_asm if_split_asm)
-  apply assumption
   done
 
 crunch pde_mappings' [wp]: cteInsert valid_pde_mappings'
@@ -2969,20 +2987,8 @@ lemma setCTE_cteCaps_of[wp]:
   "\<lbrace>\<lambda>s. P ((cteCaps_of s)(p \<mapsto> cteCap cte))\<rbrace>
       setCTE p cte
    \<lbrace>\<lambda>rv s. P (cteCaps_of s)\<rbrace>"
-  apply (simp add: cteCaps_of_def)
-  apply wp
-  apply (clarsimp elim!: rsubst[where P=P] intro!: ext)
-  done
-
-crunches setupReplyMaster
-  for inQ[wp]: "\<lambda>s. P (obj_at' (inQ d p) t s)"
-  and norq[wp]:  "\<lambda>s. P (ksReadyQueues s)"
-  and ct[wp]: "\<lambda>s. P (ksCurThread s)"
-  and state_refs_of'[wp]: "\<lambda>s. P (state_refs_of' s)"
-  and it[wp]: "\<lambda>s. P (ksIdleThread s)"
-  and nosch[wp]: "\<lambda>s. P (ksSchedulerAction s)"
-  and irq_node'[wp]: "\<lambda>s. P (irq_node' s)"
-  (wp: crunch_wps)
+  unfolding cteCaps_of_def
+  by wp (force elim!: rsubst[where P=P])
 
 lemmas setCTE_cteCap_wp_irq[wp] =
     hoare_use_eq_irq_node' [OF setCTE_ksInterruptState setCTE_cteCaps_of]
@@ -2995,16 +3001,15 @@ lemma setUntypedCapAsFull_valid_refs'[wp]:
   "\<lbrace>\<lambda>s. valid_refs' R (ctes_of s) \<and> cte_wp_at' ((=) srcCTE) src s\<rbrace>
    setUntypedCapAsFull (cteCap srcCTE) cap src
    \<lbrace>\<lambda>yb s. valid_refs' R (ctes_of s)\<rbrace>"
-  apply (clarsimp simp:valid_refs'_def setUntypedCapAsFull_def split del:if_splits)
+  apply (clarsimp simp: valid_refs'_def setUntypedCapAsFull_def split del:if_split)
   apply (rule hoare_pre)
-  apply (wp updateCap_ctes_of_wp)
+   apply (wp updateCap_ctes_of_wp)
   apply (clarsimp simp:ran_dom)
   apply (drule_tac x = y in bspec)
-    apply (drule_tac a = y in domI)
-    apply (simp add:modify_map_dom)
-  apply (clarsimp simp:modify_map_def cte_wp_at_ctes_of
-    isCap_simps split:if_splits)
-done
+   apply (drule_tac a = y in domI)
+   apply (simp add:modify_map_dom)
+  apply (clarsimp simp:modify_map_def cte_wp_at_ctes_of isCap_simps split:if_splits)
+  done
 
 crunch gsMaxObjectSize[wp]: setUntypedCapAsFull "\<lambda>s. P (gsMaxObjectSize s)"
 
@@ -3012,15 +3017,14 @@ lemma setUntypedCapAsFull_sizes[wp]:
   "\<lbrace>\<lambda>s. valid_cap_sizes' sz (ctes_of s) \<and> cte_wp_at' ((=) srcCTE) src s\<rbrace>
     setUntypedCapAsFull (cteCap srcCTE) cap src
   \<lbrace>\<lambda>rv s. valid_cap_sizes' sz (ctes_of s)\<rbrace>"
-  apply (clarsimp simp:valid_cap_sizes'_def setUntypedCapAsFull_def split del:if_splits)
+  apply (clarsimp simp: valid_cap_sizes'_def setUntypedCapAsFull_def split del: if_split)
   apply (rule hoare_pre)
-  apply (wp updateCap_ctes_of_wp | wps)+
+   apply (wp updateCap_ctes_of_wp | wps)+
   apply (clarsimp simp:ran_dom)
   apply (drule_tac x = y in bspec)
-    apply (drule_tac a = y in domI)
-    apply (simp add:modify_map_dom)
-  apply (clarsimp simp:modify_map_def cte_wp_at_ctes_of
-    isCap_simps split:if_splits)
+   apply (drule_tac a = y in domI)
+   apply (simp add:modify_map_dom)
+  apply (clarsimp simp:modify_map_def cte_wp_at_ctes_of isCap_simps split:if_splits)
   done
 
 lemma setUntypedCapAsFull_valid_global_refs'[wp]:
@@ -3057,12 +3061,6 @@ lemma cteInsert_valid_globals [wp]:
   apply simp
   done
 
-crunch arch [wp]: cteInsert "\<lambda>s. P (ksArchState s)"
-  (wp: crunch_wps simp: cte_wp_at_ctes_of)
-
-crunch pde_mappings' [wp]: cteInsert valid_pde_mappings'
-  (wp: crunch_wps)
-
 lemma setCTE_ksMachine[wp]:
   "\<lbrace>\<lambda>s. P (ksMachineState s)\<rbrace> setCTE x y \<lbrace>\<lambda>_ s. P (ksMachineState s)\<rbrace>"
   apply (clarsimp simp: setCTE_def)
@@ -3634,44 +3649,64 @@ lemma corres_caps_decomposition:
              "\<And>P. \<lbrace>\<lambda>s. P (new_action s)\<rbrace> f \<lbrace>\<lambda>rv s. P (scheduler_action s)\<rbrace>"
              "\<And>P. \<lbrace>\<lambda>s. P (new_sa' s)\<rbrace> g \<lbrace>\<lambda>rv s. P (ksSchedulerAction s)\<rbrace>"
              "\<And>P. \<lbrace>\<lambda>s. P (new_rqs' s)\<rbrace> g \<lbrace>\<lambda>rv s. P (ksReadyQueues s)\<rbrace>"
+             "\<And>P. \<lbrace>\<lambda>s. P (new_release_queue s)\<rbrace> f \<lbrace>\<lambda>rv s. P (release_queue s)\<rbrace>"
+             "\<And>P. \<lbrace>\<lambda>s. P (new_ksReleaseQueue s)\<rbrace> g \<lbrace>\<lambda>rv s. P (ksReleaseQueue s)\<rbrace>"
+             "\<And>P. \<lbrace>\<lambda>s. P (new_release_queue s)\<rbrace> f \<lbrace>\<lambda>rv s. P (release_queue s)\<rbrace>"
+             "\<And>P. \<lbrace>\<lambda>s. P (new_sc_replies_of s)\<rbrace> f \<lbrace>\<lambda>rv s. P (sc_replies_of s)\<rbrace>"
+             "\<And>P. \<lbrace>\<lambda>s. P (new_scs_of' s) (new_replies_of' s)\<rbrace> g \<lbrace>\<lambda>rv s. P (scs_of' s) (replies_of' s)\<rbrace>"
              "\<And>P. \<lbrace>\<lambda>s. P (new_di s)\<rbrace> f \<lbrace>\<lambda>rv s. P (domain_index s)\<rbrace>"
              "\<And>P. \<lbrace>\<lambda>s. P (new_dl s)\<rbrace> f \<lbrace>\<lambda>rv s. P (domain_list s)\<rbrace>"
              "\<And>P. \<lbrace>\<lambda>s. P (new_cd s)\<rbrace> f \<lbrace>\<lambda>rv s. P (cur_domain s)\<rbrace>"
              "\<And>P. \<lbrace>\<lambda>s. P (new_dt s)\<rbrace> f \<lbrace>\<lambda>rv s. P (domain_time s)\<rbrace>"
+             "\<And>P. \<lbrace>\<lambda>s. P (new_cot s)\<rbrace> f \<lbrace>\<lambda>rv s. P (consumed_time s)\<rbrace>"
+             "\<And>P. \<lbrace>\<lambda>s. P (new_cut s)\<rbrace> f \<lbrace>\<lambda>rv s. P (cur_time s)\<rbrace>"
+             "\<And>P. \<lbrace>\<lambda>s. P (new_csc s)\<rbrace> f \<lbrace>\<lambda>rv s. P (cur_sc s)\<rbrace>"
+             "\<And>P. \<lbrace>\<lambda>s. P (new_rpt s)\<rbrace> f \<lbrace>\<lambda>rv s. P (reprogram_timer s)\<rbrace>"
              "\<And>P. \<lbrace>\<lambda>s. P (new_dsi' s)\<rbrace> g \<lbrace>\<lambda>rv s. P (ksDomScheduleIdx s)\<rbrace>"
              "\<And>P. \<lbrace>\<lambda>s. P (new_ds' s)\<rbrace> g \<lbrace>\<lambda>rv s. P (ksDomSchedule s)\<rbrace>"
              "\<And>P. \<lbrace>\<lambda>s. P (new_cd' s)\<rbrace> g \<lbrace>\<lambda>rv s. P (ksCurDomain s)\<rbrace>"
              "\<And>P. \<lbrace>\<lambda>s. P (new_dt' s)\<rbrace> g \<lbrace>\<lambda>rv s. P (ksDomainTime s)\<rbrace>"
-  assumes z: "\<And>s s'. \<lbrakk> P s; P' s'; (s, s') \<in> state_relation \<rbrakk>
-                       \<Longrightarrow> cdt_relation ((\<noteq>) None \<circ> new_caps s) (new_mdb s) (new_ctes s')"
-             "\<And>s s'. \<lbrakk> P s; P' s'; (s, s') \<in> state_relation \<rbrakk>
-                       \<Longrightarrow> cdt_list_relation (new_list s) (new_mdb s) (new_ctes s')"
-             "\<And>s s'. \<lbrakk> P s; P' s'; (s, s') \<in> state_relation \<rbrakk>
-                       \<Longrightarrow> sched_act_relation (new_action s) (new_sa' s')"
-             "\<And>s s'. \<lbrakk> P s; P' s'; (s, s') \<in> state_relation \<rbrakk>
-                       \<Longrightarrow> ready_queues_relation (new_queues s) (new_rqs' s')"
-             "\<And>s s'. \<lbrakk> P s; P' s'; (s, s') \<in> state_relation \<rbrakk>
-                       \<Longrightarrow> revokable_relation (new_rvk s) (null_filter (new_caps s)) (new_ctes s')"
-             "\<And>s s'. \<lbrakk> P s; P' s'; (s, s') \<in> state_relation \<rbrakk>
-                       \<Longrightarrow> (new_as s, new_as' s') \<in> arch_state_relation
-                            \<and> interrupt_state_relation (new_irqn s) (new_irqs s) (new_irqs' s')
-                            \<and> new_ct s = new_ct' s' \<and> new_id s = new_id' s'
-                            \<and> new_ms s = new_ms' s' \<and> new_di s = new_dsi' s'
-                            \<and> new_dl s = new_ds' s' \<and> new_cd s = new_cd' s' \<and> new_dt s = new_dt' s' \<and> new_wuc s = new_wuc' s'"
-             "\<And>s s'. \<lbrakk> P s; P' s'; (s, s') \<in> state_relation \<rbrakk>
-                       \<Longrightarrow> new_ups s = new_ups' s'"
-             "\<And>s s'. \<lbrakk> P s; P' s'; (s, s') \<in> state_relation \<rbrakk>
-                       \<Longrightarrow> new_cns s = new_cns' s'"
+             "\<And>P. \<lbrace>\<lambda>s. P (new_cot' s)\<rbrace> g \<lbrace>\<lambda>rv s. P (ksConsumedTime s)\<rbrace>"
+             "\<And>P. \<lbrace>\<lambda>s. P (new_cut' s)\<rbrace> g \<lbrace>\<lambda>rv s. P (ksCurTime s)\<rbrace>"
+             "\<And>P. \<lbrace>\<lambda>s. P (new_csc' s)\<rbrace> g \<lbrace>\<lambda>rv s. P (ksCurSc s)\<rbrace>"
+             "\<And>P. \<lbrace>\<lambda>s. P (new_rpt' s)\<rbrace> g \<lbrace>\<lambda>rv s. P (ksReprogramTimer s)\<rbrace>"
+  assumes updated_relations:
+    "\<And>s s'. \<lbrakk> P s; P' s'; (s, s') \<in> state_relation \<rbrakk>
+              \<Longrightarrow> cdt_relation ((\<noteq>) None \<circ> new_caps s) (new_mdb s) (new_ctes s')
+                  \<and> cdt_list_relation (new_list s) (new_mdb s) (new_ctes s')
+                  \<and> sc_replies_relation_2 (new_sc_replies_of s) (new_scs_of' s' |> scReply)
+                      (new_replies_of' s' |> replyPrev)
+                  \<and> release_queue_relation (new_release_queue s) (new_ksReleaseQueue s')
+                  \<and> sched_act_relation (new_action s) (new_sa' s')
+                  \<and> ready_queues_relation (new_queues s) (new_rqs' s')
+                  \<and> revokable_relation (new_rvk s) (null_filter (new_caps s)) (new_ctes s')
+                  \<and> interrupt_state_relation (new_irqn s) (new_irqs s) (new_irqs' s')
+                  \<and> (new_as s, new_as' s') \<in> arch_state_relation
+                  \<and> new_ct s = new_ct' s'
+                  \<and> new_id s = new_id' s'
+                  \<and> idle_sc_ptr = new_idsc' s'
+                  \<and> new_ms s = new_ms' s'
+                  \<and> new_di s = new_dsi' s'
+                  \<and> new_dl s = new_ds' s'
+                  \<and> new_cd s = new_cd' s'
+                  \<and> new_dt s = new_dt' s'
+                  \<and> new_cot s = new_cot' s'
+                  \<and> new_cut s = new_cut' s'
+                  \<and> new_csc s = new_csc' s'
+                  \<and> new_rpt s = new_rpt' s'
+                  \<and> new_wuc s = new_wuc' s'
+                  \<and> new_ups s = new_ups' s'
+                  \<and> new_cns s = new_cns' s'"
   shows "corres r P P' f g"
 proof -
   have all_ext: "\<And>f f'. (\<forall>p. f p = f' p) = (f = f')"
-    by (fastforce intro!: ext)
+    by fastforce
   have mdb_wp':
     "\<And>ctes. \<lbrace>\<lambda>s. cdt_relation ((\<noteq>) None \<circ> new_caps s) (new_mdb s) ctes\<rbrace>
                 f
             \<lbrace>\<lambda>rv s. \<exists>m ca. (\<forall>p. ca p = ((\<noteq>) None \<circ> caps_of_state s) p) \<and> m = cdt s
                             \<and> cdt_relation ca m ctes\<rbrace>"
-    apply (wp hoare_vcg_ex_lift hoare_vcg_all_lift u)
+    apply (wp hoare_vcg_ex_lift hoare_vcg_all_lift updates)
     apply (subst all_ext)
     apply (simp add: o_def)
     done
@@ -3745,8 +3775,6 @@ lemma updateMDB_ctes_of_cases:
   apply (case_tac y, simp)
   done
 
-crunch ct[wp]: updateMDB "\<lambda>s. P (ksCurThread s)"
-
 lemma setCTE_state_bits[wp]:
   "\<lbrace>\<lambda>s. P (ksMachineState s)\<rbrace> setCTE p v \<lbrace>\<lambda>rv s. P (ksMachineState s)\<rbrace>"
   "\<lbrace>\<lambda>s. Q (ksIdleThread s)\<rbrace> setCTE p v \<lbrace>\<lambda>rv s. Q (ksIdleThread s)\<rbrace>"
@@ -3756,11 +3784,6 @@ lemma setCTE_state_bits[wp]:
   apply (wp updateObject_cte_inv | simp)+
   done
 
-crunch ms'[wp]: updateMDB "\<lambda>s. P (ksMachineState s)"
-crunch idle'[wp]: updateMDB "\<lambda>s. P (ksIdleThread s)"
-crunch arch'[wp]: updateMDB "\<lambda>s. P (ksArchState s)"
-crunch int'[wp]: updateMDB "\<lambda>s. P (ksInterruptState s)"
-
 lemma cte_map_eq_subst:
   "\<lbrakk> cte_at p s; cte_at p' s; valid_objs s; pspace_aligned s; pspace_distinct s \<rbrakk>
      \<Longrightarrow> (cte_map p = cte_map p') = (p = p')"
@@ -3842,217 +3781,16 @@ lemma valid_nullcaps_next:
   apply clarsimp
   done
 
-defs noReplyCapsFor_def:
-  "noReplyCapsFor \<equiv> \<lambda>t s. \<forall>sl m r. \<not> cte_wp_at' (\<lambda>cte. cteCap cte = ReplyCap t m r) sl s"
-
-lemma pspace_relation_no_reply_caps:
-  assumes pspace: "pspace_relation (kheap s) (ksPSpace s')"
-  and       invs: "invs s"
-  and        tcb: "tcb_at t s"
-  and     m_cte': "cte_wp_at' ((=) cte) sl' s'"
-  and     m_null: "cteCap cte = capability.NullCap"
-  and       m_sl: "sl' = cte_map (t, tcb_cnode_index 2)"
-  shows           "noReplyCapsFor t s'"
-proof -
-  from tcb have m_cte: "cte_at (t, tcb_cnode_index 2) s"
-    by (clarsimp elim!: tcb_at_cte_at)
-  have m_cte_null:
-    "cte_wp_at (\<lambda>c. c = cap.NullCap) (t, tcb_cnode_index 2) s"
-    using pspace invs
-    apply (frule_tac pspace_relation_cte_wp_atI')
-      apply (rule assms)
-     apply clarsimp
-    apply (clarsimp simp: m_sl)
-    apply (frule cte_map_inj_eq)
-         apply (rule m_cte)
-        apply (erule cte_wp_cte_at)
-       apply clarsimp+
-    apply (clarsimp elim!: cte_wp_at_weakenE simp: m_null)
-    done
-  have no_reply_caps:
-    "\<forall>sl m r. \<not> cte_wp_at (\<lambda>c. c = cap.ReplyCap t m r) sl s"
-    by (rule no_reply_caps_for_thread [OF invs tcb m_cte_null])
-  hence noReplyCaps:
-    "\<forall>sl m r. \<not> cte_wp_at' (\<lambda>cte. cteCap cte = ReplyCap t m r) sl s'"
-    apply (intro allI)
-    apply (clarsimp simp: cte_wp_at_neg2 cte_wp_at_ctes_of simp del: split_paired_All)
-    apply (frule pspace_relation_cte_wp_atI [OF pspace _ invs_valid_objs [OF invs]])
-    apply (clarsimp simp: cte_wp_at_neg2 simp del: split_paired_All)
-    apply (drule_tac x="(a, b)" in spec)
-    apply (clarsimp simp: cte_wp_cte_at cte_wp_at_caps_of_state)
-    apply (case_tac c, simp_all)
-    apply fastforce
-    done
-  thus ?thesis
-    by (simp add: noReplyCapsFor_def)
-qed
-
-lemma setupReplyMaster_corres:
-  "corres dc (einvs and tcb_at t) (invs' and tcb_at' t)
-       (setup_reply_master t) (setupReplyMaster t)"
-  apply (simp add: setupReplyMaster_def setup_reply_master_def)
-  apply (simp add: locateSlot_conv tcbReplySlot_def objBits_def objBitsKO_def)
-  apply (simp add: nullMDBNode_def, fold initMDBNode_def)
-  apply (rule_tac F="t + 2*2^cte_level_bits = cte_map (t, tcb_cnode_index 2)" in corres_req)
-   apply (clarsimp simp: tcb_cnode_index_def2 cte_map_nat_to_cref word_bits_def cte_level_bits_def)
-  apply (clarsimp simp: cte_level_bits_def)
-  apply (rule stronger_corres_guard_imp)
-    apply (rule corres_split_deprecated [OF _ get_cap_corres])
-      apply (rule corres_when)
-       apply fastforce
-      apply (rule_tac P'="einvs and tcb_at t" in corres_stateAssert_implied)
-       apply (rule create_reply_master_corres; simp)
-      apply (subgoal_tac "\<exists>cte. cte_wp_at' ((=) cte) (cte_map (t, tcb_cnode_index 2)) s'
-                              \<and> cteCap cte = capability.NullCap")
-       apply (fastforce dest: pspace_relation_no_reply_caps
-                             state_relation_pspace_relation)
-      apply (clarsimp simp: cte_map_def tcb_cnode_index_def cte_wp_at_ctes_of)
-     apply (rule_tac Q="\<lambda>rv. einvs and tcb_at t and
-                             cte_wp_at ((=) rv) (t, tcb_cnode_index 2)"
-                  in hoare_strengthen_post)
-      apply (wp hoare_drop_imps get_cap_wp)
-     apply (clarsimp simp: invs_def valid_state_def elim!: cte_wp_at_weakenE)
-    apply (rule_tac Q="\<lambda>rv. valid_pspace' and valid_mdb' and
-                            cte_wp_at' ((=) rv) (cte_map (t, tcb_cnode_index 2))"
-                 in hoare_strengthen_post)
-     apply (wp hoare_drop_imps getCTE_wp')
-    apply (clarsimp simp: cte_wp_at_ctes_of valid_mdb'_def valid_mdb_ctes_def)
-    apply (case_tac r, fastforce elim: valid_nullcapsE)
-   apply (fastforce elim: tcb_at_cte_at)
-  apply (clarsimp simp: cte_at'_obj_at' tcb_cte_cases_def cte_map_def)
-  apply (clarsimp simp: invs'_def valid_state'_def valid_pspace'_def)
-  done
-
-crunch tcb'[wp]: setupReplyMaster "tcb_at' t"
-  (wp: crunch_wps)
-
-crunch idle'[wp]: setupReplyMaster "valid_idle'"
-
 (* Levity: added (20090126 19:32:14) *)
 declare stateAssert_wp[wp]
 
-lemma setupReplyMaster_valid_mdb:
-  "slot = t + 2 ^ objBits (undefined :: cte) * tcbReplySlot \<Longrightarrow>
-   \<lbrace>valid_mdb' and valid_pspace' and tcb_at' t\<rbrace>
-   setupReplyMaster t
-   \<lbrace>\<lambda>rv. valid_mdb'\<rbrace>"
-  apply (clarsimp simp: setupReplyMaster_def locateSlot_conv
-                        nullMDBNode_def)
-  apply (fold initMDBNode_def)
-  apply (wp setCTE_valid_mdb getCTE_wp')
-  apply clarsimp
-  apply (intro conjI)
-      apply (case_tac cte)
-      apply (fastforce simp: cte_wp_at_ctes_of valid_mdb'_def valid_mdb_ctes_def
-                            no_mdb_def
-                      elim: valid_nullcapsE)
-     apply (frule obj_at_aligned')
-      apply (simp add: valid_cap'_def capAligned_def
-                       objBits_simps' word_bits_def)+
-    apply (clarsimp simp: valid_pspace'_def)
-   apply (clarsimp simp: caps_no_overlap'_def capRange_def)
-  apply (clarsimp simp: fresh_virt_cap_class_def
-                 elim!: ranE)
-  apply (clarsimp simp add: noReplyCapsFor_def cte_wp_at_ctes_of)
-  apply (case_tac x)
-  apply (rename_tac capability mdbnode)
-  apply (case_tac capability; simp)
-   apply (rename_tac arch_capability)
-   apply (case_tac arch_capability; simp)
-  apply fastforce
-  done
-
-lemma setupReplyMaster_valid_objs [wp]:
-  "\<lbrace> valid_objs' and pspace_aligned' and pspace_distinct' and tcb_at' t\<rbrace>
-  setupReplyMaster t
-  \<lbrace>\<lambda>_. valid_objs'\<rbrace>"
-  apply (simp add: setupReplyMaster_def locateSlot_conv)
-  apply (wp setCTE_valid_objs getCTE_wp')
-  apply (clarsimp)
-  apply (frule obj_at_aligned')
-   apply (simp add: valid_cap'_def capAligned_def
-                    objBits_simps' word_bits_def)+
-  done
-
-lemma setupReplyMaster_wps[wp]:
-  "\<lbrace>pspace_aligned'\<rbrace> setupReplyMaster t \<lbrace>\<lambda>rv. pspace_aligned'\<rbrace>"
-  "\<lbrace>pspace_distinct'\<rbrace> setupReplyMaster t \<lbrace>\<lambda>rv. pspace_distinct'\<rbrace>"
-  "slot = cte_map (t, tcb_cnode_index 2) \<Longrightarrow>
-   \<lbrace>\<lambda>s. P ((cteCaps_of s)(slot \<mapsto> (capability.ReplyCap t True True))) \<and> P (cteCaps_of s)\<rbrace>
-      setupReplyMaster t
-   \<lbrace>\<lambda>rv s. P (cteCaps_of s)\<rbrace>"
-  apply (simp_all add: setupReplyMaster_def locateSlot_conv)
-    apply (wp getCTE_wp | simp add: o_def cte_wp_at_ctes_of)+
-  apply clarsimp
-  apply (rule_tac x=cte in exI)
-  apply (clarsimp simp: tcbReplySlot_def objBits_simps' fun_upd_def word_bits_def
-                        tcb_cnode_index_def2 cte_map_nat_to_cref cte_level_bits_def)
-  done
-
-crunch no_0_obj'[wp]: setupReplyMaster no_0_obj'
-  (wp: crunch_wps simp: crunch_simps)
-
-lemma setupReplyMaster_valid_pspace':
-  "\<lbrace>valid_pspace' and tcb_at' t\<rbrace>
-     setupReplyMaster t
-   \<lbrace>\<lambda>rv. valid_pspace'\<rbrace>"
-  apply (simp add: valid_pspace'_def)
-  apply (wp setupReplyMaster_valid_mdb)
-   apply (simp_all add: valid_pspace'_def)
-  done
-
-lemma setupReplyMaster_ifunsafe'[wp]:
-  "slot = t + 2 ^ objBits (undefined :: cte) * tcbReplySlot \<Longrightarrow>
-   \<lbrace>if_unsafe_then_cap' and ex_cte_cap_to' slot\<rbrace>
-     setupReplyMaster t
-   \<lbrace>\<lambda>rv s. if_unsafe_then_cap' s\<rbrace>"
-  apply (simp add: ifunsafe'_def3 setupReplyMaster_def locateSlot_conv)
-  apply (wp getCTE_wp')
-  apply (clarsimp simp: ex_cte_cap_to'_def cte_wp_at_ctes_of cteCaps_of_def
-                        cte_level_bits_def objBits_simps')
-  apply (drule_tac x=crefa in spec)
-  apply (rule conjI)
-   apply clarsimp
-   apply (rule_tac x=cref in exI, fastforce)
-  apply clarsimp
-  apply (rule_tac x=cref' in exI, fastforce)
-  done
-
-
-lemma setupReplyMaster_iflive'[wp]:
-  "\<lbrace>if_live_then_nonz_cap'\<rbrace> setupReplyMaster t \<lbrace>\<lambda>rv. if_live_then_nonz_cap'\<rbrace>"
-  apply (simp add: setupReplyMaster_def locateSlot_conv)
-  apply (wp setCTE_iflive' getCTE_wp')
-  apply (clarsimp elim!: cte_wp_at_weakenE')
-  done
-
-lemma setupReplyMaster_global_refs[wp]:
-  "\<lbrace>\<lambda>s. valid_global_refs' s \<and> thread \<notin> global_refs' s \<and> tcb_at' thread s
-      \<and> ex_nonz_cap_to' thread s \<and> valid_objs' s\<rbrace>
-    setupReplyMaster thread
-   \<lbrace>\<lambda>rv. valid_global_refs'\<rbrace>"
-  apply (simp add: setupReplyMaster_def locateSlot_conv)
-  apply (wp getCTE_wp')
-  apply (clarsimp simp: capRange_def cte_wp_at_ctes_of objBits_simps)
-  apply (clarsimp simp: ex_nonz_cap_to'_def cte_wp_at_ctes_of)
-  apply (rename_tac "prev_cte")
-  apply (case_tac prev_cte, simp)
-  apply (frule(1) ctes_of_valid_cap')
-  apply (drule(1) valid_global_refsD_with_objSize)+
-  apply (clarsimp simp: valid_cap'_def objBits_simps obj_at'_def projectKOs
-                 split: capability.split_asm)
-  done
-
-crunch valid_arch'[wp]: setupReplyMaster "valid_arch_state'"
-  (wp: crunch_wps simp: crunch_simps)
-
 lemma ex_nonz_tcb_cte_caps':
   "\<lbrakk>ex_nonz_cap_to' t s; tcb_at' t s; valid_objs' s; sl \<in> dom tcb_cte_cases\<rbrakk> \<Longrightarrow>
    ex_cte_cap_to' (t + sl) s"
   apply (clarsimp simp: ex_nonz_cap_to'_def ex_cte_cap_to'_def cte_wp_at_ctes_of)
   apply (subgoal_tac "s \<turnstile>' cteCap cte")
    apply (rule_tac x=cref in exI, rule_tac x=cte in exI)
-   apply (clarsimp simp: valid_cap'_def obj_at'_def projectKOs dom_def
+   apply (clarsimp simp: valid_cap'_def obj_at'_def projectKOs dom_def ko_wp_at'_def
                   split: cte.split_asm capability.split_asm)
   apply (case_tac cte)
   apply (clarsimp simp: ctes_of_valid_cap')
@@ -4082,96 +3817,13 @@ lemma setCTE_irq_handlers':
   apply (auto simp: ran_def)
   done
 
-lemma setupReplyMaster_irq_handlers'[wp]:
-  "\<lbrace>valid_irq_handlers'\<rbrace> setupReplyMaster t \<lbrace>\<lambda>rv. valid_irq_handlers'\<rbrace>"
-  apply (simp add: setupReplyMaster_def locateSlot_conv)
-  apply (wp setCTE_irq_handlers' getCTE_wp)
-  apply (clarsimp simp: cte_wp_at_ctes_of)
-  done
-
-crunches setupReplyMaster
-  for irq_states'[wp]: valid_irq_states'
-  and irqs_masked' [wp]: irqs_masked'
-  and pde_mappings' [wp]: valid_pde_mappings'
-  and pred_tcb_at' [wp]: "pred_tcb_at' proj P t"
-  and ksMachine[wp]: "\<lambda>s. P (ksMachineState s)"
-  and pspace_domain_valid[wp]: "pspace_domain_valid"
-  and ct_not_inQ[wp]: "ct_not_inQ"
-  and ksCurDomain[wp]: "\<lambda>s. P (ksCurDomain s)"
-  and ksCurThread[wp]: "\<lambda>s. P (ksCurThread s)"
-  and ksIdlethread[wp]: "\<lambda>s. P (ksIdleThread s)"
-  and ksDomSchedule[wp]: "\<lambda>s. P (ksDomSchedule s)"
-  and scheduler_action[wp]: "\<lambda>s. P (ksSchedulerAction s)"
-  and obj_at'_inQ[wp]: "obj_at' (inQ d p) t"
-  and tcbDomain_inv[wp]: "obj_at' (\<lambda>tcb. P (tcbDomain tcb)) t"
-  and tcbPriority_inv[wp]: "obj_at' (\<lambda>tcb. P (tcbPriority tcb)) t"
-  and ready_queues[wp]: "\<lambda>s. P (ksReadyQueues s)"
-  and ready_queuesL1[wp]: "\<lambda>s. P (ksReadyQueuesL1Bitmap s)"
-  and ready_queuesL2[wp]: "\<lambda>s. P (ksReadyQueuesL2Bitmap s)"
-  and ksDomScheduleIdx[wp]: "\<lambda>s. P (ksDomScheduleIdx s)"
-  and gsUntypedZeroRanges[wp]: "\<lambda>s. P (gsUntypedZeroRanges s)"
-  (wp: crunch_wps simp: crunch_simps rule: irqs_masked_lift)
-
-lemma setupReplyMaster_vms'[wp]:
-  "\<lbrace>valid_machine_state'\<rbrace> setupReplyMaster t \<lbrace>\<lambda>_. valid_machine_state'\<rbrace>"
-  apply (simp add: valid_machine_state'_def pointerInUserData_def pointerInDeviceData_def )
-  apply (intro hoare_vcg_all_lift hoare_vcg_disj_lift)
-  apply wp+
-  done
-
-lemma setupReplyMaster_urz[wp]:
-  "\<lbrace>untyped_ranges_zero' and valid_mdb' and valid_objs'\<rbrace>
-    setupReplyMaster t
-  \<lbrace>\<lambda>rv. untyped_ranges_zero'\<rbrace>"
-  apply (simp add: setupReplyMaster_def locateSlot_conv)
-  apply (rule hoare_pre)
-   apply (wp untyped_ranges_zero_lift getCTE_wp' | simp)+
-  apply (clarsimp simp: cte_wp_at_ctes_of fun_upd_def[symmetric])
-  apply (subst untyped_ranges_zero_fun_upd, assumption, simp_all)
-  apply (clarsimp simp: cteCaps_of_def untypedZeroRange_def Let_def isCap_simps)
-  done
-
-lemma setupReplyMaster_invs'[wp]:
-  "\<lbrace>invs' and tcb_at' t and ex_nonz_cap_to' t\<rbrace>
-     setupReplyMaster t
-   \<lbrace>\<lambda>rv. invs'\<rbrace>"
-  apply (simp add: invs'_def valid_state'_def)
-  apply (rule hoare_pre)
-   apply (wp setupReplyMaster_valid_pspace' sch_act_wf_lift tcb_in_cur_domain'_lift ct_idle_or_in_cur_domain'_lift
-             valid_queues_lift cur_tcb_lift valid_queues_lift' hoare_vcg_disj_lift
-             valid_irq_node_lift | simp)+
-  apply (clarsimp simp: ex_nonz_tcb_cte_caps' valid_pspace'_def
-                        objBits_simps' tcbReplySlot_def
-                        ex_nonz_cap_not_global' dom_def)
-  done
-
-lemma setupReplyMaster_cte_wp_at'':
-  "\<lbrace>cte_wp_at' (\<lambda>cte. P (cteCap cte)) p and K (\<not> P NullCap)\<rbrace>
-     setupReplyMaster t
-   \<lbrace>\<lambda>rv s. cte_wp_at' (P \<circ> cteCap) p s\<rbrace>"
-  apply (simp add: setupReplyMaster_def locateSlot_conv tree_cte_cteCap_eq)
-  apply (wp getCTE_wp')
-  apply (fastforce simp: cte_wp_at_ctes_of cteCaps_of_def)
-  done
-
-lemmas setupReplyMaster_cte_wp_at' = setupReplyMaster_cte_wp_at''[unfolded o_def]
-
-lemma setupReplyMaster_cap_to'[wp]:
-  "\<lbrace>ex_nonz_cap_to' p\<rbrace> setupReplyMaster t \<lbrace>\<lambda>rv. ex_nonz_cap_to' p\<rbrace>"
-  apply (simp add: ex_nonz_cap_to'_def)
-  apply (rule hoare_pre)
-   apply (wp hoare_vcg_ex_lift setupReplyMaster_cte_wp_at')
-  apply clarsimp
-  done
-
 definition
   is_arch_update' :: "capability \<Rightarrow> cte \<Rightarrow> bool"
 where
   "is_arch_update' cap cte \<equiv> isArchObjectCap cap \<and> capMasterCap cap = capMasterCap (cteCap cte)"
 
 lemma mdb_next_pres:
-  "\<lbrakk> m p = Some v;
- mdbNext (cteMDBNode x) = mdbNext (cteMDBNode v) \<rbrakk> \<Longrightarrow>
+  "\<lbrakk> m p = Some v; mdbNext (cteMDBNode x) = mdbNext (cteMDBNode v) \<rbrakk> \<Longrightarrow>
   m(p \<mapsto> x) \<turnstile> a \<leadsto> b = m \<turnstile> a \<leadsto> b"
   by (simp add: mdb_next_unfold)
 

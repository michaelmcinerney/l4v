--- orphanage/Orphanage.thy
+++ orphanage/Orphanage.thy
@@ -1237,9 +1237,9 @@ lemma timerTick_no_orphans [wp]:
 
 lemma handleDoubleFault_no_orphans [wp]:
   "\<lbrace> \<lambda>s. no_orphans s \<and> valid_queues' s \<rbrace>
-   handleDoubleFault tptr ex1 ex2
+   handleNoFaultHandler tptr
    \<lbrace> \<lambda>rv s. no_orphans s \<rbrace>"
-  unfolding handleDoubleFault_def
+  unfolding handleNoFaultHandler_def
   apply (wp setThreadState_not_active_no_orphans
          | clarsimp simp: is_active_thread_state_def isRestart_def isRunning_def)+
   done
@@ -1292,17 +1292,13 @@ lemma sendIPC_no_orphans [wp]:
 
 lemma sendFaultIPC_no_orphans [wp]:
   "\<lbrace> \<lambda>s. no_orphans s \<and> valid_queues' s \<and> valid_objs' s \<and> sch_act_wf (ksSchedulerAction s) s \<rbrace>
-   sendFaultIPC tptr fault
+   sendFaultIPC tptr handlerCap fault
    \<lbrace> \<lambda>rv s. no_orphans s \<rbrace>"
   unfolding sendFaultIPC_def
   apply (rule hoare_pre)
    apply (wp threadSet_valid_queues' threadSet_no_orphans threadSet_valid_objs'
              threadSet_sch_act | wpc | clarsimp)+
-    apply (rule_tac Q'="\<lambda>handlerCap s. no_orphans s \<and> valid_queues' s
-                                         \<and> valid_objs' s
-                                         \<and> sch_act_wf (ksSchedulerAction s) s"
-             in hoare_post_imp_R)
-     apply (wp | clarsimp simp: inQ_def valid_tcb'_def tcb_cte_cases_def)+
+  apply (clarsimp simp: inQ_def valid_tcb'_def tcb_cte_cases_def)
   done
 
 lemma sendIPC_valid_queues' [wp]:
@@ -1320,16 +1316,13 @@ lemma sendIPC_valid_queues' [wp]:
 
 lemma sendFaultIPC_valid_queues' [wp]:
   "\<lbrace> \<lambda>s. valid_queues' s \<and> valid_objs' s \<and> sch_act_wf (ksSchedulerAction s) s \<rbrace>
-   sendFaultIPC tptr fault
+   sendFaultIPC tptr handlerCap fault
    \<lbrace> \<lambda>rv s. valid_queues' s \<rbrace>"
   unfolding sendFaultIPC_def
   apply (rule hoare_pre)
    apply (wp threadSet_valid_queues' threadSet_valid_objs' threadSet_sch_act
           | wpc | clarsimp)+
-    apply (rule_tac Q'="\<lambda>handlerCap s. valid_queues' s \<and> valid_objs' s
-                                         \<and> sch_act_wf (ksSchedulerAction s) s"
-             in hoare_post_imp_R)
-     apply (wp | clarsimp simp: inQ_def valid_tcb'_def tcb_cte_cases_def)+
+  apply (clarsimp simp: inQ_def valid_tcb'_def tcb_cte_cases_def)
   done
 
 lemma handleFault_no_orphans [wp]:
@@ -1338,7 +1331,9 @@ lemma handleFault_no_orphans [wp]:
    \<lbrace> \<lambda>rv s. no_orphans s \<rbrace>"
   unfolding handleFault_def
   apply (rule hoare_pre)
-   apply (wp | clarsimp)+
+   apply wpsimp
+    apply (rule_tac Q'="\<lambda>hasFh s. no_orphans s \<and> valid_queues' s" in hoare_post_imp_R)
+     apply (wp | clarsimp)+
   done
 
 lemma replyFromKernel_no_orphans [wp]:
@@ -2024,48 +2019,54 @@ lemma threadSet_ipcbuffer_invs:
   apply (wp threadSet_invs_trivial, simp_all add: inQ_def cong: conj_cong)
   done
 
+lemma installTCBCap_no_orphans:
+  "\<lbrace>no_orphans and invs' and sch_act_simple\<rbrace> installTCBCap a sl n slot_opt \<lbrace>\<lambda>rv. no_orphans\<rbrace>"
+  unfolding installTCBCap_def
+  by (wpsimp wp: checkCap_inv simp: getThreadVSpaceRoot_def getThreadFaultHandlerSlot_def split_def
+      | rule conjI)+
+
+lemma installTCBFrameCap_no_orphans:
+  "\<lbrace>no_orphans and invs' and  sch_act_simple and tcb_at' a
+               and case_option \<top> (valid_cap') (case_option None (case_option None (Some o fst) o snd) g)
+               and K (case_option True isArchObjectCap (case_option None (case_option None (Some o fst) o snd) g))
+               and K (case_option True (swp is_aligned msg_align_bits o fst) g)\<rbrace>
+    installTCBFrameCap a sl g
+   \<lbrace>\<lambda>rv. no_orphans\<rbrace>"
+  unfolding installTCBFrameCap_def
+  apply (rule hoare_gen_asm)+
+  apply (wpsimp | wpsimp wp: hoare_drop_imp checkCap_inv cteDelete_invs'
+                             threadSet_no_orphans threadSet_ipcbuffer_invs
+                | strengthen invs_valid_queues')+
+  done
+
 lemma tc_no_orphans:
-  "\<lbrace> no_orphans and invs' and sch_act_simple and tcb_at' a and ex_nonz_cap_to' a and
+  "\<lbrace> no_orphans and invs' and sch_act_simple and tcb_at' a and
     case_option \<top> (valid_cap' o fst) e' and
     K (case_option True (isCNodeCap o fst) e') and
     case_option \<top> (valid_cap' o fst) f' and
     K (case_option True (isValidVTableRoot o fst) f') and
+    case_option \<top> (valid_cap' o fst) fh' and
+    K (case_option True (isValidFaultHandler o fst) fh') and
     case_option \<top> (valid_cap') (case_option None (case_option None (Some o fst) o snd) g) and
     K (case_option True isArchObjectCap (case_option None (case_option None (Some o fst) o snd) g)) and
     K (case_option True (swp is_aligned 2 o fst) g) and
     K (case_option True (swp is_aligned msg_align_bits o fst) g) and
     K (case g of None \<Rightarrow> True | Some x \<Rightarrow> (case_option True (isArchObjectCap \<circ> fst) \<circ> snd) x) and
     K (valid_option_prio d \<and> valid_option_prio mcp) \<rbrace>
-      invokeTCB (tcbinvocation.ThreadControl a sl b' mcp d e' f' g)
+      invokeTCB (tcbinvocation.ThreadControl a sl fh' mcp d e' f' g)
    \<lbrace> \<lambda>rv s. no_orphans s \<rbrace>"
-  apply (rule hoare_gen_asm)
-  apply (rule hoare_gen_asm)
-  apply (rule hoare_gen_asm)
+  apply (rule hoare_gen_asm)+
   apply (simp add: invokeTCB_def getThreadCSpaceRoot getThreadVSpaceRoot
                    getThreadBufferSlot_def split_def)
-  apply (simp only: eq_commute[where a="a"])
-  apply (rule hoare_walk_assmsE)
-    apply (clarsimp simp: pred_conj_def option.splits[where P="\<lambda>x. x s" for s])
-    apply ((wp case_option_wp threadSet_no_orphans threadSet_invs_trivial
-               threadSet_cap_to' hoare_vcg_all_lift static_imp_wp | clarsimp simp: inQ_def)+)[2]
   apply (rule hoare_walk_assmsE)
     apply (cases mcp; clarsimp simp: pred_conj_def option.splits[where P="\<lambda>x. x s" for s])
      apply ((wp case_option_wp threadSet_no_orphans threadSet_invs_trivial setMCPriority_invs'
                 typ_at_lifts[OF setMCPriority_typ_at']
                 threadSet_cap_to' hoare_vcg_all_lift static_imp_wp | clarsimp simp: inQ_def)+)[3]
-  apply ((simp only: simp_thms cong: conj_cong
-          | wp cteDelete_deletes cteDelete_invs' cteDelete_sch_act_simple
-               case_option_wp[where m'="return ()", OF setPriority_no_orphans return_inv,simplified]
-               checkCap_inv[where P="valid_cap' c" for c] checkCap_inv[where P=sch_act_simple]
-               checkCap_inv[where P=no_orphans] checkCap_inv[where P="tcb_at' a"]
-               threadSet_cte_wp_at' hoare_vcg_all_lift_R hoare_vcg_all_lift threadSet_no_orphans
-               hoare_vcg_const_imp_lift_R static_imp_wp hoare_drop_imp threadSet_ipcbuffer_invs
-          | strengthen invs_valid_queues'
-          | (simp add: locateSlotTCB_def locateSlotBasic_def objBits_def
-                     objBitsKO_def tcbIPCBufferSlot_def tcb_cte_cases_def,
-           wp hoare_return_sp)
-          | wpc | clarsimp)+)
-  apply (fastforce simp: objBits_defs isCap_simps dest!: isValidVTableRootD)
+  apply (wpsimp wp: installTCBFrameCap_no_orphans installTCBFrameCap_invs'
+                   installTCBCap_no_orphans installTCBCap_invs' installTCBCap_sch_act_simple
+                   hoare_case_option_wp hoare_vcg_const_imp_lift_R hoare_vcg_all_lift_R)+
+  apply (auto simp: isValidFaultHandler_def isValidVTableRoot_def isCap_simps)
   done
 
 lemma bindNotification_no_orphans[wp]:
